(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.pointer-events-none{pointer-events:none}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-\\[1\\.5rem\\]{top:1.5rem}.right-\\[1\\.5rem\\]{right:1.5rem}.-z-1{z-index:-1}.z-1{z-index:1}.z-10{z-index:10}.-order-1{order:-1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-2{margin-left:calc(var(--spacing)*2)}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.inline-flex{display:inline-flex}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.min-h-\\[450px\\]{min-height:450px}.w-\\[20px\\]{width:20px}.w-full{width:100%}.max-w-max{max-width:max-content}.cursor-pointer{cursor:pointer}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-1{grid-template-rows:repeat(1,minmax(0,1fr))}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function sa(n) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const a of n.split(",")) r[a] = 1;
  return (a) => a in r;
}
const it = {}, _o = [], Bn = () => {
}, Gl = () => !1, Wi = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), aa = (n) => n.startsWith("onUpdate:"), Wt = Object.assign, ua = (n, r) => {
  const a = n.indexOf(r);
  a > -1 && n.splice(a, 1);
}, Yl = Object.prototype.hasOwnProperty, rt = (n, r) => Yl.call(n, r), Ne = Array.isArray, wo = (n) => xi(n) === "[object Map]", Co = (n) => xi(n) === "[object Set]", ka = (n) => xi(n) === "[object Date]", Ke = (n) => typeof n == "function", Et = (n) => typeof n == "string", In = (n) => typeof n == "symbol", ft = (n) => n !== null && typeof n == "object", Ou = (n) => (ft(n) || Ke(n)) && Ke(n.then) && Ke(n.catch), Cu = Object.prototype.toString, xi = (n) => Cu.call(n), Xl = (n) => xi(n).slice(8, -1), Su = (n) => xi(n) === "[object Object]", la = (n) => Et(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, ui = /* @__PURE__ */ sa(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Gi = (n) => {
  const r = /* @__PURE__ */ Object.create(null);
  return (a) => r[a] || (r[a] = n(a));
}, zl = /-(\w)/g, Sr = Gi(
  (n) => n.replace(zl, (r, a) => a ? a.toUpperCase() : "")
), Ql = /\B([A-Z])/g, yo = Gi(
  (n) => n.replace(Ql, "-$1").toLowerCase()
), Nu = Gi((n) => n.charAt(0).toUpperCase() + n.slice(1)), Ps = Gi(
  (n) => n ? `on${Nu(n)}` : ""
), Cr = (n, r) => !Object.is(n, r), Pi = (n, ...r) => {
  for (let a = 0; a < n.length; a++)
    n[a](...r);
}, $s = (n, r, a, u = !1) => {
  Object.defineProperty(n, r, {
    configurable: !0,
    enumerable: !1,
    writable: u,
    value: a
  });
}, Li = (n) => {
  const r = parseFloat(n);
  return isNaN(r) ? n : r;
};
let Da;
const Yi = () => Da || (Da = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ca(n) {
  if (Ne(n)) {
    const r = {};
    for (let a = 0; a < n.length; a++) {
      const u = n[a], c = Et(u) ? tc(u) : ca(u);
      if (c)
        for (const d in c)
          r[d] = c[d];
    }
    return r;
  } else if (Et(n) || ft(n))
    return n;
}
const Jl = /;(?![^(]*\))/g, Zl = /:([^]+)/, ec = /\/\*[^]*?\*\//g;
function tc(n) {
  const r = {};
  return n.replace(ec, "").split(Jl).forEach((a) => {
    if (a) {
      const u = a.split(Zl);
      u.length > 1 && (r[u[0].trim()] = u[1].trim());
    }
  }), r;
}
function ho(n) {
  let r = "";
  if (Et(n))
    r = n;
  else if (Ne(n))
    for (let a = 0; a < n.length; a++) {
      const u = ho(n[a]);
      u && (r += u + " ");
    }
  else if (ft(n))
    for (const a in n)
      n[a] && (r += a + " ");
  return r.trim();
}
const nc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", rc = /* @__PURE__ */ sa(nc);
function Au(n) {
  return !!n || n === "";
}
function oc(n, r) {
  if (n.length !== r.length) return !1;
  let a = !0;
  for (let u = 0; a && u < n.length; u++)
    a = mo(n[u], r[u]);
  return a;
}
function mo(n, r) {
  if (n === r) return !0;
  let a = ka(n), u = ka(r);
  if (a || u)
    return a && u ? n.getTime() === r.getTime() : !1;
  if (a = In(n), u = In(r), a || u)
    return n === r;
  if (a = Ne(n), u = Ne(r), a || u)
    return a && u ? oc(n, r) : !1;
  if (a = ft(n), u = ft(r), a || u) {
    if (!a || !u)
      return !1;
    const c = Object.keys(n).length, d = Object.keys(r).length;
    if (c !== d)
      return !1;
    for (const p in n) {
      const g = n.hasOwnProperty(p), O = r.hasOwnProperty(p);
      if (g && !O || !g && O || !mo(n[p], r[p]))
        return !1;
    }
  }
  return String(n) === String(r);
}
function fa(n, r) {
  return n.findIndex((a) => mo(a, r));
}
const Pu = (n) => !!(n && n.__v_isRef === !0), Fe = (n) => Et(n) ? n : n == null ? "" : Ne(n) || ft(n) && (n.toString === Cu || !Ke(n.toString)) ? Pu(n) ? Fe(n.value) : JSON.stringify(n, ku, 2) : String(n), ku = (n, r) => Pu(r) ? ku(n, r.value) : wo(r) ? {
  [`Map(${r.size})`]: [...r.entries()].reduce(
    (a, [u, c], d) => (a[ks(u, d) + " =>"] = c, a),
    {}
  )
} : Co(r) ? {
  [`Set(${r.size})`]: [...r.values()].map((a) => ks(a))
} : In(r) ? ks(r) : ft(r) && !Ne(r) && !Su(r) ? String(r) : r, ks = (n, r = "") => {
  var a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    In(n) ? `Symbol(${(a = n.description) != null ? a : r})` : n
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Vt;
class Du {
  constructor(r = !1) {
    this.detached = r, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Vt, !r && Vt && (this.index = (Vt.scopes || (Vt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let r, a;
      if (this.scopes)
        for (r = 0, a = this.scopes.length; r < a; r++)
          this.scopes[r].pause();
      for (r = 0, a = this.effects.length; r < a; r++)
        this.effects[r].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let r, a;
      if (this.scopes)
        for (r = 0, a = this.scopes.length; r < a; r++)
          this.scopes[r].resume();
      for (r = 0, a = this.effects.length; r < a; r++)
        this.effects[r].resume();
    }
  }
  run(r) {
    if (this._active) {
      const a = Vt;
      try {
        return Vt = this, r();
      } finally {
        Vt = a;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Vt, Vt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Vt = this.prevScope, this.prevScope = void 0);
  }
  stop(r) {
    if (this._active) {
      this._active = !1;
      let a, u;
      for (a = 0, u = this.effects.length; a < u; a++)
        this.effects[a].stop();
      for (this.effects.length = 0, a = 0, u = this.cleanups.length; a < u; a++)
        this.cleanups[a]();
      if (this.cleanups.length = 0, this.scopes) {
        for (a = 0, u = this.scopes.length; a < u; a++)
          this.scopes[a].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !r) {
        const c = this.parent.scopes.pop();
        c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Iu(n) {
  return new Du(n);
}
function Ru() {
  return Vt;
}
function ic(n, r = !1) {
  Vt && Vt.cleanups.push(n);
}
let ct;
const Ds = /* @__PURE__ */ new WeakSet();
class ju {
  constructor(r) {
    this.fn = r, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Vt && Vt.active && Vt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ds.has(this) && (Ds.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Ku(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Ia(this), Fu(this);
    const r = ct, a = Dn;
    ct = this, Dn = !0;
    try {
      return this.fn();
    } finally {
      Mu(this), ct = r, Dn = a, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let r = this.deps; r; r = r.nextDep)
        ha(r);
      this.deps = this.depsTail = void 0, Ia(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ds.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Us(this) && this.run();
  }
  get dirty() {
    return Us(this);
  }
}
let Lu = 0, li, ci;
function Ku(n, r = !1) {
  if (n.flags |= 8, r) {
    n.next = ci, ci = n;
    return;
  }
  n.next = li, li = n;
}
function da() {
  Lu++;
}
function pa() {
  if (--Lu > 0)
    return;
  if (ci) {
    let r = ci;
    for (ci = void 0; r; ) {
      const a = r.next;
      r.next = void 0, r.flags &= -9, r = a;
    }
  }
  let n;
  for (; li; ) {
    let r = li;
    for (li = void 0; r; ) {
      const a = r.next;
      if (r.next = void 0, r.flags &= -9, r.flags & 1)
        try {
          r.trigger();
        } catch (u) {
          n || (n = u);
        }
      r = a;
    }
  }
  if (n) throw n;
}
function Fu(n) {
  for (let r = n.deps; r; r = r.nextDep)
    r.version = -1, r.prevActiveLink = r.dep.activeLink, r.dep.activeLink = r;
}
function Mu(n) {
  let r, a = n.depsTail, u = a;
  for (; u; ) {
    const c = u.prevDep;
    u.version === -1 ? (u === a && (a = c), ha(u), sc(u)) : r = u, u.dep.activeLink = u.prevActiveLink, u.prevActiveLink = void 0, u = c;
  }
  n.deps = r, n.depsTail = a;
}
function Us(n) {
  for (let r = n.deps; r; r = r.nextDep)
    if (r.dep.version !== r.version || r.dep.computed && (Bu(r.dep.computed) || r.dep.version !== r.version))
      return !0;
  return !!n._dirty;
}
function Bu(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === vi) || (n.globalVersion = vi, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !Us(n))))
    return;
  n.flags |= 2;
  const r = n.dep, a = ct, u = Dn;
  ct = n, Dn = !0;
  try {
    Fu(n);
    const c = n.fn(n._value);
    (r.version === 0 || Cr(c, n._value)) && (n.flags |= 128, n._value = c, r.version++);
  } catch (c) {
    throw r.version++, c;
  } finally {
    ct = a, Dn = u, Mu(n), n.flags &= -3;
  }
}
function ha(n, r = !1) {
  const { dep: a, prevSub: u, nextSub: c } = n;
  if (u && (u.nextSub = c, n.prevSub = void 0), c && (c.prevSub = u, n.nextSub = void 0), a.subs === n && (a.subs = u, !u && a.computed)) {
    a.computed.flags &= -5;
    for (let d = a.computed.deps; d; d = d.nextDep)
      ha(d, !0);
  }
  !r && !--a.sc && a.map && a.map.delete(a.key);
}
function sc(n) {
  const { prevDep: r, nextDep: a } = n;
  r && (r.nextDep = a, n.prevDep = void 0), a && (a.prevDep = r, n.nextDep = void 0);
}
let Dn = !0;
const qu = [];
function br() {
  qu.push(Dn), Dn = !1;
}
function _r() {
  const n = qu.pop();
  Dn = n === void 0 ? !0 : n;
}
function Ia(n) {
  const { cleanup: r } = n;
  if (n.cleanup = void 0, r) {
    const a = ct;
    ct = void 0;
    try {
      r();
    } finally {
      ct = a;
    }
  }
}
let vi = 0;
class ac {
  constructor(r, a) {
    this.sub = r, this.dep = a, this.version = a.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ma {
  // TODO isolatedDeclarations "__v_skip"
  constructor(r) {
    this.computed = r, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(r) {
    if (!ct || !Dn || ct === this.computed)
      return;
    let a = this.activeLink;
    if (a === void 0 || a.sub !== ct)
      a = this.activeLink = new ac(ct, this), ct.deps ? (a.prevDep = ct.depsTail, ct.depsTail.nextDep = a, ct.depsTail = a) : ct.deps = ct.depsTail = a, $u(a);
    else if (a.version === -1 && (a.version = this.version, a.nextDep)) {
      const u = a.nextDep;
      u.prevDep = a.prevDep, a.prevDep && (a.prevDep.nextDep = u), a.prevDep = ct.depsTail, a.nextDep = void 0, ct.depsTail.nextDep = a, ct.depsTail = a, ct.deps === a && (ct.deps = u);
    }
    return a;
  }
  trigger(r) {
    this.version++, vi++, this.notify(r);
  }
  notify(r) {
    da();
    try {
      for (let a = this.subs; a; a = a.prevSub)
        a.sub.notify() && a.sub.dep.notify();
    } finally {
      pa();
    }
  }
}
function $u(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const r = n.dep.computed;
    if (r && !n.dep.subs) {
      r.flags |= 20;
      for (let u = r.deps; u; u = u.nextDep)
        $u(u);
    }
    const a = n.dep.subs;
    a !== n && (n.prevSub = a, a && (a.nextSub = n)), n.dep.subs = n;
  }
}
const Ki = /* @__PURE__ */ new WeakMap(), fo = Symbol(
  ""
), Vs = Symbol(
  ""
), gi = Symbol(
  ""
);
function Ht(n, r, a) {
  if (Dn && ct) {
    let u = Ki.get(n);
    u || Ki.set(n, u = /* @__PURE__ */ new Map());
    let c = u.get(a);
    c || (u.set(a, c = new ma()), c.map = u, c.key = a), c.track();
  }
}
function hr(n, r, a, u, c, d) {
  const p = Ki.get(n);
  if (!p) {
    vi++;
    return;
  }
  const g = (O) => {
    O && O.trigger();
  };
  if (da(), r === "clear")
    p.forEach(g);
  else {
    const O = Ne(n), K = O && la(a);
    if (O && a === "length") {
      const P = Number(u);
      p.forEach((R, j) => {
        (j === "length" || j === gi || !In(j) && j >= P) && g(R);
      });
    } else
      switch ((a !== void 0 || p.has(void 0)) && g(p.get(a)), K && g(p.get(gi)), r) {
        case "add":
          O ? K && g(p.get("length")) : (g(p.get(fo)), wo(n) && g(p.get(Vs)));
          break;
        case "delete":
          O || (g(p.get(fo)), wo(n) && g(p.get(Vs)));
          break;
        case "set":
          wo(n) && g(p.get(fo));
          break;
      }
  }
  pa();
}
function uc(n, r) {
  const a = Ki.get(n);
  return a && a.get(r);
}
function vo(n) {
  const r = Qe(n);
  return r === n ? r : (Ht(r, "iterate", gi), gn(n) ? r : r.map(qt));
}
function Xi(n) {
  return Ht(n = Qe(n), "iterate", gi), n;
}
const lc = {
  __proto__: null,
  [Symbol.iterator]() {
    return Is(this, Symbol.iterator, qt);
  },
  concat(...n) {
    return vo(this).concat(
      ...n.map((r) => Ne(r) ? vo(r) : r)
    );
  },
  entries() {
    return Is(this, "entries", (n) => (n[1] = qt(n[1]), n));
  },
  every(n, r) {
    return dr(this, "every", n, r, void 0, arguments);
  },
  filter(n, r) {
    return dr(this, "filter", n, r, (a) => a.map(qt), arguments);
  },
  find(n, r) {
    return dr(this, "find", n, r, qt, arguments);
  },
  findIndex(n, r) {
    return dr(this, "findIndex", n, r, void 0, arguments);
  },
  findLast(n, r) {
    return dr(this, "findLast", n, r, qt, arguments);
  },
  findLastIndex(n, r) {
    return dr(this, "findLastIndex", n, r, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, r) {
    return dr(this, "forEach", n, r, void 0, arguments);
  },
  includes(...n) {
    return Rs(this, "includes", n);
  },
  indexOf(...n) {
    return Rs(this, "indexOf", n);
  },
  join(n) {
    return vo(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return Rs(this, "lastIndexOf", n);
  },
  map(n, r) {
    return dr(this, "map", n, r, void 0, arguments);
  },
  pop() {
    return ii(this, "pop");
  },
  push(...n) {
    return ii(this, "push", n);
  },
  reduce(n, ...r) {
    return Ra(this, "reduce", n, r);
  },
  reduceRight(n, ...r) {
    return Ra(this, "reduceRight", n, r);
  },
  shift() {
    return ii(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, r) {
    return dr(this, "some", n, r, void 0, arguments);
  },
  splice(...n) {
    return ii(this, "splice", n);
  },
  toReversed() {
    return vo(this).toReversed();
  },
  toSorted(n) {
    return vo(this).toSorted(n);
  },
  toSpliced(...n) {
    return vo(this).toSpliced(...n);
  },
  unshift(...n) {
    return ii(this, "unshift", n);
  },
  values() {
    return Is(this, "values", qt);
  }
};
function Is(n, r, a) {
  const u = Xi(n), c = u[r]();
  return u !== n && !gn(n) && (c._next = c.next, c.next = () => {
    const d = c._next();
    return d.value && (d.value = a(d.value)), d;
  }), c;
}
const cc = Array.prototype;
function dr(n, r, a, u, c, d) {
  const p = Xi(n), g = p !== n && !gn(n), O = p[r];
  if (O !== cc[r]) {
    const R = O.apply(n, d);
    return g ? qt(R) : R;
  }
  let K = a;
  p !== n && (g ? K = function(R, j) {
    return a.call(this, qt(R), j, n);
  } : a.length > 2 && (K = function(R, j) {
    return a.call(this, R, j, n);
  }));
  const P = O.call(p, K, u);
  return g && c ? c(P) : P;
}
function Ra(n, r, a, u) {
  const c = Xi(n);
  let d = a;
  return c !== n && (gn(n) ? a.length > 3 && (d = function(p, g, O) {
    return a.call(this, p, g, O, n);
  }) : d = function(p, g, O) {
    return a.call(this, p, qt(g), O, n);
  }), c[r](d, ...u);
}
function Rs(n, r, a) {
  const u = Qe(n);
  Ht(u, "iterate", gi);
  const c = u[r](...a);
  return (c === -1 || c === !1) && ga(a[0]) ? (a[0] = Qe(a[0]), u[r](...a)) : c;
}
function ii(n, r, a = []) {
  br(), da();
  const u = Qe(n)[r].apply(n, a);
  return pa(), _r(), u;
}
const fc = /* @__PURE__ */ sa("__proto__,__v_isRef,__isVue"), Uu = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(In)
);
function dc(n) {
  In(n) || (n = String(n));
  const r = Qe(this);
  return Ht(r, "has", n), r.hasOwnProperty(n);
}
class Vu {
  constructor(r = !1, a = !1) {
    this._isReadonly = r, this._isShallow = a;
  }
  get(r, a, u) {
    if (a === "__v_skip") return r.__v_skip;
    const c = this._isReadonly, d = this._isShallow;
    if (a === "__v_isReactive")
      return !c;
    if (a === "__v_isReadonly")
      return c;
    if (a === "__v_isShallow")
      return d;
    if (a === "__v_raw")
      return u === (c ? d ? xc : Yu : d ? Gu : Wu).get(r) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(r) === Object.getPrototypeOf(u) ? r : void 0;
    const p = Ne(r);
    if (!c) {
      let O;
      if (p && (O = lc[a]))
        return O;
      if (a === "hasOwnProperty")
        return dc;
    }
    const g = Reflect.get(
      r,
      a,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      vt(r) ? r : u
    );
    return (In(a) ? Uu.has(a) : fc(a)) || (c || Ht(r, "get", a), d) ? g : vt(g) ? p && la(a) ? g : g.value : ft(g) ? c ? Xu(g) : zi(g) : g;
  }
}
class Hu extends Vu {
  constructor(r = !1) {
    super(!1, r);
  }
  set(r, a, u, c) {
    let d = r[a];
    if (!this._isShallow) {
      const O = Nr(d);
      if (!gn(u) && !Nr(u) && (d = Qe(d), u = Qe(u)), !Ne(r) && vt(d) && !vt(u))
        return O ? !1 : (d.value = u, !0);
    }
    const p = Ne(r) && la(a) ? Number(a) < r.length : rt(r, a), g = Reflect.set(
      r,
      a,
      u,
      vt(r) ? r : c
    );
    return r === Qe(c) && (p ? Cr(u, d) && hr(r, "set", a, u) : hr(r, "add", a, u)), g;
  }
  deleteProperty(r, a) {
    const u = rt(r, a);
    r[a];
    const c = Reflect.deleteProperty(r, a);
    return c && u && hr(r, "delete", a, void 0), c;
  }
  has(r, a) {
    const u = Reflect.has(r, a);
    return (!In(a) || !Uu.has(a)) && Ht(r, "has", a), u;
  }
  ownKeys(r) {
    return Ht(
      r,
      "iterate",
      Ne(r) ? "length" : fo
    ), Reflect.ownKeys(r);
  }
}
class pc extends Vu {
  constructor(r = !1) {
    super(!0, r);
  }
  set(r, a) {
    return !0;
  }
  deleteProperty(r, a) {
    return !0;
  }
}
const hc = /* @__PURE__ */ new Hu(), mc = /* @__PURE__ */ new pc(), yc = /* @__PURE__ */ new Hu(!0);
const Hs = (n) => n, Ci = (n) => Reflect.getPrototypeOf(n);
function vc(n, r, a) {
  return function(...u) {
    const c = this.__v_raw, d = Qe(c), p = wo(d), g = n === "entries" || n === Symbol.iterator && p, O = n === "keys" && p, K = c[n](...u), P = a ? Hs : r ? Fi : qt;
    return !r && Ht(
      d,
      "iterate",
      O ? Vs : fo
    ), {
      // iterator protocol
      next() {
        const { value: R, done: j } = K.next();
        return j ? { value: R, done: j } : {
          value: g ? [P(R[0]), P(R[1])] : P(R),
          done: j
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Si(n) {
  return function(...r) {
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function gc(n, r) {
  const a = {
    get(c) {
      const d = this.__v_raw, p = Qe(d), g = Qe(c);
      n || (Cr(c, g) && Ht(p, "get", c), Ht(p, "get", g));
      const { has: O } = Ci(p), K = r ? Hs : n ? Fi : qt;
      if (O.call(p, c))
        return K(d.get(c));
      if (O.call(p, g))
        return K(d.get(g));
      d !== p && d.get(c);
    },
    get size() {
      const c = this.__v_raw;
      return !n && Ht(Qe(c), "iterate", fo), Reflect.get(c, "size", c);
    },
    has(c) {
      const d = this.__v_raw, p = Qe(d), g = Qe(c);
      return n || (Cr(c, g) && Ht(p, "has", c), Ht(p, "has", g)), c === g ? d.has(c) : d.has(c) || d.has(g);
    },
    forEach(c, d) {
      const p = this, g = p.__v_raw, O = Qe(g), K = r ? Hs : n ? Fi : qt;
      return !n && Ht(O, "iterate", fo), g.forEach((P, R) => c.call(d, K(P), K(R), p));
    }
  };
  return Wt(
    a,
    n ? {
      add: Si("add"),
      set: Si("set"),
      delete: Si("delete"),
      clear: Si("clear")
    } : {
      add(c) {
        !r && !gn(c) && !Nr(c) && (c = Qe(c));
        const d = Qe(this);
        return Ci(d).has.call(d, c) || (d.add(c), hr(d, "add", c, c)), this;
      },
      set(c, d) {
        !r && !gn(d) && !Nr(d) && (d = Qe(d));
        const p = Qe(this), { has: g, get: O } = Ci(p);
        let K = g.call(p, c);
        K || (c = Qe(c), K = g.call(p, c));
        const P = O.call(p, c);
        return p.set(c, d), K ? Cr(d, P) && hr(p, "set", c, d) : hr(p, "add", c, d), this;
      },
      delete(c) {
        const d = Qe(this), { has: p, get: g } = Ci(d);
        let O = p.call(d, c);
        O || (c = Qe(c), O = p.call(d, c)), g && g.call(d, c);
        const K = d.delete(c);
        return O && hr(d, "delete", c, void 0), K;
      },
      clear() {
        const c = Qe(this), d = c.size !== 0, p = c.clear();
        return d && hr(
          c,
          "clear",
          void 0,
          void 0
        ), p;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((c) => {
    a[c] = vc(c, n, r);
  }), a;
}
function ya(n, r) {
  const a = gc(n, r);
  return (u, c, d) => c === "__v_isReactive" ? !n : c === "__v_isReadonly" ? n : c === "__v_raw" ? u : Reflect.get(
    rt(a, c) && c in u ? a : u,
    c,
    d
  );
}
const bc = {
  get: /* @__PURE__ */ ya(!1, !1)
}, _c = {
  get: /* @__PURE__ */ ya(!1, !0)
}, wc = {
  get: /* @__PURE__ */ ya(!0, !1)
};
const Wu = /* @__PURE__ */ new WeakMap(), Gu = /* @__PURE__ */ new WeakMap(), Yu = /* @__PURE__ */ new WeakMap(), xc = /* @__PURE__ */ new WeakMap();
function Tc(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Ec(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : Tc(Xl(n));
}
function zi(n) {
  return Nr(n) ? n : va(
    n,
    !1,
    hc,
    bc,
    Wu
  );
}
function Oc(n) {
  return va(
    n,
    !1,
    yc,
    _c,
    Gu
  );
}
function Xu(n) {
  return va(
    n,
    !0,
    mc,
    wc,
    Yu
  );
}
function va(n, r, a, u, c) {
  if (!ft(n) || n.__v_raw && !(r && n.__v_isReactive))
    return n;
  const d = Ec(n);
  if (d === 0)
    return n;
  const p = c.get(n);
  if (p)
    return p;
  const g = new Proxy(
    n,
    d === 2 ? u : a
  );
  return c.set(n, g), g;
}
function vr(n) {
  return Nr(n) ? vr(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Nr(n) {
  return !!(n && n.__v_isReadonly);
}
function gn(n) {
  return !!(n && n.__v_isShallow);
}
function ga(n) {
  return n ? !!n.__v_raw : !1;
}
function Qe(n) {
  const r = n && n.__v_raw;
  return r ? Qe(r) : n;
}
function ba(n) {
  return !rt(n, "__v_skip") && Object.isExtensible(n) && $s(n, "__v_skip", !0), n;
}
const qt = (n) => ft(n) ? zi(n) : n, Fi = (n) => ft(n) ? Xu(n) : n;
function vt(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function _t(n) {
  return zu(n, !1);
}
function Cc(n) {
  return zu(n, !0);
}
function zu(n, r) {
  return vt(n) ? n : new Sc(n, r);
}
class Sc {
  constructor(r, a) {
    this.dep = new ma(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = a ? r : Qe(r), this._value = a ? r : qt(r), this.__v_isShallow = a;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(r) {
    const a = this._rawValue, u = this.__v_isShallow || gn(r) || Nr(r);
    r = u ? r : Qe(r), Cr(r, a) && (this._rawValue = r, this._value = u ? r : qt(r), this.dep.trigger());
  }
}
function yt(n) {
  return vt(n) ? n.value : n;
}
const Nc = {
  get: (n, r, a) => r === "__v_raw" ? n : yt(Reflect.get(n, r, a)),
  set: (n, r, a, u) => {
    const c = n[r];
    return vt(c) && !vt(a) ? (c.value = a, !0) : Reflect.set(n, r, a, u);
  }
};
function Qu(n) {
  return vr(n) ? n : new Proxy(n, Nc);
}
function Ac(n) {
  const r = Ne(n) ? new Array(n.length) : {};
  for (const a in n)
    r[a] = Ju(n, a);
  return r;
}
class Pc {
  constructor(r, a, u) {
    this._object = r, this._key = a, this._defaultValue = u, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const r = this._object[this._key];
    return this._value = r === void 0 ? this._defaultValue : r;
  }
  set value(r) {
    this._object[this._key] = r;
  }
  get dep() {
    return uc(Qe(this._object), this._key);
  }
}
class kc {
  constructor(r) {
    this._getter = r, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Dc(n, r, a) {
  return vt(n) ? n : Ke(n) ? new kc(n) : ft(n) && arguments.length > 1 ? Ju(n, r, a) : _t(n);
}
function Ju(n, r, a) {
  const u = n[r];
  return vt(u) ? u : new Pc(n, r, a);
}
class Ic {
  constructor(r, a, u) {
    this.fn = r, this.setter = a, this._value = void 0, this.dep = new ma(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = vi - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !a, this.isSSR = u;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    ct !== this)
      return Ku(this, !0), !0;
  }
  get value() {
    const r = this.dep.track();
    return Bu(this), r && (r.version = this.dep.version), this._value;
  }
  set value(r) {
    this.setter && this.setter(r);
  }
}
function Rc(n, r, a = !1) {
  let u, c;
  return Ke(n) ? u = n : (u = n.get, c = n.set), new Ic(u, c, a);
}
const Ni = {}, Mi = /* @__PURE__ */ new WeakMap();
let co;
function jc(n, r = !1, a = co) {
  if (a) {
    let u = Mi.get(a);
    u || Mi.set(a, u = []), u.push(n);
  }
}
function Lc(n, r, a = it) {
  const { immediate: u, deep: c, once: d, scheduler: p, augmentJob: g, call: O } = a, K = (de) => c ? de : gn(de) || c === !1 || c === 0 ? mr(de, 1) : mr(de);
  let P, R, j, L, G = !1, fe = !1;
  if (vt(n) ? (R = () => n.value, G = gn(n)) : vr(n) ? (R = () => K(n), G = !0) : Ne(n) ? (fe = !0, G = n.some((de) => vr(de) || gn(de)), R = () => n.map((de) => {
    if (vt(de))
      return de.value;
    if (vr(de))
      return K(de);
    if (Ke(de))
      return O ? O(de, 2) : de();
  })) : Ke(n) ? r ? R = O ? () => O(n, 2) : n : R = () => {
    if (j) {
      br();
      try {
        j();
      } finally {
        _r();
      }
    }
    const de = co;
    co = P;
    try {
      return O ? O(n, 3, [L]) : n(L);
    } finally {
      co = de;
    }
  } : R = Bn, r && c) {
    const de = R, Ae = c === !0 ? 1 / 0 : c;
    R = () => mr(de(), Ae);
  }
  const qe = Ru(), pe = () => {
    P.stop(), qe && qe.active && ua(qe.effects, P);
  };
  if (d && r) {
    const de = r;
    r = (...Ae) => {
      de(...Ae), pe();
    };
  }
  let me = fe ? new Array(n.length).fill(Ni) : Ni;
  const Ee = (de) => {
    if (!(!(P.flags & 1) || !P.dirty && !de))
      if (r) {
        const Ae = P.run();
        if (c || G || (fe ? Ae.some((Be, ye) => Cr(Be, me[ye])) : Cr(Ae, me))) {
          j && j();
          const Be = co;
          co = P;
          try {
            const ye = [
              Ae,
              // pass undefined as the old value when it's changed for the first time
              me === Ni ? void 0 : fe && me[0] === Ni ? [] : me,
              L
            ];
            me = Ae, O ? O(r, 3, ye) : (
              // @ts-expect-error
              r(...ye)
            );
          } finally {
            co = Be;
          }
        }
      } else
        P.run();
  };
  return g && g(Ee), P = new ju(R), P.scheduler = p ? () => p(Ee, !1) : Ee, L = (de) => jc(de, !1, P), j = P.onStop = () => {
    const de = Mi.get(P);
    if (de) {
      if (O)
        O(de, 4);
      else
        for (const Ae of de) Ae();
      Mi.delete(P);
    }
  }, r ? u ? Ee(!0) : me = P.run() : p ? p(Ee.bind(null, !0), !0) : P.run(), pe.pause = P.pause.bind(P), pe.resume = P.resume.bind(P), pe.stop = pe, pe;
}
function mr(n, r = 1 / 0, a) {
  if (r <= 0 || !ft(n) || n.__v_skip || (a = a || /* @__PURE__ */ new Set(), a.has(n)))
    return n;
  if (a.add(n), r--, vt(n))
    mr(n.value, r, a);
  else if (Ne(n))
    for (let u = 0; u < n.length; u++)
      mr(n[u], r, a);
  else if (Co(n) || wo(n))
    n.forEach((u) => {
      mr(u, r, a);
    });
  else if (Su(n)) {
    for (const u in n)
      mr(n[u], r, a);
    for (const u of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, u) && mr(n[u], r, a);
  }
  return n;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Ti(n, r, a, u) {
  try {
    return u ? n(...u) : n();
  } catch (c) {
    Qi(c, r, a);
  }
}
function qn(n, r, a, u) {
  if (Ke(n)) {
    const c = Ti(n, r, a, u);
    return c && Ou(c) && c.catch((d) => {
      Qi(d, r, a);
    }), c;
  }
  if (Ne(n)) {
    const c = [];
    for (let d = 0; d < n.length; d++)
      c.push(qn(n[d], r, a, u));
    return c;
  }
}
function Qi(n, r, a, u = !0) {
  const c = r ? r.vnode : null, { errorHandler: d, throwUnhandledErrorInProduction: p } = r && r.appContext.config || it;
  if (r) {
    let g = r.parent;
    const O = r.proxy, K = `https://vuejs.org/error-reference/#runtime-${a}`;
    for (; g; ) {
      const P = g.ec;
      if (P) {
        for (let R = 0; R < P.length; R++)
          if (P[R](n, O, K) === !1)
            return;
      }
      g = g.parent;
    }
    if (d) {
      br(), Ti(d, null, 10, [
        n,
        O,
        K
      ]), _r();
      return;
    }
  }
  Kc(n, a, c, u, p);
}
function Kc(n, r, a, u = !0, c = !1) {
  if (c)
    throw n;
  console.error(n);
}
const on = [];
let Kn = -1;
const xo = [];
let Er = null, bo = 0;
const Zu = /* @__PURE__ */ Promise.resolve();
let Bi = null;
function _a(n) {
  const r = Bi || Zu;
  return n ? r.then(this ? n.bind(this) : n) : r;
}
function Fc(n) {
  let r = Kn + 1, a = on.length;
  for (; r < a; ) {
    const u = r + a >>> 1, c = on[u], d = bi(c);
    d < n || d === n && c.flags & 2 ? r = u + 1 : a = u;
  }
  return r;
}
function wa(n) {
  if (!(n.flags & 1)) {
    const r = bi(n), a = on[on.length - 1];
    !a || // fast path when the job id is larger than the tail
    !(n.flags & 2) && r >= bi(a) ? on.push(n) : on.splice(Fc(r), 0, n), n.flags |= 1, el();
  }
}
function el() {
  Bi || (Bi = Zu.then(nl));
}
function Mc(n) {
  Ne(n) ? xo.push(...n) : Er && n.id === -1 ? Er.splice(bo + 1, 0, n) : n.flags & 1 || (xo.push(n), n.flags |= 1), el();
}
function ja(n, r, a = Kn + 1) {
  for (; a < on.length; a++) {
    const u = on[a];
    if (u && u.flags & 2) {
      if (n && u.id !== n.uid)
        continue;
      on.splice(a, 1), a--, u.flags & 4 && (u.flags &= -2), u(), u.flags & 4 || (u.flags &= -2);
    }
  }
}
function tl(n) {
  if (xo.length) {
    const r = [...new Set(xo)].sort(
      (a, u) => bi(a) - bi(u)
    );
    if (xo.length = 0, Er) {
      Er.push(...r);
      return;
    }
    for (Er = r, bo = 0; bo < Er.length; bo++) {
      const a = Er[bo];
      a.flags & 4 && (a.flags &= -2), a.flags & 8 || a(), a.flags &= -2;
    }
    Er = null, bo = 0;
  }
}
const bi = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function nl(n) {
  try {
    for (Kn = 0; Kn < on.length; Kn++) {
      const r = on[Kn];
      r && !(r.flags & 8) && (r.flags & 4 && (r.flags &= -2), Ti(
        r,
        r.i,
        r.i ? 15 : 14
      ), r.flags & 4 || (r.flags &= -2));
    }
  } finally {
    for (; Kn < on.length; Kn++) {
      const r = on[Kn];
      r && (r.flags &= -2);
    }
    Kn = -1, on.length = 0, tl(), Bi = null, (on.length || xo.length) && nl();
  }
}
let Rt = null, rl = null;
function qi(n) {
  const r = Rt;
  return Rt = n, rl = n && n.type.__scopeId || null, r;
}
function Ws(n, r = Rt, a) {
  if (!r || n._n)
    return n;
  const u = (...c) => {
    u._d && Ya(-1);
    const d = qi(r);
    let p;
    try {
      p = n(...c);
    } finally {
      qi(d), u._d && Ya(1);
    }
    return p;
  };
  return u._n = !0, u._c = !0, u._d = !0, u;
}
function mt(n, r) {
  if (Rt === null)
    return n;
  const a = ts(Rt), u = n.dirs || (n.dirs = []);
  for (let c = 0; c < r.length; c++) {
    let [d, p, g, O = it] = r[c];
    d && (Ke(d) && (d = {
      mounted: d,
      updated: d
    }), d.deep && mr(p), u.push({
      dir: d,
      instance: a,
      value: p,
      oldValue: void 0,
      arg: g,
      modifiers: O
    }));
  }
  return n;
}
function uo(n, r, a, u) {
  const c = n.dirs, d = r && r.dirs;
  for (let p = 0; p < c.length; p++) {
    const g = c[p];
    d && (g.oldValue = d[p].value);
    let O = g.dir[u];
    O && (br(), qn(O, a, 8, [
      n.el,
      g,
      n,
      r
    ]), _r());
  }
}
const ol = Symbol("_vte"), Bc = (n) => n.__isTeleport, fi = (n) => n && (n.disabled || n.disabled === ""), La = (n) => n && (n.defer || n.defer === ""), Ka = (n) => typeof SVGElement < "u" && n instanceof SVGElement, Fa = (n) => typeof MathMLElement == "function" && n instanceof MathMLElement, Gs = (n, r) => {
  const a = n && n.to;
  return Et(a) ? r ? r(a) : null : a;
}, il = {
  name: "Teleport",
  __isTeleport: !0,
  process(n, r, a, u, c, d, p, g, O, K) {
    const {
      mc: P,
      pc: R,
      pbc: j,
      o: { insert: L, querySelector: G, createText: fe, createComment: qe }
    } = K, pe = fi(r.props);
    let { shapeFlag: me, children: Ee, dynamicChildren: de } = r;
    if (n == null) {
      const Ae = r.el = fe(""), Be = r.anchor = fe("");
      L(Ae, a, u), L(Be, a, u);
      const ye = (B, We) => {
        me & 16 && (c && c.isCE && (c.ce._teleportTarget = B), P(
          Ee,
          B,
          We,
          c,
          d,
          p,
          g,
          O
        ));
      }, Ce = () => {
        const B = r.target = Gs(r.props, G), We = al(B, r, fe, L);
        B && (p !== "svg" && Ka(B) ? p = "svg" : p !== "mathml" && Fa(B) && (p = "mathml"), pe || (ye(B, We), ki(r, !1)));
      };
      pe && (ye(a, Be), ki(r, !0)), La(r.props) ? (r.el.__isMounted = !1, rn(() => {
        Ce(), delete r.el.__isMounted;
      }, d)) : Ce();
    } else {
      if (La(r.props) && n.el.__isMounted === !1) {
        rn(() => {
          il.process(
            n,
            r,
            a,
            u,
            c,
            d,
            p,
            g,
            O,
            K
          );
        }, d);
        return;
      }
      r.el = n.el, r.targetStart = n.targetStart;
      const Ae = r.anchor = n.anchor, Be = r.target = n.target, ye = r.targetAnchor = n.targetAnchor, Ce = fi(n.props), B = Ce ? a : Be, We = Ce ? Ae : ye;
      if (p === "svg" || Ka(Be) ? p = "svg" : (p === "mathml" || Fa(Be)) && (p = "mathml"), de ? (j(
        n.dynamicChildren,
        de,
        B,
        c,
        d,
        p,
        g
      ), Ca(n, r, !0)) : O || R(
        n,
        r,
        B,
        We,
        c,
        d,
        p,
        g,
        !1
      ), pe)
        Ce ? r.props && n.props && r.props.to !== n.props.to && (r.props.to = n.props.to) : Ai(
          r,
          a,
          Ae,
          K,
          1
        );
      else if ((r.props && r.props.to) !== (n.props && n.props.to)) {
        const st = r.target = Gs(
          r.props,
          G
        );
        st && Ai(
          r,
          st,
          null,
          K,
          0
        );
      } else Ce && Ai(
        r,
        Be,
        ye,
        K,
        1
      );
      ki(r, pe);
    }
  },
  remove(n, r, a, { um: u, o: { remove: c } }, d) {
    const {
      shapeFlag: p,
      children: g,
      anchor: O,
      targetStart: K,
      targetAnchor: P,
      target: R,
      props: j
    } = n;
    if (R && (c(K), c(P)), d && c(O), p & 16) {
      const L = d || !fi(j);
      for (let G = 0; G < g.length; G++) {
        const fe = g[G];
        u(
          fe,
          r,
          a,
          L,
          !!fe.dynamicChildren
        );
      }
    }
  },
  move: Ai,
  hydrate: qc
};
function Ai(n, r, a, { o: { insert: u }, m: c }, d = 2) {
  d === 0 && u(n.targetAnchor, r, a);
  const { el: p, anchor: g, shapeFlag: O, children: K, props: P } = n, R = d === 2;
  if (R && u(p, r, a), (!R || fi(P)) && O & 16)
    for (let j = 0; j < K.length; j++)
      c(
        K[j],
        r,
        a,
        2
      );
  R && u(g, r, a);
}
function qc(n, r, a, u, c, d, {
  o: { nextSibling: p, parentNode: g, querySelector: O, insert: K, createText: P }
}, R) {
  const j = r.target = Gs(
    r.props,
    O
  );
  if (j) {
    const L = fi(r.props), G = j._lpa || j.firstChild;
    if (r.shapeFlag & 16)
      if (L)
        r.anchor = R(
          p(n),
          r,
          g(n),
          a,
          u,
          c,
          d
        ), r.targetStart = G, r.targetAnchor = G && p(G);
      else {
        r.anchor = p(n);
        let fe = G;
        for (; fe; ) {
          if (fe && fe.nodeType === 8) {
            if (fe.data === "teleport start anchor")
              r.targetStart = fe;
            else if (fe.data === "teleport anchor") {
              r.targetAnchor = fe, j._lpa = r.targetAnchor && p(r.targetAnchor);
              break;
            }
          }
          fe = p(fe);
        }
        r.targetAnchor || al(j, r, P, K), R(
          G && p(G),
          r,
          j,
          a,
          u,
          c,
          d
        );
      }
    ki(r, L);
  }
  return r.anchor && p(r.anchor);
}
const sl = il;
function ki(n, r) {
  const a = n.ctx;
  if (a && a.ut) {
    let u, c;
    for (r ? (u = n.el, c = n.anchor) : (u = n.targetStart, c = n.targetAnchor); u && u !== c; )
      u.nodeType === 1 && u.setAttribute("data-v-owner", a.uid), u = u.nextSibling;
    a.ut();
  }
}
function al(n, r, a, u) {
  const c = r.targetStart = a(""), d = r.targetAnchor = a("");
  return c[ol] = d, n && (u(c, n), u(d, n)), d;
}
function xa(n, r) {
  n.shapeFlag & 6 && n.component ? (n.transition = r, xa(n.component.subTree, r)) : n.shapeFlag & 128 ? (n.ssContent.transition = r.clone(n.ssContent), n.ssFallback.transition = r.clone(n.ssFallback)) : n.transition = r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Gt(n, r) {
  return Ke(n) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Wt({ name: n.name }, r, { setup: n })
  ) : n;
}
function ul(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0];
}
function ll(n) {
  const r = Ff(), a = Cc(null);
  if (r) {
    const c = r.refs === it ? r.refs = {} : r.refs;
    Object.defineProperty(c, n, {
      enumerable: !0,
      get: () => a.value,
      set: (d) => a.value = d
    });
  }
  return a;
}
function di(n, r, a, u, c = !1) {
  if (Ne(n)) {
    n.forEach(
      (G, fe) => di(
        G,
        r && (Ne(r) ? r[fe] : r),
        a,
        u,
        c
      )
    );
    return;
  }
  if (To(u) && !c) {
    u.shapeFlag & 512 && u.type.__asyncResolved && u.component.subTree.component && di(n, r, a, u.component.subTree);
    return;
  }
  const d = u.shapeFlag & 4 ? ts(u.component) : u.el, p = c ? null : d, { i: g, r: O } = n, K = r && r.r, P = g.refs === it ? g.refs = {} : g.refs, R = g.setupState, j = Qe(R), L = R === it ? () => !1 : (G) => rt(j, G);
  if (K != null && K !== O && (Et(K) ? (P[K] = null, L(K) && (R[K] = null)) : vt(K) && (K.value = null)), Ke(O))
    Ti(O, g, 12, [p, P]);
  else {
    const G = Et(O), fe = vt(O);
    if (G || fe) {
      const qe = () => {
        if (n.f) {
          const pe = G ? L(O) ? R[O] : P[O] : O.value;
          c ? Ne(pe) && ua(pe, d) : Ne(pe) ? pe.includes(d) || pe.push(d) : G ? (P[O] = [d], L(O) && (R[O] = P[O])) : (O.value = [d], n.k && (P[n.k] = O.value));
        } else G ? (P[O] = p, L(O) && (R[O] = p)) : fe && (O.value = p, n.k && (P[n.k] = p));
      };
      p ? (qe.id = -1, rn(qe, a)) : qe();
    }
  }
}
Yi().requestIdleCallback;
Yi().cancelIdleCallback;
const To = (n) => !!n.type.__asyncLoader, cl = (n) => n.type.__isKeepAlive;
function $c(n, r) {
  fl(n, "a", r);
}
function Uc(n, r) {
  fl(n, "da", r);
}
function fl(n, r, a = $t) {
  const u = n.__wdc || (n.__wdc = () => {
    let c = a;
    for (; c; ) {
      if (c.isDeactivated)
        return;
      c = c.parent;
    }
    return n();
  });
  if (Ji(r, u, a), a) {
    let c = a.parent;
    for (; c && c.parent; )
      cl(c.parent.vnode) && Vc(u, r, a, c), c = c.parent;
  }
}
function Vc(n, r, a, u) {
  const c = Ji(
    r,
    n,
    u,
    !0
    /* prepend */
  );
  Ta(() => {
    ua(u[r], c);
  }, a);
}
function Ji(n, r, a = $t, u = !1) {
  if (a) {
    const c = a[n] || (a[n] = []), d = r.__weh || (r.__weh = (...p) => {
      br();
      const g = Ei(a), O = qn(r, a, n, p);
      return g(), _r(), O;
    });
    return u ? c.unshift(d) : c.push(d), d;
  }
}
const xr = (n) => (r, a = $t) => {
  (!wi || n === "sp") && Ji(n, (...u) => r(...u), a);
}, Hc = xr("bm"), dl = xr("m"), Wc = xr(
  "bu"
), Gc = xr("u"), Yc = xr(
  "bum"
), Ta = xr("um"), Xc = xr(
  "sp"
), zc = xr("rtg"), Qc = xr("rtc");
function Jc(n, r = $t) {
  Ji("ec", n, r);
}
const Zc = Symbol.for("v-ndc");
function Ut(n, r, a, u) {
  let c;
  const d = a, p = Ne(n);
  if (p || Et(n)) {
    const g = p && vr(n);
    let O = !1, K = !1;
    g && (O = !gn(n), K = Nr(n), n = Xi(n)), c = new Array(n.length);
    for (let P = 0, R = n.length; P < R; P++)
      c[P] = r(
        O ? K ? Fi(qt(n[P])) : qt(n[P]) : n[P],
        P,
        void 0,
        d
      );
  } else if (typeof n == "number") {
    c = new Array(n);
    for (let g = 0; g < n; g++)
      c[g] = r(g + 1, g, void 0, d);
  } else if (ft(n))
    if (n[Symbol.iterator])
      c = Array.from(
        n,
        (g, O) => r(g, O, void 0, d)
      );
    else {
      const g = Object.keys(n);
      c = new Array(g.length);
      for (let O = 0, K = g.length; O < K; O++) {
        const P = g[O];
        c[O] = r(n[P], P, O, d);
      }
    }
  else
    c = [];
  return c;
}
function Ma(n, r, a = {}, u, c) {
  if (Rt.ce || Rt.parent && To(Rt.parent) && Rt.parent.ce)
    return r !== "default" && (a.name = r), be(), An(
      Je,
      null,
      [Ct("slot", a, u)],
      64
    );
  let d = n[r];
  d && d._c && (d._d = !1), be();
  const p = d && pl(d(a)), g = a.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  p && p.key, O = An(
    Je,
    {
      key: (g && !In(g) ? g : `_${r}`) + // #7256 force differentiate fallback content from actual content
      (!p && u ? "_fb" : "")
    },
    p || [],
    p && n._ === 1 ? 64 : -2
  );
  return d && d._c && (d._d = !0), O;
}
function pl(n) {
  return n.some((r) => Na(r) ? !(r.type === wr || r.type === Je && !pl(r.children)) : !0) ? n : null;
}
const Ys = (n) => n ? Il(n) ? ts(n) : Ys(n.parent) : null, pi = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Wt(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => Ys(n.parent),
    $root: (n) => Ys(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => ml(n),
    $forceUpdate: (n) => n.f || (n.f = () => {
      wa(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = _a.bind(n.proxy)),
    $watch: (n) => Tf.bind(n)
  })
), js = (n, r) => n !== it && !n.__isScriptSetup && rt(n, r), ef = {
  get({ _: n }, r) {
    if (r === "__v_skip")
      return !0;
    const { ctx: a, setupState: u, data: c, props: d, accessCache: p, type: g, appContext: O } = n;
    let K;
    if (r[0] !== "$") {
      const L = p[r];
      if (L !== void 0)
        switch (L) {
          case 1:
            return u[r];
          case 2:
            return c[r];
          case 4:
            return a[r];
          case 3:
            return d[r];
        }
      else {
        if (js(u, r))
          return p[r] = 1, u[r];
        if (c !== it && rt(c, r))
          return p[r] = 2, c[r];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (K = n.propsOptions[0]) && rt(K, r)
        )
          return p[r] = 3, d[r];
        if (a !== it && rt(a, r))
          return p[r] = 4, a[r];
        Xs && (p[r] = 0);
      }
    }
    const P = pi[r];
    let R, j;
    if (P)
      return r === "$attrs" && Ht(n.attrs, "get", ""), P(n);
    if (
      // css module (injected by vue-loader)
      (R = g.__cssModules) && (R = R[r])
    )
      return R;
    if (a !== it && rt(a, r))
      return p[r] = 4, a[r];
    if (
      // global properties
      j = O.config.globalProperties, rt(j, r)
    )
      return j[r];
  },
  set({ _: n }, r, a) {
    const { data: u, setupState: c, ctx: d } = n;
    return js(c, r) ? (c[r] = a, !0) : u !== it && rt(u, r) ? (u[r] = a, !0) : rt(n.props, r) || r[0] === "$" && r.slice(1) in n ? !1 : (d[r] = a, !0);
  },
  has({
    _: { data: n, setupState: r, accessCache: a, ctx: u, appContext: c, propsOptions: d }
  }, p) {
    let g;
    return !!a[p] || n !== it && rt(n, p) || js(r, p) || (g = d[0]) && rt(g, p) || rt(u, p) || rt(pi, p) || rt(c.config.globalProperties, p);
  },
  defineProperty(n, r, a) {
    return a.get != null ? n._.accessCache[r] = 0 : rt(a, "value") && this.set(n, r, a.value, null), Reflect.defineProperty(n, r, a);
  }
};
function Ba(n) {
  return Ne(n) ? n.reduce(
    (r, a) => (r[a] = null, r),
    {}
  ) : n;
}
let Xs = !0;
function tf(n) {
  const r = ml(n), a = n.proxy, u = n.ctx;
  Xs = !1, r.beforeCreate && qa(r.beforeCreate, n, "bc");
  const {
    // state
    data: c,
    computed: d,
    methods: p,
    watch: g,
    provide: O,
    inject: K,
    // lifecycle
    created: P,
    beforeMount: R,
    mounted: j,
    beforeUpdate: L,
    updated: G,
    activated: fe,
    deactivated: qe,
    beforeDestroy: pe,
    beforeUnmount: me,
    destroyed: Ee,
    unmounted: de,
    render: Ae,
    renderTracked: Be,
    renderTriggered: ye,
    errorCaptured: Ce,
    serverPrefetch: B,
    // public API
    expose: We,
    inheritAttrs: st,
    // assets
    components: Re,
    directives: nt,
    filters: yn
  } = r;
  if (K && nf(K, u, null), p)
    for (const ge in p) {
      const Ie = p[ge];
      Ke(Ie) && (u[ge] = Ie.bind(a));
    }
  if (c) {
    const ge = c.call(a, a);
    ft(ge) && (n.data = zi(ge));
  }
  if (Xs = !0, d)
    for (const ge in d) {
      const Ie = d[ge], dt = Ke(Ie) ? Ie.bind(a, a) : Ke(Ie.get) ? Ie.get.bind(a, a) : Bn, ot = !Ke(Ie) && Ke(Ie.set) ? Ie.set.bind(a) : Bn, ht = It({
        get: dt,
        set: ot
      });
      Object.defineProperty(u, ge, {
        enumerable: !0,
        configurable: !0,
        get: () => ht.value,
        set: (kt) => ht.value = kt
      });
    }
  if (g)
    for (const ge in g)
      hl(g[ge], u, a, ge);
  if (O) {
    const ge = Ke(O) ? O.call(a) : O;
    Reflect.ownKeys(ge).forEach((Ie) => {
      lf(Ie, ge[Ie]);
    });
  }
  P && qa(P, n, "c");
  function Ze(ge, Ie) {
    Ne(Ie) ? Ie.forEach((dt) => ge(dt.bind(a))) : Ie && ge(Ie.bind(a));
  }
  if (Ze(Hc, R), Ze(dl, j), Ze(Wc, L), Ze(Gc, G), Ze($c, fe), Ze(Uc, qe), Ze(Jc, Ce), Ze(Qc, Be), Ze(zc, ye), Ze(Yc, me), Ze(Ta, de), Ze(Xc, B), Ne(We))
    if (We.length) {
      const ge = n.exposed || (n.exposed = {});
      We.forEach((Ie) => {
        Object.defineProperty(ge, Ie, {
          get: () => a[Ie],
          set: (dt) => a[Ie] = dt
        });
      });
    } else n.exposed || (n.exposed = {});
  Ae && n.render === Bn && (n.render = Ae), st != null && (n.inheritAttrs = st), Re && (n.components = Re), nt && (n.directives = nt), B && ul(n);
}
function nf(n, r, a = Bn) {
  Ne(n) && (n = zs(n));
  for (const u in n) {
    const c = n[u];
    let d;
    ft(c) ? "default" in c ? d = hi(
      c.from || u,
      c.default,
      !0
    ) : d = hi(c.from || u) : d = hi(c), vt(d) ? Object.defineProperty(r, u, {
      enumerable: !0,
      configurable: !0,
      get: () => d.value,
      set: (p) => d.value = p
    }) : r[u] = d;
  }
}
function qa(n, r, a) {
  qn(
    Ne(n) ? n.map((u) => u.bind(r.proxy)) : n.bind(r.proxy),
    r,
    a
  );
}
function hl(n, r, a, u) {
  let c = u.includes(".") ? Sl(a, u) : () => a[u];
  if (Et(n)) {
    const d = r[n];
    Ke(d) && gr(c, d);
  } else if (Ke(n))
    gr(c, n.bind(a));
  else if (ft(n))
    if (Ne(n))
      n.forEach((d) => hl(d, r, a, u));
    else {
      const d = Ke(n.handler) ? n.handler.bind(a) : r[n.handler];
      Ke(d) && gr(c, d, n);
    }
}
function ml(n) {
  const r = n.type, { mixins: a, extends: u } = r, {
    mixins: c,
    optionsCache: d,
    config: { optionMergeStrategies: p }
  } = n.appContext, g = d.get(r);
  let O;
  return g ? O = g : !c.length && !a && !u ? O = r : (O = {}, c.length && c.forEach(
    (K) => $i(O, K, p, !0)
  ), $i(O, r, p)), ft(r) && d.set(r, O), O;
}
function $i(n, r, a, u = !1) {
  const { mixins: c, extends: d } = r;
  d && $i(n, d, a, !0), c && c.forEach(
    (p) => $i(n, p, a, !0)
  );
  for (const p in r)
    if (!(u && p === "expose")) {
      const g = rf[p] || a && a[p];
      n[p] = g ? g(n[p], r[p]) : r[p];
    }
  return n;
}
const rf = {
  data: $a,
  props: Ua,
  emits: Ua,
  // objects
  methods: ai,
  computed: ai,
  // lifecycle
  beforeCreate: nn,
  created: nn,
  beforeMount: nn,
  mounted: nn,
  beforeUpdate: nn,
  updated: nn,
  beforeDestroy: nn,
  beforeUnmount: nn,
  destroyed: nn,
  unmounted: nn,
  activated: nn,
  deactivated: nn,
  errorCaptured: nn,
  serverPrefetch: nn,
  // assets
  components: ai,
  directives: ai,
  // watch
  watch: sf,
  // provide / inject
  provide: $a,
  inject: of
};
function $a(n, r) {
  return r ? n ? function() {
    return Wt(
      Ke(n) ? n.call(this, this) : n,
      Ke(r) ? r.call(this, this) : r
    );
  } : r : n;
}
function of(n, r) {
  return ai(zs(n), zs(r));
}
function zs(n) {
  if (Ne(n)) {
    const r = {};
    for (let a = 0; a < n.length; a++)
      r[n[a]] = n[a];
    return r;
  }
  return n;
}
function nn(n, r) {
  return n ? [...new Set([].concat(n, r))] : r;
}
function ai(n, r) {
  return n ? Wt(/* @__PURE__ */ Object.create(null), n, r) : r;
}
function Ua(n, r) {
  return n ? Ne(n) && Ne(r) ? [.../* @__PURE__ */ new Set([...n, ...r])] : Wt(
    /* @__PURE__ */ Object.create(null),
    Ba(n),
    Ba(r ?? {})
  ) : r;
}
function sf(n, r) {
  if (!n) return r;
  if (!r) return n;
  const a = Wt(/* @__PURE__ */ Object.create(null), n);
  for (const u in r)
    a[u] = nn(n[u], r[u]);
  return a;
}
function yl() {
  return {
    app: null,
    config: {
      isNativeTag: Gl,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let af = 0;
function uf(n, r) {
  return function(u, c = null) {
    Ke(u) || (u = Wt({}, u)), c != null && !ft(c) && (c = null);
    const d = yl(), p = /* @__PURE__ */ new WeakSet(), g = [];
    let O = !1;
    const K = d.app = {
      _uid: af++,
      _component: u,
      _props: c,
      _container: null,
      _context: d,
      _instance: null,
      version: Vf,
      get config() {
        return d.config;
      },
      set config(P) {
      },
      use(P, ...R) {
        return p.has(P) || (P && Ke(P.install) ? (p.add(P), P.install(K, ...R)) : Ke(P) && (p.add(P), P(K, ...R))), K;
      },
      mixin(P) {
        return d.mixins.includes(P) || d.mixins.push(P), K;
      },
      component(P, R) {
        return R ? (d.components[P] = R, K) : d.components[P];
      },
      directive(P, R) {
        return R ? (d.directives[P] = R, K) : d.directives[P];
      },
      mount(P, R, j) {
        if (!O) {
          const L = K._ceVNode || Ct(u, c);
          return L.appContext = d, j === !0 ? j = "svg" : j === !1 && (j = void 0), n(L, P, j), O = !0, K._container = P, P.__vue_app__ = K, ts(L.component);
        }
      },
      onUnmount(P) {
        g.push(P);
      },
      unmount() {
        O && (qn(
          g,
          K._instance,
          16
        ), n(null, K._container), delete K._container.__vue_app__);
      },
      provide(P, R) {
        return d.provides[P] = R, K;
      },
      runWithContext(P) {
        const R = po;
        po = K;
        try {
          return P();
        } finally {
          po = R;
        }
      }
    };
    return K;
  };
}
let po = null;
function lf(n, r) {
  if ($t) {
    let a = $t.provides;
    const u = $t.parent && $t.parent.provides;
    u === a && (a = $t.provides = Object.create(u)), a[n] = r;
  }
}
function hi(n, r, a = !1) {
  const u = $t || Rt;
  if (u || po) {
    let c = po ? po._context.provides : u ? u.parent == null || u.ce ? u.vnode.appContext && u.vnode.appContext.provides : u.parent.provides : void 0;
    if (c && n in c)
      return c[n];
    if (arguments.length > 1)
      return a && Ke(r) ? r.call(u && u.proxy) : r;
  }
}
function cf() {
  return !!($t || Rt || po);
}
const vl = {}, gl = () => Object.create(vl), bl = (n) => Object.getPrototypeOf(n) === vl;
function ff(n, r, a, u = !1) {
  const c = {}, d = gl();
  n.propsDefaults = /* @__PURE__ */ Object.create(null), _l(n, r, c, d);
  for (const p in n.propsOptions[0])
    p in c || (c[p] = void 0);
  a ? n.props = u ? c : Oc(c) : n.type.props ? n.props = c : n.props = d, n.attrs = d;
}
function df(n, r, a, u) {
  const {
    props: c,
    attrs: d,
    vnode: { patchFlag: p }
  } = n, g = Qe(c), [O] = n.propsOptions;
  let K = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (u || p > 0) && !(p & 16)
  ) {
    if (p & 8) {
      const P = n.vnode.dynamicProps;
      for (let R = 0; R < P.length; R++) {
        let j = P[R];
        if (Zi(n.emitsOptions, j))
          continue;
        const L = r[j];
        if (O)
          if (rt(d, j))
            L !== d[j] && (d[j] = L, K = !0);
          else {
            const G = Sr(j);
            c[G] = Qs(
              O,
              g,
              G,
              L,
              n,
              !1
            );
          }
        else
          L !== d[j] && (d[j] = L, K = !0);
      }
    }
  } else {
    _l(n, r, c, d) && (K = !0);
    let P;
    for (const R in g)
      (!r || // for camelCase
      !rt(r, R) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((P = yo(R)) === R || !rt(r, P))) && (O ? a && // for camelCase
      (a[R] !== void 0 || // for kebab-case
      a[P] !== void 0) && (c[R] = Qs(
        O,
        g,
        R,
        void 0,
        n,
        !0
      )) : delete c[R]);
    if (d !== g)
      for (const R in d)
        (!r || !rt(r, R)) && (delete d[R], K = !0);
  }
  K && hr(n.attrs, "set", "");
}
function _l(n, r, a, u) {
  const [c, d] = n.propsOptions;
  let p = !1, g;
  if (r)
    for (let O in r) {
      if (ui(O))
        continue;
      const K = r[O];
      let P;
      c && rt(c, P = Sr(O)) ? !d || !d.includes(P) ? a[P] = K : (g || (g = {}))[P] = K : Zi(n.emitsOptions, O) || (!(O in u) || K !== u[O]) && (u[O] = K, p = !0);
    }
  if (d) {
    const O = Qe(a), K = g || it;
    for (let P = 0; P < d.length; P++) {
      const R = d[P];
      a[R] = Qs(
        c,
        O,
        R,
        K[R],
        n,
        !rt(K, R)
      );
    }
  }
  return p;
}
function Qs(n, r, a, u, c, d) {
  const p = n[a];
  if (p != null) {
    const g = rt(p, "default");
    if (g && u === void 0) {
      const O = p.default;
      if (p.type !== Function && !p.skipFactory && Ke(O)) {
        const { propsDefaults: K } = c;
        if (a in K)
          u = K[a];
        else {
          const P = Ei(c);
          u = K[a] = O.call(
            null,
            r
          ), P();
        }
      } else
        u = O;
      c.ce && c.ce._setProp(a, u);
    }
    p[
      0
      /* shouldCast */
    ] && (d && !g ? u = !1 : p[
      1
      /* shouldCastTrue */
    ] && (u === "" || u === yo(a)) && (u = !0));
  }
  return u;
}
const pf = /* @__PURE__ */ new WeakMap();
function wl(n, r, a = !1) {
  const u = a ? pf : r.propsCache, c = u.get(n);
  if (c)
    return c;
  const d = n.props, p = {}, g = [];
  let O = !1;
  if (!Ke(n)) {
    const P = (R) => {
      O = !0;
      const [j, L] = wl(R, r, !0);
      Wt(p, j), L && g.push(...L);
    };
    !a && r.mixins.length && r.mixins.forEach(P), n.extends && P(n.extends), n.mixins && n.mixins.forEach(P);
  }
  if (!d && !O)
    return ft(n) && u.set(n, _o), _o;
  if (Ne(d))
    for (let P = 0; P < d.length; P++) {
      const R = Sr(d[P]);
      Va(R) && (p[R] = it);
    }
  else if (d)
    for (const P in d) {
      const R = Sr(P);
      if (Va(R)) {
        const j = d[P], L = p[R] = Ne(j) || Ke(j) ? { type: j } : Wt({}, j), G = L.type;
        let fe = !1, qe = !0;
        if (Ne(G))
          for (let pe = 0; pe < G.length; ++pe) {
            const me = G[pe], Ee = Ke(me) && me.name;
            if (Ee === "Boolean") {
              fe = !0;
              break;
            } else Ee === "String" && (qe = !1);
          }
        else
          fe = Ke(G) && G.name === "Boolean";
        L[
          0
          /* shouldCast */
        ] = fe, L[
          1
          /* shouldCastTrue */
        ] = qe, (fe || rt(L, "default")) && g.push(R);
      }
    }
  const K = [p, g];
  return ft(n) && u.set(n, K), K;
}
function Va(n) {
  return n[0] !== "$" && !ui(n);
}
const Ea = (n) => n[0] === "_" || n === "$stable", Oa = (n) => Ne(n) ? n.map(Fn) : [Fn(n)], hf = (n, r, a) => {
  if (r._n)
    return r;
  const u = Ws((...c) => Oa(r(...c)), a);
  return u._c = !1, u;
}, xl = (n, r, a) => {
  const u = n._ctx;
  for (const c in n) {
    if (Ea(c)) continue;
    const d = n[c];
    if (Ke(d))
      r[c] = hf(c, d, u);
    else if (d != null) {
      const p = Oa(d);
      r[c] = () => p;
    }
  }
}, Tl = (n, r) => {
  const a = Oa(r);
  n.slots.default = () => a;
}, El = (n, r, a) => {
  for (const u in r)
    (a || !Ea(u)) && (n[u] = r[u]);
}, mf = (n, r, a) => {
  const u = n.slots = gl();
  if (n.vnode.shapeFlag & 32) {
    const c = r.__;
    c && $s(u, "__", c, !0);
    const d = r._;
    d ? (El(u, r, a), a && $s(u, "_", d, !0)) : xl(r, u);
  } else r && Tl(n, r);
}, yf = (n, r, a) => {
  const { vnode: u, slots: c } = n;
  let d = !0, p = it;
  if (u.shapeFlag & 32) {
    const g = r._;
    g ? a && g === 1 ? d = !1 : El(c, r, a) : (d = !r.$stable, xl(r, c)), p = r;
  } else r && (Tl(n, r), p = { default: 1 });
  if (d)
    for (const g in c)
      !Ea(g) && p[g] == null && delete c[g];
}, rn = Pf;
function vf(n) {
  return gf(n);
}
function gf(n, r) {
  const a = Yi();
  a.__VUE__ = !0;
  const {
    insert: u,
    remove: c,
    patchProp: d,
    createElement: p,
    createText: g,
    createComment: O,
    setText: K,
    setElementText: P,
    parentNode: R,
    nextSibling: j,
    setScopeId: L = Bn,
    insertStaticContent: G
  } = n, fe = (N, M, J, ee = null, re = null, te = null, ae = void 0, le = null, oe = !!M.dynamicChildren) => {
    if (N === M)
      return;
    N && !si(N, M) && (ee = A(N), kt(N, re, te, !0), N = null), M.patchFlag === -2 && (oe = !1, M.dynamicChildren = null);
    const { type: ne, ref: we, shapeFlag: ce } = M;
    switch (ne) {
      case es:
        qe(N, M, J, ee);
        break;
      case wr:
        pe(N, M, J, ee);
        break;
      case Ks:
        N == null && me(M, J, ee, ae);
        break;
      case Je:
        Re(
          N,
          M,
          J,
          ee,
          re,
          te,
          ae,
          le,
          oe
        );
        break;
      default:
        ce & 1 ? Ae(
          N,
          M,
          J,
          ee,
          re,
          te,
          ae,
          le,
          oe
        ) : ce & 6 ? nt(
          N,
          M,
          J,
          ee,
          re,
          te,
          ae,
          le,
          oe
        ) : (ce & 64 || ce & 128) && ne.process(
          N,
          M,
          J,
          ee,
          re,
          te,
          ae,
          le,
          oe,
          V
        );
    }
    we != null && re ? di(we, N && N.ref, te, M || N, !M) : we == null && N && N.ref != null && di(N.ref, null, te, N, !0);
  }, qe = (N, M, J, ee) => {
    if (N == null)
      u(
        M.el = g(M.children),
        J,
        ee
      );
    else {
      const re = M.el = N.el;
      M.children !== N.children && K(re, M.children);
    }
  }, pe = (N, M, J, ee) => {
    N == null ? u(
      M.el = O(M.children || ""),
      J,
      ee
    ) : M.el = N.el;
  }, me = (N, M, J, ee) => {
    [N.el, N.anchor] = G(
      N.children,
      M,
      J,
      ee,
      N.el,
      N.anchor
    );
  }, Ee = ({ el: N, anchor: M }, J, ee) => {
    let re;
    for (; N && N !== M; )
      re = j(N), u(N, J, ee), N = re;
    u(M, J, ee);
  }, de = ({ el: N, anchor: M }) => {
    let J;
    for (; N && N !== M; )
      J = j(N), c(N), N = J;
    c(M);
  }, Ae = (N, M, J, ee, re, te, ae, le, oe) => {
    M.type === "svg" ? ae = "svg" : M.type === "math" && (ae = "mathml"), N == null ? Be(
      M,
      J,
      ee,
      re,
      te,
      ae,
      le,
      oe
    ) : B(
      N,
      M,
      re,
      te,
      ae,
      le,
      oe
    );
  }, Be = (N, M, J, ee, re, te, ae, le) => {
    let oe, ne;
    const { props: we, shapeFlag: ce, transition: xe, dirs: Te } = N;
    if (oe = N.el = p(
      N.type,
      te,
      we && we.is,
      we
    ), ce & 8 ? P(oe, N.children) : ce & 16 && Ce(
      N.children,
      oe,
      null,
      ee,
      re,
      Ls(N, te),
      ae,
      le
    ), Te && uo(N, null, ee, "created"), ye(oe, N, N.scopeId, ae, ee), we) {
      for (const Me in we)
        Me !== "value" && !ui(Me) && d(oe, Me, null, we[Me], te, ee);
      "value" in we && d(oe, "value", null, we.value, te), (ne = we.onVnodeBeforeMount) && Ln(ne, ee, N);
    }
    Te && uo(N, null, ee, "beforeMount");
    const Pe = bf(re, xe);
    Pe && xe.beforeEnter(oe), u(oe, M, J), ((ne = we && we.onVnodeMounted) || Pe || Te) && rn(() => {
      ne && Ln(ne, ee, N), Pe && xe.enter(oe), Te && uo(N, null, ee, "mounted");
    }, re);
  }, ye = (N, M, J, ee, re) => {
    if (J && L(N, J), ee)
      for (let te = 0; te < ee.length; te++)
        L(N, ee[te]);
    if (re) {
      let te = re.subTree;
      if (M === te || Al(te.type) && (te.ssContent === M || te.ssFallback === M)) {
        const ae = re.vnode;
        ye(
          N,
          ae,
          ae.scopeId,
          ae.slotScopeIds,
          re.parent
        );
      }
    }
  }, Ce = (N, M, J, ee, re, te, ae, le, oe = 0) => {
    for (let ne = oe; ne < N.length; ne++) {
      const we = N[ne] = le ? Or(N[ne]) : Fn(N[ne]);
      fe(
        null,
        we,
        M,
        J,
        ee,
        re,
        te,
        ae,
        le
      );
    }
  }, B = (N, M, J, ee, re, te, ae) => {
    const le = M.el = N.el;
    let { patchFlag: oe, dynamicChildren: ne, dirs: we } = M;
    oe |= N.patchFlag & 16;
    const ce = N.props || it, xe = M.props || it;
    let Te;
    if (J && lo(J, !1), (Te = xe.onVnodeBeforeUpdate) && Ln(Te, J, M, N), we && uo(M, N, J, "beforeUpdate"), J && lo(J, !0), (ce.innerHTML && xe.innerHTML == null || ce.textContent && xe.textContent == null) && P(le, ""), ne ? We(
      N.dynamicChildren,
      ne,
      le,
      J,
      ee,
      Ls(M, re),
      te
    ) : ae || Ie(
      N,
      M,
      le,
      null,
      J,
      ee,
      Ls(M, re),
      te,
      !1
    ), oe > 0) {
      if (oe & 16)
        st(le, ce, xe, J, re);
      else if (oe & 2 && ce.class !== xe.class && d(le, "class", null, xe.class, re), oe & 4 && d(le, "style", ce.style, xe.style, re), oe & 8) {
        const Pe = M.dynamicProps;
        for (let Me = 0; Me < Pe.length; Me++) {
          const Ue = Pe[Me], ut = ce[Ue], gt = xe[Ue];
          (gt !== ut || Ue === "value") && d(le, Ue, ut, gt, re, J);
        }
      }
      oe & 1 && N.children !== M.children && P(le, M.children);
    } else !ae && ne == null && st(le, ce, xe, J, re);
    ((Te = xe.onVnodeUpdated) || we) && rn(() => {
      Te && Ln(Te, J, M, N), we && uo(M, N, J, "updated");
    }, ee);
  }, We = (N, M, J, ee, re, te, ae) => {
    for (let le = 0; le < M.length; le++) {
      const oe = N[le], ne = M[le], we = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oe.type === Je || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !si(oe, ne) || // - In the case of a component, it could contain anything.
        oe.shapeFlag & 198) ? R(oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          J
        )
      );
      fe(
        oe,
        ne,
        we,
        null,
        ee,
        re,
        te,
        ae,
        !0
      );
    }
  }, st = (N, M, J, ee, re) => {
    if (M !== J) {
      if (M !== it)
        for (const te in M)
          !ui(te) && !(te in J) && d(
            N,
            te,
            M[te],
            null,
            re,
            ee
          );
      for (const te in J) {
        if (ui(te)) continue;
        const ae = J[te], le = M[te];
        ae !== le && te !== "value" && d(N, te, le, ae, re, ee);
      }
      "value" in J && d(N, "value", M.value, J.value, re);
    }
  }, Re = (N, M, J, ee, re, te, ae, le, oe) => {
    const ne = M.el = N ? N.el : g(""), we = M.anchor = N ? N.anchor : g("");
    let { patchFlag: ce, dynamicChildren: xe, slotScopeIds: Te } = M;
    Te && (le = le ? le.concat(Te) : Te), N == null ? (u(ne, J, ee), u(we, J, ee), Ce(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      M.children || [],
      J,
      we,
      re,
      te,
      ae,
      le,
      oe
    )) : ce > 0 && ce & 64 && xe && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    N.dynamicChildren ? (We(
      N.dynamicChildren,
      xe,
      J,
      re,
      te,
      ae,
      le
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (M.key != null || re && M === re.subTree) && Ca(
      N,
      M,
      !0
      /* shallow */
    )) : Ie(
      N,
      M,
      J,
      we,
      re,
      te,
      ae,
      le,
      oe
    );
  }, nt = (N, M, J, ee, re, te, ae, le, oe) => {
    M.slotScopeIds = le, N == null ? M.shapeFlag & 512 ? re.ctx.activate(
      M,
      J,
      ee,
      ae,
      oe
    ) : yn(
      M,
      J,
      ee,
      re,
      te,
      ae,
      oe
    ) : Pt(N, M, oe);
  }, yn = (N, M, J, ee, re, te, ae) => {
    const le = N.component = Kf(
      N,
      ee,
      re
    );
    if (cl(N) && (le.ctx.renderer = V), Mf(le, !1, ae), le.asyncDep) {
      if (re && re.registerDep(le, Ze, ae), !N.el) {
        const oe = le.subTree = Ct(wr);
        pe(null, oe, M, J);
      }
    } else
      Ze(
        le,
        N,
        M,
        J,
        re,
        te,
        ae
      );
  }, Pt = (N, M, J) => {
    const ee = M.component = N.component;
    if (Nf(N, M, J))
      if (ee.asyncDep && !ee.asyncResolved) {
        ge(ee, M, J);
        return;
      } else
        ee.next = M, ee.update();
    else
      M.el = N.el, ee.vnode = M;
  }, Ze = (N, M, J, ee, re, te, ae) => {
    const le = () => {
      if (N.isMounted) {
        let { next: ce, bu: xe, u: Te, parent: Pe, vnode: Me } = N;
        {
          const lt = Ol(N);
          if (lt) {
            ce && (ce.el = Me.el, ge(N, ce, ae)), lt.asyncDep.then(() => {
              N.isUnmounted || le();
            });
            return;
          }
        }
        let Ue = ce, ut;
        lo(N, !1), ce ? (ce.el = Me.el, ge(N, ce, ae)) : ce = Me, xe && Pi(xe), (ut = ce.props && ce.props.onVnodeBeforeUpdate) && Ln(ut, Pe, ce, Me), lo(N, !0);
        const gt = Wa(N), Ot = N.subTree;
        N.subTree = gt, fe(
          Ot,
          gt,
          // parent may have changed if it's in a teleport
          R(Ot.el),
          // anchor may have changed if it's in a fragment
          A(Ot),
          N,
          re,
          te
        ), ce.el = gt.el, Ue === null && Af(N, gt.el), Te && rn(Te, re), (ut = ce.props && ce.props.onVnodeUpdated) && rn(
          () => Ln(ut, Pe, ce, Me),
          re
        );
      } else {
        let ce;
        const { el: xe, props: Te } = M, { bm: Pe, m: Me, parent: Ue, root: ut, type: gt } = N, Ot = To(M);
        lo(N, !1), Pe && Pi(Pe), !Ot && (ce = Te && Te.onVnodeBeforeMount) && Ln(ce, Ue, M), lo(N, !0);
        {
          ut.ce && // @ts-expect-error _def is private
          ut.ce._def.shadowRoot !== !1 && ut.ce._injectChildStyle(gt);
          const lt = N.subTree = Wa(N);
          fe(
            null,
            lt,
            J,
            ee,
            N,
            re,
            te
          ), M.el = lt.el;
        }
        if (Me && rn(Me, re), !Ot && (ce = Te && Te.onVnodeMounted)) {
          const lt = M;
          rn(
            () => Ln(ce, Ue, lt),
            re
          );
        }
        (M.shapeFlag & 256 || Ue && To(Ue.vnode) && Ue.vnode.shapeFlag & 256) && N.a && rn(N.a, re), N.isMounted = !0, M = J = ee = null;
      }
    };
    N.scope.on();
    const oe = N.effect = new ju(le);
    N.scope.off();
    const ne = N.update = oe.run.bind(oe), we = N.job = oe.runIfDirty.bind(oe);
    we.i = N, we.id = N.uid, oe.scheduler = () => wa(we), lo(N, !0), ne();
  }, ge = (N, M, J) => {
    M.component = N;
    const ee = N.vnode.props;
    N.vnode = M, N.next = null, df(N, M.props, ee, J), yf(N, M.children, J), br(), ja(N), _r();
  }, Ie = (N, M, J, ee, re, te, ae, le, oe = !1) => {
    const ne = N && N.children, we = N ? N.shapeFlag : 0, ce = M.children, { patchFlag: xe, shapeFlag: Te } = M;
    if (xe > 0) {
      if (xe & 128) {
        ot(
          ne,
          ce,
          J,
          ee,
          re,
          te,
          ae,
          le,
          oe
        );
        return;
      } else if (xe & 256) {
        dt(
          ne,
          ce,
          J,
          ee,
          re,
          te,
          ae,
          le,
          oe
        );
        return;
      }
    }
    Te & 8 ? (we & 16 && wt(ne, re, te), ce !== ne && P(J, ce)) : we & 16 ? Te & 16 ? ot(
      ne,
      ce,
      J,
      ee,
      re,
      te,
      ae,
      le,
      oe
    ) : wt(ne, re, te, !0) : (we & 8 && P(J, ""), Te & 16 && Ce(
      ce,
      J,
      ee,
      re,
      te,
      ae,
      le,
      oe
    ));
  }, dt = (N, M, J, ee, re, te, ae, le, oe) => {
    N = N || _o, M = M || _o;
    const ne = N.length, we = M.length, ce = Math.min(ne, we);
    let xe;
    for (xe = 0; xe < ce; xe++) {
      const Te = M[xe] = oe ? Or(M[xe]) : Fn(M[xe]);
      fe(
        N[xe],
        Te,
        J,
        null,
        re,
        te,
        ae,
        le,
        oe
      );
    }
    ne > we ? wt(
      N,
      re,
      te,
      !0,
      !1,
      ce
    ) : Ce(
      M,
      J,
      ee,
      re,
      te,
      ae,
      le,
      oe,
      ce
    );
  }, ot = (N, M, J, ee, re, te, ae, le, oe) => {
    let ne = 0;
    const we = M.length;
    let ce = N.length - 1, xe = we - 1;
    for (; ne <= ce && ne <= xe; ) {
      const Te = N[ne], Pe = M[ne] = oe ? Or(M[ne]) : Fn(M[ne]);
      if (si(Te, Pe))
        fe(
          Te,
          Pe,
          J,
          null,
          re,
          te,
          ae,
          le,
          oe
        );
      else
        break;
      ne++;
    }
    for (; ne <= ce && ne <= xe; ) {
      const Te = N[ce], Pe = M[xe] = oe ? Or(M[xe]) : Fn(M[xe]);
      if (si(Te, Pe))
        fe(
          Te,
          Pe,
          J,
          null,
          re,
          te,
          ae,
          le,
          oe
        );
      else
        break;
      ce--, xe--;
    }
    if (ne > ce) {
      if (ne <= xe) {
        const Te = xe + 1, Pe = Te < we ? M[Te].el : ee;
        for (; ne <= xe; )
          fe(
            null,
            M[ne] = oe ? Or(M[ne]) : Fn(M[ne]),
            J,
            Pe,
            re,
            te,
            ae,
            le,
            oe
          ), ne++;
      }
    } else if (ne > xe)
      for (; ne <= ce; )
        kt(N[ne], re, te, !0), ne++;
    else {
      const Te = ne, Pe = ne, Me = /* @__PURE__ */ new Map();
      for (ne = Pe; ne <= xe; ne++) {
        const et = M[ne] = oe ? Or(M[ne]) : Fn(M[ne]);
        et.key != null && Me.set(et.key, ne);
      }
      let Ue, ut = 0;
      const gt = xe - Pe + 1;
      let Ot = !1, lt = 0;
      const Yt = new Array(gt);
      for (ne = 0; ne < gt; ne++) Yt[ne] = 0;
      for (ne = Te; ne <= ce; ne++) {
        const et = N[ne];
        if (ut >= gt) {
          kt(et, re, te, !0);
          continue;
        }
        let Z;
        if (et.key != null)
          Z = Me.get(et.key);
        else
          for (Ue = Pe; Ue <= xe; Ue++)
            if (Yt[Ue - Pe] === 0 && si(et, M[Ue])) {
              Z = Ue;
              break;
            }
        Z === void 0 ? kt(et, re, te, !0) : (Yt[Z - Pe] = ne + 1, Z >= lt ? lt = Z : Ot = !0, fe(
          et,
          M[Z],
          J,
          null,
          re,
          te,
          ae,
          le,
          oe
        ), ut++);
      }
      const jn = Ot ? _f(Yt) : _o;
      for (Ue = jn.length - 1, ne = gt - 1; ne >= 0; ne--) {
        const et = Pe + ne, Z = M[et], an = et + 1 < we ? M[et + 1].el : ee;
        Yt[ne] === 0 ? fe(
          null,
          Z,
          J,
          an,
          re,
          te,
          ae,
          le,
          oe
        ) : Ot && (Ue < 0 || ne !== jn[Ue] ? ht(Z, J, an, 2) : Ue--);
      }
    }
  }, ht = (N, M, J, ee, re = null) => {
    const { el: te, type: ae, transition: le, children: oe, shapeFlag: ne } = N;
    if (ne & 6) {
      ht(N.component.subTree, M, J, ee);
      return;
    }
    if (ne & 128) {
      N.suspense.move(M, J, ee);
      return;
    }
    if (ne & 64) {
      ae.move(N, M, J, V);
      return;
    }
    if (ae === Je) {
      u(te, M, J);
      for (let ce = 0; ce < oe.length; ce++)
        ht(oe[ce], M, J, ee);
      u(N.anchor, M, J);
      return;
    }
    if (ae === Ks) {
      Ee(N, M, J);
      return;
    }
    if (ee !== 2 && ne & 1 && le)
      if (ee === 0)
        le.beforeEnter(te), u(te, M, J), rn(() => le.enter(te), re);
      else {
        const { leave: ce, delayLeave: xe, afterLeave: Te } = le, Pe = () => {
          N.ctx.isUnmounted ? c(te) : u(te, M, J);
        }, Me = () => {
          ce(te, () => {
            Pe(), Te && Te();
          });
        };
        xe ? xe(te, Pe, Me) : Me();
      }
    else
      u(te, M, J);
  }, kt = (N, M, J, ee = !1, re = !1) => {
    const {
      type: te,
      props: ae,
      ref: le,
      children: oe,
      dynamicChildren: ne,
      shapeFlag: we,
      patchFlag: ce,
      dirs: xe,
      cacheIndex: Te
    } = N;
    if (ce === -2 && (re = !1), le != null && (br(), di(le, null, J, N, !0), _r()), Te != null && (M.renderCache[Te] = void 0), we & 256) {
      M.ctx.deactivate(N);
      return;
    }
    const Pe = we & 1 && xe, Me = !To(N);
    let Ue;
    if (Me && (Ue = ae && ae.onVnodeBeforeUnmount) && Ln(Ue, M, N), we & 6)
      sn(N.component, J, ee);
    else {
      if (we & 128) {
        N.suspense.unmount(J, ee);
        return;
      }
      Pe && uo(N, null, M, "beforeUnmount"), we & 64 ? N.type.remove(
        N,
        M,
        J,
        V,
        ee
      ) : ne && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ne.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (te !== Je || ce > 0 && ce & 64) ? wt(
        ne,
        M,
        J,
        !1,
        !0
      ) : (te === Je && ce & 384 || !re && we & 16) && wt(oe, M, J), ee && Dt(N);
    }
    (Me && (Ue = ae && ae.onVnodeUnmounted) || Pe) && rn(() => {
      Ue && Ln(Ue, M, N), Pe && uo(N, null, M, "unmounted");
    }, J);
  }, Dt = (N) => {
    const { type: M, el: J, anchor: ee, transition: re } = N;
    if (M === Je) {
      Rn(J, ee);
      return;
    }
    if (M === Ks) {
      de(N);
      return;
    }
    const te = () => {
      c(J), re && !re.persisted && re.afterLeave && re.afterLeave();
    };
    if (N.shapeFlag & 1 && re && !re.persisted) {
      const { leave: ae, delayLeave: le } = re, oe = () => ae(J, te);
      le ? le(N.el, te, oe) : oe();
    } else
      te();
  }, Rn = (N, M) => {
    let J;
    for (; N !== M; )
      J = j(N), c(N), N = J;
    c(M);
  }, sn = (N, M, J) => {
    const {
      bum: ee,
      scope: re,
      job: te,
      subTree: ae,
      um: le,
      m: oe,
      a: ne,
      parent: we,
      slots: { __: ce }
    } = N;
    Ha(oe), Ha(ne), ee && Pi(ee), we && Ne(ce) && ce.forEach((xe) => {
      we.renderCache[xe] = void 0;
    }), re.stop(), te && (te.flags |= 8, kt(ae, N, M, J)), le && rn(le, M), rn(() => {
      N.isUnmounted = !0;
    }, M), M && M.pendingBranch && !M.isUnmounted && N.asyncDep && !N.asyncResolved && N.suspenseId === M.pendingId && (M.deps--, M.deps === 0 && M.resolve());
  }, wt = (N, M, J, ee = !1, re = !1, te = 0) => {
    for (let ae = te; ae < N.length; ae++)
      kt(N[ae], M, J, ee, re);
  }, A = (N) => {
    if (N.shapeFlag & 6)
      return A(N.component.subTree);
    if (N.shapeFlag & 128)
      return N.suspense.next();
    const M = j(N.anchor || N.el), J = M && M[ol];
    return J ? j(J) : M;
  };
  let w = !1;
  const F = (N, M, J) => {
    N == null ? M._vnode && kt(M._vnode, null, null, !0) : fe(
      M._vnode || null,
      N,
      M,
      null,
      null,
      null,
      J
    ), M._vnode = N, w || (w = !0, ja(), tl(), w = !1);
  }, V = {
    p: fe,
    um: kt,
    m: ht,
    r: Dt,
    mt: yn,
    mc: Ce,
    pc: Ie,
    pbc: We,
    n: A,
    o: n
  };
  return {
    render: F,
    hydrate: void 0,
    createApp: uf(F)
  };
}
function Ls({ type: n, props: r }, a) {
  return a === "svg" && n === "foreignObject" || a === "mathml" && n === "annotation-xml" && r && r.encoding && r.encoding.includes("html") ? void 0 : a;
}
function lo({ effect: n, job: r }, a) {
  a ? (n.flags |= 32, r.flags |= 4) : (n.flags &= -33, r.flags &= -5);
}
function bf(n, r) {
  return (!n || n && !n.pendingBranch) && r && !r.persisted;
}
function Ca(n, r, a = !1) {
  const u = n.children, c = r.children;
  if (Ne(u) && Ne(c))
    for (let d = 0; d < u.length; d++) {
      const p = u[d];
      let g = c[d];
      g.shapeFlag & 1 && !g.dynamicChildren && ((g.patchFlag <= 0 || g.patchFlag === 32) && (g = c[d] = Or(c[d]), g.el = p.el), !a && g.patchFlag !== -2 && Ca(p, g)), g.type === es && (g.el = p.el), g.type === wr && !g.el && (g.el = p.el);
    }
}
function _f(n) {
  const r = n.slice(), a = [0];
  let u, c, d, p, g;
  const O = n.length;
  for (u = 0; u < O; u++) {
    const K = n[u];
    if (K !== 0) {
      if (c = a[a.length - 1], n[c] < K) {
        r[u] = c, a.push(u);
        continue;
      }
      for (d = 0, p = a.length - 1; d < p; )
        g = d + p >> 1, n[a[g]] < K ? d = g + 1 : p = g;
      K < n[a[d]] && (d > 0 && (r[u] = a[d - 1]), a[d] = u);
    }
  }
  for (d = a.length, p = a[d - 1]; d-- > 0; )
    a[d] = p, p = r[p];
  return a;
}
function Ol(n) {
  const r = n.subTree.component;
  if (r)
    return r.asyncDep && !r.asyncResolved ? r : Ol(r);
}
function Ha(n) {
  if (n)
    for (let r = 0; r < n.length; r++)
      n[r].flags |= 8;
}
const wf = Symbol.for("v-scx"), xf = () => hi(wf);
function Cl(n, r) {
  return Sa(n, null, r);
}
function gr(n, r, a) {
  return Sa(n, r, a);
}
function Sa(n, r, a = it) {
  const { immediate: u, deep: c, flush: d, once: p } = a, g = Wt({}, a), O = r && u || !r && d !== "post";
  let K;
  if (wi) {
    if (d === "sync") {
      const L = xf();
      K = L.__watcherHandles || (L.__watcherHandles = []);
    } else if (!O) {
      const L = () => {
      };
      return L.stop = Bn, L.resume = Bn, L.pause = Bn, L;
    }
  }
  const P = $t;
  g.call = (L, G, fe) => qn(L, P, G, fe);
  let R = !1;
  d === "post" ? g.scheduler = (L) => {
    rn(L, P && P.suspense);
  } : d !== "sync" && (R = !0, g.scheduler = (L, G) => {
    G ? L() : wa(L);
  }), g.augmentJob = (L) => {
    r && (L.flags |= 4), R && (L.flags |= 2, P && (L.id = P.uid, L.i = P));
  };
  const j = Lc(n, r, g);
  return wi && (K ? K.push(j) : O && j()), j;
}
function Tf(n, r, a) {
  const u = this.proxy, c = Et(n) ? n.includes(".") ? Sl(u, n) : () => u[n] : n.bind(u, u);
  let d;
  Ke(r) ? d = r : (d = r.handler, a = r);
  const p = Ei(this), g = Sa(c, d.bind(u), a);
  return p(), g;
}
function Sl(n, r) {
  const a = r.split(".");
  return () => {
    let u = n;
    for (let c = 0; c < a.length && u; c++)
      u = u[a[c]];
    return u;
  };
}
const Ef = (n, r) => r === "modelValue" || r === "model-value" ? n.modelModifiers : n[`${r}Modifiers`] || n[`${Sr(r)}Modifiers`] || n[`${yo(r)}Modifiers`];
function Of(n, r, ...a) {
  if (n.isUnmounted) return;
  const u = n.vnode.props || it;
  let c = a;
  const d = r.startsWith("update:"), p = d && Ef(u, r.slice(7));
  p && (p.trim && (c = a.map((P) => Et(P) ? P.trim() : P)), p.number && (c = a.map(Li)));
  let g, O = u[g = Ps(r)] || // also try camelCase event handler (#2249)
  u[g = Ps(Sr(r))];
  !O && d && (O = u[g = Ps(yo(r))]), O && qn(
    O,
    n,
    6,
    c
  );
  const K = u[g + "Once"];
  if (K) {
    if (!n.emitted)
      n.emitted = {};
    else if (n.emitted[g])
      return;
    n.emitted[g] = !0, qn(
      K,
      n,
      6,
      c
    );
  }
}
function Nl(n, r, a = !1) {
  const u = r.emitsCache, c = u.get(n);
  if (c !== void 0)
    return c;
  const d = n.emits;
  let p = {}, g = !1;
  if (!Ke(n)) {
    const O = (K) => {
      const P = Nl(K, r, !0);
      P && (g = !0, Wt(p, P));
    };
    !a && r.mixins.length && r.mixins.forEach(O), n.extends && O(n.extends), n.mixins && n.mixins.forEach(O);
  }
  return !d && !g ? (ft(n) && u.set(n, null), null) : (Ne(d) ? d.forEach((O) => p[O] = null) : Wt(p, d), ft(n) && u.set(n, p), p);
}
function Zi(n, r) {
  return !n || !Wi(r) ? !1 : (r = r.slice(2).replace(/Once$/, ""), rt(n, r[0].toLowerCase() + r.slice(1)) || rt(n, yo(r)) || rt(n, r));
}
function Wa(n) {
  const {
    type: r,
    vnode: a,
    proxy: u,
    withProxy: c,
    propsOptions: [d],
    slots: p,
    attrs: g,
    emit: O,
    render: K,
    renderCache: P,
    props: R,
    data: j,
    setupState: L,
    ctx: G,
    inheritAttrs: fe
  } = n, qe = qi(n);
  let pe, me;
  try {
    if (a.shapeFlag & 4) {
      const de = c || u, Ae = de;
      pe = Fn(
        K.call(
          Ae,
          de,
          P,
          R,
          L,
          j,
          G
        )
      ), me = g;
    } else {
      const de = r;
      pe = Fn(
        de.length > 1 ? de(
          R,
          { attrs: g, slots: p, emit: O }
        ) : de(
          R,
          null
        )
      ), me = r.props ? g : Cf(g);
    }
  } catch (de) {
    mi.length = 0, Qi(de, n, 1), pe = Ct(wr);
  }
  let Ee = pe;
  if (me && fe !== !1) {
    const de = Object.keys(me), { shapeFlag: Ae } = Ee;
    de.length && Ae & 7 && (d && de.some(aa) && (me = Sf(
      me,
      d
    )), Ee = Eo(Ee, me, !1, !0));
  }
  return a.dirs && (Ee = Eo(Ee, null, !1, !0), Ee.dirs = Ee.dirs ? Ee.dirs.concat(a.dirs) : a.dirs), a.transition && xa(Ee, a.transition), pe = Ee, qi(qe), pe;
}
const Cf = (n) => {
  let r;
  for (const a in n)
    (a === "class" || a === "style" || Wi(a)) && ((r || (r = {}))[a] = n[a]);
  return r;
}, Sf = (n, r) => {
  const a = {};
  for (const u in n)
    (!aa(u) || !(u.slice(9) in r)) && (a[u] = n[u]);
  return a;
};
function Nf(n, r, a) {
  const { props: u, children: c, component: d } = n, { props: p, children: g, patchFlag: O } = r, K = d.emitsOptions;
  if (r.dirs || r.transition)
    return !0;
  if (a && O >= 0) {
    if (O & 1024)
      return !0;
    if (O & 16)
      return u ? Ga(u, p, K) : !!p;
    if (O & 8) {
      const P = r.dynamicProps;
      for (let R = 0; R < P.length; R++) {
        const j = P[R];
        if (p[j] !== u[j] && !Zi(K, j))
          return !0;
      }
    }
  } else
    return (c || g) && (!g || !g.$stable) ? !0 : u === p ? !1 : u ? p ? Ga(u, p, K) : !0 : !!p;
  return !1;
}
function Ga(n, r, a) {
  const u = Object.keys(r);
  if (u.length !== Object.keys(n).length)
    return !0;
  for (let c = 0; c < u.length; c++) {
    const d = u[c];
    if (r[d] !== n[d] && !Zi(a, d))
      return !0;
  }
  return !1;
}
function Af({ vnode: n, parent: r }, a) {
  for (; r; ) {
    const u = r.subTree;
    if (u.suspense && u.suspense.activeBranch === n && (u.el = n.el), u === n)
      (n = r.vnode).el = a, r = r.parent;
    else
      break;
  }
}
const Al = (n) => n.__isSuspense;
function Pf(n, r) {
  r && r.pendingBranch ? Ne(n) ? r.effects.push(...n) : r.effects.push(n) : Mc(n);
}
const Je = Symbol.for("v-fgt"), es = Symbol.for("v-txt"), wr = Symbol.for("v-cmt"), Ks = Symbol.for("v-stc"), mi = [];
let mn = null;
function be(n = !1) {
  mi.push(mn = n ? null : []);
}
function kf() {
  mi.pop(), mn = mi[mi.length - 1] || null;
}
let _i = 1;
function Ya(n, r = !1) {
  _i += n, n < 0 && mn && r && (mn.hasOnce = !0);
}
function Pl(n) {
  return n.dynamicChildren = _i > 0 ? mn || _o : null, kf(), _i > 0 && mn && mn.push(n), n;
}
function Oe(n, r, a, u, c, d) {
  return Pl(
    q(
      n,
      r,
      a,
      u,
      c,
      d,
      !0
    )
  );
}
function An(n, r, a, u, c) {
  return Pl(
    Ct(
      n,
      r,
      a,
      u,
      c,
      !0
    )
  );
}
function Na(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
function si(n, r) {
  return n.type === r.type && n.key === r.key;
}
const kl = ({ key: n }) => n ?? null, Di = ({
  ref: n,
  ref_key: r,
  ref_for: a
}) => (typeof n == "number" && (n = "" + n), n != null ? Et(n) || vt(n) || Ke(n) ? { i: Rt, r: n, k: r, f: !!a } : n : null);
function q(n, r = null, a = null, u = 0, c = null, d = n === Je ? 0 : 1, p = !1, g = !1) {
  const O = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: r,
    key: r && kl(r),
    ref: r && Di(r),
    scopeId: rl,
    slotScopeIds: null,
    children: a,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: d,
    patchFlag: u,
    dynamicProps: c,
    dynamicChildren: null,
    appContext: null,
    ctx: Rt
  };
  return g ? (Aa(O, a), d & 128 && n.normalize(O)) : a && (O.shapeFlag |= Et(a) ? 8 : 16), _i > 0 && // avoid a block node from tracking itself
  !p && // has current parent block
  mn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (O.patchFlag > 0 || d & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  O.patchFlag !== 32 && mn.push(O), O;
}
const Ct = Df;
function Df(n, r = null, a = null, u = 0, c = null, d = !1) {
  if ((!n || n === Zc) && (n = wr), Na(n)) {
    const g = Eo(
      n,
      r,
      !0
      /* mergeRef: true */
    );
    return a && Aa(g, a), _i > 0 && !d && mn && (g.shapeFlag & 6 ? mn[mn.indexOf(n)] = g : mn.push(g)), g.patchFlag = -2, g;
  }
  if (Uf(n) && (n = n.__vccOpts), r) {
    r = If(r);
    let { class: g, style: O } = r;
    g && !Et(g) && (r.class = ho(g)), ft(O) && (ga(O) && !Ne(O) && (O = Wt({}, O)), r.style = ca(O));
  }
  const p = Et(n) ? 1 : Al(n) ? 128 : Bc(n) ? 64 : ft(n) ? 4 : Ke(n) ? 2 : 0;
  return q(
    n,
    r,
    a,
    u,
    c,
    p,
    d,
    !0
  );
}
function If(n) {
  return n ? ga(n) || bl(n) ? Wt({}, n) : n : null;
}
function Eo(n, r, a = !1, u = !1) {
  const { props: c, ref: d, patchFlag: p, children: g, transition: O } = n, K = r ? Rf(c || {}, r) : c, P = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: K,
    key: K && kl(K),
    ref: r && r.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      a && d ? Ne(d) ? d.concat(Di(r)) : [d, Di(r)] : Di(r)
    ) : d,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: g,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: r && n.type !== Je ? p === -1 ? 16 : p | 16 : p,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: O,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && Eo(n.ssContent),
    ssFallback: n.ssFallback && Eo(n.ssFallback),
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return O && u && xa(
    P,
    O.clone(P)
  ), P;
}
function Dl(n = " ", r = 0) {
  return Ct(es, null, n, r);
}
function Pn(n = "", r = !1) {
  return r ? (be(), An(wr, null, n)) : Ct(wr, null, n);
}
function Fn(n) {
  return n == null || typeof n == "boolean" ? Ct(wr) : Ne(n) ? Ct(
    Je,
    null,
    // #3666, avoid reference pollution when reusing vnode
    n.slice()
  ) : Na(n) ? Or(n) : Ct(es, null, String(n));
}
function Or(n) {
  return n.el === null && n.patchFlag !== -1 || n.memo ? n : Eo(n);
}
function Aa(n, r) {
  let a = 0;
  const { shapeFlag: u } = n;
  if (r == null)
    r = null;
  else if (Ne(r))
    a = 16;
  else if (typeof r == "object")
    if (u & 65) {
      const c = r.default;
      c && (c._c && (c._d = !1), Aa(n, c()), c._c && (c._d = !0));
      return;
    } else {
      a = 32;
      const c = r._;
      !c && !bl(r) ? r._ctx = Rt : c === 3 && Rt && (Rt.slots._ === 1 ? r._ = 1 : (r._ = 2, n.patchFlag |= 1024));
    }
  else Ke(r) ? (r = { default: r, _ctx: Rt }, a = 32) : (r = String(r), u & 64 ? (a = 16, r = [Dl(r)]) : a = 8);
  n.children = r, n.shapeFlag |= a;
}
function Rf(...n) {
  const r = {};
  for (let a = 0; a < n.length; a++) {
    const u = n[a];
    for (const c in u)
      if (c === "class")
        r.class !== u.class && (r.class = ho([r.class, u.class]));
      else if (c === "style")
        r.style = ca([r.style, u.style]);
      else if (Wi(c)) {
        const d = r[c], p = u[c];
        p && d !== p && !(Ne(d) && d.includes(p)) && (r[c] = d ? [].concat(d, p) : p);
      } else c !== "" && (r[c] = u[c]);
  }
  return r;
}
function Ln(n, r, a, u = null) {
  qn(n, r, 7, [
    a,
    u
  ]);
}
const jf = yl();
let Lf = 0;
function Kf(n, r, a) {
  const u = n.type, c = (r ? r.appContext : n.appContext) || jf, d = {
    uid: Lf++,
    vnode: n,
    type: u,
    parent: r,
    appContext: c,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Du(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: r ? r.provides : Object.create(c.provides),
    ids: r ? r.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: wl(u, c),
    emitsOptions: Nl(u, c),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: it,
    // inheritAttrs
    inheritAttrs: u.inheritAttrs,
    // state
    ctx: it,
    data: it,
    props: it,
    attrs: it,
    slots: it,
    refs: it,
    setupState: it,
    setupContext: null,
    // suspense related
    suspense: a,
    suspenseId: a ? a.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return d.ctx = { _: d }, d.root = r ? r.root : d, d.emit = Of.bind(null, d), n.ce && n.ce(d), d;
}
let $t = null;
const Ff = () => $t || Rt;
let Ui, Js;
{
  const n = Yi(), r = (a, u) => {
    let c;
    return (c = n[a]) || (c = n[a] = []), c.push(u), (d) => {
      c.length > 1 ? c.forEach((p) => p(d)) : c[0](d);
    };
  };
  Ui = r(
    "__VUE_INSTANCE_SETTERS__",
    (a) => $t = a
  ), Js = r(
    "__VUE_SSR_SETTERS__",
    (a) => wi = a
  );
}
const Ei = (n) => {
  const r = $t;
  return Ui(n), n.scope.on(), () => {
    n.scope.off(), Ui(r);
  };
}, Xa = () => {
  $t && $t.scope.off(), Ui(null);
};
function Il(n) {
  return n.vnode.shapeFlag & 4;
}
let wi = !1;
function Mf(n, r = !1, a = !1) {
  r && Js(r);
  const { props: u, children: c } = n.vnode, d = Il(n);
  ff(n, u, d, r), mf(n, c, a || r);
  const p = d ? Bf(n, r) : void 0;
  return r && Js(!1), p;
}
function Bf(n, r) {
  const a = n.type;
  n.accessCache = /* @__PURE__ */ Object.create(null), n.proxy = new Proxy(n.ctx, ef);
  const { setup: u } = a;
  if (u) {
    br();
    const c = n.setupContext = u.length > 1 ? $f(n) : null, d = Ei(n), p = Ti(
      u,
      n,
      0,
      [
        n.props,
        c
      ]
    ), g = Ou(p);
    if (_r(), d(), (g || n.sp) && !To(n) && ul(n), g) {
      if (p.then(Xa, Xa), r)
        return p.then((O) => {
          za(n, O);
        }).catch((O) => {
          Qi(O, n, 0);
        });
      n.asyncDep = p;
    } else
      za(n, p);
  } else
    Rl(n);
}
function za(n, r, a) {
  Ke(r) ? n.type.__ssrInlineRender ? n.ssrRender = r : n.render = r : ft(r) && (n.setupState = Qu(r)), Rl(n);
}
function Rl(n, r, a) {
  const u = n.type;
  n.render || (n.render = u.render || Bn);
  {
    const c = Ei(n);
    br();
    try {
      tf(n);
    } finally {
      _r(), c();
    }
  }
}
const qf = {
  get(n, r) {
    return Ht(n, "get", ""), n[r];
  }
};
function $f(n) {
  const r = (a) => {
    n.exposed = a || {};
  };
  return {
    attrs: new Proxy(n.attrs, qf),
    slots: n.slots,
    emit: n.emit,
    expose: r
  };
}
function ts(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(Qu(ba(n.exposed)), {
    get(r, a) {
      if (a in r)
        return r[a];
      if (a in pi)
        return pi[a](n);
    },
    has(r, a) {
      return a in r || a in pi;
    }
  })) : n.proxy;
}
function Uf(n) {
  return Ke(n) && "__vccOpts" in n;
}
const It = (n, r) => Rc(n, r, wi), Vf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Zs;
const Qa = typeof window < "u" && window.trustedTypes;
if (Qa)
  try {
    Zs = /* @__PURE__ */ Qa.createPolicy("vue", {
      createHTML: (n) => n
    });
  } catch {
  }
const jl = Zs ? (n) => Zs.createHTML(n) : (n) => n, Hf = "http://www.w3.org/2000/svg", Wf = "http://www.w3.org/1998/Math/MathML", pr = typeof document < "u" ? document : null, Ja = pr && /* @__PURE__ */ pr.createElement("template"), Gf = {
  insert: (n, r, a) => {
    r.insertBefore(n, a || null);
  },
  remove: (n) => {
    const r = n.parentNode;
    r && r.removeChild(n);
  },
  createElement: (n, r, a, u) => {
    const c = r === "svg" ? pr.createElementNS(Hf, n) : r === "mathml" ? pr.createElementNS(Wf, n) : a ? pr.createElement(n, { is: a }) : pr.createElement(n);
    return n === "select" && u && u.multiple != null && c.setAttribute("multiple", u.multiple), c;
  },
  createText: (n) => pr.createTextNode(n),
  createComment: (n) => pr.createComment(n),
  setText: (n, r) => {
    n.nodeValue = r;
  },
  setElementText: (n, r) => {
    n.textContent = r;
  },
  parentNode: (n) => n.parentNode,
  nextSibling: (n) => n.nextSibling,
  querySelector: (n) => pr.querySelector(n),
  setScopeId(n, r) {
    n.setAttribute(r, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(n, r, a, u, c, d) {
    const p = a ? a.previousSibling : r.lastChild;
    if (c && (c === d || c.nextSibling))
      for (; r.insertBefore(c.cloneNode(!0), a), !(c === d || !(c = c.nextSibling)); )
        ;
    else {
      Ja.innerHTML = jl(
        u === "svg" ? `<svg>${n}</svg>` : u === "mathml" ? `<math>${n}</math>` : n
      );
      const g = Ja.content;
      if (u === "svg" || u === "mathml") {
        const O = g.firstChild;
        for (; O.firstChild; )
          g.appendChild(O.firstChild);
        g.removeChild(O);
      }
      r.insertBefore(g, a);
    }
    return [
      // first
      p ? p.nextSibling : r.firstChild,
      // last
      a ? a.previousSibling : r.lastChild
    ];
  }
}, Yf = Symbol("_vtc");
function Xf(n, r, a) {
  const u = n[Yf];
  u && (r = (r ? [r, ...u] : [...u]).join(" ")), r == null ? n.removeAttribute("class") : a ? n.setAttribute("class", r) : n.className = r;
}
const Za = Symbol("_vod"), zf = Symbol("_vsh"), Qf = Symbol(""), Jf = /(^|;)\s*display\s*:/;
function Zf(n, r, a) {
  const u = n.style, c = Et(a);
  let d = !1;
  if (a && !c) {
    if (r)
      if (Et(r))
        for (const p of r.split(";")) {
          const g = p.slice(0, p.indexOf(":")).trim();
          a[g] == null && Ii(u, g, "");
        }
      else
        for (const p in r)
          a[p] == null && Ii(u, p, "");
    for (const p in a)
      p === "display" && (d = !0), Ii(u, p, a[p]);
  } else if (c) {
    if (r !== a) {
      const p = u[Qf];
      p && (a += ";" + p), u.cssText = a, d = Jf.test(a);
    }
  } else r && n.removeAttribute("style");
  Za in n && (n[Za] = d ? u.display : "", n[zf] && (u.display = "none"));
}
const eu = /\s*!important$/;
function Ii(n, r, a) {
  if (Ne(a))
    a.forEach((u) => Ii(n, r, u));
  else if (a == null && (a = ""), r.startsWith("--"))
    n.setProperty(r, a);
  else {
    const u = ed(n, r);
    eu.test(a) ? n.setProperty(
      yo(u),
      a.replace(eu, ""),
      "important"
    ) : n[u] = a;
  }
}
const tu = ["Webkit", "Moz", "ms"], Fs = {};
function ed(n, r) {
  const a = Fs[r];
  if (a)
    return a;
  let u = Sr(r);
  if (u !== "filter" && u in n)
    return Fs[r] = u;
  u = Nu(u);
  for (let c = 0; c < tu.length; c++) {
    const d = tu[c] + u;
    if (d in n)
      return Fs[r] = d;
  }
  return r;
}
const nu = "http://www.w3.org/1999/xlink";
function ru(n, r, a, u, c, d = rc(r)) {
  u && r.startsWith("xlink:") ? a == null ? n.removeAttributeNS(nu, r.slice(6, r.length)) : n.setAttributeNS(nu, r, a) : a == null || d && !Au(a) ? n.removeAttribute(r) : n.setAttribute(
    r,
    d ? "" : In(a) ? String(a) : a
  );
}
function ou(n, r, a, u, c) {
  if (r === "innerHTML" || r === "textContent") {
    a != null && (n[r] = r === "innerHTML" ? jl(a) : a);
    return;
  }
  const d = n.tagName;
  if (r === "value" && d !== "PROGRESS" && // custom elements may use _value internally
  !d.includes("-")) {
    const g = d === "OPTION" ? n.getAttribute("value") || "" : n.value, O = a == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      n.type === "checkbox" ? "on" : ""
    ) : String(a);
    (g !== O || !("_value" in n)) && (n.value = O), a == null && n.removeAttribute(r), n._value = a;
    return;
  }
  let p = !1;
  if (a === "" || a == null) {
    const g = typeof n[r];
    g === "boolean" ? a = Au(a) : a == null && g === "string" ? (a = "", p = !0) : g === "number" && (a = 0, p = !0);
  }
  try {
    n[r] = a;
  } catch {
  }
  p && n.removeAttribute(c || r);
}
function yr(n, r, a, u) {
  n.addEventListener(r, a, u);
}
function td(n, r, a, u) {
  n.removeEventListener(r, a, u);
}
const iu = Symbol("_vei");
function nd(n, r, a, u, c = null) {
  const d = n[iu] || (n[iu] = {}), p = d[r];
  if (u && p)
    p.value = u;
  else {
    const [g, O] = rd(r);
    if (u) {
      const K = d[r] = sd(
        u,
        c
      );
      yr(n, g, K, O);
    } else p && (td(n, g, p, O), d[r] = void 0);
  }
}
const su = /(?:Once|Passive|Capture)$/;
function rd(n) {
  let r;
  if (su.test(n)) {
    r = {};
    let u;
    for (; u = n.match(su); )
      n = n.slice(0, n.length - u[0].length), r[u[0].toLowerCase()] = !0;
  }
  return [n[2] === ":" ? n.slice(3) : yo(n.slice(2)), r];
}
let Ms = 0;
const od = /* @__PURE__ */ Promise.resolve(), id = () => Ms || (od.then(() => Ms = 0), Ms = Date.now());
function sd(n, r) {
  const a = (u) => {
    if (!u._vts)
      u._vts = Date.now();
    else if (u._vts <= a.attached)
      return;
    qn(
      ad(u, a.value),
      r,
      5,
      [u]
    );
  };
  return a.value = n, a.attached = id(), a;
}
function ad(n, r) {
  if (Ne(r)) {
    const a = n.stopImmediatePropagation;
    return n.stopImmediatePropagation = () => {
      a.call(n), n._stopped = !0;
    }, r.map(
      (u) => (c) => !c._stopped && u && u(c)
    );
  } else
    return r;
}
const au = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // lowercase letter
n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, ud = (n, r, a, u, c, d) => {
  const p = c === "svg";
  r === "class" ? Xf(n, u, p) : r === "style" ? Zf(n, a, u) : Wi(r) ? aa(r) || nd(n, r, a, u, d) : (r[0] === "." ? (r = r.slice(1), !0) : r[0] === "^" ? (r = r.slice(1), !1) : ld(n, r, u, p)) ? (ou(n, r, u), !n.tagName.includes("-") && (r === "value" || r === "checked" || r === "selected") && ru(n, r, u, p, d, r !== "value")) : /* #11081 force set props for possible async custom element */ n._isVueCE && (/[A-Z]/.test(r) || !Et(u)) ? ou(n, Sr(r), u, d, r) : (r === "true-value" ? n._trueValue = u : r === "false-value" && (n._falseValue = u), ru(n, r, u, p));
};
function ld(n, r, a, u) {
  if (u)
    return !!(r === "innerHTML" || r === "textContent" || r in n && au(r) && Ke(a));
  if (r === "spellcheck" || r === "draggable" || r === "translate" || r === "autocorrect" || r === "form" || r === "list" && n.tagName === "INPUT" || r === "type" && n.tagName === "TEXTAREA")
    return !1;
  if (r === "width" || r === "height") {
    const c = n.tagName;
    if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE")
      return !1;
  }
  return au(r) && Et(a) ? !1 : r in n;
}
const Ar = (n) => {
  const r = n.props["onUpdate:modelValue"] || !1;
  return Ne(r) ? (a) => Pi(r, a) : r;
};
function cd(n) {
  n.target.composing = !0;
}
function uu(n) {
  const r = n.target;
  r.composing && (r.composing = !1, r.dispatchEvent(new Event("input")));
}
const bn = Symbol("_assign"), Pr = {
  created(n, { modifiers: { lazy: r, trim: a, number: u } }, c) {
    n[bn] = Ar(c);
    const d = u || c.props && c.props.type === "number";
    yr(n, r ? "change" : "input", (p) => {
      if (p.target.composing) return;
      let g = n.value;
      a && (g = g.trim()), d && (g = Li(g)), n[bn](g);
    }), a && yr(n, "change", () => {
      n.value = n.value.trim();
    }), r || (yr(n, "compositionstart", cd), yr(n, "compositionend", uu), yr(n, "change", uu));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(n, { value: r }) {
    n.value = r ?? "";
  },
  beforeUpdate(n, { value: r, oldValue: a, modifiers: { lazy: u, trim: c, number: d } }, p) {
    if (n[bn] = Ar(p), n.composing) return;
    const g = (d || n.type === "number") && !/^0\d/.test(n.value) ? Li(n.value) : n.value, O = r ?? "";
    g !== O && (document.activeElement === n && n.type !== "range" && (u && r === a || c && n.value.trim() === O) || (n.value = O));
  }
}, lu = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(n, r, a) {
    n[bn] = Ar(a), yr(n, "change", () => {
      const u = n._modelValue, c = Oo(n), d = n.checked, p = n[bn];
      if (Ne(u)) {
        const g = fa(u, c), O = g !== -1;
        if (d && !O)
          p(u.concat(c));
        else if (!d && O) {
          const K = [...u];
          K.splice(g, 1), p(K);
        }
      } else if (Co(u)) {
        const g = new Set(u);
        d ? g.add(c) : g.delete(c), p(g);
      } else
        p(Ll(n, d));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: cu,
  beforeUpdate(n, r, a) {
    n[bn] = Ar(a), cu(n, r, a);
  }
};
function cu(n, { value: r, oldValue: a }, u) {
  n._modelValue = r;
  let c;
  if (Ne(r))
    c = fa(r, u.props.value) > -1;
  else if (Co(r))
    c = r.has(u.props.value);
  else {
    if (r === a) return;
    c = mo(r, Ll(n, !0));
  }
  n.checked !== c && (n.checked = c);
}
const fu = {
  created(n, { value: r }, a) {
    n.checked = mo(r, a.props.value), n[bn] = Ar(a), yr(n, "change", () => {
      n[bn](Oo(n));
    });
  },
  beforeUpdate(n, { value: r, oldValue: a }, u) {
    n[bn] = Ar(u), r !== a && (n.checked = mo(r, u.props.value));
  }
}, kn = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(n, { value: r, modifiers: { number: a } }, u) {
    const c = Co(r);
    yr(n, "change", () => {
      const d = Array.prototype.filter.call(n.options, (p) => p.selected).map(
        (p) => a ? Li(Oo(p)) : Oo(p)
      );
      n[bn](
        n.multiple ? c ? new Set(d) : d : d[0]
      ), n._assigning = !0, _a(() => {
        n._assigning = !1;
      });
    }), n[bn] = Ar(u);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(n, { value: r }) {
    du(n, r);
  },
  beforeUpdate(n, r, a) {
    n[bn] = Ar(a);
  },
  updated(n, { value: r }) {
    n._assigning || du(n, r);
  }
};
function du(n, r) {
  const a = n.multiple, u = Ne(r);
  if (!(a && !u && !Co(r))) {
    for (let c = 0, d = n.options.length; c < d; c++) {
      const p = n.options[c], g = Oo(p);
      if (a)
        if (u) {
          const O = typeof g;
          O === "string" || O === "number" ? p.selected = r.some((K) => String(K) === String(g)) : p.selected = fa(r, g) > -1;
        } else
          p.selected = r.has(g);
      else if (mo(Oo(p), r)) {
        n.selectedIndex !== c && (n.selectedIndex = c);
        return;
      }
    }
    !a && n.selectedIndex !== -1 && (n.selectedIndex = -1);
  }
}
function Oo(n) {
  return "_value" in n ? n._value : n.value;
}
function Ll(n, r) {
  const a = r ? "_trueValue" : "_falseValue";
  return a in n ? n[a] : r;
}
const fd = /* @__PURE__ */ Wt({ patchProp: ud }, Gf);
let pu;
function dd() {
  return pu || (pu = vf(fd));
}
const pd = (...n) => {
  const r = dd().createApp(...n), { mount: a } = r;
  return r.mount = (u) => {
    const c = md(u);
    if (!c) return;
    const d = r._component;
    !Ke(d) && !d.render && !d.template && (d.template = c.innerHTML), c.nodeType === 1 && (c.textContent = "");
    const p = a(c, !1, hd(c));
    return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), p;
  }, r;
};
function hd(n) {
  if (n instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && n instanceof MathMLElement)
    return "mathml";
}
function md(n) {
  return Et(n) ? document.querySelector(n) : n;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Kl;
const ns = (n) => Kl = n, Fl = (
  /* istanbul ignore next */
  Symbol()
);
function ea(n) {
  return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function";
}
var yi;
(function(n) {
  n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function";
})(yi || (yi = {}));
function yd() {
  const n = Iu(!0), r = n.run(() => _t({}));
  let a = [], u = [];
  const c = ba({
    install(d) {
      ns(c), c._a = d, d.provide(Fl, c), d.config.globalProperties.$pinia = c, u.forEach((p) => a.push(p)), u = [];
    },
    use(d) {
      return this._a ? a.push(d) : u.push(d), this;
    },
    _p: a,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: n,
    _s: /* @__PURE__ */ new Map(),
    state: r
  });
  return c;
}
const Ml = () => {
};
function hu(n, r, a, u = Ml) {
  n.push(r);
  const c = () => {
    const d = n.indexOf(r);
    d > -1 && (n.splice(d, 1), u());
  };
  return !a && Ru() && ic(c), c;
}
function go(n, ...r) {
  n.slice().forEach((a) => {
    a(...r);
  });
}
const vd = (n) => n(), mu = Symbol(), Bs = Symbol();
function ta(n, r) {
  n instanceof Map && r instanceof Map ? r.forEach((a, u) => n.set(u, a)) : n instanceof Set && r instanceof Set && r.forEach(n.add, n);
  for (const a in r) {
    if (!r.hasOwnProperty(a))
      continue;
    const u = r[a], c = n[a];
    ea(c) && ea(u) && n.hasOwnProperty(a) && !vt(u) && !vr(u) ? n[a] = ta(c, u) : n[a] = u;
  }
  return n;
}
const gd = (
  /* istanbul ignore next */
  Symbol()
);
function bd(n) {
  return !ea(n) || !Object.prototype.hasOwnProperty.call(n, gd);
}
const { assign: Tr } = Object;
function _d(n) {
  return !!(vt(n) && n.effect);
}
function wd(n, r, a, u) {
  const { state: c, actions: d, getters: p } = r, g = a.state.value[n];
  let O;
  function K() {
    g || (a.state.value[n] = c ? c() : {});
    const P = Ac(a.state.value[n]);
    return Tr(P, d, Object.keys(p || {}).reduce((R, j) => (R[j] = ba(It(() => {
      ns(a);
      const L = a._s.get(n);
      return p[j].call(L, L);
    })), R), {}));
  }
  return O = Bl(n, K, r, a, u, !0), O;
}
function Bl(n, r, a = {}, u, c, d) {
  let p;
  const g = Tr({ actions: {} }, a), O = { deep: !0 };
  let K, P, R = [], j = [], L;
  const G = u.state.value[n];
  !d && !G && (u.state.value[n] = {}), _t({});
  let fe;
  function qe(Ce) {
    let B;
    K = P = !1, typeof Ce == "function" ? (Ce(u.state.value[n]), B = {
      type: yi.patchFunction,
      storeId: n,
      events: L
    }) : (ta(u.state.value[n], Ce), B = {
      type: yi.patchObject,
      payload: Ce,
      storeId: n,
      events: L
    });
    const We = fe = Symbol();
    _a().then(() => {
      fe === We && (K = !0);
    }), P = !0, go(R, B, u.state.value[n]);
  }
  const pe = d ? function() {
    const { state: B } = a, We = B ? B() : {};
    this.$patch((st) => {
      Tr(st, We);
    });
  } : (
    /* istanbul ignore next */
    Ml
  );
  function me() {
    p.stop(), R = [], j = [], u._s.delete(n);
  }
  const Ee = (Ce, B = "") => {
    if (mu in Ce)
      return Ce[Bs] = B, Ce;
    const We = function() {
      ns(u);
      const st = Array.from(arguments), Re = [], nt = [];
      function yn(ge) {
        Re.push(ge);
      }
      function Pt(ge) {
        nt.push(ge);
      }
      go(j, {
        args: st,
        name: We[Bs],
        store: Ae,
        after: yn,
        onError: Pt
      });
      let Ze;
      try {
        Ze = Ce.apply(this && this.$id === n ? this : Ae, st);
      } catch (ge) {
        throw go(nt, ge), ge;
      }
      return Ze instanceof Promise ? Ze.then((ge) => (go(Re, ge), ge)).catch((ge) => (go(nt, ge), Promise.reject(ge))) : (go(Re, Ze), Ze);
    };
    return We[mu] = !0, We[Bs] = B, We;
  }, de = {
    _p: u,
    // _s: scope,
    $id: n,
    $onAction: hu.bind(null, j),
    $patch: qe,
    $reset: pe,
    $subscribe(Ce, B = {}) {
      const We = hu(R, Ce, B.detached, () => st()), st = p.run(() => gr(() => u.state.value[n], (Re) => {
        (B.flush === "sync" ? P : K) && Ce({
          storeId: n,
          type: yi.direct,
          events: L
        }, Re);
      }, Tr({}, O, B)));
      return We;
    },
    $dispose: me
  }, Ae = zi(de);
  u._s.set(n, Ae);
  const ye = (u._a && u._a.runWithContext || vd)(() => u._e.run(() => (p = Iu()).run(() => r({ action: Ee }))));
  for (const Ce in ye) {
    const B = ye[Ce];
    if (vt(B) && !_d(B) || vr(B))
      d || (G && bd(B) && (vt(B) ? B.value = G[Ce] : ta(B, G[Ce])), u.state.value[n][Ce] = B);
    else if (typeof B == "function") {
      const We = Ee(B, Ce);
      ye[Ce] = We, g.actions[Ce] = B;
    }
  }
  return Tr(Ae, ye), Tr(Qe(Ae), ye), Object.defineProperty(Ae, "$state", {
    get: () => u.state.value[n],
    set: (Ce) => {
      qe((B) => {
        Tr(B, Ce);
      });
    }
  }), u._p.forEach((Ce) => {
    Tr(Ae, p.run(() => Ce({
      store: Ae,
      app: u._a,
      pinia: u,
      options: g
    })));
  }), G && d && a.hydrate && a.hydrate(Ae.$state, G), K = !0, P = !0, Ae;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function xd(n, r, a) {
  let u;
  const c = typeof r == "function";
  u = c ? a : r;
  function d(p, g) {
    const O = cf();
    return p = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    p || (O ? hi(Fl, null) : null), p && ns(p), p = Kl, p._s.has(n) || (c ? Bl(n, r, u, p) : wd(n, u, p)), p._s.get(n);
  }
  return d.$id = n, d;
}
function ql(n) {
  const r = Qe(n), a = {};
  for (const u in r) {
    const c = r[u];
    c.effect ? a[u] = // ...
    It({
      get: () => n[u],
      set(d) {
        n[u] = d;
      }
    }) : (vt(c) || vr(c)) && (a[u] = // ---
    Dc(n, u));
  }
  return a;
}
var Td = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ed(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Ri = { exports: {} }, Od = Ri.exports, yu;
function Cd() {
  return yu || (yu = 1, function(n, r) {
    (function(a, u) {
      n.exports = u();
    })(Od, function() {
      var a = function(e, t) {
        return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (o[s] = i[s]);
        })(e, t);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var t, o = 1, i = arguments.length; o < i; o++) for (var s in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, t, o) {
        for (var i, s = 0, l = t.length; s < l; s++) !i && s in t || ((i = i || Array.prototype.slice.call(t, 0, s))[s] = t[s]);
        return e.concat(i || Array.prototype.slice.call(t));
      }
      var d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Td, p = Object.keys, g = Array.isArray;
      function O(e, t) {
        return typeof t != "object" || p(t).forEach(function(o) {
          e[o] = t[o];
        }), e;
      }
      typeof Promise > "u" || d.Promise || (d.Promise = Promise);
      var K = Object.getPrototypeOf, P = {}.hasOwnProperty;
      function R(e, t) {
        return P.call(e, t);
      }
      function j(e, t) {
        typeof t == "function" && (t = t(K(e))), (typeof Reflect > "u" ? p : Reflect.ownKeys)(t).forEach(function(o) {
          G(e, o, t[o]);
        });
      }
      var L = Object.defineProperty;
      function G(e, t, o, i) {
        L(e, t, O(o && R(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function fe(e) {
        return { from: function(t) {
          return e.prototype = Object.create(t.prototype), G(e.prototype, "constructor", e), { extend: j.bind(null, e.prototype) };
        } };
      }
      var qe = Object.getOwnPropertyDescriptor, pe = [].slice;
      function me(e, t, o) {
        return pe.call(e, t, o);
      }
      function Ee(e, t) {
        return t(e);
      }
      function de(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function Ae(e) {
        d.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function Be(e, t) {
        if (typeof t == "string" && R(e, t)) return e[t];
        if (!t) return e;
        if (typeof t != "string") {
          for (var o = [], i = 0, s = t.length; i < s; ++i) {
            var l = Be(e, t[i]);
            o.push(l);
          }
          return o;
        }
        var f = t.indexOf(".");
        if (f !== -1) {
          var h = e[t.substr(0, f)];
          return h == null ? void 0 : Be(h, t.substr(f + 1));
        }
      }
      function ye(e, t, o) {
        if (e && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) {
          de(typeof o != "string" && "length" in o);
          for (var i = 0, s = t.length; i < s; ++i) ye(e, t[i], o[i]);
        } else {
          var l, f, h = t.indexOf(".");
          h !== -1 ? (l = t.substr(0, h), (f = t.substr(h + 1)) === "" ? o === void 0 ? g(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : ye(h = !(h = e[l]) || !R(e, l) ? e[l] = {} : h, f, o)) : o === void 0 ? g(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = o;
        }
      }
      function Ce(e) {
        var t, o = {};
        for (t in e) R(e, t) && (o[t] = e[t]);
        return o;
      }
      var B = [].concat;
      function We(e) {
        return B.apply([], e);
      }
      var Pe = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(We([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + e + "Array";
        });
      }))).filter(function(e) {
        return d[e];
      }), st = new Set(Pe.map(function(e) {
        return d[e];
      })), Re = null;
      function nt(e) {
        return Re = /* @__PURE__ */ new WeakMap(), e = function t(o) {
          if (!o || typeof o != "object") return o;
          var i = Re.get(o);
          if (i) return i;
          if (g(o)) {
            i = [], Re.set(o, i);
            for (var s = 0, l = o.length; s < l; ++s) i.push(t(o[s]));
          } else if (st.has(o.constructor)) i = o;
          else {
            var f, h = K(o);
            for (f in i = h === Object.prototype ? {} : Object.create(h), Re.set(o, i), o) R(o, f) && (i[f] = t(o[f]));
          }
          return i;
        }(e), Re = null, e;
      }
      var yn = {}.toString;
      function Pt(e) {
        return yn.call(e).slice(8, -1);
      }
      var Ze = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ge = typeof Ze == "symbol" ? function(e) {
        var t;
        return e != null && (t = e[Ze]) && t.apply(e);
      } : function() {
        return null;
      };
      function Ie(e, t) {
        return t = e.indexOf(t), 0 <= t && e.splice(t, 1), 0 <= t;
      }
      var dt = {};
      function ot(e) {
        var t, o, i, s;
        if (arguments.length === 1) {
          if (g(e)) return e.slice();
          if (this === dt && typeof e == "string") return [e];
          if (s = ge(e)) {
            for (o = []; !(i = s.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (t = e.length) != "number") return [e];
          for (o = new Array(t); t--; ) o[t] = e[t];
          return o;
        }
        for (t = arguments.length, o = new Array(t); t--; ) o[t] = arguments[t];
        return o;
      }
      var ht = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Te = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], pt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Te), kt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Dt(e, t) {
        this.name = e, this.message = t;
      }
      function Rn(e, t) {
        return e + ". Errors: " + Object.keys(t).map(function(o) {
          return t[o].toString();
        }).filter(function(o, i, s) {
          return s.indexOf(o) === i;
        }).join(`
`);
      }
      function sn(e, t, o, i) {
        this.failures = t, this.failedKeys = i, this.successCount = o, this.message = Rn(e, t);
      }
      function wt(e, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(o) {
          return t[o];
        }), this.failuresByPos = t, this.message = Rn(e, this.failures);
      }
      fe(Dt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), fe(sn).from(Dt), fe(wt).from(Dt);
      var A = pt.reduce(function(e, t) {
        return e[t] = t + "Error", e;
      }, {}), w = Dt, F = pt.reduce(function(e, t) {
        var o = t + "Error";
        function i(s, l) {
          this.name = o, s ? typeof s == "string" ? (this.message = "".concat(s).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof s == "object" && (this.message = "".concat(s.name, " ").concat(s.message), this.inner = s) : (this.message = kt[t] || o, this.inner = null);
        }
        return fe(i).from(w), e[t] = i, e;
      }, {});
      F.Syntax = SyntaxError, F.Type = TypeError, F.Range = RangeError;
      var V = Te.reduce(function(e, t) {
        return e[t + "Error"] = F[t], e;
      }, {}), $e = pt.reduce(function(e, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = F[t]), e;
      }, {});
      function N() {
      }
      function M(e) {
        return e;
      }
      function J(e, t) {
        return e == null || e === M ? t : function(o) {
          return t(e(o));
        };
      }
      function ee(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function re(e, t) {
        return e === N ? t : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, s = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = t.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? ee(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? ee(s, this.onerror) : s), l !== void 0 ? l : o;
        };
      }
      function te(e, t) {
        return e === N ? t : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? ee(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? ee(i, this.onerror) : i);
        };
      }
      function ae(e, t) {
        return e === N ? t : function(o) {
          var i = e.apply(this, arguments);
          O(o, i);
          var s = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = t.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? ee(s, this.onsuccess) : s), l && (this.onerror = this.onerror ? ee(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : O(i, o);
        };
      }
      function le(e, t) {
        return e === N ? t : function() {
          return t.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function oe(e, t) {
        return e === N ? t : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, s = arguments.length, l = new Array(s); s--; ) l[s] = arguments[s];
            return o.then(function() {
              return t.apply(i, l);
            });
          }
          return t.apply(this, arguments);
        };
      }
      $e.ModifyError = sn, $e.DexieError = Dt, $e.BulkError = wt;
      var ne = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function we(e) {
        ne = e;
      }
      var ce = {}, xe = 100, Pe = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, K(e), e];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, K(t), e];
      }(), Te = Pe[0], pt = Pe[1], Pe = Pe[2], pt = pt && pt.then, Me = Te && Te.constructor, Ue = !!Pe, ut = function(e, t) {
        an.push([e, t]), Ot && (queueMicrotask(ss), Ot = !1);
      }, gt = !0, Ot = !0, lt = [], Yt = [], jn = M, et = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: N, pgp: !1, env: {}, finalize: N }, Z = et, an = [], Xt = 0, $n = [];
      function z(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = Z;
        if (typeof e != "function") {
          if (e !== ce) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Dr(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function o(i, s) {
          try {
            s(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var f = i._lib && un();
                l && typeof l.then == "function" ? o(i, function(h, y) {
                  l instanceof z ? l._then(h, y) : l.then(h, y);
                }) : (i._state = !0, i._value = l, No(i)), f && ln();
              }
            }, Dr.bind(null, i));
          } catch (l) {
            Dr(i, l);
          }
        }(this, e);
      }
      var kr = { get: function() {
        var e = Z, t = Wn;
        function o(i, s) {
          var l = this, f = !e.global && (e !== Z || t !== Wn), h = f && !Lt(), y = new z(function(b, x) {
            Ir(l, new So(Po(i, e, f, h), Po(s, e, f, h), b, x, e));
          });
          return this._consoleTask && (y._consoleTask = this._consoleTask), y;
        }
        return o.prototype = ce, o;
      }, set: function(e) {
        G(this, "then", e && e.prototype === ce ? kr : { get: function() {
          return e;
        }, set: kr.set });
      } };
      function So(e, t, o, i, s) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = o, this.reject = i, this.psd = s;
      }
      function Dr(e, t) {
        var o, i;
        Yt.push(t), e._state === null && (o = e._lib && un(), t = jn(t), e._state = !1, e._value = t, i = e, lt.some(function(s) {
          return s._value === i._value;
        }) || lt.push(i), No(e), o && ln());
      }
      function No(e) {
        var t = e._listeners;
        e._listeners = [];
        for (var o = 0, i = t.length; o < i; ++o) Ir(e, t[o]);
        var s = e._PSD;
        --s.ref || s.finalize(), Xt === 0 && (++Xt, ut(function() {
          --Xt == 0 && Rr();
        }, []));
      }
      function Ir(e, t) {
        if (e._state !== null) {
          var o = e._state ? t.onFulfilled : t.onRejected;
          if (o === null) return (e._state ? t.resolve : t.reject)(e._value);
          ++t.psd.ref, ++Xt, ut(is, [o, e, t]);
        } else e._listeners.push(t);
      }
      function is(e, t, o) {
        try {
          var i, s = t._value;
          !t._state && Yt.length && (Yt = []), i = ne && t._consoleTask ? t._consoleTask.run(function() {
            return e(s);
          }) : e(s), t._state || Yt.indexOf(s) !== -1 || function(l) {
            for (var f = lt.length; f; ) if (lt[--f]._value === l._value) return lt.splice(f, 1);
          }(t), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Xt == 0 && Rr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function ss() {
        zt(et, function() {
          un() && ln();
        });
      }
      function un() {
        var e = gt;
        return Ot = gt = !1, e;
      }
      function ln() {
        var e, t, o;
        do
          for (; 0 < an.length; ) for (e = an, an = [], o = e.length, t = 0; t < o; ++t) {
            var i = e[t];
            i[0].apply(null, i[1]);
          }
        while (0 < an.length);
        Ot = gt = !0;
      }
      function Rr() {
        var e = lt;
        lt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var t = $n.slice(0), o = t.length; o; ) t[--o]();
      }
      function Un(e) {
        return new z(ce, !1, e);
      }
      function ke(e, t) {
        var o = Z;
        return function() {
          var i = un(), s = Z;
          try {
            return Kt(o, !0), e.apply(this, arguments);
          } catch (l) {
            t && t(l);
          } finally {
            Kt(s, !1), i && ln();
          }
        };
      }
      j(z.prototype, { then: kr, _then: function(e, t) {
        Ir(this, new So(null, null, e, t, Z));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var t = e, o = arguments[1];
        return typeof t == "function" ? this.then(null, function(i) {
          return (i instanceof t ? o : Un)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === t ? o : Un)(i);
        });
      }, finally: function(e) {
        return this.then(function(t) {
          return z.resolve(e()).then(function() {
            return t;
          });
        }, function(t) {
          return z.resolve(e()).then(function() {
            return Un(t);
          });
        });
      }, timeout: function(e, t) {
        var o = this;
        return e < 1 / 0 ? new z(function(i, s) {
          var l = setTimeout(function() {
            return s(new F.Timeout(t));
          }, e);
          o.then(i, s).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && G(z.prototype, Symbol.toStringTag, "Dexie.Promise"), et.env = Ao(), j(z, { all: function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t, o) {
          e.length === 0 && t([]);
          var i = e.length;
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(f) {
              e[l] = f, --i || t(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof z ? e : e && typeof e.then == "function" ? new z(function(t, o) {
          e.then(t, o);
        }) : new z(ce, !0, e);
      }, reject: Un, race: function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t, o) {
          e.map(function(i) {
            return z.resolve(i).then(t, o);
          });
        });
      }, PSD: { get: function() {
        return Z;
      }, set: function(e) {
        return Z = e;
      } }, totalEchoes: { get: function() {
        return Wn;
      } }, newPSD: jt, usePSD: zt, scheduler: { get: function() {
        return ut;
      }, set: function(e) {
        ut = e;
      } }, rejectionMapper: { get: function() {
        return jn;
      }, set: function(e) {
        jn = e;
      } }, follow: function(e, t) {
        return new z(function(o, i) {
          return jt(function(s, l) {
            var f = Z;
            f.unhandleds = [], f.onunhandled = l, f.finalize = ee(function() {
              var h, y = this;
              h = function() {
                y.unhandleds.length === 0 ? s() : l(y.unhandleds[0]);
              }, $n.push(function b() {
                h(), $n.splice($n.indexOf(b), 1);
              }), ++Xt, ut(function() {
                --Xt == 0 && Rr();
              }, []);
            }, f.finalize), e();
          }, t, o, i);
        });
      } }), Me && (Me.allSettled && G(z, "allSettled", function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t) {
          e.length === 0 && t([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(f) {
              return i[l] = { status: "fulfilled", value: f };
            }, function(f) {
              return i[l] = { status: "rejected", reason: f };
            }).then(function() {
              return --o || t(i);
            });
          });
        });
      }), Me.any && typeof AggregateError < "u" && G(z, "any", function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, s = new Array(i);
          e.forEach(function(l, f) {
            return z.resolve(l).then(function(h) {
              return t(h);
            }, function(h) {
              s[f] = h, --i || o(new AggregateError(s));
            });
          });
        });
      }), Me.withResolvers && (z.withResolvers = Me.withResolvers));
      var Ve = { awaits: 0, echoes: 0, id: 0 }, as = 0, Vn = [], Hn = 0, Wn = 0, us = 0;
      function jt(e, t, o, i) {
        var s = Z, l = Object.create(s);
        return l.parent = s, l.ref = 0, l.global = !1, l.id = ++us, et.env, l.env = Ue ? { Promise: z, PromiseProp: { value: z, configurable: !0, writable: !0 }, all: z.all, race: z.race, allSettled: z.allSettled, any: z.any, resolve: z.resolve, reject: z.reject } : {}, t && O(l, t), ++s.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function cn() {
        return Ve.id || (Ve.id = ++as), ++Ve.awaits, Ve.echoes += xe, Ve.id;
      }
      function Lt() {
        return !!Ve.awaits && (--Ve.awaits == 0 && (Ve.id = 0), Ve.echoes = Ve.awaits * xe, !0);
      }
      function Gn(e) {
        return Ve.echoes && e && e.constructor === Me ? (cn(), e.then(function(t) {
          return Lt(), t;
        }, function(t) {
          return Lt(), je(t);
        })) : e;
      }
      function ls() {
        var e = Vn[Vn.length - 1];
        Vn.pop(), Kt(e, !1);
      }
      function Kt(e, t) {
        var o, i = Z;
        (t ? !Ve.echoes || Hn++ && e === Z : !Hn || --Hn && e === Z) || queueMicrotask(t ? (function(s) {
          ++Wn, Ve.echoes && --Ve.echoes != 0 || (Ve.echoes = Ve.awaits = Ve.id = 0), Vn.push(Z), Kt(s, !0);
        }).bind(null, e) : ls), e !== Z && (Z = e, i === et && (et.env = Ao()), Ue && (o = et.env.Promise, t = e.env, (i.global || e.global) && (Object.defineProperty(d, "Promise", t.PromiseProp), o.all = t.all, o.race = t.race, o.resolve = t.resolve, o.reject = t.reject, t.allSettled && (o.allSettled = t.allSettled), t.any && (o.any = t.any))));
      }
      function Ao() {
        var e = d.Promise;
        return Ue ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(d, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function zt(e, t, o, i, s) {
        var l = Z;
        try {
          return Kt(e, !0), t(o, i, s);
        } finally {
          Kt(l, !1);
        }
      }
      function Po(e, t, o, i) {
        return typeof e != "function" ? e : function() {
          var s = Z;
          o && cn(), Kt(t, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Kt(s, !1), i && queueMicrotask(Lt);
          }
        };
      }
      function jr(e) {
        Promise === Me && Ve.echoes === 0 ? Hn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + pt).indexOf("[native code]") === -1 && (cn = Lt = N);
      var je = z.reject, Qt = "￿", St = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", ko = "String expected.", fn = [], Yn = "__dbnames", Lr = "readonly", Kr = "readwrite";
      function Jt(e, t) {
        return e ? t ? function() {
          return e.apply(this, arguments) && t.apply(this, arguments);
        } : e : t;
      }
      var Do = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Xn(e) {
        return typeof e != "string" || /\./.test(e) ? function(t) {
          return t;
        } : function(t) {
          return t[e] === void 0 && e in t && delete (t = nt(t))[e], t;
        };
      }
      function Io() {
        throw F.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function he(e, t) {
        try {
          var o = Ro(e), i = Ro(t);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return t < e ? 1 : e < t ? -1 : 0;
            case "binary":
              return function(s, l) {
                for (var f = s.length, h = l.length, y = f < h ? f : h, b = 0; b < y; ++b) if (s[b] !== l[b]) return s[b] < l[b] ? -1 : 1;
                return f === h ? 0 : f < h ? -1 : 1;
              }(jo(e), jo(t));
            case "Array":
              return function(s, l) {
                for (var f = s.length, h = l.length, y = f < h ? f : h, b = 0; b < y; ++b) {
                  var x = he(s[b], l[b]);
                  if (x !== 0) return x;
                }
                return f === h ? 0 : f < h ? -1 : 1;
              }(e, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ro(e) {
        var t = typeof e;
        return t != "object" ? t : ArrayBuffer.isView(e) ? "binary" : (e = Pt(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function jo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function zn(e, t, o) {
        var i = e.schema.yProps;
        return i ? (t && 0 < o.numFailures && (t = t.filter(function(s, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(s) {
          return s = s.updatesTable, t ? e.db.table(s).where("k").anyOf(t).delete() : e.db.table(s).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Lo = (Se.prototype._trans = function(e, t, o) {
        var i = this._tx || Z.trans, s = this.name, l = ne && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function f(b, x, m) {
          if (!m.schema[s]) throw new F.NotFound("Table " + s + " not part of transaction");
          return t(m.idbtrans, m);
        }
        var h = un();
        try {
          var y = i && i.db._novip === this.db._novip ? i === Z.trans ? i._promise(e, f, o) : jt(function() {
            return i._promise(e, f, o);
          }, { trans: i, transless: Z.transless || Z }) : function b(x, m, C, v) {
            if (x.idbdb && (x._state.openComplete || Z.letThrough || x._vip)) {
              var _ = x._createTransaction(m, C, x._dbSchema);
              try {
                _.create(), x._state.PR1398_maxLoop = 3;
              } catch (E) {
                return E.name === A.InvalidState && x.isOpen() && 0 < --x._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), x.close({ disableAutoOpen: !1 }), x.open().then(function() {
                  return b(x, m, C, v);
                })) : je(E);
              }
              return _._promise(m, function(E, T) {
                return jt(function() {
                  return Z.trans = _, v(E, T, _);
                });
              }).then(function(E) {
                if (m === "readwrite") try {
                  _.idbtrans.commit();
                } catch {
                }
                return m === "readonly" ? E : _._completion.then(function() {
                  return E;
                });
              });
            }
            if (x._state.openComplete) return je(new F.DatabaseClosed(x._state.dbOpenError));
            if (!x._state.isBeingOpened) {
              if (!x._state.autoOpen) return je(new F.DatabaseClosed());
              x.open().catch(N);
            }
            return x._state.dbReadyPromise.then(function() {
              return b(x, m, C, v);
            });
          }(this.db, e, [this.name], f);
          return l && (y._consoleTask = l, y = y.catch(function(b) {
            return console.trace(b), je(b);
          })), y;
        } finally {
          h && ln();
        }
      }, Se.prototype.get = function(e, t) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(t) : e == null ? je(new F.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(s) {
            return o.hook.reading.fire(s);
          });
        }).then(t);
      }, Se.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (g(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var t = p(e);
        if (t.length === 1) return this.where(t[0]).equals(e[t[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(h) {
          if (h.compound && t.every(function(b) {
            return 0 <= h.keyPath.indexOf(b);
          })) {
            for (var y = 0; y < t.length; ++y) if (t.indexOf(h.keyPath[y]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(h, y) {
          return h.keyPath.length - y.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== Qt) {
          var l = o.keyPath.slice(0, t.length);
          return this.where(l).equals(l.map(function(y) {
            return e[y];
          }));
        }
        !o && ne && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var i = this.schema.idxByName;
        function s(h, y) {
          return he(h, y) === 0;
        }
        var f = t.reduce(function(m, y) {
          var b = m[0], x = m[1], m = i[y], C = e[y];
          return [b || m, b || !m ? Jt(x, m && m.multi ? function(v) {
            return v = Be(v, y), g(v) && v.some(function(_) {
              return s(C, _);
            });
          } : function(v) {
            return s(C, Be(v, y));
          }) : x];
        }, [null, null]), l = f[0], f = f[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(f) : o ? this.filter(f) : this.where(t).equals("");
      }, Se.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Se.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Se.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Se.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Se.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Se.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Se.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Se.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, g(e) ? "[".concat(e.join("+"), "]") : e));
      }, Se.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Se.prototype.mapToClass = function(e) {
        var t, o = this.db, i = this.name;
        function s() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Io && (function(y, b) {
          if (typeof b != "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function x() {
            this.constructor = y;
          }
          a(y, b), y.prototype = b === null ? Object.create(b) : (x.prototype = b.prototype, new x());
        }(s, t = e), Object.defineProperty(s.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), s.prototype.table = function() {
          return i;
        }, e = s);
        for (var l = /* @__PURE__ */ new Set(), f = e.prototype; f; f = K(f)) Object.getOwnPropertyNames(f).forEach(function(y) {
          return l.add(y);
        });
        function h(y) {
          if (!y) return y;
          var b, x = Object.create(e.prototype);
          for (b in y) if (!l.has(b)) try {
            x[b] = y[b];
          } catch {
          }
          return x;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = h, this.hook("reading", h), e;
      }, Se.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          O(this, e);
        });
      }, Se.prototype.add = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, f = e;
        return l && s && (f = Xn(l)(e)), this._trans("readwrite", function(h) {
          return o.core.mutate({ trans: h, type: "add", keys: t != null ? [t] : null, values: [f] });
        }).then(function(h) {
          return h.numFailures ? z.reject(h.failures[0]) : h.lastResult;
        }).then(function(h) {
          if (l) try {
            ye(e, l, h);
          } catch {
          }
          return h;
        });
      }, Se.prototype.update = function(e, t) {
        return typeof e != "object" || g(e) ? this.where(":id").equals(e).modify(t) : (e = Be(e, this.schema.primKey.keyPath), e === void 0 ? je(new F.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(t));
      }, Se.prototype.put = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, f = e;
        return l && s && (f = Xn(l)(e)), this._trans("readwrite", function(h) {
          return o.core.mutate({ trans: h, type: "put", values: [f], keys: t != null ? [t] : null });
        }).then(function(h) {
          return h.numFailures ? z.reject(h.failures[0]) : h.lastResult;
        }).then(function(h) {
          if (l) try {
            ye(e, l, h);
          } catch {
          }
          return h;
        });
      }, Se.prototype.delete = function(e) {
        var t = this;
        return this._trans("readwrite", function(o) {
          return t.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return zn(t, [e], i);
          }).then(function(i) {
            return i.numFailures ? z.reject(i.failures[0]) : void 0;
          });
        });
      }, Se.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(t) {
          return e.core.mutate({ trans: t, type: "deleteRange", range: Do }).then(function(o) {
            return zn(e, null, o);
          });
        }).then(function(t) {
          return t.numFailures ? z.reject(t.failures[0]) : void 0;
        });
      }, Se.prototype.bulkGet = function(e) {
        var t = this;
        return this._trans("readonly", function(o) {
          return t.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(s) {
              return t.hook.reading.fire(s);
            });
          });
        });
      }, Se.prototype.bulkAdd = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(f) {
          var b = i.schema.primKey, h = b.auto, b = b.keyPath;
          if (b && s) throw new F.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new F.InvalidArgument("Arguments objects and keys must have the same length");
          var y = e.length, b = b && h ? e.map(Xn(b)) : e;
          return i.core.mutate({ trans: f, type: "add", keys: s, values: b, wantResults: l }).then(function(_) {
            var m = _.numFailures, C = _.results, v = _.lastResult, _ = _.failures;
            if (m === 0) return l ? C : v;
            throw new wt("".concat(i.name, ".bulkAdd(): ").concat(m, " of ").concat(y, " operations failed"), _);
          });
        });
      }, Se.prototype.bulkPut = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(f) {
          var b = i.schema.primKey, h = b.auto, b = b.keyPath;
          if (b && s) throw new F.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new F.InvalidArgument("Arguments objects and keys must have the same length");
          var y = e.length, b = b && h ? e.map(Xn(b)) : e;
          return i.core.mutate({ trans: f, type: "put", keys: s, values: b, wantResults: l }).then(function(_) {
            var m = _.numFailures, C = _.results, v = _.lastResult, _ = _.failures;
            if (m === 0) return l ? C : v;
            throw new wt("".concat(i.name, ".bulkPut(): ").concat(m, " of ").concat(y, " operations failed"), _);
          });
        });
      }, Se.prototype.bulkUpdate = function(e) {
        var t = this, o = this.core, i = e.map(function(f) {
          return f.key;
        }), s = e.map(function(f) {
          return f.changes;
        }), l = [];
        return this._trans("readwrite", function(f) {
          return o.getMany({ trans: f, keys: i, cache: "clone" }).then(function(h) {
            var y = [], b = [];
            e.forEach(function(m, C) {
              var v = m.key, _ = m.changes, E = h[C];
              if (E) {
                for (var T = 0, S = Object.keys(_); T < S.length; T++) {
                  var k = S[T], D = _[k];
                  if (k === t.schema.primKey.keyPath) {
                    if (he(D, v) !== 0) throw new F.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ye(E, k, D);
                }
                l.push(C), y.push(v), b.push(E);
              }
            });
            var x = y.length;
            return o.mutate({ trans: f, type: "put", keys: y, values: b, updates: { keys: i, changeSpecs: s } }).then(function(m) {
              var C = m.numFailures, v = m.failures;
              if (C === 0) return x;
              for (var _ = 0, E = Object.keys(v); _ < E.length; _++) {
                var T, S = E[_], k = l[Number(S)];
                k != null && (T = v[S], delete v[S], v[k] = T);
              }
              throw new wt("".concat(t.name, ".bulkUpdate(): ").concat(C, " of ").concat(x, " operations failed"), v);
            });
          });
        });
      }, Se.prototype.bulkDelete = function(e) {
        var t = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return t.core.mutate({ trans: i, type: "delete", keys: e }).then(function(s) {
            return zn(t, e, s);
          });
        }).then(function(f) {
          var s = f.numFailures, l = f.lastResult, f = f.failures;
          if (s === 0) return l;
          throw new wt("".concat(t.name, ".bulkDelete(): ").concat(s, " of ").concat(o, " operations failed"), f);
        });
      }, Se);
      function Se() {
      }
      function _n(e) {
        function t(f, h) {
          if (h) {
            for (var y = arguments.length, b = new Array(y - 1); --y; ) b[y - 1] = arguments[y];
            return o[f].subscribe.apply(null, b), e;
          }
          if (typeof f == "string") return o[f];
        }
        var o = {};
        t.addEventType = l;
        for (var i = 1, s = arguments.length; i < s; ++i) l(arguments[i]);
        return t;
        function l(f, h, y) {
          if (typeof f != "object") {
            var b;
            h = h || le;
            var x = { subscribers: [], fire: y = y || N, subscribe: function(m) {
              x.subscribers.indexOf(m) === -1 && (x.subscribers.push(m), x.fire = h(x.fire, m));
            }, unsubscribe: function(m) {
              x.subscribers = x.subscribers.filter(function(C) {
                return C !== m;
              }), x.fire = x.subscribers.reduce(h, y);
            } };
            return o[f] = t[f] = x;
          }
          p(b = f).forEach(function(m) {
            var C = b[m];
            if (g(C)) l(m, b[m][0], b[m][1]);
            else {
              if (C !== "asap") throw new F.InvalidArgument("Invalid event config");
              var v = l(m, M, function() {
                for (var _ = arguments.length, E = new Array(_); _--; ) E[_] = arguments[_];
                v.subscribers.forEach(function(T) {
                  Ae(function() {
                    T.apply(null, E);
                  });
                });
              });
            }
          });
        }
      }
      function wn(e, t) {
        return fe(t).from({ prototype: e }), t;
      }
      function dn(e, t) {
        return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);
      }
      function Fr(e, t) {
        e.filter = Jt(e.filter, t);
      }
      function Mr(e, t, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return Jt(i(), t());
        } : t, e.justLimit = o && !i;
      }
      function Qn(e, t) {
        if (e.isPrimKey) return t.primaryKey;
        var o = t.getIndexByKeyPath(e.index);
        if (!o) throw new F.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return o;
      }
      function Ko(e, t, o) {
        var i = Qn(e, t.schema);
        return t.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function Jn(e, t, o, i) {
        var s = e.replayFilter ? Jt(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, f = function(h, y, b) {
            var x, m;
            s && !s(y, b, function(C) {
              return y.stop(C);
            }, function(C) {
              return y.fail(C);
            }) || ((m = "" + (x = y.primaryKey)) == "[object ArrayBuffer]" && (m = "" + new Uint8Array(x)), R(l, m) || (l[m] = !0, t(h, y, b)));
          };
          return Promise.all([e.or._iterate(f, o), Fo(Ko(e, i, o), e.algorithm, f, !e.keysOnly && e.valueMapper)]);
        }
        return Fo(Ko(e, i, o), Jt(e.algorithm, s), t, !e.keysOnly && e.valueMapper);
      }
      function Fo(e, t, o, i) {
        var s = ke(i ? function(l, f, h) {
          return o(i(l), f, h);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var f = function() {
              return l.continue();
            };
            t && !t(l, function(h) {
              return f = h;
            }, function(h) {
              l.stop(h), f = N;
            }, function(h) {
              l.fail(h), f = N;
            }) || s(l.value, l, function(h) {
              return f = h;
            }), f();
          });
        });
      }
      var xn = (Mo.prototype.execute = function(e) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var o = t.add;
          if (g(o)) return c(c([], g(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (t.remove !== void 0) {
          var i = t.remove;
          if (g(i)) return g(e) ? e.filter(function(s) {
            return !i.includes(s);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = t.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? t.replacePrefix[1] + e.substring(o.length) : e;
      }, Mo);
      function Mo(e) {
        this["@@propmod"] = e;
      }
      var cs = (_e.prototype._read = function(e, t) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, je.bind(null, o.error)) : o.table._trans("readonly", e).then(t);
      }, _e.prototype._write = function(e) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, je.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
      }, _e.prototype._addAlgorithm = function(e) {
        var t = this._ctx;
        t.algorithm = Jt(t.algorithm, e);
      }, _e.prototype._iterate = function(e, t) {
        return Jn(this._ctx, e, t, this._ctx.table.core);
      }, _e.prototype.clone = function(e) {
        var t = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && O(o, e), t._ctx = o, t;
      }, _e.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, _e.prototype.each = function(e) {
        var t = this._ctx;
        return this._read(function(o) {
          return Jn(t, e, o, t.table.core);
        });
      }, _e.prototype.count = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx, s = i.table.core;
          if (dn(i, !0)) return s.count({ trans: o, query: { index: Qn(i, s.schema), range: i.range } }).then(function(f) {
            return Math.min(f, i.limit);
          });
          var l = 0;
          return Jn(i, function() {
            return ++l, !1;
          }, o, s).then(function() {
            return l;
          });
        }).then(e);
      }, _e.prototype.sortBy = function(e, t) {
        var o = e.split(".").reverse(), i = o[0], s = o.length - 1;
        function l(y, b) {
          return b ? l(y[o[b]], b - 1) : y[i];
        }
        var f = this._ctx.dir === "next" ? 1 : -1;
        function h(y, b) {
          return he(l(y, s), l(b, s)) * f;
        }
        return this.toArray(function(y) {
          return y.sort(h);
        }).then(t);
      }, _e.prototype.toArray = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx;
          if (i.dir === "next" && dn(i, !0) && 0 < i.limit) {
            var s = i.valueMapper, l = Qn(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(h) {
              return h = h.result, s ? h.map(s) : h;
            });
          }
          var f = [];
          return Jn(i, function(h) {
            return f.push(h);
          }, o, i.table.core).then(function() {
            return f;
          });
        }, e);
      }, _e.prototype.offset = function(e) {
        var t = this._ctx;
        return e <= 0 || (t.offset += e, dn(t) ? Mr(t, function() {
          var o = e;
          return function(i, s) {
            return o === 0 || (o === 1 ? --o : s(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : Mr(t, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, _e.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Mr(this._ctx, function() {
          var t = e;
          return function(o, i, s) {
            return --t <= 0 && i(s), 0 <= t;
          };
        }, !0), this;
      }, _e.prototype.until = function(e, t) {
        return Fr(this._ctx, function(o, i, s) {
          return !e(o.value) || (i(s), t);
        }), this;
      }, _e.prototype.first = function(e) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(e);
      }, _e.prototype.last = function(e) {
        return this.reverse().first(e);
      }, _e.prototype.filter = function(e) {
        var t;
        return Fr(this._ctx, function(o) {
          return e(o.value);
        }), (t = this._ctx).isMatch = Jt(t.isMatch, e), this;
      }, _e.prototype.and = function(e) {
        return this.filter(e);
      }, _e.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, _e.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, _e.prototype.desc = function() {
        return this.reverse();
      }, _e.prototype.eachKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, _e.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, _e.prototype.eachPrimaryKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, _e.prototype.keys = function(e) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.key);
        }).then(function() {
          return o;
        }).then(e);
      }, _e.prototype.primaryKeys = function(e) {
        var t = this._ctx;
        if (t.dir === "next" && dn(t, !0) && 0 < t.limit) return this._read(function(i) {
          var s = Qn(t, t.table.core.schema);
          return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: s, range: t.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, _e.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, _e.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(e);
      }, _e.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, _e.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var t = {};
        return Fr(this._ctx, function(s) {
          var i = s.primaryKey.toString(), s = R(t, i);
          return t[i] = !0, !s;
        }), this;
      }, _e.prototype.modify = function(e) {
        var t = this, o = this._ctx;
        return this._write(function(i) {
          var s, l, f;
          f = typeof e == "function" ? e : (s = p(e), l = s.length, function(S) {
            for (var k = !1, D = 0; D < l; ++D) {
              var I = s[D], $ = e[I], W = Be(S, I);
              $ instanceof xn ? (ye(S, I, $.execute(W)), k = !0) : W !== $ && (ye(S, I, $), k = !0);
            }
            return k;
          });
          var h = o.table.core, m = h.schema.primaryKey, y = m.outbound, b = m.extractKey, x = 200, m = t.db._options.modifyChunkSize;
          m && (x = typeof m == "object" ? m[h.name] || m["*"] || 200 : m);
          function C(S, I) {
            var D = I.failures, I = I.numFailures;
            _ += S - I;
            for (var $ = 0, W = p(D); $ < W.length; $++) {
              var U = W[$];
              v.push(D[U]);
            }
          }
          var v = [], _ = 0, E = [], T = e === Bo;
          return t.clone().primaryKeys().then(function(S) {
            function k(I) {
              var $ = Math.min(x, S.length - I), W = S.slice(I, I + $);
              return (T ? Promise.resolve([]) : h.getMany({ trans: i, keys: W, cache: "immutable" })).then(function(U) {
                var H = [], X = [], Y = y ? [] : null, Q = T ? W : [];
                if (!T) for (var ue = 0; ue < $; ++ue) {
                  var ve = U[ue], se = { value: nt(ve), primKey: S[I + ue] };
                  f.call(se, se.value, se) !== !1 && (se.value == null ? Q.push(S[I + ue]) : y || he(b(ve), b(se.value)) === 0 ? (X.push(se.value), y && Y.push(S[I + ue])) : (Q.push(S[I + ue]), H.push(se.value)));
                }
                return Promise.resolve(0 < H.length && h.mutate({ trans: i, type: "add", values: H }).then(function(De) {
                  for (var ie in De.failures) Q.splice(parseInt(ie), 1);
                  C(H.length, De);
                })).then(function() {
                  return (0 < X.length || D && typeof e == "object") && h.mutate({ trans: i, type: "put", keys: Y, values: X, criteria: D, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < I }).then(function(De) {
                    return C(X.length, De);
                  });
                }).then(function() {
                  return (0 < Q.length || D && T) && h.mutate({ trans: i, type: "delete", keys: Q, criteria: D, isAdditionalChunk: 0 < I }).then(function(De) {
                    return zn(o.table, Q, De);
                  }).then(function(De) {
                    return C(Q.length, De);
                  });
                }).then(function() {
                  return S.length > I + $ && k(I + x);
                });
              });
            }
            var D = dn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return k(0).then(function() {
              if (0 < v.length) throw new sn("Error modifying one or more objects", v, _, E);
              return S.length;
            });
          });
        });
      }, _e.prototype.delete = function() {
        var e = this._ctx, t = e.range;
        return !dn(e) || e.table.schema.yProps || !e.isPrimKey && t.type !== 3 ? this.modify(Bo) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, s = t;
          return e.table.core.count({ trans: o, query: { index: i, range: s } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: s }).then(function(y) {
              var h = y.failures, y = y.numFailures;
              if (y) throw new sn("Could not delete some values", Object.keys(h).map(function(b) {
                return h[b];
              }), l - y);
              return l - y;
            });
          });
        });
      }, _e);
      function _e() {
      }
      var Bo = function(e, t) {
        return t.value = null;
      };
      function fs(e, t) {
        return e < t ? -1 : e === t ? 0 : 1;
      }
      function ds(e, t) {
        return t < e ? -1 : e === t ? 0 : 1;
      }
      function at(e, t, o) {
        return e = e instanceof $o ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(t), e;
      }
      function pn(e) {
        return new e.Collection(e, function() {
          return qo("");
        }).limit(0);
      }
      function Zn(e, t, o, i) {
        var s, l, f, h, y, b, x, m = o.length;
        if (!o.every(function(_) {
          return typeof _ == "string";
        })) return at(e, ko);
        function C(_) {
          s = _ === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = _ === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, f = _ === "next" ? fs : ds;
          var E = o.map(function(T) {
            return { lower: l(T), upper: s(T) };
          }).sort(function(T, S) {
            return f(T.lower, S.lower);
          });
          h = E.map(function(T) {
            return T.upper;
          }), y = E.map(function(T) {
            return T.lower;
          }), x = (b = _) === "next" ? "" : i;
        }
        C("next"), e = new e.Collection(e, function() {
          return Ft(h[0], y[m - 1] + i);
        }), e._ondirectionchange = function(_) {
          C(_);
        };
        var v = 0;
        return e._addAlgorithm(function(_, E, T) {
          var S = _.key;
          if (typeof S != "string") return !1;
          var k = l(S);
          if (t(k, y, v)) return !0;
          for (var D = null, I = v; I < m; ++I) {
            var $ = function(W, U, H, X, Y, Q) {
              for (var ue = Math.min(W.length, X.length), ve = -1, se = 0; se < ue; ++se) {
                var De = U[se];
                if (De !== X[se]) return Y(W[se], H[se]) < 0 ? W.substr(0, se) + H[se] + H.substr(se + 1) : Y(W[se], X[se]) < 0 ? W.substr(0, se) + X[se] + H.substr(se + 1) : 0 <= ve ? W.substr(0, ve) + U[ve] + H.substr(ve + 1) : null;
                Y(W[se], De) < 0 && (ve = se);
              }
              return ue < X.length && Q === "next" ? W + H.substr(W.length) : ue < W.length && Q === "prev" ? W.substr(0, H.length) : ve < 0 ? null : W.substr(0, ve) + X[ve] + H.substr(ve + 1);
            }(S, k, h[I], y[I], f, b);
            $ === null && D === null ? v = I + 1 : (D === null || 0 < f(D, $)) && (D = $);
          }
          return E(D !== null ? function() {
            _.continue(D + x);
          } : T), !1;
        }), e;
      }
      function Ft(e, t, o, i) {
        return { type: 2, lower: e, upper: t, lowerOpen: o, upperOpen: i };
      }
      function qo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var $o = (Object.defineProperty(He.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), He.prototype.between = function(e, t, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, t) || this._cmp(e, t) === 0 && (o || i) && (!o || !i) ? pn(this) : new this.Collection(this, function() {
            return Ft(e, t, !o, !i);
          });
        } catch {
          return at(this, St);
        }
      }, He.prototype.equals = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return qo(e);
        });
      }, He.prototype.above = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(e, void 0, !0);
        });
      }, He.prototype.aboveOrEqual = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(e, void 0, !1);
        });
      }, He.prototype.below = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(void 0, e, !1, !0);
        });
      }, He.prototype.belowOrEqual = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(void 0, e);
        });
      }, He.prototype.startsWith = function(e) {
        return typeof e != "string" ? at(this, ko) : this.between(e, e + Qt, !0, !0);
      }, He.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : Zn(this, function(t, o) {
          return t.indexOf(o[0]) === 0;
        }, [e], Qt);
      }, He.prototype.equalsIgnoreCase = function(e) {
        return Zn(this, function(t, o) {
          return t === o[0];
        }, [e], "");
      }, He.prototype.anyOfIgnoreCase = function() {
        var e = ot.apply(dt, arguments);
        return e.length === 0 ? pn(this) : Zn(this, function(t, o) {
          return o.indexOf(t) !== -1;
        }, e, "");
      }, He.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ot.apply(dt, arguments);
        return e.length === 0 ? pn(this) : Zn(this, function(t, o) {
          return o.some(function(i) {
            return t.indexOf(i) === 0;
          });
        }, e, Qt);
      }, He.prototype.anyOf = function() {
        var e = this, t = ot.apply(dt, arguments), o = this._cmp;
        try {
          t.sort(o);
        } catch {
          return at(this, St);
        }
        if (t.length === 0) return pn(this);
        var i = new this.Collection(this, function() {
          return Ft(t[0], t[t.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, t.sort(o);
        };
        var s = 0;
        return i._addAlgorithm(function(l, f, h) {
          for (var y = l.key; 0 < o(y, t[s]); ) if (++s === t.length) return f(h), !1;
          return o(y, t[s]) === 0 || (f(function() {
            l.continue(t[s]);
          }), !1);
        }), i;
      }, He.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, He.prototype.noneOf = function() {
        var e = ot.apply(dt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return at(this, St);
        }
        var t = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, He.prototype.inAnyRange = function(S, t) {
        var o = this, i = this._cmp, s = this._ascending, l = this._descending, f = this._min, h = this._max;
        if (S.length === 0) return pn(this);
        if (!S.every(function(k) {
          return k[0] !== void 0 && k[1] !== void 0 && s(k[0], k[1]) <= 0;
        })) return at(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", F.InvalidArgument);
        var y = !t || t.includeLowers !== !1, b = t && t.includeUppers === !0, x, m = s;
        function C(k, D) {
          return m(k[0], D[0]);
        }
        try {
          (x = S.reduce(function(k, D) {
            for (var I = 0, $ = k.length; I < $; ++I) {
              var W = k[I];
              if (i(D[0], W[1]) < 0 && 0 < i(D[1], W[0])) {
                W[0] = f(W[0], D[0]), W[1] = h(W[1], D[1]);
                break;
              }
            }
            return I === $ && k.push(D), k;
          }, [])).sort(C);
        } catch {
          return at(this, St);
        }
        var v = 0, _ = b ? function(k) {
          return 0 < s(k, x[v][1]);
        } : function(k) {
          return 0 <= s(k, x[v][1]);
        }, E = y ? function(k) {
          return 0 < l(k, x[v][0]);
        } : function(k) {
          return 0 <= l(k, x[v][0]);
        }, T = _, S = new this.Collection(this, function() {
          return Ft(x[0][0], x[x.length - 1][1], !y, !b);
        });
        return S._ondirectionchange = function(k) {
          m = k === "next" ? (T = _, s) : (T = E, l), x.sort(C);
        }, S._addAlgorithm(function(k, D, I) {
          for (var $, W = k.key; T(W); ) if (++v === x.length) return D(I), !1;
          return !_($ = W) && !E($) || (o._cmp(W, x[v][1]) === 0 || o._cmp(W, x[v][0]) === 0 || D(function() {
            m === s ? k.continue(x[v][0]) : k.continue(x[v][1]);
          }), !1);
        }), S;
      }, He.prototype.startsWithAnyOf = function() {
        var e = ot.apply(dt, arguments);
        return e.every(function(t) {
          return typeof t == "string";
        }) ? e.length === 0 ? pn(this) : this.inAnyRange(e.map(function(t) {
          return [t, t + Qt];
        })) : at(this, "startsWithAnyOf() only works with strings");
      }, He);
      function He() {
      }
      function xt(e) {
        return ke(function(t) {
          return Tn(t), e(t.target.error), !1;
        });
      }
      function Tn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var En = "storagemutated", Br = "x-storagemutated-1", Mt = _n(null, En), ps = (Tt.prototype._lock = function() {
        return de(!Z.global), ++this._reculock, this._reculock !== 1 || Z.global || (Z.lockOwnerFor = this), this;
      }, Tt.prototype._unlock = function() {
        if (de(!Z.global), --this._reculock == 0) for (Z.global || (Z.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Tt.prototype._locked = function() {
        return this._reculock && Z.lockOwnerFor !== this;
      }, Tt.prototype.create = function(e) {
        var t = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (de(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new F.DatabaseClosed(i);
          case "MissingAPIError":
            throw new F.MissingAPI(i.message, i);
          default:
            throw new F.OpenFailed(i);
        }
        if (!this.active) throw new F.TransactionInactive();
        return de(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = ke(function(s) {
          Tn(s), t._reject(e.error);
        }), e.onabort = ke(function(s) {
          Tn(s), t.active && t._reject(new F.Abort(e.error)), t.active = !1, t.on("abort").fire(s);
        }), e.oncomplete = ke(function() {
          t.active = !1, t._resolve(), "mutatedParts" in e && Mt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Tt.prototype._promise = function(e, t, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return je(new F.ReadOnly("Transaction is readonly"));
        if (!this.active) return je(new F.TransactionInactive());
        if (this._locked()) return new z(function(l, f) {
          i._blockedFuncs.push([function() {
            i._promise(e, t, o).then(l, f);
          }, Z]);
        });
        if (o) return jt(function() {
          var l = new z(function(f, h) {
            i._lock();
            var y = t(f, h, i);
            y && y.then && y.then(f, h);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var s = new z(function(l, f) {
          var h = t(l, f, i);
          h && h.then && h.then(l, f);
        });
        return s._lib = !0, s;
      }, Tt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Tt.prototype.waitFor = function(e) {
        var t, o = this._root(), i = z.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], t = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (t.get(-1 / 0).onsuccess = l);
        }());
        var s = o._waitingFor;
        return new z(function(l, f) {
          i.then(function(h) {
            return o._waitingQueue.push(ke(l.bind(null, h)));
          }, function(h) {
            return o._waitingQueue.push(ke(f.bind(null, h)));
          }).finally(function() {
            o._waitingFor === s && (o._waitingFor = null);
          });
        });
      }, Tt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new F.Abort()));
      }, Tt.prototype.table = function(e) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (R(t, e)) return t[e];
        var o = this.schema[e];
        if (!o) throw new F.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), t[e] = o;
      }, Tt);
      function Tt() {
      }
      function qr(e, t, o, i, s, l, f, h) {
        return { name: e, keyPath: t, unique: o, multi: i, auto: s, compound: l, src: (o && !f ? "&" : "") + (i ? "*" : "") + (s ? "++" : "") + Uo(t), type: h };
      }
      function Uo(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function $r(e, t, o) {
        return { name: e, primKey: t, indexes: o, mappedClass: null, idxByName: (i = function(s) {
          return [s.name, s];
        }, o.reduce(function(s, l, f) {
          return f = i(l, f), f && (s[f[0]] = f[1]), s;
        }, {})) };
        var i;
      }
      var On = function(e) {
        try {
          return e.only([[]]), On = function() {
            return [[]];
          }, [[]];
        } catch {
          return On = function() {
            return Qt;
          }, Qt;
        }
      };
      function Ur(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (t = e).split(".").length === 1 ? function(o) {
          return o[t];
        } : function(o) {
          return Be(o, t);
        } : function(o) {
          return Be(o, e);
        };
        var t;
      }
      function Vo(e) {
        return [].slice.call(e);
      }
      var hs = 0;
      function Cn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function ms(e, t, y) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var v = T.lower, _ = T.upper, E = T.lowerOpen, T = T.upperOpen;
          return v === void 0 ? _ === void 0 ? null : t.upperBound(_, !!T) : _ === void 0 ? t.lowerBound(v, !!E) : t.bound(v, _, !!E, !!T);
        }
        function s(C) {
          var v, _ = C.name;
          return { name: _, schema: C, mutate: function(E) {
            var T = E.trans, S = E.type, k = E.keys, D = E.values, I = E.range;
            return new Promise(function($, W) {
              $ = ke($);
              var U = T.objectStore(_), H = U.keyPath == null, X = S === "put" || S === "add";
              if (!X && S !== "delete" && S !== "deleteRange") throw new Error("Invalid operation type: " + S);
              var Y, Q = (k || D || { length: 1 }).length;
              if (k && D && k.length !== D.length) throw new Error("Given keys array must have same length as given values array.");
              if (Q === 0) return $({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ue(tt) {
                ++De, Tn(tt);
              }
              var ve = [], se = [], De = 0;
              if (S === "deleteRange") {
                if (I.type === 4) return $({ numFailures: De, failures: se, results: [], lastResult: void 0 });
                I.type === 3 ? ve.push(Y = U.clear()) : ve.push(Y = U.delete(i(I)));
              } else {
                var H = X ? H ? [D, k] : [D, null] : [k, null], ie = H[0], Xe = H[1];
                if (X) for (var ze = 0; ze < Q; ++ze) ve.push(Y = Xe && Xe[ze] !== void 0 ? U[S](ie[ze], Xe[ze]) : U[S](ie[ze])), Y.onerror = ue;
                else for (ze = 0; ze < Q; ++ze) ve.push(Y = U[S](ie[ze])), Y.onerror = ue;
              }
              function fr(tt) {
                tt = tt.target.result, ve.forEach(function(tn, ao) {
                  return tn.error != null && (se[ao] = tn.error);
                }), $({ numFailures: De, failures: se, results: S === "delete" ? k : ve.map(function(tn) {
                  return tn.result;
                }), lastResult: tt });
              }
              Y.onerror = function(tt) {
                ue(tt), fr(tt);
              }, Y.onsuccess = fr;
            });
          }, getMany: function(E) {
            var T = E.trans, S = E.keys;
            return new Promise(function(k, D) {
              k = ke(k);
              for (var I, $ = T.objectStore(_), W = S.length, U = new Array(W), H = 0, X = 0, Y = function(ve) {
                ve = ve.target, U[ve._pos] = ve.result, ++X === H && k(U);
              }, Q = xt(D), ue = 0; ue < W; ++ue) S[ue] != null && ((I = $.get(S[ue]))._pos = ue, I.onsuccess = Y, I.onerror = Q, ++H);
              H === 0 && k(U);
            });
          }, get: function(E) {
            var T = E.trans, S = E.key;
            return new Promise(function(k, D) {
              k = ke(k);
              var I = T.objectStore(_).get(S);
              I.onsuccess = function($) {
                return k($.target.result);
              }, I.onerror = xt(D);
            });
          }, query: (v = b, function(E) {
            return new Promise(function(T, S) {
              T = ke(T);
              var k, D, I, H = E.trans, $ = E.values, W = E.limit, Y = E.query, U = W === 1 / 0 ? void 0 : W, X = Y.index, Y = Y.range, H = H.objectStore(_), X = X.isPrimaryKey ? H : H.index(X.name), Y = i(Y);
              if (W === 0) return T({ result: [] });
              v ? ((U = $ ? X.getAll(Y, U) : X.getAllKeys(Y, U)).onsuccess = function(Q) {
                return T({ result: Q.target.result });
              }, U.onerror = xt(S)) : (k = 0, D = !$ && "openKeyCursor" in X ? X.openKeyCursor(Y) : X.openCursor(Y), I = [], D.onsuccess = function(Q) {
                var ue = D.result;
                return ue ? (I.push($ ? ue.value : ue.primaryKey), ++k === W ? T({ result: I }) : void ue.continue()) : T({ result: I });
              }, D.onerror = xt(S));
            });
          }), openCursor: function(E) {
            var T = E.trans, S = E.values, k = E.query, D = E.reverse, I = E.unique;
            return new Promise(function($, W) {
              $ = ke($);
              var X = k.index, U = k.range, H = T.objectStore(_), H = X.isPrimaryKey ? H : H.index(X.name), X = D ? I ? "prevunique" : "prev" : I ? "nextunique" : "next", Y = !S && "openKeyCursor" in H ? H.openKeyCursor(i(U), X) : H.openCursor(i(U), X);
              Y.onerror = xt(W), Y.onsuccess = ke(function(Q) {
                var ue, ve, se, De, ie = Y.result;
                ie ? (ie.___id = ++hs, ie.done = !1, ue = ie.continue.bind(ie), ve = (ve = ie.continuePrimaryKey) && ve.bind(ie), se = ie.advance.bind(ie), De = function() {
                  throw new Error("Cursor not stopped");
                }, ie.trans = T, ie.stop = ie.continue = ie.continuePrimaryKey = ie.advance = function() {
                  throw new Error("Cursor not started");
                }, ie.fail = ke(W), ie.next = function() {
                  var Xe = this, ze = 1;
                  return this.start(function() {
                    return ze-- ? Xe.continue() : Xe.stop();
                  }).then(function() {
                    return Xe;
                  });
                }, ie.start = function(Xe) {
                  function ze() {
                    if (Y.result) try {
                      Xe();
                    } catch (tt) {
                      ie.fail(tt);
                    }
                    else ie.done = !0, ie.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ie.stop();
                  }
                  var fr = new Promise(function(tt, tn) {
                    tt = ke(tt), Y.onerror = xt(tn), ie.fail = tn, ie.stop = function(ao) {
                      ie.stop = ie.continue = ie.continuePrimaryKey = ie.advance = De, tt(ao);
                    };
                  });
                  return Y.onsuccess = ke(function(tt) {
                    Y.onsuccess = ze, ze();
                  }), ie.continue = ue, ie.continuePrimaryKey = ve, ie.advance = se, ze(), fr;
                }, $(ie)) : $(null);
              }, W);
            });
          }, count: function(E) {
            var T = E.query, S = E.trans, k = T.index, D = T.range;
            return new Promise(function(I, $) {
              var W = S.objectStore(_), U = k.isPrimaryKey ? W : W.index(k.name), W = i(D), U = W ? U.count(W) : U.count();
              U.onsuccess = ke(function(H) {
                return I(H.target.result);
              }), U.onerror = xt($);
            });
          } };
        }
        var l, f, h, x = (f = y, h = Vo((l = e).objectStoreNames), { schema: { name: l.name, tables: h.map(function(C) {
          return f.objectStore(C);
        }).map(function(C) {
          var v = C.keyPath, T = C.autoIncrement, _ = g(v), E = {}, T = { name: C.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: v == null, compound: _, keyPath: v, autoIncrement: T, unique: !0, extractKey: Ur(v) }, indexes: Vo(C.indexNames).map(function(S) {
            return C.index(S);
          }).map(function(I) {
            var k = I.name, D = I.unique, $ = I.multiEntry, I = I.keyPath, $ = { name: k, compound: g(I), keyPath: I, unique: D, multiEntry: $, extractKey: Ur(I) };
            return E[Cn(I)] = $;
          }), getIndexByKeyPath: function(S) {
            return E[Cn(S)];
          } };
          return E[":id"] = T.primaryKey, v != null && (E[Cn(v)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < h.length && "getAll" in f.objectStore(h[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), y = x.schema, b = x.hasGetAll, x = y.tables.map(s), m = {};
        return x.forEach(function(C) {
          return m[C.name] = C;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(C) {
          if (!m[C]) throw new Error("Table '".concat(C, "' not found"));
          return m[C];
        }, MIN_KEY: -1 / 0, MAX_KEY: On(t), schema: y };
      }
      function ys(e, t, o, i) {
        var s = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = ms(t, s, i), e.dbcore.reduce(function(l, f) {
          return f = f.create, u(u({}, l), f(l));
        }, i)) };
      }
      function er(e, i) {
        var o = i.db, i = ys(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(s) {
          var l = s.name;
          e.core.schema.tables.some(function(f) {
            return f.name === l;
          }) && (s.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = s.core));
        });
      }
      function tr(e, t, o, i) {
        o.forEach(function(s) {
          var l = i[s];
          t.forEach(function(f) {
            var h = function y(b, x) {
              return qe(b, x) || (b = K(b)) && y(b, x);
            }(f, s);
            (!h || "value" in h && h.value === void 0) && (f === e.Transaction.prototype || f instanceof e.Transaction ? G(f, s, { get: function() {
              return this.table(s);
            }, set: function(y) {
              L(this, s, { value: y, writable: !0, configurable: !0, enumerable: !0 });
            } }) : f[s] = new e.Table(s, l));
          });
        });
      }
      function Vr(e, t) {
        t.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function vs(e, t) {
        return e._cfg.version - t._cfg.version;
      }
      function gs(e, t, o, i) {
        var s = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !s.$meta && (s.$meta = $r("$meta", Wo("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, s);
        l.create(o), l._completion.catch(i);
        var f = l._reject.bind(l), h = Z.transless || Z;
        jt(function() {
          return Z.trans = l, Z.transless = h, t !== 0 ? (er(e, o), b = t, ((y = l).storeNames.includes("$meta") ? y.table("$meta").get("version").then(function(x) {
            return x ?? b;
          }) : z.resolve(b)).then(function(x) {
            return C = x, v = l, _ = o, E = [], x = (m = e)._versions, T = m._dbSchema = rr(0, m.idbdb, _), (x = x.filter(function(S) {
              return S._cfg.version >= C;
            })).length !== 0 ? (x.forEach(function(S) {
              E.push(function() {
                var k = T, D = S._cfg.dbschema;
                or(m, k, _), or(m, D, _), T = m._dbSchema = D;
                var I = Hr(k, D);
                I.add.forEach(function(X) {
                  Wr(_, X[0], X[1].primKey, X[1].indexes);
                }), I.change.forEach(function(X) {
                  if (X.recreate) throw new F.Upgrade("Not yet support for changing primary key");
                  var Y = _.objectStore(X.name);
                  X.add.forEach(function(Q) {
                    return nr(Y, Q);
                  }), X.change.forEach(function(Q) {
                    Y.deleteIndex(Q.name), nr(Y, Q);
                  }), X.del.forEach(function(Q) {
                    return Y.deleteIndex(Q);
                  });
                });
                var $ = S._cfg.contentUpgrade;
                if ($ && S._cfg.version > C) {
                  er(m, _), v._memoizedTables = {};
                  var W = Ce(D);
                  I.del.forEach(function(X) {
                    W[X] = k[X];
                  }), Vr(m, [m.Transaction.prototype]), tr(m, [m.Transaction.prototype], p(W), W), v.schema = W;
                  var U, H = ht($);
                  return H && cn(), I = z.follow(function() {
                    var X;
                    (U = $(v)) && H && (X = Lt.bind(null, null), U.then(X, X));
                  }), U && typeof U.then == "function" ? z.resolve(U) : I.then(function() {
                    return U;
                  });
                }
              }), E.push(function(k) {
                var D, I, $ = S._cfg.dbschema;
                D = $, I = k, [].slice.call(I.db.objectStoreNames).forEach(function(W) {
                  return D[W] == null && I.db.deleteObjectStore(W);
                }), Vr(m, [m.Transaction.prototype]), tr(m, [m.Transaction.prototype], m._storeNames, m._dbSchema), v.schema = m._dbSchema;
              }), E.push(function(k) {
                m.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(m.idbdb.version / 10) === S._cfg.version ? (m.idbdb.deleteObjectStore("$meta"), delete m._dbSchema.$meta, m._storeNames = m._storeNames.filter(function(D) {
                  return D !== "$meta";
                })) : k.objectStore("$meta").put(S._cfg.version, "version"));
              });
            }), function S() {
              return E.length ? z.resolve(E.shift()(v.idbtrans)).then(S) : z.resolve();
            }().then(function() {
              Ho(T, _);
            })) : z.resolve();
            var m, C, v, _, E, T;
          }).catch(f)) : (p(s).forEach(function(x) {
            Wr(o, x, s[x].primKey, s[x].indexes);
          }), er(e, o), void z.follow(function() {
            return e.on.populate.fire(l);
          }).catch(f));
          var y, b;
        });
      }
      function bs(e, t) {
        Ho(e._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var o = rr(0, e.idbdb, t);
        or(e, e._dbSchema, t);
        for (var i = 0, s = Hr(o, e._dbSchema).change; i < s.length; i++) {
          var l = function(f) {
            if (f.change.length || f.recreate) return console.warn("Unable to patch indexes of table ".concat(f.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var h = t.objectStore(f.name);
            f.add.forEach(function(y) {
              ne && console.debug("Dexie upgrade patch: Creating missing index ".concat(f.name, ".").concat(y.src)), nr(h, y);
            });
          }(s[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function Hr(e, t) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) t[o] || i.del.push(o);
        for (o in t) {
          var s = e[o], l = t[o];
          if (s) {
            var f = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (s.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || s.primKey.auto !== l.primKey.auto) f.recreate = !0, i.change.push(f);
            else {
              var h = s.idxByName, y = l.idxByName, b = void 0;
              for (b in h) y[b] || f.del.push(b);
              for (b in y) {
                var x = h[b], m = y[b];
                x ? x.src !== m.src && f.change.push(m) : f.add.push(m);
              }
              (0 < f.del.length || 0 < f.add.length || 0 < f.change.length) && i.change.push(f);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Wr(e, t, o, i) {
        var s = e.db.createObjectStore(t, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return nr(s, l);
        }), s;
      }
      function Ho(e, t) {
        p(e).forEach(function(o) {
          t.db.objectStoreNames.contains(o) || (ne && console.debug("Dexie: Creating missing table", o), Wr(t, o, e[o].primKey, e[o].indexes));
        });
      }
      function nr(e, t) {
        e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function rr(e, t, o) {
        var i = {};
        return me(t.objectStoreNames, 0).forEach(function(s) {
          for (var l = o.objectStore(s), f = qr(Uo(b = l.keyPath), b || "", !0, !1, !!l.autoIncrement, b && typeof b != "string", !0), h = [], y = 0; y < l.indexNames.length; ++y) {
            var x = l.index(l.indexNames[y]), b = x.keyPath, x = qr(x.name, b, !!x.unique, !!x.multiEntry, !1, b && typeof b != "string", !1);
            h.push(x);
          }
          i[s] = $r(s, f, h);
        }), i;
      }
      function or(e, t, o) {
        for (var i = o.db.objectStoreNames, s = 0; s < i.length; ++s) {
          var l = i[s], f = o.objectStore(l);
          e._hasGetAll = "getAll" in f;
          for (var h = 0; h < f.indexNames.length; ++h) {
            var y = f.indexNames[h], b = f.index(y).keyPath, x = typeof b == "string" ? b : "[" + me(b).join("+") + "]";
            !t[l] || (b = t[l].idxByName[x]) && (b.name = y, delete t[l].idxByName[x], t[l].idxByName[y] = b);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && d.WorkerGlobalScope && d instanceof d.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function Wo(e) {
        return e.split(",").map(function(t, o) {
          var l = t.split(":"), i = (s = l[1]) === null || s === void 0 ? void 0 : s.trim(), s = (t = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(s) ? s.match(/^\[(.*)\]$/)[1].split("+") : s;
          return qr(s, l || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), g(l), o === 0, i);
        });
      }
      var _s = (hn.prototype._createTableSchema = $r, hn.prototype._parseIndexSyntax = Wo, hn.prototype._parseStoresSpec = function(e, t) {
        var o = this;
        p(e).forEach(function(i) {
          if (e[i] !== null) {
            var s = o._parseIndexSyntax(e[i]), l = s.shift();
            if (!l) throw new F.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new F.Schema("Primary key cannot be multiEntry*");
            s.forEach(function(f) {
              if (f.auto) throw new F.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!f.keyPath) throw new F.Schema("Index must have a name and cannot be an empty string");
            }), s = o._createTableSchema(i, l, s), t[i] = s;
          }
        });
      }, hn.prototype.stores = function(o) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? O(this._cfg.storesSource, o) : o;
        var o = t._versions, i = {}, s = {};
        return o.forEach(function(l) {
          O(i, l._cfg.storesSource), s = l._cfg.dbschema = {}, l._parseStoresSpec(i, s);
        }), t._dbSchema = s, Vr(t, [t._allTables, t, t.Transaction.prototype]), tr(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], p(s), s), t._storeNames = p(s), this;
      }, hn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = oe(this._cfg.contentUpgrade || N, e), this;
      }, hn);
      function hn() {
      }
      function Gr(e, t) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Nt(Yn, { addons: [], indexedDB: e, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function Yr(e) {
        return e && typeof e.databases == "function";
      }
      function Xr(e) {
        return jt(function() {
          return Z.letThrough = !0, e();
        });
      }
      function zr(e) {
        return !("from" in e);
      }
      var Ye = function(e, t) {
        if (!this) {
          var o = new Ye();
          return e && "d" in e && O(o, e), o;
        }
        O(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? t : e } : { d: 0 });
      };
      function Sn(e, t, o) {
        var i = he(t, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (zr(e)) return O(e, { from: t, to: o, d: 1 });
          var s = e.l, i = e.r;
          if (he(o, e.from) < 0) return s ? Sn(s, t, o) : e.l = { from: t, to: o, d: 1, l: null, r: null }, Yo(e);
          if (0 < he(t, e.to)) return i ? Sn(i, t, o) : e.r = { from: t, to: o, d: 1, l: null, r: null }, Yo(e);
          he(t, e.from) < 0 && (e.from = t, e.l = null, e.d = i ? i.d + 1 : 1), 0 < he(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, s && !e.l && Nn(e, s), i && o && Nn(e, i);
        }
      }
      function Nn(e, t) {
        zr(t) || function o(i, y) {
          var l = y.from, f = y.to, h = y.l, y = y.r;
          Sn(i, l, f), h && o(i, h), y && o(i, y);
        }(e, t);
      }
      function Go(e, t) {
        var o = ir(t), i = o.next();
        if (i.done) return !1;
        for (var s = i.value, l = ir(e), f = l.next(s.from), h = f.value; !i.done && !f.done; ) {
          if (he(h.from, s.to) <= 0 && 0 <= he(h.to, s.from)) return !0;
          he(s.from, h.from) < 0 ? s = (i = o.next(h.from)).value : h = (f = l.next(s.from)).value;
        }
        return !1;
      }
      function ir(e) {
        var t = zr(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, i) for (; t.n.l && he(o, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !i || he(o, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function Yo(e) {
        var t, o, i = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), s = 1 < i ? "r" : i < -1 ? "l" : "";
        s && (t = s == "r" ? "l" : "r", o = u({}, e), i = e[s], e.from = i.from, e.to = i.to, e[s] = i[s], o[s] = i[t], (e[t] = o).d = Xo(o)), e.d = Xo(e);
      }
      function Xo(o) {
        var t = o.r, o = o.l;
        return (t ? o ? Math.max(t.d, o.d) : t.d : o ? o.d : 0) + 1;
      }
      function sr(e, t) {
        return p(t).forEach(function(o) {
          e[o] ? Nn(e[o], t[o]) : e[o] = function i(s) {
            var l, f, h = {};
            for (l in s) R(s, l) && (f = s[l], h[l] = !f || typeof f != "object" || st.has(f.constructor) ? f : i(f));
            return h;
          }(t[o]);
        }), e;
      }
      function Qr(e, t) {
        return e.all || t.all || Object.keys(e).some(function(o) {
          return t[o] && Go(t[o], e[o]);
        });
      }
      j(Ye.prototype, ((pt = { add: function(e) {
        return Nn(this, e), this;
      }, addKey: function(e) {
        return Sn(this, e, e), this;
      }, addKeys: function(e) {
        var t = this;
        return e.forEach(function(o) {
          return Sn(t, o, o);
        }), this;
      }, hasKey: function(e) {
        var t = ir(this).next(e).value;
        return t && he(t.from, e) <= 0 && 0 <= he(t.to, e);
      } })[Ze] = function() {
        return ir(this);
      }, pt));
      var Zt = {}, Jr = {}, Zr = !1;
      function ar(e) {
        sr(Jr, e), Zr || (Zr = !0, setTimeout(function() {
          Zr = !1, eo(Jr, !(Jr = {}));
        }, 0));
      }
      function eo(e, t) {
        t === void 0 && (t = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, s = Object.values(Zt); i < s.length; i++) zo(f = s[i], e, o, t);
        else for (var l in e) {
          var f, h = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          h && (l = h[1], h = h[2], (f = Zt["idb://".concat(l, "/").concat(h)]) && zo(f, e, o, t));
        }
        o.forEach(function(y) {
          return y();
        });
      }
      function zo(e, t, o, i) {
        for (var s = [], l = 0, f = Object.entries(e.queries.query); l < f.length; l++) {
          for (var h = f[l], y = h[0], b = [], x = 0, m = h[1]; x < m.length; x++) {
            var C = m[x];
            Qr(t, C.obsSet) ? C.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && b.push(C);
          }
          i && s.push([y, b]);
        }
        if (i) for (var v = 0, _ = s; v < _.length; v++) {
          var E = _[v], y = E[0], b = E[1];
          e.queries.query[y] = b;
        }
      }
      function ws(e) {
        var t = e._state, o = e._deps.indexedDB;
        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? je(t.dbOpenError) : e;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var i = t.openCanceller, s = Math.round(10 * e.verno), l = !1;
        function f() {
          if (t.openCanceller !== i) throw new F.DatabaseClosed("db.open() was cancelled");
        }
        function h() {
          return new z(function(C, v) {
            if (f(), !o) throw new F.MissingAPI();
            var _ = e.name, E = t.autoSchema || !s ? o.open(_) : o.open(_, s);
            if (!E) throw new F.MissingAPI();
            E.onerror = xt(v), E.onblocked = ke(e._fireOnBlocked), E.onupgradeneeded = ke(function(T) {
              var S;
              x = E.transaction, t.autoSchema && !e._options.allowEmptyDB ? (E.onerror = Tn, x.abort(), E.result.close(), (S = o.deleteDatabase(_)).onsuccess = S.onerror = ke(function() {
                v(new F.NoSuchDatabase("Database ".concat(_, " doesnt exist")));
              })) : (x.onerror = xt(v), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, m = T < 1, e.idbdb = E.result, l && bs(e, x), gs(e, T / 10, x, v));
            }, v), E.onsuccess = ke(function() {
              x = null;
              var T, S, k, D, I, $ = e.idbdb = E.result, W = me($.objectStoreNames);
              if (0 < W.length) try {
                var U = $.transaction((D = W).length === 1 ? D[0] : D, "readonly");
                if (t.autoSchema) S = $, k = U, (T = e).verno = S.version / 10, k = T._dbSchema = rr(0, S, k), T._storeNames = me(S.objectStoreNames, 0), tr(T, [T._allTables], p(k), k);
                else if (or(e, e._dbSchema, U), ((I = Hr(rr(0, (I = e).idbdb, U), I._dbSchema)).add.length || I.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), $.close(), s = $.version + 1, l = !0, C(h());
                er(e, U);
              } catch {
              }
              fn.push(e), $.onversionchange = ke(function(H) {
                t.vcFired = !0, e.on("versionchange").fire(H);
              }), $.onclose = ke(function(H) {
                e.on("close").fire(H);
              }), m && (I = e._deps, U = _, $ = I.indexedDB, I = I.IDBKeyRange, Yr($) || U === Yn || Gr($, I).put({ name: U }).catch(N)), C();
            }, v);
          }).catch(function(C) {
            switch (C?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), h();
                break;
              case "VersionError":
                if (0 < s) return s = 0, h();
            }
            return z.reject(C);
          });
        }
        var y, b = t.dbReadyResolve, x = null, m = !1;
        return z.race([i, (typeof navigator > "u" ? z.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(C) {
          function v() {
            return indexedDB.databases().finally(C);
          }
          y = setInterval(v, 100), v();
        }).finally(function() {
          return clearInterval(y);
        }) : Promise.resolve()).then(h)]).then(function() {
          return f(), t.onReadyBeingFired = [], z.resolve(Xr(function() {
            return e.on.ready.fire(e.vip);
          })).then(function C() {
            if (0 < t.onReadyBeingFired.length) {
              var v = t.onReadyBeingFired.reduce(oe, N);
              return t.onReadyBeingFired = [], z.resolve(Xr(function() {
                return v(e.vip);
              })).then(C);
            }
          });
        }).finally(function() {
          t.openCanceller === i && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(C) {
          t.dbOpenError = C;
          try {
            x && x.abort();
          } catch {
          }
          return i === t.openCanceller && e._close(), je(C);
        }).finally(function() {
          t.openComplete = !0, b();
        }).then(function() {
          var C;
          return m && (C = {}, e.tables.forEach(function(v) {
            v.schema.indexes.forEach(function(_) {
              _.name && (C["idb://".concat(e.name, "/").concat(v.name, "/").concat(_.name)] = new Ye(-1 / 0, [[[]]]));
            }), C["idb://".concat(e.name, "/").concat(v.name, "/")] = C["idb://".concat(e.name, "/").concat(v.name, "/:dels")] = new Ye(-1 / 0, [[[]]]);
          }), Mt(En).fire(C), eo(C, !0)), e;
        });
      }
      function to(e) {
        function t(l) {
          return e.next(l);
        }
        var o = s(t), i = s(function(l) {
          return e.throw(l);
        });
        function s(l) {
          return function(y) {
            var h = l(y), y = h.value;
            return h.done ? y : y && typeof y.then == "function" ? y.then(o, i) : g(y) ? Promise.all(y).then(o, i) : o(y);
          };
        }
        return s(t)();
      }
      function ur(e, t, o) {
        for (var i = g(e) ? e.slice() : [e], s = 0; s < o; ++s) i.push(t);
        return i;
      }
      var xs = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema, s = {}, l = [];
          function f(m, C, v) {
            var _ = Cn(m), E = s[_] = s[_] || [], T = m == null ? 0 : typeof m == "string" ? 1 : m.length, S = 0 < C, S = u(u({}, v), { name: S ? "".concat(_, "(virtual-from:").concat(v.name, ")") : v.name, lowLevelIndex: v, isVirtual: S, keyTail: C, keyLength: T, extractKey: Ur(m), unique: !S && v.unique });
            return E.push(S), S.isPrimaryKey || l.push(S), 1 < T && f(T === 2 ? m[0] : m.slice(0, T - 1), C + 1, v), E.sort(function(k, D) {
              return k.keyTail - D.keyTail;
            }), S;
          }
          t = f(i.primaryKey.keyPath, 0, i.primaryKey), s[":id"] = [t];
          for (var h = 0, y = i.indexes; h < y.length; h++) {
            var b = y[h];
            f(b.keyPath, 0, b);
          }
          function x(m) {
            var C, v = m.query.index;
            return v.isVirtual ? u(u({}, m), { query: { index: v.lowLevelIndex, range: (C = m.query.range, v = v.keyTail, { type: C.type === 1 ? 2 : C.type, lower: ur(C.lower, C.lowerOpen ? e.MAX_KEY : e.MIN_KEY, v), lowerOpen: !0, upper: ur(C.upper, C.upperOpen ? e.MIN_KEY : e.MAX_KEY, v), upperOpen: !0 }) } }) : m;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: t, indexes: l, getIndexByKeyPath: function(m) {
            return (m = s[Cn(m)]) && m[0];
          } }), count: function(m) {
            return o.count(x(m));
          }, query: function(m) {
            return o.query(x(m));
          }, openCursor: function(m) {
            var C = m.query.index, v = C.keyTail, _ = C.isVirtual, E = C.keyLength;
            return _ ? o.openCursor(x(m)).then(function(S) {
              return S && T(S);
            }) : o.openCursor(m);
            function T(S) {
              return Object.create(S, { continue: { value: function(k) {
                k != null ? S.continue(ur(k, m.reverse ? e.MAX_KEY : e.MIN_KEY, v)) : m.unique ? S.continue(S.key.slice(0, E).concat(m.reverse ? e.MIN_KEY : e.MAX_KEY, v)) : S.continue();
              } }, continuePrimaryKey: { value: function(k, D) {
                S.continuePrimaryKey(ur(k, e.MAX_KEY, v), D);
              } }, primaryKey: { get: function() {
                return S.primaryKey;
              } }, key: { get: function() {
                var k = S.key;
                return E === 1 ? k[0] : k.slice(0, E);
              } }, value: { get: function() {
                return S.value;
              } } });
            }
          } });
        } });
      } };
      function no(e, t, o, i) {
        return o = o || {}, i = i || "", p(e).forEach(function(s) {
          var l, f, h;
          R(t, s) ? (l = e[s], f = t[s], typeof l == "object" && typeof f == "object" && l && f ? (h = Pt(l)) !== Pt(f) ? o[i + s] = t[s] : h === "Object" ? no(l, f, o, i + s + ".") : l !== f && (o[i + s] = t[s]) : l !== f && (o[i + s] = t[s])) : o[i + s] = void 0;
        }), p(t).forEach(function(s) {
          R(e, s) || (o[i + s] = t[s]);
        }), o;
      }
      function ro(e, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey);
      }
      var Ts = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(s) {
            var l = Z.trans, f = l.table(t).hook, h = f.deleting, y = f.creating, b = f.updating;
            switch (s.type) {
              case "add":
                if (y.fire === N) break;
                return l._promise("readwrite", function() {
                  return x(s);
                }, !0);
              case "put":
                if (y.fire === N && b.fire === N) break;
                return l._promise("readwrite", function() {
                  return x(s);
                }, !0);
              case "delete":
                if (h.fire === N) break;
                return l._promise("readwrite", function() {
                  return x(s);
                }, !0);
              case "deleteRange":
                if (h.fire === N) break;
                return l._promise("readwrite", function() {
                  return function m(C, v, _) {
                    return o.query({ trans: C, values: !1, query: { index: i, range: v }, limit: _ }).then(function(E) {
                      var T = E.result;
                      return x({ type: "delete", keys: T, trans: C }).then(function(S) {
                        return 0 < S.numFailures ? Promise.reject(S.failures[0]) : T.length < _ ? { failures: [], numFailures: 0, lastResult: void 0 } : m(C, u(u({}, v), { lower: T[T.length - 1], lowerOpen: !0 }), _);
                      });
                    });
                  }(s.trans, s.range, 1e4);
                }, !0);
            }
            return o.mutate(s);
            function x(m) {
              var C, v, _, E = Z.trans, T = m.keys || ro(i, m);
              if (!T) throw new Error("Keys missing");
              return (m = m.type === "add" || m.type === "put" ? u(u({}, m), { keys: T }) : u({}, m)).type !== "delete" && (m.values = c([], m.values)), m.keys && (m.keys = c([], m.keys)), C = o, _ = T, ((v = m).type === "add" ? Promise.resolve([]) : C.getMany({ trans: v.trans, keys: _, cache: "immutable" })).then(function(S) {
                var k = T.map(function(D, I) {
                  var $, W, U, H = S[I], X = { onerror: null, onsuccess: null };
                  return m.type === "delete" ? h.fire.call(X, D, H, E) : m.type === "add" || H === void 0 ? ($ = y.fire.call(X, D, m.values[I], E), D == null && $ != null && (m.keys[I] = D = $, i.outbound || ye(m.values[I], i.keyPath, D))) : ($ = no(H, m.values[I]), (W = b.fire.call(X, $, D, H, E)) && (U = m.values[I], Object.keys(W).forEach(function(Y) {
                    R(U, Y) ? U[Y] = W[Y] : ye(U, Y, W[Y]);
                  }))), X;
                });
                return o.mutate(m).then(function(D) {
                  for (var I = D.failures, $ = D.results, W = D.numFailures, D = D.lastResult, U = 0; U < T.length; ++U) {
                    var H = ($ || T)[U], X = k[U];
                    H == null ? X.onerror && X.onerror(I[U]) : X.onsuccess && X.onsuccess(m.type === "put" && S[U] ? m.values[U] : H);
                  }
                  return { failures: I, results: $, numFailures: W, lastResult: D };
                }).catch(function(D) {
                  return k.forEach(function(I) {
                    return I.onerror && I.onerror(D);
                  }), Promise.reject(D);
                });
              });
            }
          } });
        } });
      } };
      function Qo(e, t, o) {
        try {
          if (!t || t.keys.length < e.length) return null;
          for (var i = [], s = 0, l = 0; s < t.keys.length && l < e.length; ++s) he(t.keys[s], e[l]) === 0 && (i.push(o ? nt(t.values[s]) : t.values[s]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Es = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(t) {
          var o = e.table(t);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var s = Qo(i.keys, i.trans._cache, i.cache === "clone");
            return s ? z.resolve(s) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? nt(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function Jo(e, t) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Zo(e, t) {
        switch (e) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Os = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var t = e.schema.name, o = new Ye(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, s, l) {
          if (Z.subscr && s !== "readonly") throw new F.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Z.querier));
          return e.transaction(i, s, l);
        }, table: function(i) {
          var s = e.table(i), l = s.schema, f = l.primaryKey, m = l.indexes, h = f.extractKey, y = f.outbound, b = f.autoIncrement && m.filter(function(v) {
            return v.compound && v.keyPath.includes(f.keyPath);
          }), x = u(u({}, s), { mutate: function(v) {
            function _(Y) {
              return Y = "idb://".concat(t, "/").concat(i, "/").concat(Y), D[Y] || (D[Y] = new Ye());
            }
            var E, T, S, k = v.trans, D = v.mutatedParts || (v.mutatedParts = {}), I = _(""), $ = _(":dels"), W = v.type, X = v.type === "deleteRange" ? [v.range] : v.type === "delete" ? [v.keys] : v.values.length < 50 ? [ro(f, v).filter(function(Y) {
              return Y;
            }), v.values] : [], U = X[0], H = X[1], X = v.trans._cache;
            return g(U) ? (I.addKeys(U), (X = W === "delete" || U.length === H.length ? Qo(U, X) : null) || $.addKeys(U), (X || H) && (E = _, T = X, S = H, l.indexes.forEach(function(Y) {
              var Q = E(Y.name || "");
              function ue(se) {
                return se != null ? Y.extractKey(se) : null;
              }
              function ve(se) {
                return Y.multiEntry && g(se) ? se.forEach(function(De) {
                  return Q.addKey(De);
                }) : Q.addKey(se);
              }
              (T || S).forEach(function(se, Xe) {
                var ie = T && ue(T[Xe]), Xe = S && ue(S[Xe]);
                he(ie, Xe) !== 0 && (ie != null && ve(ie), Xe != null && ve(Xe));
              });
            }))) : U ? (H = { from: (H = U.lower) !== null && H !== void 0 ? H : e.MIN_KEY, to: (H = U.upper) !== null && H !== void 0 ? H : e.MAX_KEY }, $.add(H), I.add(H)) : (I.add(o), $.add(o), l.indexes.forEach(function(Y) {
              return _(Y.name).add(o);
            })), s.mutate(v).then(function(Y) {
              return !U || v.type !== "add" && v.type !== "put" || (I.addKeys(Y.results), b && b.forEach(function(Q) {
                for (var ue = v.values.map(function(ie) {
                  return Q.extractKey(ie);
                }), ve = Q.keyPath.findIndex(function(ie) {
                  return ie === f.keyPath;
                }), se = 0, De = Y.results.length; se < De; ++se) ue[se][ve] = Y.results[se];
                _(Q.name).addKeys(ue);
              })), k.mutatedParts = sr(k.mutatedParts || {}, D), Y;
            });
          } }), m = function(_) {
            var E = _.query, _ = E.index, E = E.range;
            return [_, new Ye((_ = E.lower) !== null && _ !== void 0 ? _ : e.MIN_KEY, (E = E.upper) !== null && E !== void 0 ? E : e.MAX_KEY)];
          }, C = { get: function(v) {
            return [f, new Ye(v.key)];
          }, getMany: function(v) {
            return [f, new Ye().addKeys(v.keys)];
          }, count: m, query: m, openCursor: m };
          return p(C).forEach(function(v) {
            x[v] = function(_) {
              var E = Z.subscr, T = !!E, S = Jo(Z, s) && Zo(v, _) ? _.obsSet = {} : E;
              if (T) {
                var k = function(H) {
                  return H = "idb://".concat(t, "/").concat(i, "/").concat(H), S[H] || (S[H] = new Ye());
                }, D = k(""), I = k(":dels"), E = C[v](_), T = E[0], E = E[1];
                if ((v === "query" && T.isPrimaryKey && !_.values ? I : k(T.name || "")).add(E), !T.isPrimaryKey) {
                  if (v !== "count") {
                    var $ = v === "query" && y && _.values && s.query(u(u({}, _), { values: !1 }));
                    return s[v].apply(this, arguments).then(function(H) {
                      if (v === "query") {
                        if (y && _.values) return $.then(function(ue) {
                          return ue = ue.result, D.addKeys(ue), H;
                        });
                        var X = _.values ? H.result.map(h) : H.result;
                        (_.values ? D : I).addKeys(X);
                      } else if (v === "openCursor") {
                        var Y = H, Q = _.values;
                        return Y && Object.create(Y, { key: { get: function() {
                          return I.addKey(Y.primaryKey), Y.key;
                        } }, primaryKey: { get: function() {
                          var ue = Y.primaryKey;
                          return I.addKey(ue), ue;
                        } }, value: { get: function() {
                          return Q && D.addKey(Y.primaryKey), Y.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  I.add(o);
                }
              }
              return s[v].apply(this, arguments);
            };
          }), x;
        } });
      } };
      function ei(e, t, o) {
        if (o.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var i = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return o.numFailures === i ? null : (t = u({}, t), g(t.keys) && (t.keys = t.keys.filter(function(s, l) {
          return !(l in o.failures);
        })), "values" in t && g(t.values) && (t.values = t.values.filter(function(s, l) {
          return !(l in o.failures);
        })), t);
      }
      function oo(e, t) {
        return o = e, ((i = t).lower === void 0 || (i.lowerOpen ? 0 < he(o, i.lower) : 0 <= he(o, i.lower))) && (e = e, (t = t).upper === void 0 || (t.upperOpen ? he(e, t.upper) < 0 : he(e, t.upper) <= 0));
        var o, i;
      }
      function ti(e, t, C, i, s, l) {
        if (!C || C.length === 0) return e;
        var f = t.query.index, h = f.multiEntry, y = t.query.range, b = i.schema.primaryKey.extractKey, x = f.extractKey, m = (f.lowLevelIndex || f).extractKey, C = C.reduce(function(v, _) {
          var E = v, T = [];
          if (_.type === "add" || _.type === "put") for (var S = new Ye(), k = _.values.length - 1; 0 <= k; --k) {
            var D, I = _.values[k], $ = b(I);
            S.hasKey($) || (D = x(I), (h && g(D) ? D.some(function(Y) {
              return oo(Y, y);
            }) : oo(D, y)) && (S.addKey($), T.push(I)));
          }
          switch (_.type) {
            case "add":
              var W = new Ye().addKeys(t.values ? v.map(function(Q) {
                return b(Q);
              }) : v), E = v.concat(t.values ? T.filter(function(Q) {
                return Q = b(Q), !W.hasKey(Q) && (W.addKey(Q), !0);
              }) : T.map(function(Q) {
                return b(Q);
              }).filter(function(Q) {
                return !W.hasKey(Q) && (W.addKey(Q), !0);
              }));
              break;
            case "put":
              var U = new Ye().addKeys(_.values.map(function(Q) {
                return b(Q);
              }));
              E = v.filter(function(Q) {
                return !U.hasKey(t.values ? b(Q) : Q);
              }).concat(t.values ? T : T.map(function(Q) {
                return b(Q);
              }));
              break;
            case "delete":
              var H = new Ye().addKeys(_.keys);
              E = v.filter(function(Q) {
                return !H.hasKey(t.values ? b(Q) : Q);
              });
              break;
            case "deleteRange":
              var X = _.range;
              E = v.filter(function(Q) {
                return !oo(b(Q), X);
              });
          }
          return E;
        }, e);
        return C === e ? e : (C.sort(function(v, _) {
          return he(m(v), m(_)) || he(b(v), b(_));
        }), t.limit && t.limit < 1 / 0 && (C.length > t.limit ? C.length = t.limit : e.length === t.limit && C.length < t.limit && (s.dirty = !0)), l ? Object.freeze(C) : C);
      }
      function ni(e, t) {
        return he(e.lower, t.lower) === 0 && he(e.upper, t.upper) === 0 && !!e.lowerOpen == !!t.lowerOpen && !!e.upperOpen == !!t.upperOpen;
      }
      function Cs(e, t) {
        return function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = he(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, t.lower, e.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = he(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, t.upper, e.upperOpen, t.upperOpen);
      }
      function Ss(e, t, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var s, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (s = e, l = t, setTimeout(function() {
            s.subscribers.size === 0 && Ie(l, s);
          }, 3e3));
        });
      }
      var Ns = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var t = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, s) {
          var l, f, h = e.transaction(o, i, s);
          return i === "readwrite" && (f = (l = new AbortController()).signal, s = function(y) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var b = /* @__PURE__ */ new Set(), x = 0, m = o; x < m.length; x++) {
                  var C = m[x], v = Zt["idb://".concat(t, "/").concat(C)];
                  if (v) {
                    var _ = e.table(C), E = v.optimisticOps.filter(function(Q) {
                      return Q.trans === h;
                    });
                    if (h._explicit && y && h.mutatedParts) for (var T = 0, S = Object.values(v.queries.query); T < S.length; T++) for (var k = 0, D = (W = S[T]).slice(); k < D.length; k++) Qr((U = D[k]).obsSet, h.mutatedParts) && (Ie(W, U), U.subscribers.forEach(function(Q) {
                      return b.add(Q);
                    }));
                    else if (0 < E.length) {
                      v.optimisticOps = v.optimisticOps.filter(function(Q) {
                        return Q.trans !== h;
                      });
                      for (var I = 0, $ = Object.values(v.queries.query); I < $.length; I++) for (var W, U, H, X = 0, Y = (W = $[I]).slice(); X < Y.length; X++) (U = Y[X]).res != null && h.mutatedParts && (y && !U.dirty ? (H = Object.isFrozen(U.res), H = ti(U.res, U.req, E, _, U, H), U.dirty ? (Ie(W, U), U.subscribers.forEach(function(Q) {
                        return b.add(Q);
                      })) : H !== U.res && (U.res = H, U.promise = z.resolve({ result: H }))) : (U.dirty && Ie(W, U), U.subscribers.forEach(function(Q) {
                        return b.add(Q);
                      })));
                    }
                  }
                }
                b.forEach(function(Q) {
                  return Q();
                });
              }
            };
          }, h.addEventListener("abort", s(!1), { signal: f }), h.addEventListener("error", s(!1), { signal: f }), h.addEventListener("complete", s(!0), { signal: f })), h;
        }, table: function(o) {
          var i = e.table(o), s = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var f = Z.trans;
            if (s.outbound || f.db._options.cache === "disabled" || f.explicit || f.idbtrans.mode !== "readwrite") return i.mutate(l);
            var h = Zt["idb://".concat(t, "/").concat(o)];
            return h ? (f = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || ro(s, l).some(function(y) {
              return y == null;
            })) ? (h.optimisticOps.push(l), l.mutatedParts && ar(l.mutatedParts), f.then(function(y) {
              0 < y.numFailures && (Ie(h.optimisticOps, l), (y = ei(0, l, y)) && h.optimisticOps.push(y), l.mutatedParts && ar(l.mutatedParts));
            }), f.catch(function() {
              Ie(h.optimisticOps, l), l.mutatedParts && ar(l.mutatedParts);
            })) : f.then(function(y) {
              var b = ei(0, u(u({}, l), { values: l.values.map(function(x, m) {
                var C;
                return y.failures[m] ? x : (x = (C = s.keyPath) !== null && C !== void 0 && C.includes(".") ? nt(x) : u({}, x), ye(x, s.keyPath, y.results[m]), x);
              }) }), y);
              h.optimisticOps.push(b), queueMicrotask(function() {
                return l.mutatedParts && ar(l.mutatedParts);
              });
            }), f) : i.mutate(l);
          }, query: function(l) {
            if (!Jo(Z, i) || !Zo("query", l)) return i.query(l);
            var f = ((b = Z.trans) === null || b === void 0 ? void 0 : b.db._options.cache) === "immutable", m = Z, h = m.requery, y = m.signal, b = function(_, E, T, S) {
              var k = Zt["idb://".concat(_, "/").concat(E)];
              if (!k) return [];
              if (!(E = k.queries[T])) return [null, !1, k, null];
              var D = E[(S.query ? S.query.index.name : null) || ""];
              if (!D) return [null, !1, k, null];
              switch (T) {
                case "query":
                  var I = D.find(function($) {
                    return $.req.limit === S.limit && $.req.values === S.values && ni($.req.query.range, S.query.range);
                  });
                  return I ? [I, !0, k, D] : [D.find(function($) {
                    return ("limit" in $.req ? $.req.limit : 1 / 0) >= S.limit && (!S.values || $.req.values) && Cs($.req.query.range, S.query.range);
                  }), !1, k, D];
                case "count":
                  return I = D.find(function($) {
                    return ni($.req.query.range, S.query.range);
                  }), [I, !!I, k, D];
              }
            }(t, o, "query", l), x = b[0], m = b[1], C = b[2], v = b[3];
            return x && m ? x.obsSet = l.obsSet : (m = i.query(l).then(function(_) {
              var E = _.result;
              if (x && (x.res = E), f) {
                for (var T = 0, S = E.length; T < S; ++T) Object.freeze(E[T]);
                Object.freeze(E);
              } else _.result = nt(E);
              return _;
            }).catch(function(_) {
              return v && x && Ie(v, x), Promise.reject(_);
            }), x = { obsSet: l.obsSet, promise: m, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, v ? v.push(x) : (v = [x], (C = C || (Zt["idb://".concat(t, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = v)), Ss(x, v, h, y), x.promise.then(function(_) {
              return { result: ti(_.result, l, C?.optimisticOps, i, x, f) };
            });
          } });
        } });
      } };
      function lr(e, t) {
        return new Proxy(e, { get: function(o, i, s) {
          return i === "db" ? t : Reflect.get(o, i, s);
        } });
      }
      var Nt = (Le.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new F.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new F.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var t = this._versions, o = t.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), t.push(o), t.sort(vs), o.stores({}), this._state.autoSchema = !1, o);
      }, Le.prototype._whenReady = function(e) {
        var t = this;
        return this.idbdb && (this._state.openComplete || Z.letThrough || this._vip) ? e() : new z(function(o, i) {
          if (t._state.openComplete) return i(new F.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void i(new F.DatabaseClosed());
            t.open().catch(N);
          }
          t._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, Le.prototype.use = function(e) {
        var t = e.stack, o = e.create, i = e.level, s = e.name;
        return s && this.unuse({ stack: t, name: s }), e = this._middlewares[t] || (this._middlewares[t] = []), e.push({ stack: t, create: o, level: i ?? 10, name: s }), e.sort(function(l, f) {
          return l.level - f.level;
        }), this;
      }, Le.prototype.unuse = function(e) {
        var t = e.stack, o = e.name, i = e.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(s) {
          return i ? s.create !== i : !!o && s.name !== o;
        })), this;
      }, Le.prototype.open = function() {
        var e = this;
        return zt(et, function() {
          return ws(e);
        });
      }, Le.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, t = fn.indexOf(this);
        if (0 <= t && fn.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new z(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new z(function(o, i) {
          e.cancelOpen = i;
        }));
      }, Le.prototype.close = function(o) {
        var t = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        t ? (o.isBeingOpened && o.cancelOpen(new F.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new F.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, Le.prototype.delete = function(e) {
        var t = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new z(function(s, l) {
          function f() {
            t.close(e);
            var h = t._deps.indexedDB.deleteDatabase(t.name);
            h.onsuccess = ke(function() {
              var y, b, x;
              y = t._deps, b = t.name, x = y.indexedDB, y = y.IDBKeyRange, Yr(x) || b === Yn || Gr(x, y).delete(b).catch(N), s();
            }), h.onerror = xt(l), h.onblocked = t._fireOnBlocked;
          }
          if (o) throw new F.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(f) : f();
        });
      }, Le.prototype.backendDB = function() {
        return this.idbdb;
      }, Le.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Le.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, Le.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Le.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Le.prototype, "tables", { get: function() {
        var e = this;
        return p(this._allTables).map(function(t) {
          return e._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), Le.prototype.transaction = function() {
        var e = (function(t, o, i) {
          var s = arguments.length;
          if (s < 2) throw new F.InvalidArgument("Too few arguments");
          for (var l = new Array(s - 1); --s; ) l[s - 1] = arguments[s];
          return i = l.pop(), [t, We(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, Le.prototype._transaction = function(e, t, o) {
        var i = this, s = Z.trans;
        s && s.db === this && e.indexOf("!") === -1 || (s = null);
        var l, f, h = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (f = t.map(function(b) {
            if (b = b instanceof i.Table ? b.name : b, typeof b != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return b;
          }), e == "r" || e === Lr) l = Lr;
          else {
            if (e != "rw" && e != Kr) throw new F.InvalidArgument("Invalid transaction mode: " + e);
            l = Kr;
          }
          if (s) {
            if (s.mode === Lr && l === Kr) {
              if (!h) throw new F.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              s = null;
            }
            s && f.forEach(function(b) {
              if (s && s.storeNames.indexOf(b) === -1) {
                if (!h) throw new F.SubTransaction("Table " + b + " not included in parent transaction.");
                s = null;
              }
            }), h && s && !s.active && (s = null);
          }
        } catch (b) {
          return s ? s._promise(null, function(x, m) {
            m(b);
          }) : je(b);
        }
        var y = (function b(x, m, C, v, _) {
          return z.resolve().then(function() {
            var E = Z.transless || Z, T = x._createTransaction(m, C, x._dbSchema, v);
            if (T.explicit = !0, E = { trans: T, transless: E }, v) T.idbtrans = v.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, x._state.PR1398_maxLoop = 3;
            } catch (D) {
              return D.name === A.InvalidState && x.isOpen() && 0 < --x._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), x.close({ disableAutoOpen: !1 }), x.open().then(function() {
                return b(x, m, C, null, _);
              })) : je(D);
            }
            var S, k = ht(_);
            return k && cn(), E = z.follow(function() {
              var D;
              (S = _.call(T, T)) && (k ? (D = Lt.bind(null, null), S.then(D, D)) : typeof S.next == "function" && typeof S.throw == "function" && (S = to(S)));
            }, E), (S && typeof S.then == "function" ? z.resolve(S).then(function(D) {
              return T.active ? D : je(new F.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : E.then(function() {
              return S;
            })).then(function(D) {
              return v && T._resolve(), T._completion.then(function() {
                return D;
              });
            }).catch(function(D) {
              return T._reject(D), je(D);
            });
          });
        }).bind(null, this, l, f, s, o);
        return s ? s._promise(l, y, "lock") : Z.trans ? zt(Z.transless, function() {
          return i._whenReady(y);
        }) : this._whenReady(y);
      }, Le.prototype.table = function(e) {
        if (!R(this._allTables, e)) throw new F.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, Le);
      function Le(e, t) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = Le.dependencies;
        this._options = t = u({ addons: Le.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, i = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var s, l, f, h, y, b = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: N, dbReadyPromise: null, cancelOpen: N, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        b.dbReadyPromise = new z(function(m) {
          b.dbReadyResolve = m;
        }), b.openCanceller = new z(function(m, C) {
          b.cancelOpen = C;
        }), this._state = b, this.name = e, this.on = _n(this, "populate", "blocked", "versionchange", "close", { ready: [oe, N] }), this.once = function(m, C) {
          var v = function() {
            for (var _ = [], E = 0; E < arguments.length; E++) _[E] = arguments[E];
            o.on(m).unsubscribe(v), C.apply(o, _);
          };
          return o.on(m, v);
        }, this.on.ready.subscribe = Ee(this.on.ready.subscribe, function(m) {
          return function(C, v) {
            Le.vip(function() {
              var _, E = o._state;
              E.openComplete ? (E.dbOpenError || z.resolve().then(C), v && m(C)) : E.onReadyBeingFired ? (E.onReadyBeingFired.push(C), v && m(C)) : (m(C), _ = o, v || m(function T() {
                _.on.ready.unsubscribe(C), _.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (s = this, wn(cs.prototype, function(S, T) {
          this.db = s;
          var v = Do, _ = null;
          if (T) try {
            v = T();
          } catch (k) {
            _ = k;
          }
          var E = S._ctx, T = E.table, S = T.hook.reading.fire;
          this._ctx = { table: T, index: E.index, isPrimKey: !E.index || T.schema.primKey.keyPath && E.index === T.schema.primKey.name, range: v, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: _, or: E.or, valueMapper: S !== M ? S : null };
        })), this.Table = (l = this, wn(Lo.prototype, function(m, C, v) {
          this.db = l, this._tx = v, this.name = m, this.schema = C, this.hook = l._allTables[m] ? l._allTables[m].hook : _n(null, { creating: [re, N], reading: [J, M], updating: [ae, N], deleting: [te, N] });
        })), this.Transaction = (f = this, wn(ps.prototype, function(m, C, v, _, E) {
          var T = this;
          m !== "readonly" && C.forEach(function(S) {
            S = (S = v[S]) === null || S === void 0 ? void 0 : S.yProps, S && (C = C.concat(S.map(function(k) {
              return k.updatesTable;
            })));
          }), this.db = f, this.mode = m, this.storeNames = C, this.schema = v, this.chromeTransactionDurability = _, this.idbtrans = null, this.on = _n(this, "complete", "error", "abort"), this.parent = E || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new z(function(S, k) {
            T._resolve = S, T._reject = k;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(S) {
            var k = T.active;
            return T.active = !1, T.on.error.fire(S), T.parent ? T.parent._reject(S) : k && T.idbtrans && T.idbtrans.abort(), je(S);
          });
        })), this.Version = (h = this, wn(_s.prototype, function(m) {
          this.db = h, this._cfg = { version: m, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (y = this, wn($o.prototype, function(m, C, v) {
          if (this.db = y, this._ctx = { table: m, index: C === ":id" ? null : C, or: v }, this._cmp = this._ascending = he, this._descending = function(_, E) {
            return he(E, _);
          }, this._max = function(_, E) {
            return 0 < he(_, E) ? _ : E;
          }, this._min = function(_, E) {
            return he(_, E) < 0 ? _ : E;
          }, this._IDBKeyRange = y._deps.IDBKeyRange, !this._IDBKeyRange) throw new F.MissingAPI();
        })), this.on("versionchange", function(m) {
          0 < m.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(m) {
          !m.newVersion || m.newVersion < m.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(m.oldVersion / 10));
        }), this._maxKey = On(t.IDBKeyRange), this._createTransaction = function(m, C, v, _) {
          return new o.Transaction(m, C, v, o._options.chromeTransactionDurability, _);
        }, this._fireOnBlocked = function(m) {
          o.on("blocked").fire(m), fn.filter(function(C) {
            return C.name === o.name && C !== o && !C._state.vcFired;
          }).map(function(C) {
            return C.on("versionchange").fire(m);
          });
        }, this.use(Es), this.use(Ns), this.use(Os), this.use(xs), this.use(Ts);
        var x = new Proxy(this, { get: function(m, C, v) {
          if (C === "_vip") return !0;
          if (C === "table") return function(E) {
            return lr(o.table(E), x);
          };
          var _ = Reflect.get(m, C, v);
          return _ instanceof Lo ? lr(_, x) : C === "tables" ? _.map(function(E) {
            return lr(E, x);
          }) : C === "_createTransaction" ? function() {
            return lr(_.apply(this, arguments), x);
          } : _;
        } });
        this.vip = x, i.forEach(function(m) {
          return m(o);
        });
      }
      var cr, pt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", As = (io.prototype.subscribe = function(e, t, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: o });
      }, io.prototype[pt] = function() {
        return this;
      }, io);
      function io(e) {
        this._subscribe = e;
      }
      try {
        cr = { indexedDB: d.indexedDB || d.mozIndexedDB || d.webkitIndexedDB || d.msIndexedDB, IDBKeyRange: d.IDBKeyRange || d.webkitIDBKeyRange };
      } catch {
        cr = { indexedDB: null, IDBKeyRange: null };
      }
      function ri(e) {
        var t, o = !1, i = new As(function(s) {
          var l = ht(e), f, h = !1, y = {}, b = {}, x = { get closed() {
            return h;
          }, unsubscribe: function() {
            h || (h = !0, f && f.abort(), m && Mt.storagemutated.unsubscribe(v));
          } };
          s.start && s.start(x);
          var m = !1, C = function() {
            return jr(_);
          }, v = function(E) {
            sr(y, E), Qr(b, y) && C();
          }, _ = function() {
            var E, T, S;
            !h && cr.indexedDB && (y = {}, E = {}, f && f.abort(), f = new AbortController(), S = function(k) {
              var D = un();
              try {
                l && cn();
                var I = jt(e, k);
                return I = l ? I.finally(Lt) : I;
              } finally {
                D && ln();
              }
            }(T = { subscr: E, signal: f.signal, requery: C, querier: e, trans: null }), Promise.resolve(S).then(function(k) {
              o = !0, t = k, h || T.signal.aborted || (y = {}, function(D) {
                for (var I in D) if (R(D, I)) return;
                return 1;
              }(b = E) || m || (Mt(En, v), m = !0), jr(function() {
                return !h && s.next && s.next(k);
              }));
            }, function(k) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(k?.name) || h || jr(function() {
                h || s.error && s.error(k);
              });
            }));
          };
          return setTimeout(C, 0), x;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return t;
        }, i;
      }
      var en = Nt;
      function so(e) {
        var t = Bt;
        try {
          Bt = !0, Mt.storagemutated.fire(e), eo(e, !0);
        } finally {
          Bt = t;
        }
      }
      j(en, u(u({}, $e), { delete: function(e) {
        return new en(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new en(e, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return t = en.dependencies, o = t.indexedDB, t = t.IDBKeyRange, (Yr(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(s) {
              return s.name;
            }).filter(function(s) {
              return s !== Yn;
            });
          }) : Gr(o, t).toCollection().primaryKeys()).then(e);
        } catch {
          return je(new F.MissingAPI());
        }
        var t, o;
      }, defineClass: function() {
        return function(e) {
          O(this, e);
        };
      }, ignoreTransaction: function(e) {
        return Z.trans ? zt(Z.transless, e) : e();
      }, vip: Xr, async: function(e) {
        return function() {
          try {
            var t = to(e.apply(this, arguments));
            return t && typeof t.then == "function" ? t : z.resolve(t);
          } catch (o) {
            return je(o);
          }
        };
      }, spawn: function(e, t, o) {
        try {
          var i = to(e.apply(o, t || []));
          return i && typeof i.then == "function" ? i : z.resolve(i);
        } catch (s) {
          return je(s);
        }
      }, currentTransaction: { get: function() {
        return Z.trans || null;
      } }, waitFor: function(e, t) {
        return t = z.resolve(typeof e == "function" ? en.ignoreTransaction(e) : e).timeout(t || 6e4), Z.trans ? Z.trans.waitFor(t) : t;
      }, Promise: z, debug: { get: function() {
        return ne;
      }, set: function(e) {
        we(e);
      } }, derive: fe, extend: O, props: j, override: Ee, Events: _n, on: Mt, liveQuery: ri, extendObservabilitySet: sr, getByKeyPath: Be, setByKeyPath: ye, delByKeyPath: function(e, t) {
        typeof t == "string" ? ye(e, t, void 0) : "length" in t && [].map.call(t, function(o) {
          ye(e, o, void 0);
        });
      }, shallowClone: Ce, deepClone: nt, getObjectDiff: no, cmp: he, asap: Ae, minKey: -1 / 0, addons: [], connections: fn, errnames: A, dependencies: cr, cache: Zt, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, t, o) {
        return e + t / Math.pow(10, 2 * o);
      }) })), en.maxKey = On(en.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Mt(En, function(e) {
        Bt || (e = new CustomEvent(Br, { detail: e }), Bt = !0, dispatchEvent(e), Bt = !1);
      }), addEventListener(Br, function(e) {
        e = e.detail, Bt || so(e);
      }));
      var vn, Bt = !1, oi = function() {
      };
      return typeof BroadcastChannel < "u" && ((oi = function() {
        (vn = new BroadcastChannel(Br)).onmessage = function(e) {
          return e.data && so(e.data);
        };
      })(), typeof vn.unref == "function" && vn.unref(), Mt(En, function(e) {
        Bt || vn.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Nt.disableBfCache && e.persisted) {
          ne && console.debug("Dexie: handling persisted pagehide"), vn?.close();
          for (var t = 0, o = fn; t < o.length; t++) o[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Nt.disableBfCache && e.persisted && (ne && console.debug("Dexie: handling persisted pageshow"), oi(), so({ all: new Ye(-1 / 0, [[]]) }));
      })), z.rejectionMapper = function(e, t) {
        return !e || e instanceof Dt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !V[e.name] ? e : (t = new V[e.name](t || e.message, e), "stack" in e && G(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, we(ne), u(Nt, Object.freeze({ __proto__: null, Dexie: Nt, liveQuery: ri, Entity: Io, cmp: he, PropModification: xn, replacePrefix: function(e, t) {
        return new xn({ replacePrefix: [e, t] });
      }, add: function(e) {
        return new xn({ add: e });
      }, remove: function(e) {
        return new xn({ remove: e });
      }, default: Nt, RangeSet: Ye, mergeRanges: Nn, rangesOverlap: Go }), { default: Nt }), Nt;
    });
  }(Ri)), Ri.exports;
}
var Sd = Cd();
const na = /* @__PURE__ */ Ed(Sd), vu = Symbol.for("Dexie"), Vi = globalThis[vu] || (globalThis[vu] = na);
if (na.semVer !== Vi.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${na.semVer} and ${Vi.semVer}`);
const {
  liveQuery: cm,
  mergeRanges: fm,
  rangesOverlap: dm,
  RangeSet: pm,
  cmp: hm,
  Entity: mm,
  PropModification: ym,
  replacePrefix: vm,
  add: gm,
  remove: bm,
  DexieYProvider: _m
} = Vi;
var At = /* @__PURE__ */ ((n) => (n.GOOSE = "GOOSE", n.SMV = "SMV", n.REPORT = "Report", n.INTERNAL = "Internal", n.WIRED = "Wired", n.CONTROL = "Control", n))(At || {});
const Hi = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Internal: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: []
};
var Nd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ad(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Pd(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var r = n.default;
  if (typeof r == "function") {
    var a = function u() {
      var c = !1;
      try {
        c = this instanceof u;
      } catch {
      }
      return c ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    a.prototype = r.prototype;
  } else a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(n).forEach(function(u) {
    var c = Object.getOwnPropertyDescriptor(n, u);
    Object.defineProperty(a, u, c.get ? c : {
      enumerable: !0,
      get: function() {
        return n[u];
      }
    });
  }), a;
}
var gu = {};
const kd = {}, Dd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: kd
}, Symbol.toStringTag, { value: "Module" })), bu = /* @__PURE__ */ Pd(Dd);
var _u;
function Id() {
  return _u || (_u = 1, function(n) {
    (function(r) {
      r.parser = function(A, w) {
        return new u(A, w);
      }, r.SAXParser = u, r.SAXStream = P, r.createStream = K, r.MAX_BUFFER_LENGTH = 64 * 1024;
      var a = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      r.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function u(A, w) {
        if (!(this instanceof u))
          return new u(A, w);
        var F = this;
        d(F), F.q = F.c = "", F.bufferCheckPosition = r.MAX_BUFFER_LENGTH, F.opt = w || {}, F.opt.lowercase = F.opt.lowercase || F.opt.lowercasetags, F.looseCase = F.opt.lowercase ? "toLowerCase" : "toUpperCase", F.tags = [], F.closed = F.closedRoot = F.sawRoot = !1, F.tag = F.error = null, F.strict = !!A, F.noscript = !!(A || F.opt.noscript), F.state = B.BEGIN, F.strictEntities = F.opt.strictEntities, F.ENTITIES = F.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), F.attribList = [], F.opt.xmlns && (F.ns = Object.create(fe)), F.opt.unquotedAttributeValues === void 0 && (F.opt.unquotedAttributeValues = !A), F.trackPosition = F.opt.position !== !1, F.trackPosition && (F.position = F.line = F.column = 0), st(F, "onready");
      }
      Object.create || (Object.create = function(A) {
        function w() {
        }
        w.prototype = A;
        var F = new w();
        return F;
      }), Object.keys || (Object.keys = function(A) {
        var w = [];
        for (var F in A) A.hasOwnProperty(F) && w.push(F);
        return w;
      });
      function c(A) {
        for (var w = Math.max(r.MAX_BUFFER_LENGTH, 10), F = 0, V = 0, $e = a.length; V < $e; V++) {
          var N = A[a[V]].length;
          if (N > w)
            switch (a[V]) {
              case "textNode":
                nt(A);
                break;
              case "cdata":
                Re(A, "oncdata", A.cdata), A.cdata = "";
                break;
              case "script":
                Re(A, "onscript", A.script), A.script = "";
                break;
              default:
                Pt(A, "Max buffer length exceeded: " + a[V]);
            }
          F = Math.max(F, N);
        }
        var M = r.MAX_BUFFER_LENGTH - F;
        A.bufferCheckPosition = M + A.position;
      }
      function d(A) {
        for (var w = 0, F = a.length; w < F; w++)
          A[a[w]] = "";
      }
      function p(A) {
        nt(A), A.cdata !== "" && (Re(A, "oncdata", A.cdata), A.cdata = ""), A.script !== "" && (Re(A, "onscript", A.script), A.script = "");
      }
      u.prototype = {
        end: function() {
          Ze(this);
        },
        write: wt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          p(this);
        }
      };
      var g;
      try {
        g = bu.Stream;
      } catch {
        g = function() {
        };
      }
      g || (g = function() {
      });
      var O = r.EVENTS.filter(function(A) {
        return A !== "error" && A !== "end";
      });
      function K(A, w) {
        return new P(A, w);
      }
      function P(A, w) {
        if (!(this instanceof P))
          return new P(A, w);
        g.apply(this), this._parser = new u(A, w), this.writable = !0, this.readable = !0;
        var F = this;
        this._parser.onend = function() {
          F.emit("end");
        }, this._parser.onerror = function(V) {
          F.emit("error", V), F._parser.error = null;
        }, this._decoder = null, O.forEach(function(V) {
          Object.defineProperty(F, "on" + V, {
            get: function() {
              return F._parser["on" + V];
            },
            set: function($e) {
              if (!$e)
                return F.removeAllListeners(V), F._parser["on" + V] = $e, $e;
              F.on(V, $e);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      P.prototype = Object.create(g.prototype, {
        constructor: {
          value: P
        }
      }), P.prototype.write = function(A) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(A)) {
          if (!this._decoder) {
            var w = bu.StringDecoder;
            this._decoder = new w("utf8");
          }
          A = this._decoder.write(A);
        }
        return this._parser.write(A.toString()), this.emit("data", A), !0;
      }, P.prototype.end = function(A) {
        return A && A.length && this.write(A), this._parser.end(), !0;
      }, P.prototype.on = function(A, w) {
        var F = this;
        return !F._parser["on" + A] && O.indexOf(A) !== -1 && (F._parser["on" + A] = function() {
          var V = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          V.splice(0, 0, A), F.emit.apply(F, V);
        }), g.prototype.on.call(F, A, w);
      };
      var R = "[CDATA[", j = "DOCTYPE", L = "http://www.w3.org/XML/1998/namespace", G = "http://www.w3.org/2000/xmlns/", fe = { xml: L, xmlns: G }, qe = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, pe = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, me = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Ee = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function de(A) {
        return A === " " || A === `
` || A === "\r" || A === "	";
      }
      function Ae(A) {
        return A === '"' || A === "'";
      }
      function Be(A) {
        return A === ">" || de(A);
      }
      function ye(A, w) {
        return A.test(w);
      }
      function Ce(A, w) {
        return !ye(A, w);
      }
      var B = 0;
      r.STATE = {
        BEGIN: B++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: B++,
        // leading whitespace
        TEXT: B++,
        // general stuff
        TEXT_ENTITY: B++,
        // &amp and such.
        OPEN_WAKA: B++,
        // <
        SGML_DECL: B++,
        // <!BLARG
        SGML_DECL_QUOTED: B++,
        // <!BLARG foo "bar
        DOCTYPE: B++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: B++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: B++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: B++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: B++,
        // <!-
        COMMENT: B++,
        // <!--
        COMMENT_ENDING: B++,
        // <!-- blah -
        COMMENT_ENDED: B++,
        // <!-- blah --
        CDATA: B++,
        // <![CDATA[ something
        CDATA_ENDING: B++,
        // ]
        CDATA_ENDING_2: B++,
        // ]]
        PROC_INST: B++,
        // <?hi
        PROC_INST_BODY: B++,
        // <?hi there
        PROC_INST_ENDING: B++,
        // <?hi "there" ?
        OPEN_TAG: B++,
        // <strong
        OPEN_TAG_SLASH: B++,
        // <strong /
        ATTRIB: B++,
        // <a
        ATTRIB_NAME: B++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: B++,
        // <a foo _
        ATTRIB_VALUE: B++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: B++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: B++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: B++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: B++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: B++,
        // <foo bar=&quot
        CLOSE_TAG: B++,
        // </a
        CLOSE_TAG_SAW_WHITE: B++,
        // </a   >
        SCRIPT: B++,
        // <script> ...
        SCRIPT_ENDING: B++
        // <script> ... <
      }, r.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, r.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(r.ENTITIES).forEach(function(A) {
        var w = r.ENTITIES[A], F = typeof w == "number" ? String.fromCharCode(w) : w;
        r.ENTITIES[A] = F;
      });
      for (var We in r.STATE)
        r.STATE[r.STATE[We]] = We;
      B = r.STATE;
      function st(A, w, F) {
        A[w] && A[w](F);
      }
      function Re(A, w, F) {
        A.textNode && nt(A), st(A, w, F);
      }
      function nt(A) {
        A.textNode = yn(A.opt, A.textNode), A.textNode && st(A, "ontext", A.textNode), A.textNode = "";
      }
      function yn(A, w) {
        return A.trim && (w = w.trim()), A.normalize && (w = w.replace(/\s+/g, " ")), w;
      }
      function Pt(A, w) {
        return nt(A), A.trackPosition && (w += `
Line: ` + A.line + `
Column: ` + A.column + `
Char: ` + A.c), w = new Error(w), A.error = w, st(A, "onerror", w), A;
      }
      function Ze(A) {
        return A.sawRoot && !A.closedRoot && ge(A, "Unclosed root tag"), A.state !== B.BEGIN && A.state !== B.BEGIN_WHITESPACE && A.state !== B.TEXT && Pt(A, "Unexpected end"), nt(A), A.c = "", A.closed = !0, st(A, "onend"), u.call(A, A.strict, A.opt), A;
      }
      function ge(A, w) {
        if (typeof A != "object" || !(A instanceof u))
          throw new Error("bad call to strictFail");
        A.strict && Pt(A, w);
      }
      function Ie(A) {
        A.strict || (A.tagName = A.tagName[A.looseCase]());
        var w = A.tags[A.tags.length - 1] || A, F = A.tag = { name: A.tagName, attributes: {} };
        A.opt.xmlns && (F.ns = w.ns), A.attribList.length = 0, Re(A, "onopentagstart", F);
      }
      function dt(A, w) {
        var F = A.indexOf(":"), V = F < 0 ? ["", A] : A.split(":"), $e = V[0], N = V[1];
        return w && A === "xmlns" && ($e = "xmlns", N = ""), { prefix: $e, local: N };
      }
      function ot(A) {
        if (A.strict || (A.attribName = A.attribName[A.looseCase]()), A.attribList.indexOf(A.attribName) !== -1 || A.tag.attributes.hasOwnProperty(A.attribName)) {
          A.attribName = A.attribValue = "";
          return;
        }
        if (A.opt.xmlns) {
          var w = dt(A.attribName, !0), F = w.prefix, V = w.local;
          if (F === "xmlns")
            if (V === "xml" && A.attribValue !== L)
              ge(
                A,
                "xml: prefix must be bound to " + L + `
Actual: ` + A.attribValue
              );
            else if (V === "xmlns" && A.attribValue !== G)
              ge(
                A,
                "xmlns: prefix must be bound to " + G + `
Actual: ` + A.attribValue
              );
            else {
              var $e = A.tag, N = A.tags[A.tags.length - 1] || A;
              $e.ns === N.ns && ($e.ns = Object.create(N.ns)), $e.ns[V] = A.attribValue;
            }
          A.attribList.push([A.attribName, A.attribValue]);
        } else
          A.tag.attributes[A.attribName] = A.attribValue, Re(A, "onattribute", {
            name: A.attribName,
            value: A.attribValue
          });
        A.attribName = A.attribValue = "";
      }
      function ht(A, w) {
        if (A.opt.xmlns) {
          var F = A.tag, V = dt(A.tagName);
          F.prefix = V.prefix, F.local = V.local, F.uri = F.ns[V.prefix] || "", F.prefix && !F.uri && (ge(A, "Unbound namespace prefix: " + JSON.stringify(A.tagName)), F.uri = V.prefix);
          var $e = A.tags[A.tags.length - 1] || A;
          F.ns && $e.ns !== F.ns && Object.keys(F.ns).forEach(function(we) {
            Re(A, "onopennamespace", {
              prefix: we,
              uri: F.ns[we]
            });
          });
          for (var N = 0, M = A.attribList.length; N < M; N++) {
            var J = A.attribList[N], ee = J[0], re = J[1], te = dt(ee, !0), ae = te.prefix, le = te.local, oe = ae === "" ? "" : F.ns[ae] || "", ne = {
              name: ee,
              value: re,
              prefix: ae,
              local: le,
              uri: oe
            };
            ae && ae !== "xmlns" && !oe && (ge(A, "Unbound namespace prefix: " + JSON.stringify(ae)), ne.uri = ae), A.tag.attributes[ee] = ne, Re(A, "onattribute", ne);
          }
          A.attribList.length = 0;
        }
        A.tag.isSelfClosing = !!w, A.sawRoot = !0, A.tags.push(A.tag), Re(A, "onopentag", A.tag), w || (!A.noscript && A.tagName.toLowerCase() === "script" ? A.state = B.SCRIPT : A.state = B.TEXT, A.tag = null, A.tagName = ""), A.attribName = A.attribValue = "", A.attribList.length = 0;
      }
      function kt(A) {
        if (!A.tagName) {
          ge(A, "Weird empty close tag."), A.textNode += "</>", A.state = B.TEXT;
          return;
        }
        if (A.script) {
          if (A.tagName !== "script") {
            A.script += "</" + A.tagName + ">", A.tagName = "", A.state = B.SCRIPT;
            return;
          }
          Re(A, "onscript", A.script), A.script = "";
        }
        var w = A.tags.length, F = A.tagName;
        A.strict || (F = F[A.looseCase]());
        for (var V = F; w--; ) {
          var $e = A.tags[w];
          if ($e.name !== V)
            ge(A, "Unexpected close tag");
          else
            break;
        }
        if (w < 0) {
          ge(A, "Unmatched closing tag: " + A.tagName), A.textNode += "</" + A.tagName + ">", A.state = B.TEXT;
          return;
        }
        A.tagName = F;
        for (var N = A.tags.length; N-- > w; ) {
          var M = A.tag = A.tags.pop();
          A.tagName = A.tag.name, Re(A, "onclosetag", A.tagName);
          var J = {};
          for (var ee in M.ns)
            J[ee] = M.ns[ee];
          var re = A.tags[A.tags.length - 1] || A;
          A.opt.xmlns && M.ns !== re.ns && Object.keys(M.ns).forEach(function(te) {
            var ae = M.ns[te];
            Re(A, "onclosenamespace", { prefix: te, uri: ae });
          });
        }
        w === 0 && (A.closedRoot = !0), A.tagName = A.attribValue = A.attribName = "", A.attribList.length = 0, A.state = B.TEXT;
      }
      function Dt(A) {
        var w = A.entity, F = w.toLowerCase(), V, $e = "";
        return A.ENTITIES[w] ? A.ENTITIES[w] : A.ENTITIES[F] ? A.ENTITIES[F] : (w = F, w.charAt(0) === "#" && (w.charAt(1) === "x" ? (w = w.slice(2), V = parseInt(w, 16), $e = V.toString(16)) : (w = w.slice(1), V = parseInt(w, 10), $e = V.toString(10))), w = w.replace(/^0+/, ""), isNaN(V) || $e.toLowerCase() !== w ? (ge(A, "Invalid character entity"), "&" + A.entity + ";") : String.fromCodePoint(V));
      }
      function Rn(A, w) {
        w === "<" ? (A.state = B.OPEN_WAKA, A.startTagPosition = A.position) : de(w) || (ge(A, "Non-whitespace before first tag."), A.textNode = w, A.state = B.TEXT);
      }
      function sn(A, w) {
        var F = "";
        return w < A.length && (F = A.charAt(w)), F;
      }
      function wt(A) {
        var w = this;
        if (this.error)
          throw this.error;
        if (w.closed)
          return Pt(
            w,
            "Cannot write after close. Assign an onready handler."
          );
        if (A === null)
          return Ze(w);
        typeof A == "object" && (A = A.toString());
        for (var F = 0, V = ""; V = sn(A, F++), w.c = V, !!V; )
          switch (w.trackPosition && (w.position++, V === `
` ? (w.line++, w.column = 0) : w.column++), w.state) {
            case B.BEGIN:
              if (w.state = B.BEGIN_WHITESPACE, V === "\uFEFF")
                continue;
              Rn(w, V);
              continue;
            case B.BEGIN_WHITESPACE:
              Rn(w, V);
              continue;
            case B.TEXT:
              if (w.sawRoot && !w.closedRoot) {
                for (var $e = F - 1; V && V !== "<" && V !== "&"; )
                  V = sn(A, F++), V && w.trackPosition && (w.position++, V === `
` ? (w.line++, w.column = 0) : w.column++);
                w.textNode += A.substring($e, F - 1);
              }
              V === "<" && !(w.sawRoot && w.closedRoot && !w.strict) ? (w.state = B.OPEN_WAKA, w.startTagPosition = w.position) : (!de(V) && (!w.sawRoot || w.closedRoot) && ge(w, "Text data outside of root node."), V === "&" ? w.state = B.TEXT_ENTITY : w.textNode += V);
              continue;
            case B.SCRIPT:
              V === "<" ? w.state = B.SCRIPT_ENDING : w.script += V;
              continue;
            case B.SCRIPT_ENDING:
              V === "/" ? w.state = B.CLOSE_TAG : (w.script += "<" + V, w.state = B.SCRIPT);
              continue;
            case B.OPEN_WAKA:
              if (V === "!")
                w.state = B.SGML_DECL, w.sgmlDecl = "";
              else if (!de(V)) if (ye(qe, V))
                w.state = B.OPEN_TAG, w.tagName = V;
              else if (V === "/")
                w.state = B.CLOSE_TAG, w.tagName = "";
              else if (V === "?")
                w.state = B.PROC_INST, w.procInstName = w.procInstBody = "";
              else {
                if (ge(w, "Unencoded <"), w.startTagPosition + 1 < w.position) {
                  var N = w.position - w.startTagPosition;
                  V = new Array(N).join(" ") + V;
                }
                w.textNode += "<" + V, w.state = B.TEXT;
              }
              continue;
            case B.SGML_DECL:
              if (w.sgmlDecl + V === "--") {
                w.state = B.COMMENT, w.comment = "", w.sgmlDecl = "";
                continue;
              }
              w.doctype && w.doctype !== !0 && w.sgmlDecl ? (w.state = B.DOCTYPE_DTD, w.doctype += "<!" + w.sgmlDecl + V, w.sgmlDecl = "") : (w.sgmlDecl + V).toUpperCase() === R ? (Re(w, "onopencdata"), w.state = B.CDATA, w.sgmlDecl = "", w.cdata = "") : (w.sgmlDecl + V).toUpperCase() === j ? (w.state = B.DOCTYPE, (w.doctype || w.sawRoot) && ge(
                w,
                "Inappropriately located doctype declaration"
              ), w.doctype = "", w.sgmlDecl = "") : V === ">" ? (Re(w, "onsgmldeclaration", w.sgmlDecl), w.sgmlDecl = "", w.state = B.TEXT) : (Ae(V) && (w.state = B.SGML_DECL_QUOTED), w.sgmlDecl += V);
              continue;
            case B.SGML_DECL_QUOTED:
              V === w.q && (w.state = B.SGML_DECL, w.q = ""), w.sgmlDecl += V;
              continue;
            case B.DOCTYPE:
              V === ">" ? (w.state = B.TEXT, Re(w, "ondoctype", w.doctype), w.doctype = !0) : (w.doctype += V, V === "[" ? w.state = B.DOCTYPE_DTD : Ae(V) && (w.state = B.DOCTYPE_QUOTED, w.q = V));
              continue;
            case B.DOCTYPE_QUOTED:
              w.doctype += V, V === w.q && (w.q = "", w.state = B.DOCTYPE);
              continue;
            case B.DOCTYPE_DTD:
              V === "]" ? (w.doctype += V, w.state = B.DOCTYPE) : V === "<" ? (w.state = B.OPEN_WAKA, w.startTagPosition = w.position) : Ae(V) ? (w.doctype += V, w.state = B.DOCTYPE_DTD_QUOTED, w.q = V) : w.doctype += V;
              continue;
            case B.DOCTYPE_DTD_QUOTED:
              w.doctype += V, V === w.q && (w.state = B.DOCTYPE_DTD, w.q = "");
              continue;
            case B.COMMENT:
              V === "-" ? w.state = B.COMMENT_ENDING : w.comment += V;
              continue;
            case B.COMMENT_ENDING:
              V === "-" ? (w.state = B.COMMENT_ENDED, w.comment = yn(w.opt, w.comment), w.comment && Re(w, "oncomment", w.comment), w.comment = "") : (w.comment += "-" + V, w.state = B.COMMENT);
              continue;
            case B.COMMENT_ENDED:
              V !== ">" ? (ge(w, "Malformed comment"), w.comment += "--" + V, w.state = B.COMMENT) : w.doctype && w.doctype !== !0 ? w.state = B.DOCTYPE_DTD : w.state = B.TEXT;
              continue;
            case B.CDATA:
              V === "]" ? w.state = B.CDATA_ENDING : w.cdata += V;
              continue;
            case B.CDATA_ENDING:
              V === "]" ? w.state = B.CDATA_ENDING_2 : (w.cdata += "]" + V, w.state = B.CDATA);
              continue;
            case B.CDATA_ENDING_2:
              V === ">" ? (w.cdata && Re(w, "oncdata", w.cdata), Re(w, "onclosecdata"), w.cdata = "", w.state = B.TEXT) : V === "]" ? w.cdata += "]" : (w.cdata += "]]" + V, w.state = B.CDATA);
              continue;
            case B.PROC_INST:
              V === "?" ? w.state = B.PROC_INST_ENDING : de(V) ? w.state = B.PROC_INST_BODY : w.procInstName += V;
              continue;
            case B.PROC_INST_BODY:
              if (!w.procInstBody && de(V))
                continue;
              V === "?" ? w.state = B.PROC_INST_ENDING : w.procInstBody += V;
              continue;
            case B.PROC_INST_ENDING:
              V === ">" ? (Re(w, "onprocessinginstruction", {
                name: w.procInstName,
                body: w.procInstBody
              }), w.procInstName = w.procInstBody = "", w.state = B.TEXT) : (w.procInstBody += "?" + V, w.state = B.PROC_INST_BODY);
              continue;
            case B.OPEN_TAG:
              ye(pe, V) ? w.tagName += V : (Ie(w), V === ">" ? ht(w) : V === "/" ? w.state = B.OPEN_TAG_SLASH : (de(V) || ge(w, "Invalid character in tag name"), w.state = B.ATTRIB));
              continue;
            case B.OPEN_TAG_SLASH:
              V === ">" ? (ht(w, !0), kt(w)) : (ge(w, "Forward-slash in opening tag not followed by >"), w.state = B.ATTRIB);
              continue;
            case B.ATTRIB:
              if (de(V))
                continue;
              V === ">" ? ht(w) : V === "/" ? w.state = B.OPEN_TAG_SLASH : ye(qe, V) ? (w.attribName = V, w.attribValue = "", w.state = B.ATTRIB_NAME) : ge(w, "Invalid attribute name");
              continue;
            case B.ATTRIB_NAME:
              V === "=" ? w.state = B.ATTRIB_VALUE : V === ">" ? (ge(w, "Attribute without value"), w.attribValue = w.attribName, ot(w), ht(w)) : de(V) ? w.state = B.ATTRIB_NAME_SAW_WHITE : ye(pe, V) ? w.attribName += V : ge(w, "Invalid attribute name");
              continue;
            case B.ATTRIB_NAME_SAW_WHITE:
              if (V === "=")
                w.state = B.ATTRIB_VALUE;
              else {
                if (de(V))
                  continue;
                ge(w, "Attribute without value"), w.tag.attributes[w.attribName] = "", w.attribValue = "", Re(w, "onattribute", {
                  name: w.attribName,
                  value: ""
                }), w.attribName = "", V === ">" ? ht(w) : ye(qe, V) ? (w.attribName = V, w.state = B.ATTRIB_NAME) : (ge(w, "Invalid attribute name"), w.state = B.ATTRIB);
              }
              continue;
            case B.ATTRIB_VALUE:
              if (de(V))
                continue;
              Ae(V) ? (w.q = V, w.state = B.ATTRIB_VALUE_QUOTED) : (w.opt.unquotedAttributeValues || Pt(w, "Unquoted attribute value"), w.state = B.ATTRIB_VALUE_UNQUOTED, w.attribValue = V);
              continue;
            case B.ATTRIB_VALUE_QUOTED:
              if (V !== w.q) {
                V === "&" ? w.state = B.ATTRIB_VALUE_ENTITY_Q : w.attribValue += V;
                continue;
              }
              ot(w), w.q = "", w.state = B.ATTRIB_VALUE_CLOSED;
              continue;
            case B.ATTRIB_VALUE_CLOSED:
              de(V) ? w.state = B.ATTRIB : V === ">" ? ht(w) : V === "/" ? w.state = B.OPEN_TAG_SLASH : ye(qe, V) ? (ge(w, "No whitespace between attributes"), w.attribName = V, w.attribValue = "", w.state = B.ATTRIB_NAME) : ge(w, "Invalid attribute name");
              continue;
            case B.ATTRIB_VALUE_UNQUOTED:
              if (!Be(V)) {
                V === "&" ? w.state = B.ATTRIB_VALUE_ENTITY_U : w.attribValue += V;
                continue;
              }
              ot(w), V === ">" ? ht(w) : w.state = B.ATTRIB;
              continue;
            case B.CLOSE_TAG:
              if (w.tagName)
                V === ">" ? kt(w) : ye(pe, V) ? w.tagName += V : w.script ? (w.script += "</" + w.tagName, w.tagName = "", w.state = B.SCRIPT) : (de(V) || ge(w, "Invalid tagname in closing tag"), w.state = B.CLOSE_TAG_SAW_WHITE);
              else {
                if (de(V))
                  continue;
                Ce(qe, V) ? w.script ? (w.script += "</" + V, w.state = B.SCRIPT) : ge(w, "Invalid tagname in closing tag.") : w.tagName = V;
              }
              continue;
            case B.CLOSE_TAG_SAW_WHITE:
              if (de(V))
                continue;
              V === ">" ? kt(w) : ge(w, "Invalid characters in closing tag");
              continue;
            case B.TEXT_ENTITY:
            case B.ATTRIB_VALUE_ENTITY_Q:
            case B.ATTRIB_VALUE_ENTITY_U:
              var M, J;
              switch (w.state) {
                case B.TEXT_ENTITY:
                  M = B.TEXT, J = "textNode";
                  break;
                case B.ATTRIB_VALUE_ENTITY_Q:
                  M = B.ATTRIB_VALUE_QUOTED, J = "attribValue";
                  break;
                case B.ATTRIB_VALUE_ENTITY_U:
                  M = B.ATTRIB_VALUE_UNQUOTED, J = "attribValue";
                  break;
              }
              if (V === ";") {
                var ee = Dt(w);
                w.opt.unparsedEntities && !Object.values(r.XML_ENTITIES).includes(ee) ? (w.entity = "", w.state = M, w.write(ee)) : (w[J] += ee, w.entity = "", w.state = M);
              } else ye(w.entity.length ? Ee : me, V) ? w.entity += V : (ge(w, "Invalid character in entity name"), w[J] += "&" + w.entity + V, w.entity = "", w.state = M);
              continue;
            default:
              throw new Error(w, "Unknown state: " + w.state);
          }
        return w.position >= w.bufferCheckPosition && c(w), w;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var A = String.fromCharCode, w = Math.floor, F = function() {
          var V = 16384, $e = [], N, M, J = -1, ee = arguments.length;
          if (!ee)
            return "";
          for (var re = ""; ++J < ee; ) {
            var te = Number(arguments[J]);
            if (!isFinite(te) || // `NaN`, `+Infinity`, or `-Infinity`
            te < 0 || // not a valid Unicode code point
            te > 1114111 || // not a valid Unicode code point
            w(te) !== te)
              throw RangeError("Invalid code point: " + te);
            te <= 65535 ? $e.push(te) : (te -= 65536, N = (te >> 10) + 55296, M = te % 1024 + 56320, $e.push(N, M)), (J + 1 === ee || $e.length > V) && (re += A.apply(null, $e), $e.length = 0);
          }
          return re;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: F,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = F;
      }();
    })(n);
  }(gu)), gu;
}
Id();
var ra = { exports: {} }, Rd = ra.exports, wu;
function jd() {
  return wu || (wu = 1, function(n, r) {
    (function(a, u) {
      n.exports = u();
    })(Rd, function() {
      var a = function(e, t) {
        return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (o[s] = i[s]);
        })(e, t);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var t, o = 1, i = arguments.length; o < i; o++) for (var s in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, t, o) {
        for (var i, s = 0, l = t.length; s < l; s++) !i && s in t || ((i = i || Array.prototype.slice.call(t, 0, s))[s] = t[s]);
        return e.concat(i || Array.prototype.slice.call(t));
      }
      var d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Nd, p = Object.keys, g = Array.isArray;
      function O(e, t) {
        return typeof t != "object" || p(t).forEach(function(o) {
          e[o] = t[o];
        }), e;
      }
      typeof Promise > "u" || d.Promise || (d.Promise = Promise);
      var K = Object.getPrototypeOf, P = {}.hasOwnProperty;
      function R(e, t) {
        return P.call(e, t);
      }
      function j(e, t) {
        typeof t == "function" && (t = t(K(e))), (typeof Reflect > "u" ? p : Reflect.ownKeys)(t).forEach(function(o) {
          G(e, o, t[o]);
        });
      }
      var L = Object.defineProperty;
      function G(e, t, o, i) {
        L(e, t, O(o && R(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function fe(e) {
        return { from: function(t) {
          return e.prototype = Object.create(t.prototype), G(e.prototype, "constructor", e), { extend: j.bind(null, e.prototype) };
        } };
      }
      var qe = Object.getOwnPropertyDescriptor, pe = [].slice;
      function me(e, t, o) {
        return pe.call(e, t, o);
      }
      function Ee(e, t) {
        return t(e);
      }
      function de(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function Ae(e) {
        d.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function Be(e, t) {
        if (typeof t == "string" && R(e, t)) return e[t];
        if (!t) return e;
        if (typeof t != "string") {
          for (var o = [], i = 0, s = t.length; i < s; ++i) {
            var l = Be(e, t[i]);
            o.push(l);
          }
          return o;
        }
        var f = t.indexOf(".");
        if (f !== -1) {
          var h = e[t.substr(0, f)];
          return h == null ? void 0 : Be(h, t.substr(f + 1));
        }
      }
      function ye(e, t, o) {
        if (e && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) {
          de(typeof o != "string" && "length" in o);
          for (var i = 0, s = t.length; i < s; ++i) ye(e, t[i], o[i]);
        } else {
          var l, f, h = t.indexOf(".");
          h !== -1 ? (l = t.substr(0, h), (f = t.substr(h + 1)) === "" ? o === void 0 ? g(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : ye(h = !(h = e[l]) || !R(e, l) ? e[l] = {} : h, f, o)) : o === void 0 ? g(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = o;
        }
      }
      function Ce(e) {
        var t, o = {};
        for (t in e) R(e, t) && (o[t] = e[t]);
        return o;
      }
      var B = [].concat;
      function We(e) {
        return B.apply([], e);
      }
      var Pe = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(We([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + e + "Array";
        });
      }))).filter(function(e) {
        return d[e];
      }), st = new Set(Pe.map(function(e) {
        return d[e];
      })), Re = null;
      function nt(e) {
        return Re = /* @__PURE__ */ new WeakMap(), e = function t(o) {
          if (!o || typeof o != "object") return o;
          var i = Re.get(o);
          if (i) return i;
          if (g(o)) {
            i = [], Re.set(o, i);
            for (var s = 0, l = o.length; s < l; ++s) i.push(t(o[s]));
          } else if (st.has(o.constructor)) i = o;
          else {
            var f, h = K(o);
            for (f in i = h === Object.prototype ? {} : Object.create(h), Re.set(o, i), o) R(o, f) && (i[f] = t(o[f]));
          }
          return i;
        }(e), Re = null, e;
      }
      var yn = {}.toString;
      function Pt(e) {
        return yn.call(e).slice(8, -1);
      }
      var Ze = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", ge = typeof Ze == "symbol" ? function(e) {
        var t;
        return e != null && (t = e[Ze]) && t.apply(e);
      } : function() {
        return null;
      };
      function Ie(e, t) {
        return t = e.indexOf(t), 0 <= t && e.splice(t, 1), 0 <= t;
      }
      var dt = {};
      function ot(e) {
        var t, o, i, s;
        if (arguments.length === 1) {
          if (g(e)) return e.slice();
          if (this === dt && typeof e == "string") return [e];
          if (s = ge(e)) {
            for (o = []; !(i = s.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (t = e.length) != "number") return [e];
          for (o = new Array(t); t--; ) o[t] = e[t];
          return o;
        }
        for (t = arguments.length, o = new Array(t); t--; ) o[t] = arguments[t];
        return o;
      }
      var ht = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Te = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], pt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Te), kt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Dt(e, t) {
        this.name = e, this.message = t;
      }
      function Rn(e, t) {
        return e + ". Errors: " + Object.keys(t).map(function(o) {
          return t[o].toString();
        }).filter(function(o, i, s) {
          return s.indexOf(o) === i;
        }).join(`
`);
      }
      function sn(e, t, o, i) {
        this.failures = t, this.failedKeys = i, this.successCount = o, this.message = Rn(e, t);
      }
      function wt(e, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(o) {
          return t[o];
        }), this.failuresByPos = t, this.message = Rn(e, this.failures);
      }
      fe(Dt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), fe(sn).from(Dt), fe(wt).from(Dt);
      var A = pt.reduce(function(e, t) {
        return e[t] = t + "Error", e;
      }, {}), w = Dt, F = pt.reduce(function(e, t) {
        var o = t + "Error";
        function i(s, l) {
          this.name = o, s ? typeof s == "string" ? (this.message = "".concat(s).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof s == "object" && (this.message = "".concat(s.name, " ").concat(s.message), this.inner = s) : (this.message = kt[t] || o, this.inner = null);
        }
        return fe(i).from(w), e[t] = i, e;
      }, {});
      F.Syntax = SyntaxError, F.Type = TypeError, F.Range = RangeError;
      var V = Te.reduce(function(e, t) {
        return e[t + "Error"] = F[t], e;
      }, {}), $e = pt.reduce(function(e, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = F[t]), e;
      }, {});
      function N() {
      }
      function M(e) {
        return e;
      }
      function J(e, t) {
        return e == null || e === M ? t : function(o) {
          return t(e(o));
        };
      }
      function ee(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function re(e, t) {
        return e === N ? t : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, s = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = t.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? ee(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? ee(s, this.onerror) : s), l !== void 0 ? l : o;
        };
      }
      function te(e, t) {
        return e === N ? t : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? ee(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? ee(i, this.onerror) : i);
        };
      }
      function ae(e, t) {
        return e === N ? t : function(o) {
          var i = e.apply(this, arguments);
          O(o, i);
          var s = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = t.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? ee(s, this.onsuccess) : s), l && (this.onerror = this.onerror ? ee(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : O(i, o);
        };
      }
      function le(e, t) {
        return e === N ? t : function() {
          return t.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function oe(e, t) {
        return e === N ? t : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, s = arguments.length, l = new Array(s); s--; ) l[s] = arguments[s];
            return o.then(function() {
              return t.apply(i, l);
            });
          }
          return t.apply(this, arguments);
        };
      }
      $e.ModifyError = sn, $e.DexieError = Dt, $e.BulkError = wt;
      var ne = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function we(e) {
        ne = e;
      }
      var ce = {}, xe = 100, Pe = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, K(e), e];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, K(t), e];
      }(), Te = Pe[0], pt = Pe[1], Pe = Pe[2], pt = pt && pt.then, Me = Te && Te.constructor, Ue = !!Pe, ut = function(e, t) {
        an.push([e, t]), Ot && (queueMicrotask(ss), Ot = !1);
      }, gt = !0, Ot = !0, lt = [], Yt = [], jn = M, et = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: N, pgp: !1, env: {}, finalize: N }, Z = et, an = [], Xt = 0, $n = [];
      function z(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = Z;
        if (typeof e != "function") {
          if (e !== ce) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Dr(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function o(i, s) {
          try {
            s(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var f = i._lib && un();
                l && typeof l.then == "function" ? o(i, function(h, y) {
                  l instanceof z ? l._then(h, y) : l.then(h, y);
                }) : (i._state = !0, i._value = l, No(i)), f && ln();
              }
            }, Dr.bind(null, i));
          } catch (l) {
            Dr(i, l);
          }
        }(this, e);
      }
      var kr = { get: function() {
        var e = Z, t = Wn;
        function o(i, s) {
          var l = this, f = !e.global && (e !== Z || t !== Wn), h = f && !Lt(), y = new z(function(b, x) {
            Ir(l, new So(Po(i, e, f, h), Po(s, e, f, h), b, x, e));
          });
          return this._consoleTask && (y._consoleTask = this._consoleTask), y;
        }
        return o.prototype = ce, o;
      }, set: function(e) {
        G(this, "then", e && e.prototype === ce ? kr : { get: function() {
          return e;
        }, set: kr.set });
      } };
      function So(e, t, o, i, s) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = o, this.reject = i, this.psd = s;
      }
      function Dr(e, t) {
        var o, i;
        Yt.push(t), e._state === null && (o = e._lib && un(), t = jn(t), e._state = !1, e._value = t, i = e, lt.some(function(s) {
          return s._value === i._value;
        }) || lt.push(i), No(e), o && ln());
      }
      function No(e) {
        var t = e._listeners;
        e._listeners = [];
        for (var o = 0, i = t.length; o < i; ++o) Ir(e, t[o]);
        var s = e._PSD;
        --s.ref || s.finalize(), Xt === 0 && (++Xt, ut(function() {
          --Xt == 0 && Rr();
        }, []));
      }
      function Ir(e, t) {
        if (e._state !== null) {
          var o = e._state ? t.onFulfilled : t.onRejected;
          if (o === null) return (e._state ? t.resolve : t.reject)(e._value);
          ++t.psd.ref, ++Xt, ut(is, [o, e, t]);
        } else e._listeners.push(t);
      }
      function is(e, t, o) {
        try {
          var i, s = t._value;
          !t._state && Yt.length && (Yt = []), i = ne && t._consoleTask ? t._consoleTask.run(function() {
            return e(s);
          }) : e(s), t._state || Yt.indexOf(s) !== -1 || function(l) {
            for (var f = lt.length; f; ) if (lt[--f]._value === l._value) return lt.splice(f, 1);
          }(t), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Xt == 0 && Rr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function ss() {
        zt(et, function() {
          un() && ln();
        });
      }
      function un() {
        var e = gt;
        return Ot = gt = !1, e;
      }
      function ln() {
        var e, t, o;
        do
          for (; 0 < an.length; ) for (e = an, an = [], o = e.length, t = 0; t < o; ++t) {
            var i = e[t];
            i[0].apply(null, i[1]);
          }
        while (0 < an.length);
        Ot = gt = !0;
      }
      function Rr() {
        var e = lt;
        lt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var t = $n.slice(0), o = t.length; o; ) t[--o]();
      }
      function Un(e) {
        return new z(ce, !1, e);
      }
      function ke(e, t) {
        var o = Z;
        return function() {
          var i = un(), s = Z;
          try {
            return Kt(o, !0), e.apply(this, arguments);
          } catch (l) {
            t && t(l);
          } finally {
            Kt(s, !1), i && ln();
          }
        };
      }
      j(z.prototype, { then: kr, _then: function(e, t) {
        Ir(this, new So(null, null, e, t, Z));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var t = e, o = arguments[1];
        return typeof t == "function" ? this.then(null, function(i) {
          return (i instanceof t ? o : Un)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === t ? o : Un)(i);
        });
      }, finally: function(e) {
        return this.then(function(t) {
          return z.resolve(e()).then(function() {
            return t;
          });
        }, function(t) {
          return z.resolve(e()).then(function() {
            return Un(t);
          });
        });
      }, timeout: function(e, t) {
        var o = this;
        return e < 1 / 0 ? new z(function(i, s) {
          var l = setTimeout(function() {
            return s(new F.Timeout(t));
          }, e);
          o.then(i, s).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && G(z.prototype, Symbol.toStringTag, "Dexie.Promise"), et.env = Ao(), j(z, { all: function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t, o) {
          e.length === 0 && t([]);
          var i = e.length;
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(f) {
              e[l] = f, --i || t(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof z ? e : e && typeof e.then == "function" ? new z(function(t, o) {
          e.then(t, o);
        }) : new z(ce, !0, e);
      }, reject: Un, race: function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t, o) {
          e.map(function(i) {
            return z.resolve(i).then(t, o);
          });
        });
      }, PSD: { get: function() {
        return Z;
      }, set: function(e) {
        return Z = e;
      } }, totalEchoes: { get: function() {
        return Wn;
      } }, newPSD: jt, usePSD: zt, scheduler: { get: function() {
        return ut;
      }, set: function(e) {
        ut = e;
      } }, rejectionMapper: { get: function() {
        return jn;
      }, set: function(e) {
        jn = e;
      } }, follow: function(e, t) {
        return new z(function(o, i) {
          return jt(function(s, l) {
            var f = Z;
            f.unhandleds = [], f.onunhandled = l, f.finalize = ee(function() {
              var h, y = this;
              h = function() {
                y.unhandleds.length === 0 ? s() : l(y.unhandleds[0]);
              }, $n.push(function b() {
                h(), $n.splice($n.indexOf(b), 1);
              }), ++Xt, ut(function() {
                --Xt == 0 && Rr();
              }, []);
            }, f.finalize), e();
          }, t, o, i);
        });
      } }), Me && (Me.allSettled && G(z, "allSettled", function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t) {
          e.length === 0 && t([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(f) {
              return i[l] = { status: "fulfilled", value: f };
            }, function(f) {
              return i[l] = { status: "rejected", reason: f };
            }).then(function() {
              return --o || t(i);
            });
          });
        });
      }), Me.any && typeof AggregateError < "u" && G(z, "any", function() {
        var e = ot.apply(null, arguments).map(Gn);
        return new z(function(t, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, s = new Array(i);
          e.forEach(function(l, f) {
            return z.resolve(l).then(function(h) {
              return t(h);
            }, function(h) {
              s[f] = h, --i || o(new AggregateError(s));
            });
          });
        });
      }), Me.withResolvers && (z.withResolvers = Me.withResolvers));
      var Ve = { awaits: 0, echoes: 0, id: 0 }, as = 0, Vn = [], Hn = 0, Wn = 0, us = 0;
      function jt(e, t, o, i) {
        var s = Z, l = Object.create(s);
        return l.parent = s, l.ref = 0, l.global = !1, l.id = ++us, et.env, l.env = Ue ? { Promise: z, PromiseProp: { value: z, configurable: !0, writable: !0 }, all: z.all, race: z.race, allSettled: z.allSettled, any: z.any, resolve: z.resolve, reject: z.reject } : {}, t && O(l, t), ++s.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function cn() {
        return Ve.id || (Ve.id = ++as), ++Ve.awaits, Ve.echoes += xe, Ve.id;
      }
      function Lt() {
        return !!Ve.awaits && (--Ve.awaits == 0 && (Ve.id = 0), Ve.echoes = Ve.awaits * xe, !0);
      }
      function Gn(e) {
        return Ve.echoes && e && e.constructor === Me ? (cn(), e.then(function(t) {
          return Lt(), t;
        }, function(t) {
          return Lt(), je(t);
        })) : e;
      }
      function ls() {
        var e = Vn[Vn.length - 1];
        Vn.pop(), Kt(e, !1);
      }
      function Kt(e, t) {
        var o, i = Z;
        (t ? !Ve.echoes || Hn++ && e === Z : !Hn || --Hn && e === Z) || queueMicrotask(t ? (function(s) {
          ++Wn, Ve.echoes && --Ve.echoes != 0 || (Ve.echoes = Ve.awaits = Ve.id = 0), Vn.push(Z), Kt(s, !0);
        }).bind(null, e) : ls), e !== Z && (Z = e, i === et && (et.env = Ao()), Ue && (o = et.env.Promise, t = e.env, (i.global || e.global) && (Object.defineProperty(d, "Promise", t.PromiseProp), o.all = t.all, o.race = t.race, o.resolve = t.resolve, o.reject = t.reject, t.allSettled && (o.allSettled = t.allSettled), t.any && (o.any = t.any))));
      }
      function Ao() {
        var e = d.Promise;
        return Ue ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(d, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function zt(e, t, o, i, s) {
        var l = Z;
        try {
          return Kt(e, !0), t(o, i, s);
        } finally {
          Kt(l, !1);
        }
      }
      function Po(e, t, o, i) {
        return typeof e != "function" ? e : function() {
          var s = Z;
          o && cn(), Kt(t, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Kt(s, !1), i && queueMicrotask(Lt);
          }
        };
      }
      function jr(e) {
        Promise === Me && Ve.echoes === 0 ? Hn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + pt).indexOf("[native code]") === -1 && (cn = Lt = N);
      var je = z.reject, Qt = "￿", St = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", ko = "String expected.", fn = [], Yn = "__dbnames", Lr = "readonly", Kr = "readwrite";
      function Jt(e, t) {
        return e ? t ? function() {
          return e.apply(this, arguments) && t.apply(this, arguments);
        } : e : t;
      }
      var Do = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Xn(e) {
        return typeof e != "string" || /\./.test(e) ? function(t) {
          return t;
        } : function(t) {
          return t[e] === void 0 && e in t && delete (t = nt(t))[e], t;
        };
      }
      function Io() {
        throw F.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function he(e, t) {
        try {
          var o = Ro(e), i = Ro(t);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return t < e ? 1 : e < t ? -1 : 0;
            case "binary":
              return function(s, l) {
                for (var f = s.length, h = l.length, y = f < h ? f : h, b = 0; b < y; ++b) if (s[b] !== l[b]) return s[b] < l[b] ? -1 : 1;
                return f === h ? 0 : f < h ? -1 : 1;
              }(jo(e), jo(t));
            case "Array":
              return function(s, l) {
                for (var f = s.length, h = l.length, y = f < h ? f : h, b = 0; b < y; ++b) {
                  var x = he(s[b], l[b]);
                  if (x !== 0) return x;
                }
                return f === h ? 0 : f < h ? -1 : 1;
              }(e, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ro(e) {
        var t = typeof e;
        return t != "object" ? t : ArrayBuffer.isView(e) ? "binary" : (e = Pt(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function jo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function zn(e, t, o) {
        var i = e.schema.yProps;
        return i ? (t && 0 < o.numFailures && (t = t.filter(function(s, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(s) {
          return s = s.updatesTable, t ? e.db.table(s).where("k").anyOf(t).delete() : e.db.table(s).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Lo = (Se.prototype._trans = function(e, t, o) {
        var i = this._tx || Z.trans, s = this.name, l = ne && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function f(b, x, m) {
          if (!m.schema[s]) throw new F.NotFound("Table " + s + " not part of transaction");
          return t(m.idbtrans, m);
        }
        var h = un();
        try {
          var y = i && i.db._novip === this.db._novip ? i === Z.trans ? i._promise(e, f, o) : jt(function() {
            return i._promise(e, f, o);
          }, { trans: i, transless: Z.transless || Z }) : function b(x, m, C, v) {
            if (x.idbdb && (x._state.openComplete || Z.letThrough || x._vip)) {
              var _ = x._createTransaction(m, C, x._dbSchema);
              try {
                _.create(), x._state.PR1398_maxLoop = 3;
              } catch (E) {
                return E.name === A.InvalidState && x.isOpen() && 0 < --x._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), x.close({ disableAutoOpen: !1 }), x.open().then(function() {
                  return b(x, m, C, v);
                })) : je(E);
              }
              return _._promise(m, function(E, T) {
                return jt(function() {
                  return Z.trans = _, v(E, T, _);
                });
              }).then(function(E) {
                if (m === "readwrite") try {
                  _.idbtrans.commit();
                } catch {
                }
                return m === "readonly" ? E : _._completion.then(function() {
                  return E;
                });
              });
            }
            if (x._state.openComplete) return je(new F.DatabaseClosed(x._state.dbOpenError));
            if (!x._state.isBeingOpened) {
              if (!x._state.autoOpen) return je(new F.DatabaseClosed());
              x.open().catch(N);
            }
            return x._state.dbReadyPromise.then(function() {
              return b(x, m, C, v);
            });
          }(this.db, e, [this.name], f);
          return l && (y._consoleTask = l, y = y.catch(function(b) {
            return console.trace(b), je(b);
          })), y;
        } finally {
          h && ln();
        }
      }, Se.prototype.get = function(e, t) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(t) : e == null ? je(new F.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(s) {
            return o.hook.reading.fire(s);
          });
        }).then(t);
      }, Se.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (g(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var t = p(e);
        if (t.length === 1) return this.where(t[0]).equals(e[t[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(h) {
          if (h.compound && t.every(function(b) {
            return 0 <= h.keyPath.indexOf(b);
          })) {
            for (var y = 0; y < t.length; ++y) if (t.indexOf(h.keyPath[y]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(h, y) {
          return h.keyPath.length - y.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== Qt) {
          var l = o.keyPath.slice(0, t.length);
          return this.where(l).equals(l.map(function(y) {
            return e[y];
          }));
        }
        !o && ne && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var i = this.schema.idxByName;
        function s(h, y) {
          return he(h, y) === 0;
        }
        var f = t.reduce(function(m, y) {
          var b = m[0], x = m[1], m = i[y], C = e[y];
          return [b || m, b || !m ? Jt(x, m && m.multi ? function(v) {
            return v = Be(v, y), g(v) && v.some(function(_) {
              return s(C, _);
            });
          } : function(v) {
            return s(C, Be(v, y));
          }) : x];
        }, [null, null]), l = f[0], f = f[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(f) : o ? this.filter(f) : this.where(t).equals("");
      }, Se.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Se.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Se.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Se.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Se.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Se.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Se.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Se.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, g(e) ? "[".concat(e.join("+"), "]") : e));
      }, Se.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Se.prototype.mapToClass = function(e) {
        var t, o = this.db, i = this.name;
        function s() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Io && (function(y, b) {
          if (typeof b != "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function x() {
            this.constructor = y;
          }
          a(y, b), y.prototype = b === null ? Object.create(b) : (x.prototype = b.prototype, new x());
        }(s, t = e), Object.defineProperty(s.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), s.prototype.table = function() {
          return i;
        }, e = s);
        for (var l = /* @__PURE__ */ new Set(), f = e.prototype; f; f = K(f)) Object.getOwnPropertyNames(f).forEach(function(y) {
          return l.add(y);
        });
        function h(y) {
          if (!y) return y;
          var b, x = Object.create(e.prototype);
          for (b in y) if (!l.has(b)) try {
            x[b] = y[b];
          } catch {
          }
          return x;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = h, this.hook("reading", h), e;
      }, Se.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          O(this, e);
        });
      }, Se.prototype.add = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, f = e;
        return l && s && (f = Xn(l)(e)), this._trans("readwrite", function(h) {
          return o.core.mutate({ trans: h, type: "add", keys: t != null ? [t] : null, values: [f] });
        }).then(function(h) {
          return h.numFailures ? z.reject(h.failures[0]) : h.lastResult;
        }).then(function(h) {
          if (l) try {
            ye(e, l, h);
          } catch {
          }
          return h;
        });
      }, Se.prototype.update = function(e, t) {
        return typeof e != "object" || g(e) ? this.where(":id").equals(e).modify(t) : (e = Be(e, this.schema.primKey.keyPath), e === void 0 ? je(new F.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(t));
      }, Se.prototype.put = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, f = e;
        return l && s && (f = Xn(l)(e)), this._trans("readwrite", function(h) {
          return o.core.mutate({ trans: h, type: "put", values: [f], keys: t != null ? [t] : null });
        }).then(function(h) {
          return h.numFailures ? z.reject(h.failures[0]) : h.lastResult;
        }).then(function(h) {
          if (l) try {
            ye(e, l, h);
          } catch {
          }
          return h;
        });
      }, Se.prototype.delete = function(e) {
        var t = this;
        return this._trans("readwrite", function(o) {
          return t.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return zn(t, [e], i);
          }).then(function(i) {
            return i.numFailures ? z.reject(i.failures[0]) : void 0;
          });
        });
      }, Se.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(t) {
          return e.core.mutate({ trans: t, type: "deleteRange", range: Do }).then(function(o) {
            return zn(e, null, o);
          });
        }).then(function(t) {
          return t.numFailures ? z.reject(t.failures[0]) : void 0;
        });
      }, Se.prototype.bulkGet = function(e) {
        var t = this;
        return this._trans("readonly", function(o) {
          return t.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(s) {
              return t.hook.reading.fire(s);
            });
          });
        });
      }, Se.prototype.bulkAdd = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(f) {
          var b = i.schema.primKey, h = b.auto, b = b.keyPath;
          if (b && s) throw new F.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new F.InvalidArgument("Arguments objects and keys must have the same length");
          var y = e.length, b = b && h ? e.map(Xn(b)) : e;
          return i.core.mutate({ trans: f, type: "add", keys: s, values: b, wantResults: l }).then(function(_) {
            var m = _.numFailures, C = _.results, v = _.lastResult, _ = _.failures;
            if (m === 0) return l ? C : v;
            throw new wt("".concat(i.name, ".bulkAdd(): ").concat(m, " of ").concat(y, " operations failed"), _);
          });
        });
      }, Se.prototype.bulkPut = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(f) {
          var b = i.schema.primKey, h = b.auto, b = b.keyPath;
          if (b && s) throw new F.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new F.InvalidArgument("Arguments objects and keys must have the same length");
          var y = e.length, b = b && h ? e.map(Xn(b)) : e;
          return i.core.mutate({ trans: f, type: "put", keys: s, values: b, wantResults: l }).then(function(_) {
            var m = _.numFailures, C = _.results, v = _.lastResult, _ = _.failures;
            if (m === 0) return l ? C : v;
            throw new wt("".concat(i.name, ".bulkPut(): ").concat(m, " of ").concat(y, " operations failed"), _);
          });
        });
      }, Se.prototype.bulkUpdate = function(e) {
        var t = this, o = this.core, i = e.map(function(f) {
          return f.key;
        }), s = e.map(function(f) {
          return f.changes;
        }), l = [];
        return this._trans("readwrite", function(f) {
          return o.getMany({ trans: f, keys: i, cache: "clone" }).then(function(h) {
            var y = [], b = [];
            e.forEach(function(m, C) {
              var v = m.key, _ = m.changes, E = h[C];
              if (E) {
                for (var T = 0, S = Object.keys(_); T < S.length; T++) {
                  var k = S[T], D = _[k];
                  if (k === t.schema.primKey.keyPath) {
                    if (he(D, v) !== 0) throw new F.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ye(E, k, D);
                }
                l.push(C), y.push(v), b.push(E);
              }
            });
            var x = y.length;
            return o.mutate({ trans: f, type: "put", keys: y, values: b, updates: { keys: i, changeSpecs: s } }).then(function(m) {
              var C = m.numFailures, v = m.failures;
              if (C === 0) return x;
              for (var _ = 0, E = Object.keys(v); _ < E.length; _++) {
                var T, S = E[_], k = l[Number(S)];
                k != null && (T = v[S], delete v[S], v[k] = T);
              }
              throw new wt("".concat(t.name, ".bulkUpdate(): ").concat(C, " of ").concat(x, " operations failed"), v);
            });
          });
        });
      }, Se.prototype.bulkDelete = function(e) {
        var t = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return t.core.mutate({ trans: i, type: "delete", keys: e }).then(function(s) {
            return zn(t, e, s);
          });
        }).then(function(f) {
          var s = f.numFailures, l = f.lastResult, f = f.failures;
          if (s === 0) return l;
          throw new wt("".concat(t.name, ".bulkDelete(): ").concat(s, " of ").concat(o, " operations failed"), f);
        });
      }, Se);
      function Se() {
      }
      function _n(e) {
        function t(f, h) {
          if (h) {
            for (var y = arguments.length, b = new Array(y - 1); --y; ) b[y - 1] = arguments[y];
            return o[f].subscribe.apply(null, b), e;
          }
          if (typeof f == "string") return o[f];
        }
        var o = {};
        t.addEventType = l;
        for (var i = 1, s = arguments.length; i < s; ++i) l(arguments[i]);
        return t;
        function l(f, h, y) {
          if (typeof f != "object") {
            var b;
            h = h || le;
            var x = { subscribers: [], fire: y = y || N, subscribe: function(m) {
              x.subscribers.indexOf(m) === -1 && (x.subscribers.push(m), x.fire = h(x.fire, m));
            }, unsubscribe: function(m) {
              x.subscribers = x.subscribers.filter(function(C) {
                return C !== m;
              }), x.fire = x.subscribers.reduce(h, y);
            } };
            return o[f] = t[f] = x;
          }
          p(b = f).forEach(function(m) {
            var C = b[m];
            if (g(C)) l(m, b[m][0], b[m][1]);
            else {
              if (C !== "asap") throw new F.InvalidArgument("Invalid event config");
              var v = l(m, M, function() {
                for (var _ = arguments.length, E = new Array(_); _--; ) E[_] = arguments[_];
                v.subscribers.forEach(function(T) {
                  Ae(function() {
                    T.apply(null, E);
                  });
                });
              });
            }
          });
        }
      }
      function wn(e, t) {
        return fe(t).from({ prototype: e }), t;
      }
      function dn(e, t) {
        return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);
      }
      function Fr(e, t) {
        e.filter = Jt(e.filter, t);
      }
      function Mr(e, t, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return Jt(i(), t());
        } : t, e.justLimit = o && !i;
      }
      function Qn(e, t) {
        if (e.isPrimKey) return t.primaryKey;
        var o = t.getIndexByKeyPath(e.index);
        if (!o) throw new F.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return o;
      }
      function Ko(e, t, o) {
        var i = Qn(e, t.schema);
        return t.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function Jn(e, t, o, i) {
        var s = e.replayFilter ? Jt(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, f = function(h, y, b) {
            var x, m;
            s && !s(y, b, function(C) {
              return y.stop(C);
            }, function(C) {
              return y.fail(C);
            }) || ((m = "" + (x = y.primaryKey)) == "[object ArrayBuffer]" && (m = "" + new Uint8Array(x)), R(l, m) || (l[m] = !0, t(h, y, b)));
          };
          return Promise.all([e.or._iterate(f, o), Fo(Ko(e, i, o), e.algorithm, f, !e.keysOnly && e.valueMapper)]);
        }
        return Fo(Ko(e, i, o), Jt(e.algorithm, s), t, !e.keysOnly && e.valueMapper);
      }
      function Fo(e, t, o, i) {
        var s = ke(i ? function(l, f, h) {
          return o(i(l), f, h);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var f = function() {
              return l.continue();
            };
            t && !t(l, function(h) {
              return f = h;
            }, function(h) {
              l.stop(h), f = N;
            }, function(h) {
              l.fail(h), f = N;
            }) || s(l.value, l, function(h) {
              return f = h;
            }), f();
          });
        });
      }
      var xn = (Mo.prototype.execute = function(e) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var o = t.add;
          if (g(o)) return c(c([], g(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (t.remove !== void 0) {
          var i = t.remove;
          if (g(i)) return g(e) ? e.filter(function(s) {
            return !i.includes(s);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = t.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? t.replacePrefix[1] + e.substring(o.length) : e;
      }, Mo);
      function Mo(e) {
        this["@@propmod"] = e;
      }
      var cs = (_e.prototype._read = function(e, t) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, je.bind(null, o.error)) : o.table._trans("readonly", e).then(t);
      }, _e.prototype._write = function(e) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, je.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
      }, _e.prototype._addAlgorithm = function(e) {
        var t = this._ctx;
        t.algorithm = Jt(t.algorithm, e);
      }, _e.prototype._iterate = function(e, t) {
        return Jn(this._ctx, e, t, this._ctx.table.core);
      }, _e.prototype.clone = function(e) {
        var t = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && O(o, e), t._ctx = o, t;
      }, _e.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, _e.prototype.each = function(e) {
        var t = this._ctx;
        return this._read(function(o) {
          return Jn(t, e, o, t.table.core);
        });
      }, _e.prototype.count = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx, s = i.table.core;
          if (dn(i, !0)) return s.count({ trans: o, query: { index: Qn(i, s.schema), range: i.range } }).then(function(f) {
            return Math.min(f, i.limit);
          });
          var l = 0;
          return Jn(i, function() {
            return ++l, !1;
          }, o, s).then(function() {
            return l;
          });
        }).then(e);
      }, _e.prototype.sortBy = function(e, t) {
        var o = e.split(".").reverse(), i = o[0], s = o.length - 1;
        function l(y, b) {
          return b ? l(y[o[b]], b - 1) : y[i];
        }
        var f = this._ctx.dir === "next" ? 1 : -1;
        function h(y, b) {
          return he(l(y, s), l(b, s)) * f;
        }
        return this.toArray(function(y) {
          return y.sort(h);
        }).then(t);
      }, _e.prototype.toArray = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx;
          if (i.dir === "next" && dn(i, !0) && 0 < i.limit) {
            var s = i.valueMapper, l = Qn(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(h) {
              return h = h.result, s ? h.map(s) : h;
            });
          }
          var f = [];
          return Jn(i, function(h) {
            return f.push(h);
          }, o, i.table.core).then(function() {
            return f;
          });
        }, e);
      }, _e.prototype.offset = function(e) {
        var t = this._ctx;
        return e <= 0 || (t.offset += e, dn(t) ? Mr(t, function() {
          var o = e;
          return function(i, s) {
            return o === 0 || (o === 1 ? --o : s(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : Mr(t, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, _e.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Mr(this._ctx, function() {
          var t = e;
          return function(o, i, s) {
            return --t <= 0 && i(s), 0 <= t;
          };
        }, !0), this;
      }, _e.prototype.until = function(e, t) {
        return Fr(this._ctx, function(o, i, s) {
          return !e(o.value) || (i(s), t);
        }), this;
      }, _e.prototype.first = function(e) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(e);
      }, _e.prototype.last = function(e) {
        return this.reverse().first(e);
      }, _e.prototype.filter = function(e) {
        var t;
        return Fr(this._ctx, function(o) {
          return e(o.value);
        }), (t = this._ctx).isMatch = Jt(t.isMatch, e), this;
      }, _e.prototype.and = function(e) {
        return this.filter(e);
      }, _e.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, _e.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, _e.prototype.desc = function() {
        return this.reverse();
      }, _e.prototype.eachKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, _e.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, _e.prototype.eachPrimaryKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, _e.prototype.keys = function(e) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.key);
        }).then(function() {
          return o;
        }).then(e);
      }, _e.prototype.primaryKeys = function(e) {
        var t = this._ctx;
        if (t.dir === "next" && dn(t, !0) && 0 < t.limit) return this._read(function(i) {
          var s = Qn(t, t.table.core.schema);
          return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: s, range: t.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, _e.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, _e.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(e);
      }, _e.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, _e.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var t = {};
        return Fr(this._ctx, function(s) {
          var i = s.primaryKey.toString(), s = R(t, i);
          return t[i] = !0, !s;
        }), this;
      }, _e.prototype.modify = function(e) {
        var t = this, o = this._ctx;
        return this._write(function(i) {
          var s, l, f;
          f = typeof e == "function" ? e : (s = p(e), l = s.length, function(S) {
            for (var k = !1, D = 0; D < l; ++D) {
              var I = s[D], $ = e[I], W = Be(S, I);
              $ instanceof xn ? (ye(S, I, $.execute(W)), k = !0) : W !== $ && (ye(S, I, $), k = !0);
            }
            return k;
          });
          var h = o.table.core, m = h.schema.primaryKey, y = m.outbound, b = m.extractKey, x = 200, m = t.db._options.modifyChunkSize;
          m && (x = typeof m == "object" ? m[h.name] || m["*"] || 200 : m);
          function C(S, I) {
            var D = I.failures, I = I.numFailures;
            _ += S - I;
            for (var $ = 0, W = p(D); $ < W.length; $++) {
              var U = W[$];
              v.push(D[U]);
            }
          }
          var v = [], _ = 0, E = [], T = e === Bo;
          return t.clone().primaryKeys().then(function(S) {
            function k(I) {
              var $ = Math.min(x, S.length - I), W = S.slice(I, I + $);
              return (T ? Promise.resolve([]) : h.getMany({ trans: i, keys: W, cache: "immutable" })).then(function(U) {
                var H = [], X = [], Y = y ? [] : null, Q = T ? W : [];
                if (!T) for (var ue = 0; ue < $; ++ue) {
                  var ve = U[ue], se = { value: nt(ve), primKey: S[I + ue] };
                  f.call(se, se.value, se) !== !1 && (se.value == null ? Q.push(S[I + ue]) : y || he(b(ve), b(se.value)) === 0 ? (X.push(se.value), y && Y.push(S[I + ue])) : (Q.push(S[I + ue]), H.push(se.value)));
                }
                return Promise.resolve(0 < H.length && h.mutate({ trans: i, type: "add", values: H }).then(function(De) {
                  for (var ie in De.failures) Q.splice(parseInt(ie), 1);
                  C(H.length, De);
                })).then(function() {
                  return (0 < X.length || D && typeof e == "object") && h.mutate({ trans: i, type: "put", keys: Y, values: X, criteria: D, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < I }).then(function(De) {
                    return C(X.length, De);
                  });
                }).then(function() {
                  return (0 < Q.length || D && T) && h.mutate({ trans: i, type: "delete", keys: Q, criteria: D, isAdditionalChunk: 0 < I }).then(function(De) {
                    return zn(o.table, Q, De);
                  }).then(function(De) {
                    return C(Q.length, De);
                  });
                }).then(function() {
                  return S.length > I + $ && k(I + x);
                });
              });
            }
            var D = dn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return k(0).then(function() {
              if (0 < v.length) throw new sn("Error modifying one or more objects", v, _, E);
              return S.length;
            });
          });
        });
      }, _e.prototype.delete = function() {
        var e = this._ctx, t = e.range;
        return !dn(e) || e.table.schema.yProps || !e.isPrimKey && t.type !== 3 ? this.modify(Bo) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, s = t;
          return e.table.core.count({ trans: o, query: { index: i, range: s } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: s }).then(function(y) {
              var h = y.failures, y = y.numFailures;
              if (y) throw new sn("Could not delete some values", Object.keys(h).map(function(b) {
                return h[b];
              }), l - y);
              return l - y;
            });
          });
        });
      }, _e);
      function _e() {
      }
      var Bo = function(e, t) {
        return t.value = null;
      };
      function fs(e, t) {
        return e < t ? -1 : e === t ? 0 : 1;
      }
      function ds(e, t) {
        return t < e ? -1 : e === t ? 0 : 1;
      }
      function at(e, t, o) {
        return e = e instanceof $o ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(t), e;
      }
      function pn(e) {
        return new e.Collection(e, function() {
          return qo("");
        }).limit(0);
      }
      function Zn(e, t, o, i) {
        var s, l, f, h, y, b, x, m = o.length;
        if (!o.every(function(_) {
          return typeof _ == "string";
        })) return at(e, ko);
        function C(_) {
          s = _ === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = _ === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, f = _ === "next" ? fs : ds;
          var E = o.map(function(T) {
            return { lower: l(T), upper: s(T) };
          }).sort(function(T, S) {
            return f(T.lower, S.lower);
          });
          h = E.map(function(T) {
            return T.upper;
          }), y = E.map(function(T) {
            return T.lower;
          }), x = (b = _) === "next" ? "" : i;
        }
        C("next"), e = new e.Collection(e, function() {
          return Ft(h[0], y[m - 1] + i);
        }), e._ondirectionchange = function(_) {
          C(_);
        };
        var v = 0;
        return e._addAlgorithm(function(_, E, T) {
          var S = _.key;
          if (typeof S != "string") return !1;
          var k = l(S);
          if (t(k, y, v)) return !0;
          for (var D = null, I = v; I < m; ++I) {
            var $ = function(W, U, H, X, Y, Q) {
              for (var ue = Math.min(W.length, X.length), ve = -1, se = 0; se < ue; ++se) {
                var De = U[se];
                if (De !== X[se]) return Y(W[se], H[se]) < 0 ? W.substr(0, se) + H[se] + H.substr(se + 1) : Y(W[se], X[se]) < 0 ? W.substr(0, se) + X[se] + H.substr(se + 1) : 0 <= ve ? W.substr(0, ve) + U[ve] + H.substr(ve + 1) : null;
                Y(W[se], De) < 0 && (ve = se);
              }
              return ue < X.length && Q === "next" ? W + H.substr(W.length) : ue < W.length && Q === "prev" ? W.substr(0, H.length) : ve < 0 ? null : W.substr(0, ve) + X[ve] + H.substr(ve + 1);
            }(S, k, h[I], y[I], f, b);
            $ === null && D === null ? v = I + 1 : (D === null || 0 < f(D, $)) && (D = $);
          }
          return E(D !== null ? function() {
            _.continue(D + x);
          } : T), !1;
        }), e;
      }
      function Ft(e, t, o, i) {
        return { type: 2, lower: e, upper: t, lowerOpen: o, upperOpen: i };
      }
      function qo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var $o = (Object.defineProperty(He.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), He.prototype.between = function(e, t, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, t) || this._cmp(e, t) === 0 && (o || i) && (!o || !i) ? pn(this) : new this.Collection(this, function() {
            return Ft(e, t, !o, !i);
          });
        } catch {
          return at(this, St);
        }
      }, He.prototype.equals = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return qo(e);
        });
      }, He.prototype.above = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(e, void 0, !0);
        });
      }, He.prototype.aboveOrEqual = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(e, void 0, !1);
        });
      }, He.prototype.below = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(void 0, e, !1, !0);
        });
      }, He.prototype.belowOrEqual = function(e) {
        return e == null ? at(this, St) : new this.Collection(this, function() {
          return Ft(void 0, e);
        });
      }, He.prototype.startsWith = function(e) {
        return typeof e != "string" ? at(this, ko) : this.between(e, e + Qt, !0, !0);
      }, He.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : Zn(this, function(t, o) {
          return t.indexOf(o[0]) === 0;
        }, [e], Qt);
      }, He.prototype.equalsIgnoreCase = function(e) {
        return Zn(this, function(t, o) {
          return t === o[0];
        }, [e], "");
      }, He.prototype.anyOfIgnoreCase = function() {
        var e = ot.apply(dt, arguments);
        return e.length === 0 ? pn(this) : Zn(this, function(t, o) {
          return o.indexOf(t) !== -1;
        }, e, "");
      }, He.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ot.apply(dt, arguments);
        return e.length === 0 ? pn(this) : Zn(this, function(t, o) {
          return o.some(function(i) {
            return t.indexOf(i) === 0;
          });
        }, e, Qt);
      }, He.prototype.anyOf = function() {
        var e = this, t = ot.apply(dt, arguments), o = this._cmp;
        try {
          t.sort(o);
        } catch {
          return at(this, St);
        }
        if (t.length === 0) return pn(this);
        var i = new this.Collection(this, function() {
          return Ft(t[0], t[t.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, t.sort(o);
        };
        var s = 0;
        return i._addAlgorithm(function(l, f, h) {
          for (var y = l.key; 0 < o(y, t[s]); ) if (++s === t.length) return f(h), !1;
          return o(y, t[s]) === 0 || (f(function() {
            l.continue(t[s]);
          }), !1);
        }), i;
      }, He.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, He.prototype.noneOf = function() {
        var e = ot.apply(dt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return at(this, St);
        }
        var t = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, He.prototype.inAnyRange = function(S, t) {
        var o = this, i = this._cmp, s = this._ascending, l = this._descending, f = this._min, h = this._max;
        if (S.length === 0) return pn(this);
        if (!S.every(function(k) {
          return k[0] !== void 0 && k[1] !== void 0 && s(k[0], k[1]) <= 0;
        })) return at(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", F.InvalidArgument);
        var y = !t || t.includeLowers !== !1, b = t && t.includeUppers === !0, x, m = s;
        function C(k, D) {
          return m(k[0], D[0]);
        }
        try {
          (x = S.reduce(function(k, D) {
            for (var I = 0, $ = k.length; I < $; ++I) {
              var W = k[I];
              if (i(D[0], W[1]) < 0 && 0 < i(D[1], W[0])) {
                W[0] = f(W[0], D[0]), W[1] = h(W[1], D[1]);
                break;
              }
            }
            return I === $ && k.push(D), k;
          }, [])).sort(C);
        } catch {
          return at(this, St);
        }
        var v = 0, _ = b ? function(k) {
          return 0 < s(k, x[v][1]);
        } : function(k) {
          return 0 <= s(k, x[v][1]);
        }, E = y ? function(k) {
          return 0 < l(k, x[v][0]);
        } : function(k) {
          return 0 <= l(k, x[v][0]);
        }, T = _, S = new this.Collection(this, function() {
          return Ft(x[0][0], x[x.length - 1][1], !y, !b);
        });
        return S._ondirectionchange = function(k) {
          m = k === "next" ? (T = _, s) : (T = E, l), x.sort(C);
        }, S._addAlgorithm(function(k, D, I) {
          for (var $, W = k.key; T(W); ) if (++v === x.length) return D(I), !1;
          return !_($ = W) && !E($) || (o._cmp(W, x[v][1]) === 0 || o._cmp(W, x[v][0]) === 0 || D(function() {
            m === s ? k.continue(x[v][0]) : k.continue(x[v][1]);
          }), !1);
        }), S;
      }, He.prototype.startsWithAnyOf = function() {
        var e = ot.apply(dt, arguments);
        return e.every(function(t) {
          return typeof t == "string";
        }) ? e.length === 0 ? pn(this) : this.inAnyRange(e.map(function(t) {
          return [t, t + Qt];
        })) : at(this, "startsWithAnyOf() only works with strings");
      }, He);
      function He() {
      }
      function xt(e) {
        return ke(function(t) {
          return Tn(t), e(t.target.error), !1;
        });
      }
      function Tn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var En = "storagemutated", Br = "x-storagemutated-1", Mt = _n(null, En), ps = (Tt.prototype._lock = function() {
        return de(!Z.global), ++this._reculock, this._reculock !== 1 || Z.global || (Z.lockOwnerFor = this), this;
      }, Tt.prototype._unlock = function() {
        if (de(!Z.global), --this._reculock == 0) for (Z.global || (Z.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Tt.prototype._locked = function() {
        return this._reculock && Z.lockOwnerFor !== this;
      }, Tt.prototype.create = function(e) {
        var t = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (de(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new F.DatabaseClosed(i);
          case "MissingAPIError":
            throw new F.MissingAPI(i.message, i);
          default:
            throw new F.OpenFailed(i);
        }
        if (!this.active) throw new F.TransactionInactive();
        return de(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = ke(function(s) {
          Tn(s), t._reject(e.error);
        }), e.onabort = ke(function(s) {
          Tn(s), t.active && t._reject(new F.Abort(e.error)), t.active = !1, t.on("abort").fire(s);
        }), e.oncomplete = ke(function() {
          t.active = !1, t._resolve(), "mutatedParts" in e && Mt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Tt.prototype._promise = function(e, t, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return je(new F.ReadOnly("Transaction is readonly"));
        if (!this.active) return je(new F.TransactionInactive());
        if (this._locked()) return new z(function(l, f) {
          i._blockedFuncs.push([function() {
            i._promise(e, t, o).then(l, f);
          }, Z]);
        });
        if (o) return jt(function() {
          var l = new z(function(f, h) {
            i._lock();
            var y = t(f, h, i);
            y && y.then && y.then(f, h);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var s = new z(function(l, f) {
          var h = t(l, f, i);
          h && h.then && h.then(l, f);
        });
        return s._lib = !0, s;
      }, Tt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Tt.prototype.waitFor = function(e) {
        var t, o = this._root(), i = z.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], t = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (t.get(-1 / 0).onsuccess = l);
        }());
        var s = o._waitingFor;
        return new z(function(l, f) {
          i.then(function(h) {
            return o._waitingQueue.push(ke(l.bind(null, h)));
          }, function(h) {
            return o._waitingQueue.push(ke(f.bind(null, h)));
          }).finally(function() {
            o._waitingFor === s && (o._waitingFor = null);
          });
        });
      }, Tt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new F.Abort()));
      }, Tt.prototype.table = function(e) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (R(t, e)) return t[e];
        var o = this.schema[e];
        if (!o) throw new F.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), t[e] = o;
      }, Tt);
      function Tt() {
      }
      function qr(e, t, o, i, s, l, f, h) {
        return { name: e, keyPath: t, unique: o, multi: i, auto: s, compound: l, src: (o && !f ? "&" : "") + (i ? "*" : "") + (s ? "++" : "") + Uo(t), type: h };
      }
      function Uo(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function $r(e, t, o) {
        return { name: e, primKey: t, indexes: o, mappedClass: null, idxByName: (i = function(s) {
          return [s.name, s];
        }, o.reduce(function(s, l, f) {
          return f = i(l, f), f && (s[f[0]] = f[1]), s;
        }, {})) };
        var i;
      }
      var On = function(e) {
        try {
          return e.only([[]]), On = function() {
            return [[]];
          }, [[]];
        } catch {
          return On = function() {
            return Qt;
          }, Qt;
        }
      };
      function Ur(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (t = e).split(".").length === 1 ? function(o) {
          return o[t];
        } : function(o) {
          return Be(o, t);
        } : function(o) {
          return Be(o, e);
        };
        var t;
      }
      function Vo(e) {
        return [].slice.call(e);
      }
      var hs = 0;
      function Cn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function ms(e, t, y) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var v = T.lower, _ = T.upper, E = T.lowerOpen, T = T.upperOpen;
          return v === void 0 ? _ === void 0 ? null : t.upperBound(_, !!T) : _ === void 0 ? t.lowerBound(v, !!E) : t.bound(v, _, !!E, !!T);
        }
        function s(C) {
          var v, _ = C.name;
          return { name: _, schema: C, mutate: function(E) {
            var T = E.trans, S = E.type, k = E.keys, D = E.values, I = E.range;
            return new Promise(function($, W) {
              $ = ke($);
              var U = T.objectStore(_), H = U.keyPath == null, X = S === "put" || S === "add";
              if (!X && S !== "delete" && S !== "deleteRange") throw new Error("Invalid operation type: " + S);
              var Y, Q = (k || D || { length: 1 }).length;
              if (k && D && k.length !== D.length) throw new Error("Given keys array must have same length as given values array.");
              if (Q === 0) return $({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ue(tt) {
                ++De, Tn(tt);
              }
              var ve = [], se = [], De = 0;
              if (S === "deleteRange") {
                if (I.type === 4) return $({ numFailures: De, failures: se, results: [], lastResult: void 0 });
                I.type === 3 ? ve.push(Y = U.clear()) : ve.push(Y = U.delete(i(I)));
              } else {
                var H = X ? H ? [D, k] : [D, null] : [k, null], ie = H[0], Xe = H[1];
                if (X) for (var ze = 0; ze < Q; ++ze) ve.push(Y = Xe && Xe[ze] !== void 0 ? U[S](ie[ze], Xe[ze]) : U[S](ie[ze])), Y.onerror = ue;
                else for (ze = 0; ze < Q; ++ze) ve.push(Y = U[S](ie[ze])), Y.onerror = ue;
              }
              function fr(tt) {
                tt = tt.target.result, ve.forEach(function(tn, ao) {
                  return tn.error != null && (se[ao] = tn.error);
                }), $({ numFailures: De, failures: se, results: S === "delete" ? k : ve.map(function(tn) {
                  return tn.result;
                }), lastResult: tt });
              }
              Y.onerror = function(tt) {
                ue(tt), fr(tt);
              }, Y.onsuccess = fr;
            });
          }, getMany: function(E) {
            var T = E.trans, S = E.keys;
            return new Promise(function(k, D) {
              k = ke(k);
              for (var I, $ = T.objectStore(_), W = S.length, U = new Array(W), H = 0, X = 0, Y = function(ve) {
                ve = ve.target, U[ve._pos] = ve.result, ++X === H && k(U);
              }, Q = xt(D), ue = 0; ue < W; ++ue) S[ue] != null && ((I = $.get(S[ue]))._pos = ue, I.onsuccess = Y, I.onerror = Q, ++H);
              H === 0 && k(U);
            });
          }, get: function(E) {
            var T = E.trans, S = E.key;
            return new Promise(function(k, D) {
              k = ke(k);
              var I = T.objectStore(_).get(S);
              I.onsuccess = function($) {
                return k($.target.result);
              }, I.onerror = xt(D);
            });
          }, query: (v = b, function(E) {
            return new Promise(function(T, S) {
              T = ke(T);
              var k, D, I, H = E.trans, $ = E.values, W = E.limit, Y = E.query, U = W === 1 / 0 ? void 0 : W, X = Y.index, Y = Y.range, H = H.objectStore(_), X = X.isPrimaryKey ? H : H.index(X.name), Y = i(Y);
              if (W === 0) return T({ result: [] });
              v ? ((U = $ ? X.getAll(Y, U) : X.getAllKeys(Y, U)).onsuccess = function(Q) {
                return T({ result: Q.target.result });
              }, U.onerror = xt(S)) : (k = 0, D = !$ && "openKeyCursor" in X ? X.openKeyCursor(Y) : X.openCursor(Y), I = [], D.onsuccess = function(Q) {
                var ue = D.result;
                return ue ? (I.push($ ? ue.value : ue.primaryKey), ++k === W ? T({ result: I }) : void ue.continue()) : T({ result: I });
              }, D.onerror = xt(S));
            });
          }), openCursor: function(E) {
            var T = E.trans, S = E.values, k = E.query, D = E.reverse, I = E.unique;
            return new Promise(function($, W) {
              $ = ke($);
              var X = k.index, U = k.range, H = T.objectStore(_), H = X.isPrimaryKey ? H : H.index(X.name), X = D ? I ? "prevunique" : "prev" : I ? "nextunique" : "next", Y = !S && "openKeyCursor" in H ? H.openKeyCursor(i(U), X) : H.openCursor(i(U), X);
              Y.onerror = xt(W), Y.onsuccess = ke(function(Q) {
                var ue, ve, se, De, ie = Y.result;
                ie ? (ie.___id = ++hs, ie.done = !1, ue = ie.continue.bind(ie), ve = (ve = ie.continuePrimaryKey) && ve.bind(ie), se = ie.advance.bind(ie), De = function() {
                  throw new Error("Cursor not stopped");
                }, ie.trans = T, ie.stop = ie.continue = ie.continuePrimaryKey = ie.advance = function() {
                  throw new Error("Cursor not started");
                }, ie.fail = ke(W), ie.next = function() {
                  var Xe = this, ze = 1;
                  return this.start(function() {
                    return ze-- ? Xe.continue() : Xe.stop();
                  }).then(function() {
                    return Xe;
                  });
                }, ie.start = function(Xe) {
                  function ze() {
                    if (Y.result) try {
                      Xe();
                    } catch (tt) {
                      ie.fail(tt);
                    }
                    else ie.done = !0, ie.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ie.stop();
                  }
                  var fr = new Promise(function(tt, tn) {
                    tt = ke(tt), Y.onerror = xt(tn), ie.fail = tn, ie.stop = function(ao) {
                      ie.stop = ie.continue = ie.continuePrimaryKey = ie.advance = De, tt(ao);
                    };
                  });
                  return Y.onsuccess = ke(function(tt) {
                    Y.onsuccess = ze, ze();
                  }), ie.continue = ue, ie.continuePrimaryKey = ve, ie.advance = se, ze(), fr;
                }, $(ie)) : $(null);
              }, W);
            });
          }, count: function(E) {
            var T = E.query, S = E.trans, k = T.index, D = T.range;
            return new Promise(function(I, $) {
              var W = S.objectStore(_), U = k.isPrimaryKey ? W : W.index(k.name), W = i(D), U = W ? U.count(W) : U.count();
              U.onsuccess = ke(function(H) {
                return I(H.target.result);
              }), U.onerror = xt($);
            });
          } };
        }
        var l, f, h, x = (f = y, h = Vo((l = e).objectStoreNames), { schema: { name: l.name, tables: h.map(function(C) {
          return f.objectStore(C);
        }).map(function(C) {
          var v = C.keyPath, T = C.autoIncrement, _ = g(v), E = {}, T = { name: C.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: v == null, compound: _, keyPath: v, autoIncrement: T, unique: !0, extractKey: Ur(v) }, indexes: Vo(C.indexNames).map(function(S) {
            return C.index(S);
          }).map(function(I) {
            var k = I.name, D = I.unique, $ = I.multiEntry, I = I.keyPath, $ = { name: k, compound: g(I), keyPath: I, unique: D, multiEntry: $, extractKey: Ur(I) };
            return E[Cn(I)] = $;
          }), getIndexByKeyPath: function(S) {
            return E[Cn(S)];
          } };
          return E[":id"] = T.primaryKey, v != null && (E[Cn(v)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < h.length && "getAll" in f.objectStore(h[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), y = x.schema, b = x.hasGetAll, x = y.tables.map(s), m = {};
        return x.forEach(function(C) {
          return m[C.name] = C;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(C) {
          if (!m[C]) throw new Error("Table '".concat(C, "' not found"));
          return m[C];
        }, MIN_KEY: -1 / 0, MAX_KEY: On(t), schema: y };
      }
      function ys(e, t, o, i) {
        var s = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = ms(t, s, i), e.dbcore.reduce(function(l, f) {
          return f = f.create, u(u({}, l), f(l));
        }, i)) };
      }
      function er(e, i) {
        var o = i.db, i = ys(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(s) {
          var l = s.name;
          e.core.schema.tables.some(function(f) {
            return f.name === l;
          }) && (s.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = s.core));
        });
      }
      function tr(e, t, o, i) {
        o.forEach(function(s) {
          var l = i[s];
          t.forEach(function(f) {
            var h = function y(b, x) {
              return qe(b, x) || (b = K(b)) && y(b, x);
            }(f, s);
            (!h || "value" in h && h.value === void 0) && (f === e.Transaction.prototype || f instanceof e.Transaction ? G(f, s, { get: function() {
              return this.table(s);
            }, set: function(y) {
              L(this, s, { value: y, writable: !0, configurable: !0, enumerable: !0 });
            } }) : f[s] = new e.Table(s, l));
          });
        });
      }
      function Vr(e, t) {
        t.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function vs(e, t) {
        return e._cfg.version - t._cfg.version;
      }
      function gs(e, t, o, i) {
        var s = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !s.$meta && (s.$meta = $r("$meta", Wo("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, s);
        l.create(o), l._completion.catch(i);
        var f = l._reject.bind(l), h = Z.transless || Z;
        jt(function() {
          return Z.trans = l, Z.transless = h, t !== 0 ? (er(e, o), b = t, ((y = l).storeNames.includes("$meta") ? y.table("$meta").get("version").then(function(x) {
            return x ?? b;
          }) : z.resolve(b)).then(function(x) {
            return C = x, v = l, _ = o, E = [], x = (m = e)._versions, T = m._dbSchema = rr(0, m.idbdb, _), (x = x.filter(function(S) {
              return S._cfg.version >= C;
            })).length !== 0 ? (x.forEach(function(S) {
              E.push(function() {
                var k = T, D = S._cfg.dbschema;
                or(m, k, _), or(m, D, _), T = m._dbSchema = D;
                var I = Hr(k, D);
                I.add.forEach(function(X) {
                  Wr(_, X[0], X[1].primKey, X[1].indexes);
                }), I.change.forEach(function(X) {
                  if (X.recreate) throw new F.Upgrade("Not yet support for changing primary key");
                  var Y = _.objectStore(X.name);
                  X.add.forEach(function(Q) {
                    return nr(Y, Q);
                  }), X.change.forEach(function(Q) {
                    Y.deleteIndex(Q.name), nr(Y, Q);
                  }), X.del.forEach(function(Q) {
                    return Y.deleteIndex(Q);
                  });
                });
                var $ = S._cfg.contentUpgrade;
                if ($ && S._cfg.version > C) {
                  er(m, _), v._memoizedTables = {};
                  var W = Ce(D);
                  I.del.forEach(function(X) {
                    W[X] = k[X];
                  }), Vr(m, [m.Transaction.prototype]), tr(m, [m.Transaction.prototype], p(W), W), v.schema = W;
                  var U, H = ht($);
                  return H && cn(), I = z.follow(function() {
                    var X;
                    (U = $(v)) && H && (X = Lt.bind(null, null), U.then(X, X));
                  }), U && typeof U.then == "function" ? z.resolve(U) : I.then(function() {
                    return U;
                  });
                }
              }), E.push(function(k) {
                var D, I, $ = S._cfg.dbschema;
                D = $, I = k, [].slice.call(I.db.objectStoreNames).forEach(function(W) {
                  return D[W] == null && I.db.deleteObjectStore(W);
                }), Vr(m, [m.Transaction.prototype]), tr(m, [m.Transaction.prototype], m._storeNames, m._dbSchema), v.schema = m._dbSchema;
              }), E.push(function(k) {
                m.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(m.idbdb.version / 10) === S._cfg.version ? (m.idbdb.deleteObjectStore("$meta"), delete m._dbSchema.$meta, m._storeNames = m._storeNames.filter(function(D) {
                  return D !== "$meta";
                })) : k.objectStore("$meta").put(S._cfg.version, "version"));
              });
            }), function S() {
              return E.length ? z.resolve(E.shift()(v.idbtrans)).then(S) : z.resolve();
            }().then(function() {
              Ho(T, _);
            })) : z.resolve();
            var m, C, v, _, E, T;
          }).catch(f)) : (p(s).forEach(function(x) {
            Wr(o, x, s[x].primKey, s[x].indexes);
          }), er(e, o), void z.follow(function() {
            return e.on.populate.fire(l);
          }).catch(f));
          var y, b;
        });
      }
      function bs(e, t) {
        Ho(e._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var o = rr(0, e.idbdb, t);
        or(e, e._dbSchema, t);
        for (var i = 0, s = Hr(o, e._dbSchema).change; i < s.length; i++) {
          var l = function(f) {
            if (f.change.length || f.recreate) return console.warn("Unable to patch indexes of table ".concat(f.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var h = t.objectStore(f.name);
            f.add.forEach(function(y) {
              ne && console.debug("Dexie upgrade patch: Creating missing index ".concat(f.name, ".").concat(y.src)), nr(h, y);
            });
          }(s[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function Hr(e, t) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) t[o] || i.del.push(o);
        for (o in t) {
          var s = e[o], l = t[o];
          if (s) {
            var f = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (s.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || s.primKey.auto !== l.primKey.auto) f.recreate = !0, i.change.push(f);
            else {
              var h = s.idxByName, y = l.idxByName, b = void 0;
              for (b in h) y[b] || f.del.push(b);
              for (b in y) {
                var x = h[b], m = y[b];
                x ? x.src !== m.src && f.change.push(m) : f.add.push(m);
              }
              (0 < f.del.length || 0 < f.add.length || 0 < f.change.length) && i.change.push(f);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Wr(e, t, o, i) {
        var s = e.db.createObjectStore(t, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return nr(s, l);
        }), s;
      }
      function Ho(e, t) {
        p(e).forEach(function(o) {
          t.db.objectStoreNames.contains(o) || (ne && console.debug("Dexie: Creating missing table", o), Wr(t, o, e[o].primKey, e[o].indexes));
        });
      }
      function nr(e, t) {
        e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function rr(e, t, o) {
        var i = {};
        return me(t.objectStoreNames, 0).forEach(function(s) {
          for (var l = o.objectStore(s), f = qr(Uo(b = l.keyPath), b || "", !0, !1, !!l.autoIncrement, b && typeof b != "string", !0), h = [], y = 0; y < l.indexNames.length; ++y) {
            var x = l.index(l.indexNames[y]), b = x.keyPath, x = qr(x.name, b, !!x.unique, !!x.multiEntry, !1, b && typeof b != "string", !1);
            h.push(x);
          }
          i[s] = $r(s, f, h);
        }), i;
      }
      function or(e, t, o) {
        for (var i = o.db.objectStoreNames, s = 0; s < i.length; ++s) {
          var l = i[s], f = o.objectStore(l);
          e._hasGetAll = "getAll" in f;
          for (var h = 0; h < f.indexNames.length; ++h) {
            var y = f.indexNames[h], b = f.index(y).keyPath, x = typeof b == "string" ? b : "[" + me(b).join("+") + "]";
            !t[l] || (b = t[l].idxByName[x]) && (b.name = y, delete t[l].idxByName[x], t[l].idxByName[y] = b);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && d.WorkerGlobalScope && d instanceof d.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function Wo(e) {
        return e.split(",").map(function(t, o) {
          var l = t.split(":"), i = (s = l[1]) === null || s === void 0 ? void 0 : s.trim(), s = (t = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(s) ? s.match(/^\[(.*)\]$/)[1].split("+") : s;
          return qr(s, l || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), g(l), o === 0, i);
        });
      }
      var _s = (hn.prototype._createTableSchema = $r, hn.prototype._parseIndexSyntax = Wo, hn.prototype._parseStoresSpec = function(e, t) {
        var o = this;
        p(e).forEach(function(i) {
          if (e[i] !== null) {
            var s = o._parseIndexSyntax(e[i]), l = s.shift();
            if (!l) throw new F.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new F.Schema("Primary key cannot be multiEntry*");
            s.forEach(function(f) {
              if (f.auto) throw new F.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!f.keyPath) throw new F.Schema("Index must have a name and cannot be an empty string");
            }), s = o._createTableSchema(i, l, s), t[i] = s;
          }
        });
      }, hn.prototype.stores = function(o) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? O(this._cfg.storesSource, o) : o;
        var o = t._versions, i = {}, s = {};
        return o.forEach(function(l) {
          O(i, l._cfg.storesSource), s = l._cfg.dbschema = {}, l._parseStoresSpec(i, s);
        }), t._dbSchema = s, Vr(t, [t._allTables, t, t.Transaction.prototype]), tr(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], p(s), s), t._storeNames = p(s), this;
      }, hn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = oe(this._cfg.contentUpgrade || N, e), this;
      }, hn);
      function hn() {
      }
      function Gr(e, t) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Nt(Yn, { addons: [], indexedDB: e, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function Yr(e) {
        return e && typeof e.databases == "function";
      }
      function Xr(e) {
        return jt(function() {
          return Z.letThrough = !0, e();
        });
      }
      function zr(e) {
        return !("from" in e);
      }
      var Ye = function(e, t) {
        if (!this) {
          var o = new Ye();
          return e && "d" in e && O(o, e), o;
        }
        O(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? t : e } : { d: 0 });
      };
      function Sn(e, t, o) {
        var i = he(t, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (zr(e)) return O(e, { from: t, to: o, d: 1 });
          var s = e.l, i = e.r;
          if (he(o, e.from) < 0) return s ? Sn(s, t, o) : e.l = { from: t, to: o, d: 1, l: null, r: null }, Yo(e);
          if (0 < he(t, e.to)) return i ? Sn(i, t, o) : e.r = { from: t, to: o, d: 1, l: null, r: null }, Yo(e);
          he(t, e.from) < 0 && (e.from = t, e.l = null, e.d = i ? i.d + 1 : 1), 0 < he(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, s && !e.l && Nn(e, s), i && o && Nn(e, i);
        }
      }
      function Nn(e, t) {
        zr(t) || function o(i, y) {
          var l = y.from, f = y.to, h = y.l, y = y.r;
          Sn(i, l, f), h && o(i, h), y && o(i, y);
        }(e, t);
      }
      function Go(e, t) {
        var o = ir(t), i = o.next();
        if (i.done) return !1;
        for (var s = i.value, l = ir(e), f = l.next(s.from), h = f.value; !i.done && !f.done; ) {
          if (he(h.from, s.to) <= 0 && 0 <= he(h.to, s.from)) return !0;
          he(s.from, h.from) < 0 ? s = (i = o.next(h.from)).value : h = (f = l.next(s.from)).value;
        }
        return !1;
      }
      function ir(e) {
        var t = zr(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, i) for (; t.n.l && he(o, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !i || he(o, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function Yo(e) {
        var t, o, i = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), s = 1 < i ? "r" : i < -1 ? "l" : "";
        s && (t = s == "r" ? "l" : "r", o = u({}, e), i = e[s], e.from = i.from, e.to = i.to, e[s] = i[s], o[s] = i[t], (e[t] = o).d = Xo(o)), e.d = Xo(e);
      }
      function Xo(o) {
        var t = o.r, o = o.l;
        return (t ? o ? Math.max(t.d, o.d) : t.d : o ? o.d : 0) + 1;
      }
      function sr(e, t) {
        return p(t).forEach(function(o) {
          e[o] ? Nn(e[o], t[o]) : e[o] = function i(s) {
            var l, f, h = {};
            for (l in s) R(s, l) && (f = s[l], h[l] = !f || typeof f != "object" || st.has(f.constructor) ? f : i(f));
            return h;
          }(t[o]);
        }), e;
      }
      function Qr(e, t) {
        return e.all || t.all || Object.keys(e).some(function(o) {
          return t[o] && Go(t[o], e[o]);
        });
      }
      j(Ye.prototype, ((pt = { add: function(e) {
        return Nn(this, e), this;
      }, addKey: function(e) {
        return Sn(this, e, e), this;
      }, addKeys: function(e) {
        var t = this;
        return e.forEach(function(o) {
          return Sn(t, o, o);
        }), this;
      }, hasKey: function(e) {
        var t = ir(this).next(e).value;
        return t && he(t.from, e) <= 0 && 0 <= he(t.to, e);
      } })[Ze] = function() {
        return ir(this);
      }, pt));
      var Zt = {}, Jr = {}, Zr = !1;
      function ar(e) {
        sr(Jr, e), Zr || (Zr = !0, setTimeout(function() {
          Zr = !1, eo(Jr, !(Jr = {}));
        }, 0));
      }
      function eo(e, t) {
        t === void 0 && (t = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, s = Object.values(Zt); i < s.length; i++) zo(f = s[i], e, o, t);
        else for (var l in e) {
          var f, h = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          h && (l = h[1], h = h[2], (f = Zt["idb://".concat(l, "/").concat(h)]) && zo(f, e, o, t));
        }
        o.forEach(function(y) {
          return y();
        });
      }
      function zo(e, t, o, i) {
        for (var s = [], l = 0, f = Object.entries(e.queries.query); l < f.length; l++) {
          for (var h = f[l], y = h[0], b = [], x = 0, m = h[1]; x < m.length; x++) {
            var C = m[x];
            Qr(t, C.obsSet) ? C.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && b.push(C);
          }
          i && s.push([y, b]);
        }
        if (i) for (var v = 0, _ = s; v < _.length; v++) {
          var E = _[v], y = E[0], b = E[1];
          e.queries.query[y] = b;
        }
      }
      function ws(e) {
        var t = e._state, o = e._deps.indexedDB;
        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? je(t.dbOpenError) : e;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var i = t.openCanceller, s = Math.round(10 * e.verno), l = !1;
        function f() {
          if (t.openCanceller !== i) throw new F.DatabaseClosed("db.open() was cancelled");
        }
        function h() {
          return new z(function(C, v) {
            if (f(), !o) throw new F.MissingAPI();
            var _ = e.name, E = t.autoSchema || !s ? o.open(_) : o.open(_, s);
            if (!E) throw new F.MissingAPI();
            E.onerror = xt(v), E.onblocked = ke(e._fireOnBlocked), E.onupgradeneeded = ke(function(T) {
              var S;
              x = E.transaction, t.autoSchema && !e._options.allowEmptyDB ? (E.onerror = Tn, x.abort(), E.result.close(), (S = o.deleteDatabase(_)).onsuccess = S.onerror = ke(function() {
                v(new F.NoSuchDatabase("Database ".concat(_, " doesnt exist")));
              })) : (x.onerror = xt(v), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, m = T < 1, e.idbdb = E.result, l && bs(e, x), gs(e, T / 10, x, v));
            }, v), E.onsuccess = ke(function() {
              x = null;
              var T, S, k, D, I, $ = e.idbdb = E.result, W = me($.objectStoreNames);
              if (0 < W.length) try {
                var U = $.transaction((D = W).length === 1 ? D[0] : D, "readonly");
                if (t.autoSchema) S = $, k = U, (T = e).verno = S.version / 10, k = T._dbSchema = rr(0, S, k), T._storeNames = me(S.objectStoreNames, 0), tr(T, [T._allTables], p(k), k);
                else if (or(e, e._dbSchema, U), ((I = Hr(rr(0, (I = e).idbdb, U), I._dbSchema)).add.length || I.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), $.close(), s = $.version + 1, l = !0, C(h());
                er(e, U);
              } catch {
              }
              fn.push(e), $.onversionchange = ke(function(H) {
                t.vcFired = !0, e.on("versionchange").fire(H);
              }), $.onclose = ke(function(H) {
                e.on("close").fire(H);
              }), m && (I = e._deps, U = _, $ = I.indexedDB, I = I.IDBKeyRange, Yr($) || U === Yn || Gr($, I).put({ name: U }).catch(N)), C();
            }, v);
          }).catch(function(C) {
            switch (C?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), h();
                break;
              case "VersionError":
                if (0 < s) return s = 0, h();
            }
            return z.reject(C);
          });
        }
        var y, b = t.dbReadyResolve, x = null, m = !1;
        return z.race([i, (typeof navigator > "u" ? z.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(C) {
          function v() {
            return indexedDB.databases().finally(C);
          }
          y = setInterval(v, 100), v();
        }).finally(function() {
          return clearInterval(y);
        }) : Promise.resolve()).then(h)]).then(function() {
          return f(), t.onReadyBeingFired = [], z.resolve(Xr(function() {
            return e.on.ready.fire(e.vip);
          })).then(function C() {
            if (0 < t.onReadyBeingFired.length) {
              var v = t.onReadyBeingFired.reduce(oe, N);
              return t.onReadyBeingFired = [], z.resolve(Xr(function() {
                return v(e.vip);
              })).then(C);
            }
          });
        }).finally(function() {
          t.openCanceller === i && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(C) {
          t.dbOpenError = C;
          try {
            x && x.abort();
          } catch {
          }
          return i === t.openCanceller && e._close(), je(C);
        }).finally(function() {
          t.openComplete = !0, b();
        }).then(function() {
          var C;
          return m && (C = {}, e.tables.forEach(function(v) {
            v.schema.indexes.forEach(function(_) {
              _.name && (C["idb://".concat(e.name, "/").concat(v.name, "/").concat(_.name)] = new Ye(-1 / 0, [[[]]]));
            }), C["idb://".concat(e.name, "/").concat(v.name, "/")] = C["idb://".concat(e.name, "/").concat(v.name, "/:dels")] = new Ye(-1 / 0, [[[]]]);
          }), Mt(En).fire(C), eo(C, !0)), e;
        });
      }
      function to(e) {
        function t(l) {
          return e.next(l);
        }
        var o = s(t), i = s(function(l) {
          return e.throw(l);
        });
        function s(l) {
          return function(y) {
            var h = l(y), y = h.value;
            return h.done ? y : y && typeof y.then == "function" ? y.then(o, i) : g(y) ? Promise.all(y).then(o, i) : o(y);
          };
        }
        return s(t)();
      }
      function ur(e, t, o) {
        for (var i = g(e) ? e.slice() : [e], s = 0; s < o; ++s) i.push(t);
        return i;
      }
      var xs = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema, s = {}, l = [];
          function f(m, C, v) {
            var _ = Cn(m), E = s[_] = s[_] || [], T = m == null ? 0 : typeof m == "string" ? 1 : m.length, S = 0 < C, S = u(u({}, v), { name: S ? "".concat(_, "(virtual-from:").concat(v.name, ")") : v.name, lowLevelIndex: v, isVirtual: S, keyTail: C, keyLength: T, extractKey: Ur(m), unique: !S && v.unique });
            return E.push(S), S.isPrimaryKey || l.push(S), 1 < T && f(T === 2 ? m[0] : m.slice(0, T - 1), C + 1, v), E.sort(function(k, D) {
              return k.keyTail - D.keyTail;
            }), S;
          }
          t = f(i.primaryKey.keyPath, 0, i.primaryKey), s[":id"] = [t];
          for (var h = 0, y = i.indexes; h < y.length; h++) {
            var b = y[h];
            f(b.keyPath, 0, b);
          }
          function x(m) {
            var C, v = m.query.index;
            return v.isVirtual ? u(u({}, m), { query: { index: v.lowLevelIndex, range: (C = m.query.range, v = v.keyTail, { type: C.type === 1 ? 2 : C.type, lower: ur(C.lower, C.lowerOpen ? e.MAX_KEY : e.MIN_KEY, v), lowerOpen: !0, upper: ur(C.upper, C.upperOpen ? e.MIN_KEY : e.MAX_KEY, v), upperOpen: !0 }) } }) : m;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: t, indexes: l, getIndexByKeyPath: function(m) {
            return (m = s[Cn(m)]) && m[0];
          } }), count: function(m) {
            return o.count(x(m));
          }, query: function(m) {
            return o.query(x(m));
          }, openCursor: function(m) {
            var C = m.query.index, v = C.keyTail, _ = C.isVirtual, E = C.keyLength;
            return _ ? o.openCursor(x(m)).then(function(S) {
              return S && T(S);
            }) : o.openCursor(m);
            function T(S) {
              return Object.create(S, { continue: { value: function(k) {
                k != null ? S.continue(ur(k, m.reverse ? e.MAX_KEY : e.MIN_KEY, v)) : m.unique ? S.continue(S.key.slice(0, E).concat(m.reverse ? e.MIN_KEY : e.MAX_KEY, v)) : S.continue();
              } }, continuePrimaryKey: { value: function(k, D) {
                S.continuePrimaryKey(ur(k, e.MAX_KEY, v), D);
              } }, primaryKey: { get: function() {
                return S.primaryKey;
              } }, key: { get: function() {
                var k = S.key;
                return E === 1 ? k[0] : k.slice(0, E);
              } }, value: { get: function() {
                return S.value;
              } } });
            }
          } });
        } });
      } };
      function no(e, t, o, i) {
        return o = o || {}, i = i || "", p(e).forEach(function(s) {
          var l, f, h;
          R(t, s) ? (l = e[s], f = t[s], typeof l == "object" && typeof f == "object" && l && f ? (h = Pt(l)) !== Pt(f) ? o[i + s] = t[s] : h === "Object" ? no(l, f, o, i + s + ".") : l !== f && (o[i + s] = t[s]) : l !== f && (o[i + s] = t[s])) : o[i + s] = void 0;
        }), p(t).forEach(function(s) {
          R(e, s) || (o[i + s] = t[s]);
        }), o;
      }
      function ro(e, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey);
      }
      var Ts = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(s) {
            var l = Z.trans, f = l.table(t).hook, h = f.deleting, y = f.creating, b = f.updating;
            switch (s.type) {
              case "add":
                if (y.fire === N) break;
                return l._promise("readwrite", function() {
                  return x(s);
                }, !0);
              case "put":
                if (y.fire === N && b.fire === N) break;
                return l._promise("readwrite", function() {
                  return x(s);
                }, !0);
              case "delete":
                if (h.fire === N) break;
                return l._promise("readwrite", function() {
                  return x(s);
                }, !0);
              case "deleteRange":
                if (h.fire === N) break;
                return l._promise("readwrite", function() {
                  return function m(C, v, _) {
                    return o.query({ trans: C, values: !1, query: { index: i, range: v }, limit: _ }).then(function(E) {
                      var T = E.result;
                      return x({ type: "delete", keys: T, trans: C }).then(function(S) {
                        return 0 < S.numFailures ? Promise.reject(S.failures[0]) : T.length < _ ? { failures: [], numFailures: 0, lastResult: void 0 } : m(C, u(u({}, v), { lower: T[T.length - 1], lowerOpen: !0 }), _);
                      });
                    });
                  }(s.trans, s.range, 1e4);
                }, !0);
            }
            return o.mutate(s);
            function x(m) {
              var C, v, _, E = Z.trans, T = m.keys || ro(i, m);
              if (!T) throw new Error("Keys missing");
              return (m = m.type === "add" || m.type === "put" ? u(u({}, m), { keys: T }) : u({}, m)).type !== "delete" && (m.values = c([], m.values)), m.keys && (m.keys = c([], m.keys)), C = o, _ = T, ((v = m).type === "add" ? Promise.resolve([]) : C.getMany({ trans: v.trans, keys: _, cache: "immutable" })).then(function(S) {
                var k = T.map(function(D, I) {
                  var $, W, U, H = S[I], X = { onerror: null, onsuccess: null };
                  return m.type === "delete" ? h.fire.call(X, D, H, E) : m.type === "add" || H === void 0 ? ($ = y.fire.call(X, D, m.values[I], E), D == null && $ != null && (m.keys[I] = D = $, i.outbound || ye(m.values[I], i.keyPath, D))) : ($ = no(H, m.values[I]), (W = b.fire.call(X, $, D, H, E)) && (U = m.values[I], Object.keys(W).forEach(function(Y) {
                    R(U, Y) ? U[Y] = W[Y] : ye(U, Y, W[Y]);
                  }))), X;
                });
                return o.mutate(m).then(function(D) {
                  for (var I = D.failures, $ = D.results, W = D.numFailures, D = D.lastResult, U = 0; U < T.length; ++U) {
                    var H = ($ || T)[U], X = k[U];
                    H == null ? X.onerror && X.onerror(I[U]) : X.onsuccess && X.onsuccess(m.type === "put" && S[U] ? m.values[U] : H);
                  }
                  return { failures: I, results: $, numFailures: W, lastResult: D };
                }).catch(function(D) {
                  return k.forEach(function(I) {
                    return I.onerror && I.onerror(D);
                  }), Promise.reject(D);
                });
              });
            }
          } });
        } });
      } };
      function Qo(e, t, o) {
        try {
          if (!t || t.keys.length < e.length) return null;
          for (var i = [], s = 0, l = 0; s < t.keys.length && l < e.length; ++s) he(t.keys[s], e[l]) === 0 && (i.push(o ? nt(t.values[s]) : t.values[s]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Es = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(t) {
          var o = e.table(t);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var s = Qo(i.keys, i.trans._cache, i.cache === "clone");
            return s ? z.resolve(s) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? nt(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function Jo(e, t) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function Zo(e, t) {
        switch (e) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Os = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var t = e.schema.name, o = new Ye(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, s, l) {
          if (Z.subscr && s !== "readonly") throw new F.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(Z.querier));
          return e.transaction(i, s, l);
        }, table: function(i) {
          var s = e.table(i), l = s.schema, f = l.primaryKey, m = l.indexes, h = f.extractKey, y = f.outbound, b = f.autoIncrement && m.filter(function(v) {
            return v.compound && v.keyPath.includes(f.keyPath);
          }), x = u(u({}, s), { mutate: function(v) {
            function _(Y) {
              return Y = "idb://".concat(t, "/").concat(i, "/").concat(Y), D[Y] || (D[Y] = new Ye());
            }
            var E, T, S, k = v.trans, D = v.mutatedParts || (v.mutatedParts = {}), I = _(""), $ = _(":dels"), W = v.type, X = v.type === "deleteRange" ? [v.range] : v.type === "delete" ? [v.keys] : v.values.length < 50 ? [ro(f, v).filter(function(Y) {
              return Y;
            }), v.values] : [], U = X[0], H = X[1], X = v.trans._cache;
            return g(U) ? (I.addKeys(U), (X = W === "delete" || U.length === H.length ? Qo(U, X) : null) || $.addKeys(U), (X || H) && (E = _, T = X, S = H, l.indexes.forEach(function(Y) {
              var Q = E(Y.name || "");
              function ue(se) {
                return se != null ? Y.extractKey(se) : null;
              }
              function ve(se) {
                return Y.multiEntry && g(se) ? se.forEach(function(De) {
                  return Q.addKey(De);
                }) : Q.addKey(se);
              }
              (T || S).forEach(function(se, Xe) {
                var ie = T && ue(T[Xe]), Xe = S && ue(S[Xe]);
                he(ie, Xe) !== 0 && (ie != null && ve(ie), Xe != null && ve(Xe));
              });
            }))) : U ? (H = { from: (H = U.lower) !== null && H !== void 0 ? H : e.MIN_KEY, to: (H = U.upper) !== null && H !== void 0 ? H : e.MAX_KEY }, $.add(H), I.add(H)) : (I.add(o), $.add(o), l.indexes.forEach(function(Y) {
              return _(Y.name).add(o);
            })), s.mutate(v).then(function(Y) {
              return !U || v.type !== "add" && v.type !== "put" || (I.addKeys(Y.results), b && b.forEach(function(Q) {
                for (var ue = v.values.map(function(ie) {
                  return Q.extractKey(ie);
                }), ve = Q.keyPath.findIndex(function(ie) {
                  return ie === f.keyPath;
                }), se = 0, De = Y.results.length; se < De; ++se) ue[se][ve] = Y.results[se];
                _(Q.name).addKeys(ue);
              })), k.mutatedParts = sr(k.mutatedParts || {}, D), Y;
            });
          } }), m = function(_) {
            var E = _.query, _ = E.index, E = E.range;
            return [_, new Ye((_ = E.lower) !== null && _ !== void 0 ? _ : e.MIN_KEY, (E = E.upper) !== null && E !== void 0 ? E : e.MAX_KEY)];
          }, C = { get: function(v) {
            return [f, new Ye(v.key)];
          }, getMany: function(v) {
            return [f, new Ye().addKeys(v.keys)];
          }, count: m, query: m, openCursor: m };
          return p(C).forEach(function(v) {
            x[v] = function(_) {
              var E = Z.subscr, T = !!E, S = Jo(Z, s) && Zo(v, _) ? _.obsSet = {} : E;
              if (T) {
                var k = function(H) {
                  return H = "idb://".concat(t, "/").concat(i, "/").concat(H), S[H] || (S[H] = new Ye());
                }, D = k(""), I = k(":dels"), E = C[v](_), T = E[0], E = E[1];
                if ((v === "query" && T.isPrimaryKey && !_.values ? I : k(T.name || "")).add(E), !T.isPrimaryKey) {
                  if (v !== "count") {
                    var $ = v === "query" && y && _.values && s.query(u(u({}, _), { values: !1 }));
                    return s[v].apply(this, arguments).then(function(H) {
                      if (v === "query") {
                        if (y && _.values) return $.then(function(ue) {
                          return ue = ue.result, D.addKeys(ue), H;
                        });
                        var X = _.values ? H.result.map(h) : H.result;
                        (_.values ? D : I).addKeys(X);
                      } else if (v === "openCursor") {
                        var Y = H, Q = _.values;
                        return Y && Object.create(Y, { key: { get: function() {
                          return I.addKey(Y.primaryKey), Y.key;
                        } }, primaryKey: { get: function() {
                          var ue = Y.primaryKey;
                          return I.addKey(ue), ue;
                        } }, value: { get: function() {
                          return Q && D.addKey(Y.primaryKey), Y.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  I.add(o);
                }
              }
              return s[v].apply(this, arguments);
            };
          }), x;
        } });
      } };
      function ei(e, t, o) {
        if (o.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var i = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return o.numFailures === i ? null : (t = u({}, t), g(t.keys) && (t.keys = t.keys.filter(function(s, l) {
          return !(l in o.failures);
        })), "values" in t && g(t.values) && (t.values = t.values.filter(function(s, l) {
          return !(l in o.failures);
        })), t);
      }
      function oo(e, t) {
        return o = e, ((i = t).lower === void 0 || (i.lowerOpen ? 0 < he(o, i.lower) : 0 <= he(o, i.lower))) && (e = e, (t = t).upper === void 0 || (t.upperOpen ? he(e, t.upper) < 0 : he(e, t.upper) <= 0));
        var o, i;
      }
      function ti(e, t, C, i, s, l) {
        if (!C || C.length === 0) return e;
        var f = t.query.index, h = f.multiEntry, y = t.query.range, b = i.schema.primaryKey.extractKey, x = f.extractKey, m = (f.lowLevelIndex || f).extractKey, C = C.reduce(function(v, _) {
          var E = v, T = [];
          if (_.type === "add" || _.type === "put") for (var S = new Ye(), k = _.values.length - 1; 0 <= k; --k) {
            var D, I = _.values[k], $ = b(I);
            S.hasKey($) || (D = x(I), (h && g(D) ? D.some(function(Y) {
              return oo(Y, y);
            }) : oo(D, y)) && (S.addKey($), T.push(I)));
          }
          switch (_.type) {
            case "add":
              var W = new Ye().addKeys(t.values ? v.map(function(Q) {
                return b(Q);
              }) : v), E = v.concat(t.values ? T.filter(function(Q) {
                return Q = b(Q), !W.hasKey(Q) && (W.addKey(Q), !0);
              }) : T.map(function(Q) {
                return b(Q);
              }).filter(function(Q) {
                return !W.hasKey(Q) && (W.addKey(Q), !0);
              }));
              break;
            case "put":
              var U = new Ye().addKeys(_.values.map(function(Q) {
                return b(Q);
              }));
              E = v.filter(function(Q) {
                return !U.hasKey(t.values ? b(Q) : Q);
              }).concat(t.values ? T : T.map(function(Q) {
                return b(Q);
              }));
              break;
            case "delete":
              var H = new Ye().addKeys(_.keys);
              E = v.filter(function(Q) {
                return !H.hasKey(t.values ? b(Q) : Q);
              });
              break;
            case "deleteRange":
              var X = _.range;
              E = v.filter(function(Q) {
                return !oo(b(Q), X);
              });
          }
          return E;
        }, e);
        return C === e ? e : (C.sort(function(v, _) {
          return he(m(v), m(_)) || he(b(v), b(_));
        }), t.limit && t.limit < 1 / 0 && (C.length > t.limit ? C.length = t.limit : e.length === t.limit && C.length < t.limit && (s.dirty = !0)), l ? Object.freeze(C) : C);
      }
      function ni(e, t) {
        return he(e.lower, t.lower) === 0 && he(e.upper, t.upper) === 0 && !!e.lowerOpen == !!t.lowerOpen && !!e.upperOpen == !!t.upperOpen;
      }
      function Cs(e, t) {
        return function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = he(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, t.lower, e.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = he(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, t.upper, e.upperOpen, t.upperOpen);
      }
      function Ss(e, t, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var s, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (s = e, l = t, setTimeout(function() {
            s.subscribers.size === 0 && Ie(l, s);
          }, 3e3));
        });
      }
      var Ns = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var t = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, s) {
          var l, f, h = e.transaction(o, i, s);
          return i === "readwrite" && (f = (l = new AbortController()).signal, s = function(y) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var b = /* @__PURE__ */ new Set(), x = 0, m = o; x < m.length; x++) {
                  var C = m[x], v = Zt["idb://".concat(t, "/").concat(C)];
                  if (v) {
                    var _ = e.table(C), E = v.optimisticOps.filter(function(Q) {
                      return Q.trans === h;
                    });
                    if (h._explicit && y && h.mutatedParts) for (var T = 0, S = Object.values(v.queries.query); T < S.length; T++) for (var k = 0, D = (W = S[T]).slice(); k < D.length; k++) Qr((U = D[k]).obsSet, h.mutatedParts) && (Ie(W, U), U.subscribers.forEach(function(Q) {
                      return b.add(Q);
                    }));
                    else if (0 < E.length) {
                      v.optimisticOps = v.optimisticOps.filter(function(Q) {
                        return Q.trans !== h;
                      });
                      for (var I = 0, $ = Object.values(v.queries.query); I < $.length; I++) for (var W, U, H, X = 0, Y = (W = $[I]).slice(); X < Y.length; X++) (U = Y[X]).res != null && h.mutatedParts && (y && !U.dirty ? (H = Object.isFrozen(U.res), H = ti(U.res, U.req, E, _, U, H), U.dirty ? (Ie(W, U), U.subscribers.forEach(function(Q) {
                        return b.add(Q);
                      })) : H !== U.res && (U.res = H, U.promise = z.resolve({ result: H }))) : (U.dirty && Ie(W, U), U.subscribers.forEach(function(Q) {
                        return b.add(Q);
                      })));
                    }
                  }
                }
                b.forEach(function(Q) {
                  return Q();
                });
              }
            };
          }, h.addEventListener("abort", s(!1), { signal: f }), h.addEventListener("error", s(!1), { signal: f }), h.addEventListener("complete", s(!0), { signal: f })), h;
        }, table: function(o) {
          var i = e.table(o), s = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var f = Z.trans;
            if (s.outbound || f.db._options.cache === "disabled" || f.explicit || f.idbtrans.mode !== "readwrite") return i.mutate(l);
            var h = Zt["idb://".concat(t, "/").concat(o)];
            return h ? (f = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || ro(s, l).some(function(y) {
              return y == null;
            })) ? (h.optimisticOps.push(l), l.mutatedParts && ar(l.mutatedParts), f.then(function(y) {
              0 < y.numFailures && (Ie(h.optimisticOps, l), (y = ei(0, l, y)) && h.optimisticOps.push(y), l.mutatedParts && ar(l.mutatedParts));
            }), f.catch(function() {
              Ie(h.optimisticOps, l), l.mutatedParts && ar(l.mutatedParts);
            })) : f.then(function(y) {
              var b = ei(0, u(u({}, l), { values: l.values.map(function(x, m) {
                var C;
                return y.failures[m] || (x = (C = s.keyPath) !== null && C !== void 0 && C.includes(".") ? nt(x) : u({}, x), ye(x, s.keyPath, y.results[m])), x;
              }) }), y);
              h.optimisticOps.push(b), queueMicrotask(function() {
                return l.mutatedParts && ar(l.mutatedParts);
              });
            }), f) : i.mutate(l);
          }, query: function(l) {
            if (!Jo(Z, i) || !Zo("query", l)) return i.query(l);
            var f = ((b = Z.trans) === null || b === void 0 ? void 0 : b.db._options.cache) === "immutable", m = Z, h = m.requery, y = m.signal, b = function(_, E, T, S) {
              var k = Zt["idb://".concat(_, "/").concat(E)];
              if (!k) return [];
              if (!(E = k.queries[T])) return [null, !1, k, null];
              var D = E[(S.query ? S.query.index.name : null) || ""];
              if (!D) return [null, !1, k, null];
              switch (T) {
                case "query":
                  var I = D.find(function($) {
                    return $.req.limit === S.limit && $.req.values === S.values && ni($.req.query.range, S.query.range);
                  });
                  return I ? [I, !0, k, D] : [D.find(function($) {
                    return ("limit" in $.req ? $.req.limit : 1 / 0) >= S.limit && (!S.values || $.req.values) && Cs($.req.query.range, S.query.range);
                  }), !1, k, D];
                case "count":
                  return I = D.find(function($) {
                    return ni($.req.query.range, S.query.range);
                  }), [I, !!I, k, D];
              }
            }(t, o, "query", l), x = b[0], m = b[1], C = b[2], v = b[3];
            return x && m ? x.obsSet = l.obsSet : (m = i.query(l).then(function(_) {
              var E = _.result;
              if (x && (x.res = E), f) {
                for (var T = 0, S = E.length; T < S; ++T) Object.freeze(E[T]);
                Object.freeze(E);
              } else _.result = nt(E);
              return _;
            }).catch(function(_) {
              return v && x && Ie(v, x), Promise.reject(_);
            }), x = { obsSet: l.obsSet, promise: m, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, v ? v.push(x) : (v = [x], (C = C || (Zt["idb://".concat(t, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = v)), Ss(x, v, h, y), x.promise.then(function(_) {
              return { result: ti(_.result, l, C?.optimisticOps, i, x, f) };
            });
          } });
        } });
      } };
      function lr(e, t) {
        return new Proxy(e, { get: function(o, i, s) {
          return i === "db" ? t : Reflect.get(o, i, s);
        } });
      }
      var Nt = (Le.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new F.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new F.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var t = this._versions, o = t.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), t.push(o), t.sort(vs), o.stores({}), this._state.autoSchema = !1, o);
      }, Le.prototype._whenReady = function(e) {
        var t = this;
        return this.idbdb && (this._state.openComplete || Z.letThrough || this._vip) ? e() : new z(function(o, i) {
          if (t._state.openComplete) return i(new F.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void i(new F.DatabaseClosed());
            t.open().catch(N);
          }
          t._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, Le.prototype.use = function(e) {
        var t = e.stack, o = e.create, i = e.level, s = e.name;
        return s && this.unuse({ stack: t, name: s }), e = this._middlewares[t] || (this._middlewares[t] = []), e.push({ stack: t, create: o, level: i ?? 10, name: s }), e.sort(function(l, f) {
          return l.level - f.level;
        }), this;
      }, Le.prototype.unuse = function(e) {
        var t = e.stack, o = e.name, i = e.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(s) {
          return i ? s.create !== i : !!o && s.name !== o;
        })), this;
      }, Le.prototype.open = function() {
        var e = this;
        return zt(et, function() {
          return ws(e);
        });
      }, Le.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, t = fn.indexOf(this);
        if (0 <= t && fn.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new z(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new z(function(o, i) {
          e.cancelOpen = i;
        }));
      }, Le.prototype.close = function(o) {
        var t = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        t ? (o.isBeingOpened && o.cancelOpen(new F.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new F.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, Le.prototype.delete = function(e) {
        var t = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new z(function(s, l) {
          function f() {
            t.close(e);
            var h = t._deps.indexedDB.deleteDatabase(t.name);
            h.onsuccess = ke(function() {
              var y, b, x;
              y = t._deps, b = t.name, x = y.indexedDB, y = y.IDBKeyRange, Yr(x) || b === Yn || Gr(x, y).delete(b).catch(N), s();
            }), h.onerror = xt(l), h.onblocked = t._fireOnBlocked;
          }
          if (o) throw new F.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(f) : f();
        });
      }, Le.prototype.backendDB = function() {
        return this.idbdb;
      }, Le.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Le.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, Le.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Le.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Le.prototype, "tables", { get: function() {
        var e = this;
        return p(this._allTables).map(function(t) {
          return e._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), Le.prototype.transaction = function() {
        var e = (function(t, o, i) {
          var s = arguments.length;
          if (s < 2) throw new F.InvalidArgument("Too few arguments");
          for (var l = new Array(s - 1); --s; ) l[s - 1] = arguments[s];
          return i = l.pop(), [t, We(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, Le.prototype._transaction = function(e, t, o) {
        var i = this, s = Z.trans;
        s && s.db === this && e.indexOf("!") === -1 || (s = null);
        var l, f, h = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (f = t.map(function(b) {
            if (b = b instanceof i.Table ? b.name : b, typeof b != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return b;
          }), e == "r" || e === Lr) l = Lr;
          else {
            if (e != "rw" && e != Kr) throw new F.InvalidArgument("Invalid transaction mode: " + e);
            l = Kr;
          }
          if (s) {
            if (s.mode === Lr && l === Kr) {
              if (!h) throw new F.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              s = null;
            }
            s && f.forEach(function(b) {
              if (s && s.storeNames.indexOf(b) === -1) {
                if (!h) throw new F.SubTransaction("Table " + b + " not included in parent transaction.");
                s = null;
              }
            }), h && s && !s.active && (s = null);
          }
        } catch (b) {
          return s ? s._promise(null, function(x, m) {
            m(b);
          }) : je(b);
        }
        var y = (function b(x, m, C, v, _) {
          return z.resolve().then(function() {
            var E = Z.transless || Z, T = x._createTransaction(m, C, x._dbSchema, v);
            if (T.explicit = !0, E = { trans: T, transless: E }, v) T.idbtrans = v.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, x._state.PR1398_maxLoop = 3;
            } catch (D) {
              return D.name === A.InvalidState && x.isOpen() && 0 < --x._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), x.close({ disableAutoOpen: !1 }), x.open().then(function() {
                return b(x, m, C, null, _);
              })) : je(D);
            }
            var S, k = ht(_);
            return k && cn(), E = z.follow(function() {
              var D;
              (S = _.call(T, T)) && (k ? (D = Lt.bind(null, null), S.then(D, D)) : typeof S.next == "function" && typeof S.throw == "function" && (S = to(S)));
            }, E), (S && typeof S.then == "function" ? z.resolve(S).then(function(D) {
              return T.active ? D : je(new F.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : E.then(function() {
              return S;
            })).then(function(D) {
              return v && T._resolve(), T._completion.then(function() {
                return D;
              });
            }).catch(function(D) {
              return T._reject(D), je(D);
            });
          });
        }).bind(null, this, l, f, s, o);
        return s ? s._promise(l, y, "lock") : Z.trans ? zt(Z.transless, function() {
          return i._whenReady(y);
        }) : this._whenReady(y);
      }, Le.prototype.table = function(e) {
        if (!R(this._allTables, e)) throw new F.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, Le);
      function Le(e, t) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = Le.dependencies;
        this._options = t = u({ addons: Le.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, i = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var s, l, f, h, y, b = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: N, dbReadyPromise: null, cancelOpen: N, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        b.dbReadyPromise = new z(function(m) {
          b.dbReadyResolve = m;
        }), b.openCanceller = new z(function(m, C) {
          b.cancelOpen = C;
        }), this._state = b, this.name = e, this.on = _n(this, "populate", "blocked", "versionchange", "close", { ready: [oe, N] }), this.once = function(m, C) {
          var v = function() {
            for (var _ = [], E = 0; E < arguments.length; E++) _[E] = arguments[E];
            o.on(m).unsubscribe(v), C.apply(o, _);
          };
          return o.on(m, v);
        }, this.on.ready.subscribe = Ee(this.on.ready.subscribe, function(m) {
          return function(C, v) {
            Le.vip(function() {
              var _, E = o._state;
              E.openComplete ? (E.dbOpenError || z.resolve().then(C), v && m(C)) : E.onReadyBeingFired ? (E.onReadyBeingFired.push(C), v && m(C)) : (m(C), _ = o, v || m(function T() {
                _.on.ready.unsubscribe(C), _.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (s = this, wn(cs.prototype, function(S, T) {
          this.db = s;
          var v = Do, _ = null;
          if (T) try {
            v = T();
          } catch (k) {
            _ = k;
          }
          var E = S._ctx, T = E.table, S = T.hook.reading.fire;
          this._ctx = { table: T, index: E.index, isPrimKey: !E.index || T.schema.primKey.keyPath && E.index === T.schema.primKey.name, range: v, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: _, or: E.or, valueMapper: S !== M ? S : null };
        })), this.Table = (l = this, wn(Lo.prototype, function(m, C, v) {
          this.db = l, this._tx = v, this.name = m, this.schema = C, this.hook = l._allTables[m] ? l._allTables[m].hook : _n(null, { creating: [re, N], reading: [J, M], updating: [ae, N], deleting: [te, N] });
        })), this.Transaction = (f = this, wn(ps.prototype, function(m, C, v, _, E) {
          var T = this;
          m !== "readonly" && C.forEach(function(S) {
            S = (S = v[S]) === null || S === void 0 ? void 0 : S.yProps, S && (C = C.concat(S.map(function(k) {
              return k.updatesTable;
            })));
          }), this.db = f, this.mode = m, this.storeNames = C, this.schema = v, this.chromeTransactionDurability = _, this.idbtrans = null, this.on = _n(this, "complete", "error", "abort"), this.parent = E || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new z(function(S, k) {
            T._resolve = S, T._reject = k;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(S) {
            var k = T.active;
            return T.active = !1, T.on.error.fire(S), T.parent ? T.parent._reject(S) : k && T.idbtrans && T.idbtrans.abort(), je(S);
          });
        })), this.Version = (h = this, wn(_s.prototype, function(m) {
          this.db = h, this._cfg = { version: m, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (y = this, wn($o.prototype, function(m, C, v) {
          if (this.db = y, this._ctx = { table: m, index: C === ":id" ? null : C, or: v }, this._cmp = this._ascending = he, this._descending = function(_, E) {
            return he(E, _);
          }, this._max = function(_, E) {
            return 0 < he(_, E) ? _ : E;
          }, this._min = function(_, E) {
            return he(_, E) < 0 ? _ : E;
          }, this._IDBKeyRange = y._deps.IDBKeyRange, !this._IDBKeyRange) throw new F.MissingAPI();
        })), this.on("versionchange", function(m) {
          0 < m.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(m) {
          !m.newVersion || m.newVersion < m.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(m.oldVersion / 10));
        }), this._maxKey = On(t.IDBKeyRange), this._createTransaction = function(m, C, v, _) {
          return new o.Transaction(m, C, v, o._options.chromeTransactionDurability, _);
        }, this._fireOnBlocked = function(m) {
          o.on("blocked").fire(m), fn.filter(function(C) {
            return C.name === o.name && C !== o && !C._state.vcFired;
          }).map(function(C) {
            return C.on("versionchange").fire(m);
          });
        }, this.use(Es), this.use(Ns), this.use(Os), this.use(xs), this.use(Ts);
        var x = new Proxy(this, { get: function(m, C, v) {
          if (C === "_vip") return !0;
          if (C === "table") return function(E) {
            return lr(o.table(E), x);
          };
          var _ = Reflect.get(m, C, v);
          return _ instanceof Lo ? lr(_, x) : C === "tables" ? _.map(function(E) {
            return lr(E, x);
          }) : C === "_createTransaction" ? function() {
            return lr(_.apply(this, arguments), x);
          } : _;
        } });
        this.vip = x, i.forEach(function(m) {
          return m(o);
        });
      }
      var cr, pt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", As = (io.prototype.subscribe = function(e, t, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: o });
      }, io.prototype[pt] = function() {
        return this;
      }, io);
      function io(e) {
        this._subscribe = e;
      }
      try {
        cr = { indexedDB: d.indexedDB || d.mozIndexedDB || d.webkitIndexedDB || d.msIndexedDB, IDBKeyRange: d.IDBKeyRange || d.webkitIDBKeyRange };
      } catch {
        cr = { indexedDB: null, IDBKeyRange: null };
      }
      function ri(e) {
        var t, o = !1, i = new As(function(s) {
          var l = ht(e), f, h = !1, y = {}, b = {}, x = { get closed() {
            return h;
          }, unsubscribe: function() {
            h || (h = !0, f && f.abort(), m && Mt.storagemutated.unsubscribe(v));
          } };
          s.start && s.start(x);
          var m = !1, C = function() {
            return jr(_);
          }, v = function(E) {
            sr(y, E), Qr(b, y) && C();
          }, _ = function() {
            var E, T, S;
            !h && cr.indexedDB && (y = {}, E = {}, f && f.abort(), f = new AbortController(), S = function(k) {
              var D = un();
              try {
                l && cn();
                var I = jt(e, k);
                return I = l ? I.finally(Lt) : I;
              } finally {
                D && ln();
              }
            }(T = { subscr: E, signal: f.signal, requery: C, querier: e, trans: null }), Promise.resolve(S).then(function(k) {
              o = !0, t = k, h || T.signal.aborted || (y = {}, function(D) {
                for (var I in D) if (R(D, I)) return;
                return 1;
              }(b = E) || m || (Mt(En, v), m = !0), jr(function() {
                return !h && s.next && s.next(k);
              }));
            }, function(k) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(k?.name) || h || jr(function() {
                h || s.error && s.error(k);
              });
            }));
          };
          return setTimeout(C, 0), x;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return t;
        }, i;
      }
      var en = Nt;
      function so(e) {
        var t = Bt;
        try {
          Bt = !0, Mt.storagemutated.fire(e), eo(e, !0);
        } finally {
          Bt = t;
        }
      }
      j(en, u(u({}, $e), { delete: function(e) {
        return new en(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new en(e, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return t = en.dependencies, o = t.indexedDB, t = t.IDBKeyRange, (Yr(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(s) {
              return s.name;
            }).filter(function(s) {
              return s !== Yn;
            });
          }) : Gr(o, t).toCollection().primaryKeys()).then(e);
        } catch {
          return je(new F.MissingAPI());
        }
        var t, o;
      }, defineClass: function() {
        return function(e) {
          O(this, e);
        };
      }, ignoreTransaction: function(e) {
        return Z.trans ? zt(Z.transless, e) : e();
      }, vip: Xr, async: function(e) {
        return function() {
          try {
            var t = to(e.apply(this, arguments));
            return t && typeof t.then == "function" ? t : z.resolve(t);
          } catch (o) {
            return je(o);
          }
        };
      }, spawn: function(e, t, o) {
        try {
          var i = to(e.apply(o, t || []));
          return i && typeof i.then == "function" ? i : z.resolve(i);
        } catch (s) {
          return je(s);
        }
      }, currentTransaction: { get: function() {
        return Z.trans || null;
      } }, waitFor: function(e, t) {
        return t = z.resolve(typeof e == "function" ? en.ignoreTransaction(e) : e).timeout(t || 6e4), Z.trans ? Z.trans.waitFor(t) : t;
      }, Promise: z, debug: { get: function() {
        return ne;
      }, set: function(e) {
        we(e);
      } }, derive: fe, extend: O, props: j, override: Ee, Events: _n, on: Mt, liveQuery: ri, extendObservabilitySet: sr, getByKeyPath: Be, setByKeyPath: ye, delByKeyPath: function(e, t) {
        typeof t == "string" ? ye(e, t, void 0) : "length" in t && [].map.call(t, function(o) {
          ye(e, o, void 0);
        });
      }, shallowClone: Ce, deepClone: nt, getObjectDiff: no, cmp: he, asap: Ae, minKey: -1 / 0, addons: [], connections: fn, errnames: A, dependencies: cr, cache: Zt, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, t, o) {
        return e + t / Math.pow(10, 2 * o);
      }) })), en.maxKey = On(en.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Mt(En, function(e) {
        Bt || (e = new CustomEvent(Br, { detail: e }), Bt = !0, dispatchEvent(e), Bt = !1);
      }), addEventListener(Br, function(e) {
        e = e.detail, Bt || so(e);
      }));
      var vn, Bt = !1, oi = function() {
      };
      return typeof BroadcastChannel < "u" && ((oi = function() {
        (vn = new BroadcastChannel(Br)).onmessage = function(e) {
          return e.data && so(e.data);
        };
      })(), typeof vn.unref == "function" && vn.unref(), Mt(En, function(e) {
        Bt || vn.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Nt.disableBfCache && e.persisted) {
          ne && console.debug("Dexie: handling persisted pagehide"), vn?.close();
          for (var t = 0, o = fn; t < o.length; t++) o[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Nt.disableBfCache && e.persisted && (ne && console.debug("Dexie: handling persisted pageshow"), oi(), so({ all: new Ye(-1 / 0, [[]]) }));
      })), z.rejectionMapper = function(e, t) {
        return !e || e instanceof Dt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !V[e.name] ? e : (t = new V[e.name](t || e.message, e), "stack" in e && G(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, we(ne), u(Nt, Object.freeze({ __proto__: null, Dexie: Nt, liveQuery: ri, Entity: Io, cmp: he, PropModification: xn, replacePrefix: function(e, t) {
        return new xn({ replacePrefix: [e, t] });
      }, add: function(e) {
        return new xn({ add: e });
      }, remove: function(e) {
        return new xn({ remove: e });
      }, default: Nt, RangeSet: Ye, mergeRanges: Nn, rangesOverlap: Go }), { default: Nt }), Nt;
    });
  }(ra)), ra.exports;
}
var Ld = jd();
const oa = /* @__PURE__ */ Ad(Ld), xu = Symbol.for("Dexie"), ia = globalThis[xu] || (globalThis[xu] = oa);
if (oa.semVer !== ia.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${oa.semVer} and ${ia.semVer}`);
const {
  liveQuery: wm,
  mergeRanges: xm,
  rangesOverlap: Tm,
  RangeSet: Em,
  cmp: Om,
  Entity: Cm,
  PropModification: Sm,
  replacePrefix: Nm,
  add: Am,
  remove: Pm,
  DexieYProvider: km
} = ia, bt = "sclElements";
function $l(n) {
  return {
    addRecord: r,
    findChildRecordsByTagName: p,
    ensureRelationship: u,
    removeRelationship: c,
    findParentRecordsWithinDepthAndGivenTagName: g,
    db: n
  };
  async function r(O) {
    const K = { ...O, id: crypto.randomUUID() };
    try {
      return await n.table(bt).add(K), K;
    } catch (P) {
      const R = {
        msg: "could not add record",
        db: n.name,
        newRecord: K,
        err: P
      };
      throw console.error(R), new Error(JSON.stringify(R));
    }
  }
  async function a(O) {
    try {
      if (await n.table(bt).update(O.id, O) < 1) {
        const P = { msg: "nothing has been updated", record: O };
        throw console.error(P), new Error(JSON.stringify(P));
      }
    } catch (K) {
      console.error(K);
    }
  }
  async function u(O, K) {
    const P = O.children?.some((j) => j.id === K.id), R = K.parent?.id === O.id;
    if (P || await n.table(bt).where({ id: O.id }).modify((j) => {
      j.children.push({ id: K.id, tagName: K.tagName });
    }), !R) {
      const j = {
        id: O.id,
        tagName: O.tagName
      };
      await n.table(bt).update(K.id, { parent: j });
    }
  }
  async function c(O, K) {
    K.parent = null, await a(K), O.children && (O.children = O.children.filter((P) => P.id !== K.id), await a(O));
  }
  async function d(O) {
    return O.children?.length ? await n.table(bt).where({ "parent.id": O.id }).toArray() : [];
  }
  async function p(O, K) {
    return (await d(O)).filter((R) => K.includes(R.tagName));
  }
  async function g(O, K, P = []) {
    const R = [];
    let j = O;
    for (let L = 0; L < K; L++) {
      if (!j.parent)
        return R;
      const G = await n.table(bt).get(j.parent.id);
      if (!G) {
        const fe = {
          msg: "Parent record not found",
          table: j.parent.tagName,
          id: j.parent.id
        };
        throw console.error(fe), new Error(JSON.stringify(fe));
      }
      (P.length == 0 || P.length > 0 && P.includes(G.tagName)) && R.push(G), j = G;
    }
    return R;
  }
}
function Kd(n, r) {
  return n.attributes?.find((a) => a.name === r);
}
function Ge(n, r) {
  return n?.attributes?.find((a) => a.name === r)?.value;
}
function Fd(n) {
  return {
    findAllEnrichedLNodes: r,
    findAllLNodeTypes: a,
    enrichWithDataObjectSpecifications: d
  };
  async function r() {
    const g = await p();
    return g.length ? await d(g) : [];
  }
  async function a() {
    const g = await n.table(bt).where({ tagName: "LNodeType" }).toArray(), O = [];
    for (const K of g)
      O.push({
        id: K.id,
        typeId: Ge(K, "id") ?? "",
        lnClass: Ge(K, "lnClass") ?? "",
        dataObjects: await u(K)
      });
    return O;
  }
  async function u(g) {
    if (!g.children) return [];
    const O = [];
    for (const K of g.children) {
      if (K.tagName !== "DO") continue;
      const P = await n.table(bt).get(K.id);
      P && O.push({
        id: P.id,
        name: Ge(P, "name") ?? "",
        type: Ge(P, "type") ?? "",
        dataAttributes: await c(P),
        lnodeTypeId: g.id
      });
    }
    return O;
  }
  async function c(g) {
    const O = Ge(g, "type");
    if (!O) return [];
    const K = (await n.table(bt).where({ tagName: "DOType" }).toArray()).find((R) => R.attributes?.find((j) => j.name === "id" && j.value === O));
    if (!K || !K.children) return [];
    const P = [];
    for (const R of K.children) {
      if (R.tagName !== "DA") continue;
      const j = await n.table(bt).get(R.id);
      j && P.push({
        id: j.id,
        name: Ge(j, "name") ?? "",
        type: Ge(j, "type") ?? "",
        bType: Ge(j, "bType") ?? "",
        fc: Ge(j, "fc") ?? "",
        dataObjectId: g.id
      });
    }
    return P;
  }
  async function d(g) {
    const O = await n.table(bt).where({ tagName: "Private" }).toArray(), K = await n.table(bt).where({ tagName: "DOS" }).toArray(), P = await n.table(bt).where({ tagName: "DAS" }).toArray(), R = await n.table(bt).where({ tagName: "SubscriberLNode" }).toArray();
    return Promise.all(
      g.map(async (j) => {
        const L = O.find(
          (fe) => fe.parent?.id === j.id && fe.parent?.tagName === "LNode" && Ge(fe, "type") === "eIEC61850-6-100"
        );
        if (!L || !L.children)
          return { ...j, dataObjectSpecifications: [] };
        const G = [];
        for (const fe of L.children) {
          if (fe.tagName !== "DOS") continue;
          const qe = K.find((me) => me.id === fe.id);
          if (!qe) continue;
          const pe = [];
          if (qe.children)
            for (const me of qe.children) {
              if (me.tagName !== "DAS") continue;
              const Ee = P.find((Ae) => Ae.id === me.id);
              if (!Ee) continue;
              let de = [];
              if (Ee.children) {
                const Ae = Ee.children.filter((ye) => ye.tagName === "SubscriberLNode"), Be = R.filter(
                  (ye) => Ae.some((Ce) => Ce.id === ye.id)
                );
                for (const ye of Be)
                  de.push({
                    id: ye.id,
                    inputName: Ge(ye, "inputName") ?? "",
                    service: Ul(ye, "service"),
                    pLN: Ge(ye, "pLN") ?? ""
                  });
              }
              pe.push({
                id: Ee.id,
                name: Ge(Ee, "name") ?? "",
                desc: Ge(Ee, "desc") ?? "",
                dataObjectSpecificationId: qe.id,
                subscriberLNodes: de
              });
            }
          G.push({
            id: qe.id,
            name: Ge(qe, "name") ?? "",
            desc: Ge(qe, "desc") ?? "",
            dataAttributeSpecifications: pe,
            lNodeId: j.id
          });
        }
        return { ...j, dataObjectSpecifications: G };
      })
    );
  }
  async function p() {
    return (await n.table(bt).where({ tagName: "LNode" }).toArray()).map((O) => ({
      id: O.id,
      uuid: Ge(O, "uuid") ?? "",
      iedName: Ge(O, "iedName") ?? "",
      prefix: Ge(O, "prefix") ?? "",
      lnClass: Ge(O, "lnClass") ?? "",
      lnInst: Ge(O, "lnInst") ?? "",
      lnType: Ge(O, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function Ul(n, r) {
  const a = n?.attributes?.find((c) => c.name === r)?.value;
  if (!a) return;
  switch (a.toUpperCase()) {
    case "GOOSE":
      return At.GOOSE;
    case "SMV":
      return At.SMV;
    case "REPORT":
      return At.REPORT;
    case "INTERNAL":
      return At.INTERNAL;
    case "WIRED":
      return At.WIRED;
    case "CONTROL":
      return At.CONTROL;
    default:
      return;
  }
}
async function Oi(n) {
  try {
    const r = new Vi(n);
    return await r.open(), r;
  } catch (r) {
    throw console.error("Error opening database:", r), r;
  }
}
function Md(n) {
  const r = $l(n);
  return {
    findAllExistingConnections: a,
    findAllExistingControlledConnections: u
  };
  async function a() {
    const c = await n.table(bt).where({ tagName: "SourceRef" }).toArray();
    if (!c.length) return [];
    const d = [];
    for (const p of c) {
      if (!p.attributes) continue;
      const g = Ge(p, "sourceLNodeUuid"), O = await n.table(bt).where({ tagName: "LNode" }).toArray().then(
        (R) => R.find(
          (j) => j.attributes?.some(
            (L) => L.name === "uuid" && L.value === g
          )
        )?.id
      ) || null, K = await r.findParentRecordsWithinDepthAndGivenTagName(
        p,
        3,
        ["LNode"]
      );
      if (K.length != 1) {
        const R = {
          msg: "LNode record not found for SourceRef id",
          id: p.id
        };
        throw console.error(R), new Error(JSON.stringify(R));
      }
      const P = {
        id: p.id,
        sourceLNodeId: O,
        destinationLNodeId: K[0].id,
        sourceDataObject: Ge(p, "sourceDoName") || "",
        sourceDataAttribute: Ge(p, "sourceDaName") || "",
        dataflowType: Ul(p, "service"),
        inputInstance: Ge(p, "inputInst") || "",
        input: Ge(p, "input") || "",
        preferredLNode: Ge(p, "pLN") || "",
        preferredDataObject: Ge(p, "pDO") || "",
        preferredDataAttribute: Ge(p, "pDA") || "",
        processResource: Ge(p, "resourceName") || ""
      };
      d.push(P);
    }
    return d;
  }
  async function u() {
    const c = await n.table(bt).where({ tagName: "ControlRef" }).toArray();
    if (!c.length) return [];
    const d = [];
    for (const p of c) {
      if (!p.attributes) continue;
      const g = Ge(p, "controlledLNodeUuid"), O = Ge(p, "controlledDoName"), K = await n.table(bt).where({ tagName: "LNode" }).toArray().then(
        (j) => j.find(
          (L) => L.attributes?.some(
            (G) => G.name === "uuid" && G.value === g
          )
        )?.id
      ) || null, P = await r.findParentRecordsWithinDepthAndGivenTagName(
        p,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (P.length != 1) {
        const j = {
          msg: "LNode record not found for ControlRef id",
          id: p.id
        };
        throw console.error(j), new Error(JSON.stringify(j));
      }
      const R = {
        controllerLNodeId: P[0].id,
        controlledLNodeId: K,
        controlledDataObject: O || "",
        dataflowType: At.CONTROL,
        outputInstance: Ge(p, "outputInst") || "",
        outputName: Ge(p, "output") || ""
      };
      d.push(R);
    }
    return d;
  }
}
function Mn(n) {
  return `${n.prefix} ${n.lnClass} ${n.lnInst}`;
}
const Bd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, qd = { class: "col-start-1 col-span-1 self-center justify-self-end" }, $d = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Ud = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Vd = ["data-testid"], Hd = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Wd = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Gd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Yd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Xd = /* @__PURE__ */ Gt({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(n) {
    const r = n, a = It(() => [...r.connections].sort((u, c) => u.dataflowType < c.dataflowType ? -1 : u.dataflowType > c.dataflowType ? 1 : 0));
    return (u, c) => (be(!0), Oe(Je, null, Ut(a.value, (d, p) => (be(), Oe("div", Bd, [
      q("div", qd, [
        q("span", $d, Fe(d.sourceDataObject), 1),
        q("span", Ud, Fe(d.sourceDataAttribute), 1)
      ]),
      c[0] || (c[0] = q("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      q("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-line-${p}`
      }, null, 8, Vd),
      c[1] || (c[1] = q("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        q("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      q("div", Hd, Fe(d.dataflowType), 1),
      c[2] || (c[2] = q("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      q("div", Wd, [
        q("span", Gd, Fe(d.input), 1),
        q("span", Yd, Fe(d.inputInstance), 1)
      ])
    ]))), 256));
  }
}), zd = { key: 0 }, Qd = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, Jd = /* @__PURE__ */ Gt({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(n) {
    return (r, a) => (be(), Oe("div", null, [
      (be(), Oe("div", zd, [
        a[0] || (a[0] = q("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
        r.placeholder.dataflowType ? (be(), Oe("span", Qd, Fe(r.placeholder.dataflowType), 1)) : Pn("", !0),
        q("p", null, "Input: " + Fe(r.placeholder.input), 1),
        q("p", null, "Preferred LNode: " + Fe(r.placeholder.preferredLNode || "-"), 1),
        q("p", null, "Preferred DO: " + Fe(r.placeholder.preferredDataObject || "-"), 1),
        q("p", null, "Preferred DA: " + Fe(r.placeholder.preferredDataAttribute || "-"), 1),
        q("p", null, "Process Resource: " + Fe(r.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Zd = ["y1", "x2", "y2"], ep = ["points"], tp = /* @__PURE__ */ Gt({
  __name: "arrow",
  props: {
    height: {},
    length: {}
  },
  setup(n) {
    return (r, a) => (be(), Oe(Je, null, [
      q("line", {
        x1: 0,
        y1: r.height / 2,
        x2: r.length - r.height / 2,
        y2: r.height / 2,
        stroke: "currentColor",
        "stroke-width": "2"
      }, null, 8, Zd),
      q("polygon", {
        points: `${r.length - r.height * 0.7}, 0 ${r.length}, ${r.height / 2} ${r.length - r.height * 0.7}, ${r.height}`,
        fill: "currentColor"
      }, null, 8, ep)
    ], 64));
  }
}), Vl = /* @__PURE__ */ xd("dataflow/sidebar", () => {
  const n = _t(null);
  function r(a) {
    n.value = a;
  }
  return {
    activeElement: n,
    setActiveElement: r
  };
}), np = ["onClick"], rp = ["data-testid"], op = ["onClick"], ip = { class: "col-start-5 col-span-1 self-center justify-self-start" }, sp = ["onClick"], ap = /* @__PURE__ */ Gt({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(n) {
    const r = Vl(), { activeElement: a } = ql(r);
    function u(c) {
      const d = c == a.value ? null : c;
      r.setActiveElement(d);
    }
    return (c, d) => (be(!0), Oe(Je, null, Ut(c.destinationPlaceHolderPorts, (p, g) => (be(), Oe("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
      key: `destination-placeholder-port-${g}`
    }, [
      (be(), Oe("svg", {
        height: "12",
        width: "35",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 text-(--color-ocean-gray-100) hover:cursor-pointer",
        onClick: (O) => u(p.id)
      }, [
        q("g", {
          "data-testid": `placeholder-line-${g}`,
          class: ho({
            "text-(--color-primary)": yt(a) === p.id
          })
        }, [
          Ct(tp, {
            height: 12,
            length: 35
          })
        ], 10, rp)
      ], 8, np)),
      q("div", {
        onClick: (O) => u(p.id),
        class: ho(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": yt(a) === p.id
        }])
      }, null, 10, op),
      q("div", ip, [
        q("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
          onClick: (O) => u(p.id)
        }, Fe(p.input), 9, sp)
      ]),
      yt(a) == p.id ? (be(), An(sl, {
        key: 0,
        to: "#sidebar-details"
      }, [
        Ct(Jd, { placeholder: p }, null, 8, ["placeholder"])
      ])) : Pn("", !0)
    ]))), 128));
  }
}), Pa = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
};
function rs(n) {
  const r = $l(n);
  return {
    createControlledConnection: u,
    createConnection: a,
    createSourcePlaceholder: d,
    createDestinationPlaceholder: c
  };
  async function a(p, g, O) {
    const K = await Tu(n, r, O);
    await lp(r, g, K, p), await cp(n, r, g, p);
  }
  async function u(p, g, O) {
    const K = await up(n, r, g), P = dp(
      p,
      O
    ), R = await fp(r, P);
    await r.ensureRelationship(K, R);
    const j = await os(n, r, O), L = {
      name: p.controlledSignal,
      desc: ""
    }, G = await Hl(r, L);
    await r.ensureRelationship(j[0], G);
  }
  async function c(p, g) {
    const O = await Tu(n, r, g), K = await ji(
      r,
      pp(p),
      O.namespace
    );
    await r.ensureRelationship(O, K);
  }
  async function d(p) {
    let g = [{ name: "inputName", value: p.inputName }];
    p.preferredLNode && g.push({ name: "pLN", value: p.preferredLNode }), p.dataflowType && g.push({ name: "service", value: p.dataflowType }), p.processResource && g.push({ name: "resourceName", value: p.processResource });
    const O = p.dataAttribute, K = await n.table(bt).get(O);
    if (!K) throw new Error(`DAS element with id ${O} not found`);
    const P = await r.addRecord({
      tagName: "SubscriberLNode",
      attributes: g,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(K, P);
  }
}
async function Tu(n, r, a) {
  const u = await os(n, r, a), c = await r.findChildRecordsByTagName(u[0], [
    "LNodeInputs"
  ]);
  if (c.length != 1) {
    const d = {
      msg: `LNodeInputs element not found or more than one element found in LNode with uuid ${a.uuid}`
    };
    throw console.error(d), new Error(JSON.stringify(d));
  }
  return c[0];
}
async function up(n, r, a) {
  const u = await os(n, r, a), c = await r.findChildRecordsByTagName(u[0], [
    "LNodeOutputs"
  ]);
  if (c.length != 1) {
    const d = {
      msg: `LNodeOutputs element not found or more than one element found in LNode with uuid ${a.uuid}`
    };
    throw console.error(d), new Error(JSON.stringify(d));
  }
  return c[0];
}
async function lp(n, r, a, u) {
  const c = await ji(
    n,
    qs(u, r),
    a.namespace
  );
  if (await n.ensureRelationship(a, c), u.includeQuality) {
    const d = {
      ...u,
      attribute: "q"
      // Set to 'q' for Quality
    }, p = await ji(
      n,
      qs(d, r),
      a.namespace
    );
    await n.ensureRelationship(a, p);
  }
  if (u.includeTimestamp) {
    const d = {
      ...u,
      attribute: "t"
      // Set to 't' for Timestamp
    }, p = await ji(
      n,
      qs(d, r),
      a.namespace
    );
    await n.ensureRelationship(a, p);
  }
}
async function os(n, r, a) {
  const u = await n.table(bt).get(a.id);
  if (!u || !u.children || u.children.length == 0) {
    const p = {
      msg: `LNode element with uuid ${a.uuid} not found or empty`
    };
    throw console.error(p), new Error(JSON.stringify(p));
  }
  const c = await r.findChildRecordsByTagName(u, ["Private"]);
  if (!c.filter((p) => Kd(p, "type")?.value === "eIEC61850-6-100").at(0)) {
    const p = {
      msg: `Private element of type 'eIEC61850-6-100' not found in LNode with uuid ${a.uuid}`
    };
    throw console.error(p), new Error(JSON.stringify(p));
  }
  return c;
}
async function ji(n, r, a) {
  const u = {
    tagName: "SourceRef",
    namespace: a,
    attributes: [
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pDA",
        value: r.pDA
      },
      {
        name: "input",
        value: r.inputName
      },
      {
        name: "inputInst",
        value: r.inputInstance
      },
      {
        name: "service",
        value: r.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: r.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: r.sourceDoName
      },
      {
        name: "sourceDaName",
        value: r.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: r.resourceName
      },
      {
        name: "source",
        value: r.source
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(u);
}
async function cp(n, r, a, u) {
  const c = a.dataObjectSpecifications?.filter((p) => p.name === u.signal) ?? [];
  let d;
  for (const p of c) {
    const g = p.dataAttributeSpecifications.find((O) => O.name === u.attribute);
    if (g) {
      d = g;
      break;
    }
  }
  if (!d && c[0]) {
    const p = await n.table(bt).get(c[0].id), g = {
      name: u.attribute,
      desc: ""
    }, O = await Eu(
      r,
      g
    );
    p ? await r.ensureRelationship(p, O) : console.error("Could not find find matching DOS in db");
  } else if (!d && !c[0]) {
    const p = await os(n, r, a), g = {
      name: u.signal,
      //check done, shoulb be good
      desc: ""
    }, O = await Hl(r, g);
    await r.ensureRelationship(p[0], O);
    const K = {
      name: u.attribute,
      //check done, should be good
      desc: ""
    }, P = await Eu(
      r,
      K
    );
    await r.ensureRelationship(O, P);
  }
}
async function fp(n, r) {
  const a = {
    tagName: "ControlRef",
    namespace: Pa,
    attributes: [
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "controlled",
        value: r.controlled
      },
      {
        name: "output",
        value: r.output
      },
      {
        name: "outputInst",
        value: r.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: r.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: r.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(a);
}
function qs(n, r) {
  return {
    dataflowType: n.type,
    inputName: n.inputName,
    inputInstance: n.inputInstance,
    sourceLNodeUuid: r.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    source: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: n.signal,
    sourceDaName: n.attribute,
    pLN: r.lnClass,
    pDO: n.signal,
    pDA: n.attribute
  };
}
function dp(n, r) {
  return {
    pDO: "",
    pLN: "",
    controlled: "",
    //TODO: see "path"-rule (Standart: 6.2.4 ControlRef)
    output: n.outputName,
    outputInst: n.outputInstance,
    controlledLNodeUuid: r.uuid,
    controlledDoName: n.controlledSignal
  };
}
function pp(n) {
  return {
    dataflowType: n.dataflowType,
    inputName: n.inputName,
    inputInstance: "",
    sourceLNodeUuid: "",
    resourceName: n.processResource,
    source: "",
    sourceDoName: "",
    sourceDaName: "",
    pLN: n.preferredLNode,
    pDO: n.preferredDataObject,
    pDA: n.preferredDataAttribute
  };
}
async function Hl(n, r) {
  const a = {
    tagName: "DOS",
    namespace: Pa,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(a);
}
async function Eu(n, r) {
  const a = {
    tagName: "DAS",
    namespace: Pa,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(a);
}
const hp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, mp = { class: "modal-box" }, yp = { class: "grid grid-cols-2 gap-4 mt-4" }, vp = { class: "grid grid-cols-2 gap-4 mt-4" }, gp = ["value", "disabled"], bp = { class: "grid grid-cols-2 gap-4 mt-4" }, _p = ["value"], wp = { class: "grid grid-cols-2 gap-4 mt-4" }, xp = ["value"], Tp = { class: "grid grid-cols-2 gap-4 mt-4" }, Ep = ["value"], Op = { class: "grid grid-cols-2 gap-4 mt-4" }, Cp = /* @__PURE__ */ Gt({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["placeholderCreated"],
  setup(n, { emit: r }) {
    const a = n, u = r, c = _t(
      O()
    ), d = ll("dialog"), p = It(() => {
      const j = a.lnodeTypes.find(
        (L) => L.lnClass === c.value.preferredLNode
      );
      return j ? c.value.dataflowType ? j.dataObjects.filter(
        (L) => L.dataAttributes.some(
          (G) => Hi[c.value.dataflowType].includes(G.fc)
        )
      ).map((L) => L.name) : j.dataObjects.map((L) => L.name) : [];
    }), g = It(() => {
      const j = a.lnodeTypes.find(
        (G) => G.lnClass === c.value.preferredLNode
      );
      if (!j) return [];
      const L = j.dataObjects.find(
        (G) => G.name === c.value.preferredDataObject
      );
      return L ? c.value.dataflowType ? L.dataAttributes.filter(
        (G) => Hi[c.value.dataflowType].includes(G.fc)
      ).map((G) => G.name) : L.dataAttributes.map((G) => G.name) : [];
    });
    function O() {
      return {
        dataflowType: null,
        inputName: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    async function K() {
      try {
        const j = localStorage.getItem("currentActiveFileDatabaseName");
        if (!j)
          throw new Error("no active file");
        const L = await Oi(j);
        await rs(L).createDestinationPlaceholder(
          c.value,
          a.destinationLNode
        ), L.close(), u("placeholderCreated"), P();
      } catch (j) {
        console.error("Error creating destination placeholder port:", j), alert(`Error creating placeholder: ${j instanceof Error ? j.message : "Unknown error"}`);
      }
    }
    function P() {
      c.value = O();
    }
    function R(j) {
      for (const L of j)
        c.value[L] = "";
    }
    return (j, L) => (be(), Oe("div", hp, [
      q("button", {
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center",
        onClick: L[0] || (L[0] = (G) => d.value?.showModal()),
        "aria-label": "Add destination placeholder"
      }, L[10] || (L[10] = [
        q("svg", {
          width: "16px",
          height: "16px",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          q("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          q("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      q("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: d
      }, [
        q("div", mp, [
          L[22] || (L[22] = q("h3", { class: "text-lg font-bold" }, "Create Placeholder - Receive data from", -1)),
          L[23] || (L[23] = q("form", { method: "dialog" }, [
            q("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close destination placeholder creation"
            }, [
              q("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                q("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          q("form", {
            method: "dialog",
            onSubmit: K
          }, [
            q("div", yp, [
              L[11] || (L[11] = q("label", {
                for: "input-name-input",
                class: "col-start-1 self-center"
              }, "Input", -1)),
              mt(q("input", {
                id: "input-name-input",
                type: "text",
                required: "",
                placeholder: "Input Name",
                class: "input col-start-2",
                "onUpdate:modelValue": L[1] || (L[1] = (G) => c.value.inputName = G)
              }, null, 512), [
                [Pr, c.value.inputName]
              ])
            ]),
            q("div", vp, [
              L[13] || (L[13] = q("label", {
                for: "dataflow-type-select",
                class: "col-start-1 self-center"
              }, "Dataflow Type", -1)),
              mt(q("select", {
                id: "dataflow-type-select",
                class: "select col-start-2",
                "onUpdate:modelValue": L[2] || (L[2] = (G) => c.value.dataflowType = G),
                onChange: L[3] || (L[3] = (G) => R(["preferredDataObject"]))
              }, [
                (be(!0), Oe(Je, null, Ut(Object.values(yt(At)), (G) => (be(), Oe("option", {
                  key: G,
                  value: G,
                  disabled: G === yt(At).CONTROL
                }, Fe(G), 9, gp))), 128)),
                L[12] || (L[12] = q("option", {
                  key: "empty",
                  value: null
                }, "-", -1))
              ], 544), [
                [kn, c.value.dataflowType]
              ])
            ]),
            q("div", bp, [
              L[15] || (L[15] = q("label", {
                for: "preferred-lnode-select",
                class: "col-start-1 self-center"
              }, "Preferred LNode", -1)),
              mt(q("select", {
                id: "preferred-lnode-select",
                class: "select col-start-2",
                "onUpdate:modelValue": L[4] || (L[4] = (G) => c.value.preferredLNode = G),
                onChange: L[5] || (L[5] = (G) => R(["preferredDataObject"]))
              }, [
                (be(!0), Oe(Je, null, Ut(j.lnodeTypes, (G) => (be(), Oe("option", {
                  key: G.lnClass,
                  value: G.lnClass
                }, Fe(G.lnClass), 9, _p))), 128)),
                L[14] || (L[14] = q("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 544), [
                [kn, c.value.preferredLNode]
              ])
            ]),
            q("div", wp, [
              L[17] || (L[17] = q("label", {
                for: "data-object-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Object", -1)),
              mt(q("select", {
                id: "data-object-select",
                class: "select col-start-2",
                "onUpdate:modelValue": L[6] || (L[6] = (G) => c.value.preferredDataObject = G),
                onChange: L[7] || (L[7] = (G) => R(["preferredDataAttribute"]))
              }, [
                (be(!0), Oe(Je, null, Ut(p.value, (G) => (be(), Oe("option", {
                  key: G,
                  value: G
                }, Fe(G), 9, xp))), 128)),
                L[16] || (L[16] = q("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 544), [
                [kn, c.value.preferredDataObject]
              ])
            ]),
            q("div", Tp, [
              L[19] || (L[19] = q("label", {
                for: "data-attribute-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Attribute", -1)),
              mt(q("select", {
                id: "data-attribute-select",
                class: "select col-start-2",
                "onUpdate:modelValue": L[8] || (L[8] = (G) => c.value.preferredDataAttribute = G)
              }, [
                (be(!0), Oe(Je, null, Ut(g.value, (G) => (be(), Oe("option", {
                  key: G,
                  value: G
                }, Fe(G), 9, Ep))), 128)),
                L[18] || (L[18] = q("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 512), [
                [kn, c.value.preferredDataAttribute]
              ])
            ]),
            q("div", Op, [
              L[20] || (L[20] = q("label", {
                for: "process-resource-input",
                class: "col-start-1 self-center"
              }, "Process Resource", -1)),
              mt(q("input", {
                id: "process-resource-input",
                type: "text",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": L[9] || (L[9] = (G) => c.value.processResource = G)
              }, null, 512), [
                [Pr, c.value.processResource]
              ])
            ]),
            L[21] || (L[21] = q("div", { class: "modal-action" }, [
              q("button", {
                class: "btn bg-(--color-primary) border-none text-white",
                type: "submit"
              }, " Save ")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), Sp = { key: 0 }, Np = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, Ap = /* @__PURE__ */ Gt({
  __name: "source-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(n) {
    return (r, a) => (be(), Oe("div", null, [
      (be(), Oe("div", Sp, [
        a[0] || (a[0] = q("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder Details", -1)),
        r.placeholder.dataflowType ? (be(), Oe("span", Np, Fe(r.placeholder.dataflowType), 1)) : Pn("", !0),
        q("p", null, "Input: " + Fe(r.placeholder.input), 1),
        q("p", null, "Data Object: " + Fe(r.placeholder.dataObject || "-"), 1),
        q("p", null, "Data Attribute: " + Fe(r.placeholder.dataAttribute || "-"), 1),
        q("p", null, "Preferred LNode: " + Fe(r.placeholder.preferredLNode || "-"), 1),
        q("p", null, "Process Resource: " + Fe(r.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Pp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12 *:pointer-events-auto" }, kp = ["onClick"], Dp = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Ip = ["onClick"], Rp = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, jp = ["onClick"], Lp = {
  height: "12",
  width: "24"
}, Kp = { class: "ml-2" }, Fp = /* @__PURE__ */ Gt({
  __name: "source-placeholder-ports",
  props: {
    dataObjectSpecifications: {}
  },
  setup(n) {
    const r = n, a = It(
      () => r.dataObjectSpecifications.flatMap(
        (p) => p.dataAttributeSpecifications.flatMap(
          (g) => g.subscriberLNodes?.map(
            (O) => ({
              id: O.id,
              dataObject: p.name,
              dataAttribute: g.name,
              dataflowType: O.service,
              preferredLNode: O.pLN,
              input: O.inputName,
              processResource: ""
            })
          ) ?? []
        )
      )
    ), u = Vl(), { activeElement: c } = ql(u);
    function d(p) {
      const g = p == c.value ? null : p;
      u.setActiveElement(g);
    }
    return (p, g) => (be(!0), Oe(Je, null, Ut(a.value, (O) => (be(), Oe("div", Pp, [
      q("div", {
        onClick: (K) => d(O.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        q("span", Dp, Fe(O.dataObject) + "." + Fe(O.dataAttribute), 1)
      ], 8, kp),
      q("div", {
        onClick: (K) => d(O.id),
        class: ho([{
          "bg-(--color-primary)": yt(c) === O.id
        }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
      }, null, 10, Ip),
      q("div", Rp, [
        q("div", {
          class: "inline-flex items-center h-full max-w-max hover:cursor-pointer",
          onClick: (K) => d(O.id)
        }, [
          (be(), Oe("svg", Lp, [
            q("line", {
              x1: "0",
              y1: "6",
              x2: "24",
              y2: "6",
              stroke: "currentColor",
              "stroke-width": "2",
              class: ho({
                "text-(--color-primary)": yt(c) === O.id,
                "text-(--color-ocean-gray-100)": yt(c) !== O.id
              })
            }, null, 2)
          ])),
          q("span", Kp, Fe(O.input), 1)
        ], 8, jp)
      ]),
      yt(c) == O.id ? (be(), An(sl, {
        key: 0,
        to: "#sidebar-details"
      }, [
        Ct(Ap, { placeholder: O }, null, 8, ["placeholder"])
      ])) : Pn("", !0)
    ]))), 256));
  }
}), Mp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Bp = { class: "col-start-1 col-span-1 self-center justify-self-end" }, qp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, $p = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Up = ["data-testid"], Vp = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Hp = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Wp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Gp = /* @__PURE__ */ Gt({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(n) {
    return (r, a) => (be(!0), Oe(Je, null, Ut(r.controlledConnections, (u, c) => (be(), Oe("div", Mp, [
      q("div", Bp, [
        q("span", qp, Fe(u.outputName), 1),
        q("span", $p, Fe(u.outputInstance), 1)
      ]),
      a[0] || (a[0] = q("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      q("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-controlled-connection-line-${c}`
      }, null, 8, Up),
      a[1] || (a[1] = q("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        q("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      q("div", Vp, Fe(u.dataflowType), 1),
      a[2] || (a[2] = q("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      q("div", Hp, [
        q("span", Wp, Fe(u.controlledDataObject), 1)
      ])
    ]))), 256));
  }
}), Yp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Xp = { class: "modal-box" }, zp = { class: "grid grid-cols-2 gap-4 items-center" }, Qp = { class: "grid grid-cols-2 gap-4 items-center" }, Jp = ["value", "disabled"], Zp = { class: "grid grid-cols-2 gap-4 items-center" }, eh = ["value"], th = { class: "grid grid-cols-2 gap-4 items-center" }, nh = { class: "grid grid-cols-2 gap-4 items-center" }, rh = ["value"], oh = /* @__PURE__ */ Gt({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {},
    lnodeTypes: {}
  },
  emits: ["placeholderCreated"],
  setup(n, { emit: r }) {
    const a = r, u = n, c = {
      dataAttribute: "",
      inputName: "",
      dataflowType: "",
      processResource: "",
      preferredLNode: ""
    }, d = _t(c);
    async function p(K) {
      const P = K.target;
      try {
        const R = localStorage.getItem("currentActiveFileDatabaseName");
        if (!R) throw new Error("no active file");
        const j = await Oi(R);
        await rs(j).createSourcePlaceholder(d.value), j.close(), a("placeholderCreated"), d.value = c, P.reset();
      } catch (R) {
        console.error("Error creating source placeholder port:", R), alert(`Error creating placeholder: ${R instanceof Error ? R.message : "Unknown error"}`);
      }
    }
    const g = It(() => (u.sourceLNode.dataObjectSpecifications ?? []).flatMap((j) => j.dataAttributeSpecifications).filter((j) => {
      const L = d.value.dataflowType;
      return !L || !j.subscriberLNode?.service ? !0 : L == j.subscriberLNode.service;
    }).map((j) => ({ id: j.id, name: j.name })).sort((j, L) => j.name.localeCompare(L.name))), O = ll("dialog");
    return (K, P) => (be(), Oe("div", Yp, [
      q("button", {
        onClick: P[0] || (P[0] = (R) => O.value?.showModal()),
        "aria-label": "Add source placeholder",
        class: "btn btn-primary btn-circle size-5 col-start-3 col-span-1 -ml-[12px] self-center relative z-10"
      }, P[6] || (P[6] = [
        q("svg", {
          width: "16",
          height: "16",
          viewBox: "0 0 20 20",
          fill: "currentColor"
        }, [
          q("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          q("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      q("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: O
      }, [
        q("div", Xp, [
          P[16] || (P[16] = q("h3", { class: "text-lg font-bold" }, "Create Placeholder - Provide data", -1)),
          P[17] || (P[17] = q("form", { method: "dialog" }, [
            q("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close source placeholder creation"
            }, [
              q("svg", {
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                q("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          q("form", {
            onSubmit: p,
            method: "dialog",
            class: "flex flex-col gap-4 mt-4"
          }, [
            q("div", zp, [
              P[7] || (P[7] = q("label", { for: "input-name" }, "Input", -1)),
              mt(q("input", {
                required: "",
                id: "input-name",
                name: "inputName",
                "onUpdate:modelValue": P[1] || (P[1] = (R) => d.value.inputName = R),
                placeholder: "Input Name",
                class: "input col-start-2"
              }, null, 512), [
                [Pr, d.value.inputName]
              ])
            ]),
            q("div", Qp, [
              P[9] || (P[9] = q("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
              mt(q("select", {
                id: "dataflow-type-select",
                name: "dataflowType",
                class: "select col-start-2",
                "onUpdate:modelValue": P[2] || (P[2] = (R) => d.value.dataflowType = R)
              }, [
                P[8] || (P[8] = q("option", { value: "" }, "-", -1)),
                (be(!0), Oe(Je, null, Ut(Object.values(yt(At)), (R) => (be(), Oe("option", {
                  key: R,
                  value: R,
                  disabled: R === yt(At).CONTROL
                }, Fe(R), 9, Jp))), 128))
              ], 512), [
                [kn, d.value.dataflowType]
              ])
            ]),
            q("div", Zp, [
              P[11] || (P[11] = q("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
              mt(q("select", {
                required: "",
                id: "data-attribute-select",
                name: "attribute",
                "onUpdate:modelValue": P[3] || (P[3] = (R) => d.value.dataAttribute = R),
                class: "select col-start-2",
                placeholder: "No Attribute"
              }, [
                P[10] || (P[10] = q("option", {
                  value: "",
                  disabled: ""
                }, "-", -1)),
                (be(!0), Oe(Je, null, Ut(g.value, (R) => (be(), Oe("option", {
                  key: R.id,
                  value: R.id
                }, Fe(R.name), 9, eh))), 128))
              ], 512), [
                [kn, d.value.dataAttribute]
              ])
            ]),
            q("div", th, [
              P[12] || (P[12] = q("label", { for: "process-resource-input" }, "Process Resource", -1)),
              mt(q("input", {
                id: "process-resource-input",
                name: "processResource",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": P[4] || (P[4] = (R) => d.value.processResource = R)
              }, null, 512), [
                [Pr, d.value.processResource]
              ])
            ]),
            q("div", nh, [
              P[14] || (P[14] = q("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
              mt(q("select", {
                id: "preferred-lnode-select",
                name: "preferredLNode",
                class: "select col-start-2",
                "onUpdate:modelValue": P[5] || (P[5] = (R) => d.value.preferredLNode = R)
              }, [
                (be(!0), Oe(Je, null, Ut(K.lnodeTypes, (R) => (be(), Oe("option", {
                  key: R.lnClass,
                  value: R.lnClass
                }, Fe(R.lnClass), 9, rh))), 128)),
                P[13] || (P[13] = q("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 512), [
                [kn, d.value.preferredLNode]
              ])
            ]),
            P[15] || (P[15] = q("div", { class: "modal-action" }, [
              q("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), ih = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, sh = ["value"], ah = ["value"], uh = ["value"], lh = ["value"], ch = { class: "col-span-full row-start-2" }, fh = { class: "grid" }, dh = { class: "col-start-1 row-start-1 pointer-events-none" }, ph = { class: "col-start-1 row-start-1 -order-1" }, hh = /* @__PURE__ */ Gt({
  __name: "dataflow-visualisation",
  props: {
    lnodes: {},
    connections: {},
    lnodeTypes: {},
    controlledConnections: {}
  },
  emits: ["sourceLNodeChange", "destinationLNodeChange", "placeholderCreated"],
  setup(n, { emit: r }) {
    const a = r, u = n;
    gr(
      () => u.lnodes,
      () => {
        c.value = void 0, d.value = void 0;
      }
    );
    const c = _t(), d = _t(), p = _t(), g = _t(), O = It(
      () => u.lnodes.filter((pe) => pe.id !== d.value).sort((pe, me) => Mn(pe).localeCompare(Mn(me)))
    ), K = It(() => u.lnodes.find((me) => me.id === c.value)?.dataObjectSpecifications ?? []), P = It(
      () => u.lnodes.filter((pe) => pe.id !== c.value).sort((pe, me) => Mn(pe).localeCompare(Mn(me)))
    ), R = It(() => !c.value || !d.value ? [] : u.connections.filter(
      (pe) => pe.sourceLNodeId === c.value && pe.destinationLNodeId === d.value
    )), j = It(() => !c.value || !d.value ? [] : u.controlledConnections.filter(
      (pe) => pe.controllerLNodeId === c.value && pe.controlledLNodeId === d.value
    )), L = It(() => d.value ? u.connections.filter(
      (pe) => pe.destinationLNodeId === d.value && !pe.sourceLNodeId
    ) : []);
    function G(pe) {
      return u.lnodes.find((me) => me.id === pe) ?? void 0;
    }
    function fe(pe) {
      c.value = pe, p.value = G(pe), a("sourceLNodeChange", pe);
    }
    function qe(pe) {
      d.value = pe, g.value = G(pe), a("destinationLNodeChange", pe);
    }
    return (pe, me) => (be(), Oe("div", ih, [
      me[7] || (me[7] = q("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      q("select", {
        value: c.value ?? "",
        onChange: me[0] || (me[0] = (Ee) => fe(Ee.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        me[4] || (me[4] = Dl(" > ")),
        me[5] || (me[5] = q("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (be(!0), Oe(Je, null, Ut(O.value, (Ee) => (be(), Oe("option", {
          key: Ee.id,
          value: Ee.id
        }, Fe(yt(Mn)(Ee)), 9, ah))), 128))
      ], 40, sh),
      me[8] || (me[8] = q("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      q("select", {
        value: d.value ?? "",
        onChange: me[1] || (me[1] = (Ee) => qe(Ee.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        me[6] || (me[6] = q("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (be(!0), Oe(Je, null, Ut(P.value, (Ee) => (be(), Oe("option", {
          key: Ee.id,
          value: Ee.id
        }, Fe(yt(Mn)(Ee)), 9, lh))), 128))
      ], 40, uh),
      q("div", ch, [
        R.value.length > 0 ? (be(), An(Xd, {
          key: 0,
          connections: R.value
        }, null, 8, ["connections"])) : Pn("", !0),
        j.value.length > 0 ? (be(), An(Gp, {
          key: 1,
          controlledConnections: j.value
        }, null, 8, ["controlledConnections"])) : Pn("", !0),
        q("div", fh, [
          q("div", dh, [
            Ct(Fp, { dataObjectSpecifications: K.value }, null, 8, ["dataObjectSpecifications"])
          ]),
          q("div", ph, [
            Ct(ap, { destinationPlaceHolderPorts: L.value }, null, 8, ["destinationPlaceHolderPorts"])
          ])
        ])
      ]),
      p.value ? (be(), An(oh, {
        key: p.value.id,
        sourceLNode: p.value,
        class: "col-span-full row-start-3",
        lnodeTypes: pe.lnodeTypes,
        onPlaceholderCreated: me[2] || (me[2] = (Ee) => a("placeholderCreated"))
      }, null, 8, ["sourceLNode", "lnodeTypes"])) : Pn("", !0),
      g.value ? (be(), An(Cp, {
        key: 1,
        destinationLNode: g.value,
        class: "col-span-full row-start-3",
        lnodeTypes: pe.lnodeTypes,
        onPlaceholderCreated: me[3] || (me[3] = (Ee) => a("placeholderCreated"))
      }, null, 8, ["destinationLNode", "lnodeTypes"])) : Pn("", !0)
    ]));
  }
}), mh = { class: "grid grid-cols-2 gap-4 mt-4" }, yh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, vh = ["value"], gh = { class: "grid grid-cols-2 gap-4 mt-4" }, bh = ["value"], _h = { class: "grid grid-cols-2 gap-4 mt-4" }, wh = ["value"], xh = { class: "grid grid-cols-2 gap-4 mt-4" }, Th = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Eh = ["value"], Oh = { class: "grid grid-cols-2 gap-4 mt-4" }, Ch = { class: "grid grid-cols-2 gap-4 mt-4" }, Sh = { class: "mt-4" }, Nh = { class: "mt-4" }, Ah = /* @__PURE__ */ Gt({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const a = n, u = r, c = _t(g());
    Cl(
      () => c.value.inputName = c.value.signal
    ), gr(
      () => c.value.inputName,
      () => {
        c.value.inputInstance = "1";
      }
    ), gr(
      () => a.dataflowType,
      (j) => {
        switch (R(), c.value.type = j, j) {
          case At.GOOSE:
          case At.SMV:
            c.value.includeQuality = !0, c.value.includeTimestamp = !1;
            break;
          case At.REPORT:
            c.value.includeQuality = !0, c.value.includeTimestamp = !0;
            break;
          default:
            c.value.includeQuality = !1, c.value.includeTimestamp = !1;
        }
      }
    );
    const d = It(() => !a.dataflowType || !a.sourceLNode ? [] : a.lnodeTypes.find((j) => j.typeId === a.sourceLNode.lnType)?.dataObjects.filter(
      (j) => j.dataAttributes.some(
        (L) => Hi[a.dataflowType]?.includes(L.fc)
      )
    ).map((j) => j.name) || []), p = It(() => !a.dataflowType || !a.sourceLNode ? [] : a.lnodeTypes.find((j) => j.typeId === a.sourceLNode.lnType)?.dataObjects.find((j) => j.name === c.value.signal)?.dataAttributes.filter(
      (j) => Hi[a.dataflowType]?.includes(j.fc)
    ).filter((j) => j.name !== "t" && j.name !== "q").map((j) => j.name) || []);
    function g() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function O(j) {
      for (const L of j)
        c.value[L] = "";
    }
    async function K() {
      try {
        if (!P(c.value))
          return;
        const j = localStorage.getItem("currentActiveFileDatabaseName");
        if (!j)
          throw new Error("no active file");
        const L = await Oi(j);
        await rs(L).createConnection(
          c.value,
          a.sourceLNode,
          a.destinationLNode
        ), L.close(), u("connectionCreated"), R();
      } catch (j) {
        console.error("Error creating dataflow:", j), alert(`Error creating dataflow: ${j instanceof Error ? j.message : "Unknown error"}`);
      }
    }
    function P(j) {
      return j.type ? j.signal ? j.attribute ? j.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function R() {
      c.value = g();
    }
    return (j, L) => (be(), Oe(Je, null, [
      L[17] || (L[17] = q("hr", { class: "solid mt-4" }, null, -1)),
      q("div", mh, [
        L[7] || (L[7] = q("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Source", -1)),
        q("select", yh, [
          q("option", {
            value: a.sourceLNode.id
          }, Fe(yt(Mn)(j.sourceLNode)), 9, vh)
        ])
      ]),
      q("div", gh, [
        L[9] || (L[9] = q("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Signal (DO)", -1)),
        mt(q("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": L[0] || (L[0] = (G) => c.value.signal = G),
          onChange: L[1] || (L[1] = (G) => O(["attribute"]))
        }, [
          (be(!0), Oe(Je, null, Ut(d.value, (G) => (be(), Oe("option", {
            key: G,
            value: G
          }, Fe(G), 9, bh))), 128)),
          L[8] || (L[8] = q("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 544), [
          [kn, c.value.signal]
        ])
      ]),
      q("div", _h, [
        L[11] || (L[11] = q("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Attribute (DA)", -1)),
        mt(q("select", {
          id: "data-attribute-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": L[2] || (L[2] = (G) => c.value.attribute = G)
        }, [
          (be(!0), Oe(Je, null, Ut(p.value, (G) => (be(), Oe("option", {
            key: G,
            value: G
          }, Fe(G), 9, wh))), 128)),
          L[10] || (L[10] = q("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [kn, c.value.attribute]
        ])
      ]),
      L[18] || (L[18] = q("hr", { class: "solid mt-4" }, null, -1)),
      q("div", xh, [
        L[12] || (L[12] = q("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Destination", -1)),
        q("select", Th, [
          q("option", {
            value: a.destinationLNode.id
          }, Fe(yt(Mn)(j.destinationLNode)), 9, Eh)
        ])
      ]),
      q("div", Oh, [
        L[13] || (L[13] = q("label", {
          for: "input-name-input",
          class: "col-start-1 self-center"
        }, "Input Name", -1)),
        mt(q("input", {
          id: "input-name-input",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": L[3] || (L[3] = (G) => c.value.inputName = G)
        }, null, 512), [
          [Pr, c.value.inputName]
        ])
      ]),
      q("div", Ch, [
        L[14] || (L[14] = q("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        mt(q("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": L[4] || (L[4] = (G) => c.value.inputInstance = G)
        }, null, 512), [
          [Pr, c.value.inputInstance]
        ])
      ]),
      L[19] || (L[19] = q("hr", { class: "solid mt-4" }, null, -1)),
      q("div", Sh, [
        mt(q("input", {
          type: "checkbox",
          "onUpdate:modelValue": L[5] || (L[5] = (G) => c.value.includeQuality = G),
          class: "checkbox mr-2",
          id: "checkbox-include-quality"
        }, null, 512), [
          [lu, c.value.includeQuality]
        ]),
        L[15] || (L[15] = q("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
      ]),
      q("div", Nh, [
        mt(q("input", {
          type: "checkbox",
          "onUpdate:modelValue": L[6] || (L[6] = (G) => c.value.includeTimestamp = G),
          class: "checkbox mr-2",
          id: "checkbox-include-timestamp"
        }, null, 512), [
          [lu, c.value.includeTimestamp]
        ]),
        L[16] || (L[16] = q("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
      ]),
      q("div", { class: "modal-action" }, [
        q("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: K,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), Ph = { class: "grid grid-cols-2 gap-4 mt-4" }, kh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Dh = ["value"], Ih = { class: "grid grid-cols-2 gap-4 mt-4" }, Rh = ["value"], jh = { class: "grid grid-cols-2 gap-4 mt-4" }, Lh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Kh = ["value"], Fh = { class: "grid grid-cols-2 gap-4 mt-4" }, Mh = { class: "grid grid-cols-2 gap-4 mt-4" }, Bh = /* @__PURE__ */ Gt({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const a = n, u = r, c = _t(
      p()
    );
    Cl(
      () => c.value.outputName = c.value.controlledSignal
    ), gr(
      () => c.value.outputName,
      () => {
        c.value.outputInstance = "1";
      }
    );
    const d = It(() => a.destinationLNode ? a.lnodeTypes.find((R) => R.typeId === a.destinationLNode.lnType)?.dataObjects.map((R) => R.name) || [] : []);
    function p() {
      return {
        type: At.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function g() {
      try {
        if (!O(c.value))
          return;
        const P = localStorage.getItem("currentActiveFileDatabaseName");
        if (!P)
          throw new Error("no active file");
        const R = await Oi(P);
        await rs(R).createControlledConnection(
          c.value,
          a.sourceLNode,
          a.destinationLNode
        ), R.close(), u("connectionCreated"), K();
      } catch (P) {
        console.error("Error creating controlled dataflow:", P), alert(`Error creating controlled dataflow: ${P instanceof Error ? P.message : "Unknown error"}`);
      }
    }
    function O(P) {
      return P.type ? P.outputName ? P.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function K() {
      c.value = p();
    }
    return (P, R) => (be(), Oe(Je, null, [
      R[9] || (R[9] = q("hr", { class: "solid mt-4" }, null, -1)),
      q("div", Ph, [
        R[3] || (R[3] = q("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        q("select", kh, [
          q("option", {
            value: a.destinationLNode.id
          }, Fe(yt(Mn)(P.destinationLNode)), 9, Dh)
        ])
      ]),
      q("div", Ih, [
        R[5] || (R[5] = q("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        mt(q("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": R[0] || (R[0] = (j) => c.value.controlledSignal = j)
        }, [
          (be(!0), Oe(Je, null, Ut(d.value, (j) => (be(), Oe("option", {
            key: j,
            value: j
          }, Fe(j), 9, Rh))), 128)),
          R[4] || (R[4] = q("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [kn, c.value.controlledSignal]
        ])
      ]),
      R[10] || (R[10] = q("hr", { class: "solid mt-4" }, null, -1)),
      q("div", jh, [
        R[6] || (R[6] = q("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        q("select", Lh, [
          q("option", {
            value: a.sourceLNode.id
          }, Fe(yt(Mn)(P.sourceLNode)), 9, Kh)
        ])
      ]),
      q("div", Fh, [
        R[7] || (R[7] = q("label", {
          for: "output-name-input",
          class: "col-start-1 self-center"
        }, "Controller Output Name", -1)),
        mt(q("input", {
          id: "output-name-input",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": R[1] || (R[1] = (j) => c.value.outputName = j)
        }, null, 512), [
          [Pr, c.value.outputName]
        ])
      ]),
      q("div", Mh, [
        R[8] || (R[8] = q("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Ouput Instance", -1)),
        mt(q("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": R[2] || (R[2] = (j) => c.value.outputInstance = j)
        }, null, 512), [
          [Pr, c.value.outputInstance]
        ])
      ]),
      R[11] || (R[11] = q("hr", { class: "solid mt-4" }, null, -1)),
      q("div", { class: "modal-action" }, [
        q("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: g,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), qh = ["disabled"], $h = ["open"], Uh = { class: "modal-box" }, Vh = { class: "grid grid-cols-2 gap-4 mt-4" }, Hh = ["value", "disabled"], Wh = /* @__PURE__ */ Gt({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const a = n, u = r, c = _t(!1), d = _t(null), p = It(
      () => a.sourceLNode?.lnClass === "IHMI" || a.sourceLNode?.lnClass === "ITCI"
    );
    function g(R) {
      const j = R.target.value;
      d.value = j;
    }
    function O() {
      u("connectionCreated"), P();
    }
    function K() {
      c.value = !0;
    }
    function P() {
      c.value = !1, d.value = null;
    }
    return (R, j) => (be(), Oe(Je, null, [
      q("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: K,
        disabled: !a.sourceLNode || !a.destinationLNode,
        "aria-label": "Add connection"
      }, " + ", 8, qh),
      a.sourceLNode && a.destinationLNode ? (be(), Oe("dialog", {
        key: 0,
        class: "modal",
        open: c.value
      }, [
        q("div", Uh, [
          j[4] || (j[4] = q("h3", { class: "text-lg font-bold" }, "Create Connection", -1)),
          q("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: P,
            "aria-label": "Close dataflow creation",
            "data-testId": "close-dataflow-creation"
          }, j[1] || (j[1] = [
            q("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              q("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          q("div", Vh, [
            j[3] || (j[3] = q("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            mt(q("select", {
              id: "dataflow-type-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": j[0] || (j[0] = (L) => d.value = L),
              onChange: g
            }, [
              (be(!0), Oe(Je, null, Ut(Object.values(yt(At)), (L) => (be(), Oe("option", {
                key: L,
                value: L,
                disabled: L === yt(At).CONTROL && !p.value
              }, Fe(L), 9, Hh))), 128)),
              j[2] || (j[2] = q("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [kn, d.value]
            ])
          ]),
          d.value !== yt(At).CONTROL ? (be(), An(Ah, {
            key: 0,
            sourceLNode: a.sourceLNode,
            destinationLNode: a.destinationLNode,
            lnodeTypes: a.lnodeTypes,
            dataflowType: d.value,
            onConnectionCreated: O
          }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes", "dataflowType"])) : (be(), An(Bh, {
            key: 1,
            sourceLNode: a.sourceLNode,
            destinationLNode: a.destinationLNode,
            lnodeTypes: a.lnodeTypes,
            dataflowType: d.value,
            onConnectionCreated: O
          }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes", "dataflowType"]))
        ])
      ], 8, $h)) : Pn("", !0)
    ], 64));
  }
}), Gh = { class: "flex flex-col items-center justify-center w-full" }, Yh = /* @__PURE__ */ Gt({
  __name: "dataflow-view",
  props: {
    sdks: {}
  },
  setup(n) {
    const r = n, a = _t(), u = _t(), c = _t([]), d = _t([]), p = _t([]), g = _t([]);
    gr(
      () => r.sdks,
      () => {
        O(), K();
      },
      { immediate: !0 }
    );
    async function O() {
      r.sdks && (c.value = await r.sdks.lnodeSDK.findAllEnrichedLNodes(), d.value = await r.sdks.lnodeSDK.findAllLNodeTypes());
    }
    async function K() {
      r.sdks && (p.value = await r.sdks.connectionSDK.findAllExistingConnections(), g.value = await r.sdks.connectionSDK.findAllExistingControlledConnections());
    }
    function P(L) {
      a.value = j(L);
    }
    function R(L) {
      u.value = j(L);
    }
    function j(L) {
      return c.value.find((G) => G.id === L) ?? void 0;
    }
    return (L, G) => (be(), Oe("div", Gh, [
      Ct(hh, {
        connections: p.value,
        controlledConnections: g.value,
        lnodes: c.value,
        lnodeTypes: d.value,
        onSourceLNodeChange: P,
        onDestinationLNodeChange: R,
        onPlaceholderCreated: K
      }, null, 8, ["connections", "controlledConnections", "lnodes", "lnodeTypes"]),
      Ct(Wh, {
        sourceLNode: a.value,
        destinationLNode: u.value,
        lnodeTypes: d.value,
        onConnectionCreated: K
      }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes"])
    ]));
  }
}), Wl = (n, r) => {
  const a = n.__vccOpts || n;
  for (const [u, c] of r)
    a[u] = c;
  return a;
}, Xh = {}, zh = { class: "layout" }, Qh = { class: "main" }, Jh = { class: "sidebar" };
function Zh(n, r) {
  return be(), Oe("div", zh, [
    q("div", Qh, [
      Ma(n.$slots, "main", {}, void 0)
    ]),
    q("div", Jh, [
      Ma(n.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const em = /* @__PURE__ */ Wl(Xh, [["render", Zh], ["__scopeId", "data-v-5f95d421"]]), tm = {
  name: "sidebar",
  class: "root"
}, nm = { class: "tabs tabs-box" }, rm = { key: 0 }, om = { key: 1 }, im = /* @__PURE__ */ Gt({
  __name: "sidebar",
  setup(n) {
    const r = _t("details");
    return (a, u) => (be(), Oe("div", tm, [
      q("div", nm, [
        mt(q("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": u[0] || (u[0] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [fu, r.value]
        ]),
        mt(q("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": u[1] || (u[1] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [fu, r.value]
        ])
      ]),
      q("div", null, [
        r.value === "details" ? (be(), Oe("div", rm, u[2] || (u[2] = [
          q("div", { id: "sidebar-details" }, null, -1)
        ]))) : Pn("", !0),
        r.value === "advanced" ? (be(), Oe("div", om)) : Pn("", !0)
      ])
    ]));
  }
}), sm = /* @__PURE__ */ Wl(im, [["__scopeId", "data-v-ec5c053a"]]), am = ["id"], um = { class: "p-10" }, lm = /* @__PURE__ */ Gt({
  __name: "app",
  props: {
    api: {}
  },
  setup(n) {
    const r = "dataflow";
    let a = _t();
    dl(() => {
      window.addEventListener("storage", u), c();
    }), Ta(() => {
      window.removeEventListener("storage", u);
    });
    async function u(p) {
      if (p.key !== "currentActiveFileDatabaseName")
        return;
      const g = p.newValue;
      if (!g)
        throw new Error("incorrect active file name: " + g);
      await d(g);
    }
    async function c() {
      const p = localStorage.getItem("currentActiveFileDatabaseName");
      p && await d(p);
    }
    async function d(p) {
      a.value && a.value.db.close();
      const g = await Oi(p);
      if (!g) throw new Error("database is not initialized.");
      a.value = {
        db: g,
        lnodeSDK: Fd(g),
        connectionSDK: Md(g)
      };
    }
    return (p, g) => (be(), Oe("article", {
      id: yt(r),
      style: { height: "100%" }
    }, [
      Ct(em, null, {
        main: Ws(() => [
          q("div", um, [
            Ct(Yh, { sdks: yt(a) }, null, 8, ["sdks"])
          ])
        ]),
        sidebar: Ws(() => [
          Ct(sm)
        ]),
        _: 1
      })
    ], 8, am));
  }
});
function Dm(n, r) {
  if (!document.getElementById(n)) {
    console.error({ msg: "could not found root element", rootId: n });
    return;
  }
  const u = pd(lm, { api: r });
  return u.use(yd()), u.mount(`#${n}`), u.unmount;
}
export {
  Dm as default
};
