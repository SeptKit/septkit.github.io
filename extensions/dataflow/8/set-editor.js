(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-86088f9f]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-86088f9f]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-86088f9f]{padding:1rem;height:100%}.root[data-v-d560451c]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-d560451c]{transition:all .2s}.tabs[data-v-d560451c]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-\\[1\\.5rem\\]{top:1.5rem}.right-\\[1\\.5rem\\]{right:1.5rem}.left-\\[80\\%\\]{left:80%}.-z-1{z-index:-1}.z-1{z-index:1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.min-h-\\[450px\\]{min-height:450px}.w-\\[20\\%\\]{width:20%}.w-\\[20px\\]{width:20px}.w-full{width:100%}.cursor-pointer{cursor:pointer}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-1{grid-template-rows:repeat(1,minmax(0,1fr))}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-white{color:var(--color-white)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Gi(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const o of e.split(",")) t[o] = 1;
  return (o) => o in t;
}
const Ke = {}, nr = [], Ut = () => {
}, bl = () => !1, Do = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Yi = (e) => e.startsWith("onUpdate:"), mt = Object.assign, Qi = (e, t) => {
  const o = e.indexOf(t);
  o > -1 && e.splice(o, 1);
}, _l = Object.prototype.hasOwnProperty, Ie = (e, t) => _l.call(e, t), fe = Array.isArray, rr = (e) => Kr(e) === "[object Map]", ur = (e) => Kr(e) === "[object Set]", Gs = (e) => Kr(e) === "[object Date]", ge = (e) => typeof e == "function", Je = (e) => typeof e == "string", Kt = (e) => typeof e == "symbol", qe = (e) => e !== null && typeof e == "object", Da = (e) => (qe(e) || ge(e)) && ge(e.then) && ge(e.catch), Ia = Object.prototype.toString, Kr = (e) => Ia.call(e), wl = (e) => Kr(e).slice(8, -1), ja = (e) => Kr(e) === "[object Object]", Ji = (e) => Je(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Sr = /* @__PURE__ */ Gi(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Io = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (o) => t[o] || (t[o] = e(o));
}, xl = /-(\w)/g, Cn = Io(
  (e) => e.replace(xl, (t, o) => o ? o.toUpperCase() : "")
), Sl = /\B([A-Z])/g, qn = Io(
  (e) => e.replace(Sl, "-$1").toLowerCase()
), La = Io((e) => e.charAt(0).toUpperCase() + e.slice(1)), xi = Io(
  (e) => e ? `on${La(e)}` : ""
), xn = (e, t) => !Object.is(e, t), mo = (e, ...t) => {
  for (let o = 0; o < e.length; o++)
    e[o](...t);
}, Ii = (e, t, o, i = !1) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: o
  });
}, _o = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
};
let Ys;
const jo = () => Ys || (Ys = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Lo(e) {
  if (fe(e)) {
    const t = {};
    for (let o = 0; o < e.length; o++) {
      const i = e[o], a = Je(i) ? Pl(i) : Lo(i);
      if (a)
        for (const l in a)
          t[l] = a[l];
    }
    return t;
  } else if (Je(e) || qe(e))
    return e;
}
const Cl = /;(?![^(]*\))/g, Ol = /:([^]+)/, El = /\/\*[^]*?\*\//g;
function Pl(e) {
  const t = {};
  return e.replace(El, "").split(Cl).forEach((o) => {
    if (o) {
      const i = o.split(Ol);
      i.length > 1 && (t[i[0].trim()] = i[1].trim());
    }
  }), t;
}
function kr(e) {
  let t = "";
  if (Je(e))
    t = e;
  else if (fe(e))
    for (let o = 0; o < e.length; o++) {
      const i = kr(e[o]);
      i && (t += i + " ");
    }
  else if (qe(e))
    for (const o in e)
      e[o] && (t += o + " ");
  return t.trim();
}
const Tl = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Nl = /* @__PURE__ */ Gi(Tl);
function Ka(e) {
  return !!e || e === "";
}
function Al(e, t) {
  if (e.length !== t.length) return !1;
  let o = !0;
  for (let i = 0; o && i < e.length; i++)
    o = Bn(e[i], t[i]);
  return o;
}
function Bn(e, t) {
  if (e === t) return !0;
  let o = Gs(e), i = Gs(t);
  if (o || i)
    return o && i ? e.getTime() === t.getTime() : !1;
  if (o = Kt(e), i = Kt(t), o || i)
    return e === t;
  if (o = fe(e), i = fe(t), o || i)
    return o && i ? Al(e, t) : !1;
  if (o = qe(e), i = qe(t), o || i) {
    if (!o || !i)
      return !1;
    const a = Object.keys(e).length, l = Object.keys(t).length;
    if (a !== l)
      return !1;
    for (const f in e) {
      const p = e.hasOwnProperty(f), m = t.hasOwnProperty(f);
      if (p && !m || !p && m || !Bn(e[f], t[f]))
        return !1;
    }
  }
  return String(e) === String(t);
}
function Xi(e, t) {
  return e.findIndex((o) => Bn(o, t));
}
const Ma = (e) => !!(e && e.__v_isRef === !0), je = (e) => Je(e) ? e : e == null ? "" : fe(e) || qe(e) && (e.toString === Ia || !ge(e.toString)) ? Ma(e) ? je(e.value) : JSON.stringify(e, Fa, 2) : String(e), Fa = (e, t) => Ma(t) ? Fa(e, t.value) : rr(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (o, [i, a], l) => (o[Si(i, l) + " =>"] = a, o),
    {}
  )
} : ur(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((o) => Si(o))
} : Kt(t) ? Si(t) : qe(t) && !fe(t) && !ja(t) ? String(t) : t, Si = (e, t = "") => {
  var o;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Kt(e) ? `Symbol(${(o = e.description) != null ? o : t})` : e
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let dt;
class $a {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = dt, !t && dt && (this.index = (dt.scopes || (dt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, o;
      if (this.scopes)
        for (t = 0, o = this.scopes.length; t < o; t++)
          this.scopes[t].pause();
      for (t = 0, o = this.effects.length; t < o; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, o;
      if (this.scopes)
        for (t = 0, o = this.scopes.length; t < o; t++)
          this.scopes[t].resume();
      for (t = 0, o = this.effects.length; t < o; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const o = dt;
      try {
        return dt = this, t();
      } finally {
        dt = o;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = dt, dt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (dt = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let o, i;
      for (o = 0, i = this.effects.length; o < i; o++)
        this.effects[o].stop();
      for (this.effects.length = 0, o = 0, i = this.cleanups.length; o < i; o++)
        this.cleanups[o]();
      if (this.cleanups.length = 0, this.scopes) {
        for (o = 0, i = this.scopes.length; o < i; o++)
          this.scopes[o].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const a = this.parent.scopes.pop();
        a && a !== this && (this.parent.scopes[this.index] = a, a.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Ba(e) {
  return new $a(e);
}
function qa() {
  return dt;
}
function kl(e, t = !1) {
  dt && dt.cleanups.push(e);
}
let Me;
const Ci = /* @__PURE__ */ new WeakSet();
class Va {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, dt && dt.active && dt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ci.has(this) && (Ci.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Ha(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Qs(this), Wa(this);
    const t = Me, o = Lt;
    Me = this, Lt = !0;
    try {
      return this.fn();
    } finally {
      za(this), Me = t, Lt = o, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        ts(t);
      this.deps = this.depsTail = void 0, Qs(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ci.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    ji(this) && this.run();
  }
  get dirty() {
    return ji(this);
  }
}
let Ua = 0, Cr, Or;
function Ha(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = Or, Or = e;
    return;
  }
  e.next = Cr, Cr = e;
}
function Zi() {
  Ua++;
}
function es() {
  if (--Ua > 0)
    return;
  if (Or) {
    let t = Or;
    for (Or = void 0; t; ) {
      const o = t.next;
      t.next = void 0, t.flags &= -9, t = o;
    }
  }
  let e;
  for (; Cr; ) {
    let t = Cr;
    for (Cr = void 0; t; ) {
      const o = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (i) {
          e || (e = i);
        }
      t = o;
    }
  }
  if (e) throw e;
}
function Wa(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function za(e) {
  let t, o = e.depsTail, i = o;
  for (; i; ) {
    const a = i.prevDep;
    i.version === -1 ? (i === o && (o = a), ts(i), Rl(i)) : t = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = a;
  }
  e.deps = t, e.depsTail = o;
}
function ji(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (Ga(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function Ga(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Rr) || (e.globalVersion = Rr, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !ji(e))))
    return;
  e.flags |= 2;
  const t = e.dep, o = Me, i = Lt;
  Me = e, Lt = !0;
  try {
    Wa(e);
    const a = e.fn(e._value);
    (t.version === 0 || xn(a, e._value)) && (e.flags |= 128, e._value = a, t.version++);
  } catch (a) {
    throw t.version++, a;
  } finally {
    Me = o, Lt = i, za(e), e.flags &= -3;
  }
}
function ts(e, t = !1) {
  const { dep: o, prevSub: i, nextSub: a } = e;
  if (i && (i.nextSub = a, e.prevSub = void 0), a && (a.prevSub = i, e.nextSub = void 0), o.subs === e && (o.subs = i, !i && o.computed)) {
    o.computed.flags &= -5;
    for (let l = o.computed.deps; l; l = l.nextDep)
      ts(l, !0);
  }
  !t && !--o.sc && o.map && o.map.delete(o.key);
}
function Rl(e) {
  const { prevDep: t, nextDep: o } = e;
  t && (t.nextDep = o, e.prevDep = void 0), o && (o.prevDep = t, e.nextDep = void 0);
}
let Lt = !0;
const Ya = [];
function rn() {
  Ya.push(Lt), Lt = !1;
}
function on() {
  const e = Ya.pop();
  Lt = e === void 0 ? !0 : e;
}
function Qs(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const o = Me;
    Me = void 0;
    try {
      t();
    } finally {
      Me = o;
    }
  }
}
let Rr = 0;
class Dl {
  constructor(t, o) {
    this.sub = t, this.dep = o, this.version = o.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ns {
  // TODO isolatedDeclarations "__v_skip"
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(t) {
    if (!Me || !Lt || Me === this.computed)
      return;
    let o = this.activeLink;
    if (o === void 0 || o.sub !== Me)
      o = this.activeLink = new Dl(Me, this), Me.deps ? (o.prevDep = Me.depsTail, Me.depsTail.nextDep = o, Me.depsTail = o) : Me.deps = Me.depsTail = o, Qa(o);
    else if (o.version === -1 && (o.version = this.version, o.nextDep)) {
      const i = o.nextDep;
      i.prevDep = o.prevDep, o.prevDep && (o.prevDep.nextDep = i), o.prevDep = Me.depsTail, o.nextDep = void 0, Me.depsTail.nextDep = o, Me.depsTail = o, Me.deps === o && (Me.deps = i);
    }
    return o;
  }
  trigger(t) {
    this.version++, Rr++, this.notify(t);
  }
  notify(t) {
    Zi();
    try {
      for (let o = this.subs; o; o = o.prevSub)
        o.sub.notify() && o.sub.dep.notify();
    } finally {
      es();
    }
  }
}
function Qa(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let i = t.deps; i; i = i.nextDep)
        Qa(i);
    }
    const o = e.dep.subs;
    o !== e && (e.prevSub = o, o && (o.nextSub = e)), e.dep.subs = e;
  }
}
const wo = /* @__PURE__ */ new WeakMap(), Fn = Symbol(
  ""
), Li = Symbol(
  ""
), Dr = Symbol(
  ""
);
function pt(e, t, o) {
  if (Lt && Me) {
    let i = wo.get(e);
    i || wo.set(e, i = /* @__PURE__ */ new Map());
    let a = i.get(o);
    a || (i.set(o, a = new ns()), a.map = i, a.key = o), a.track();
  }
}
function Jt(e, t, o, i, a, l) {
  const f = wo.get(e);
  if (!f) {
    Rr++;
    return;
  }
  const p = (m) => {
    m && m.trigger();
  };
  if (Zi(), t === "clear")
    f.forEach(p);
  else {
    const m = fe(e), P = m && Ji(o);
    if (m && o === "length") {
      const S = Number(i);
      f.forEach((R, F) => {
        (F === "length" || F === Dr || !Kt(F) && F >= S) && p(R);
      });
    } else
      switch ((o !== void 0 || f.has(void 0)) && p(f.get(o)), P && p(f.get(Dr)), t) {
        case "add":
          m ? P && p(f.get("length")) : (p(f.get(Fn)), rr(e) && p(f.get(Li)));
          break;
        case "delete":
          m || (p(f.get(Fn)), rr(e) && p(f.get(Li)));
          break;
        case "set":
          rr(e) && p(f.get(Fn));
          break;
      }
  }
  es();
}
function Il(e, t) {
  const o = wo.get(e);
  return o && o.get(t);
}
function Zn(e) {
  const t = Ae(e);
  return t === e ? t : (pt(t, "iterate", Dr), Dt(e) ? t : t.map(it));
}
function Ko(e) {
  return pt(e = Ae(e), "iterate", Dr), e;
}
const jl = {
  __proto__: null,
  [Symbol.iterator]() {
    return Oi(this, Symbol.iterator, it);
  },
  concat(...e) {
    return Zn(this).concat(
      ...e.map((t) => fe(t) ? Zn(t) : t)
    );
  },
  entries() {
    return Oi(this, "entries", (e) => (e[1] = it(e[1]), e));
  },
  every(e, t) {
    return Yt(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return Yt(this, "filter", e, t, (o) => o.map(it), arguments);
  },
  find(e, t) {
    return Yt(this, "find", e, t, it, arguments);
  },
  findIndex(e, t) {
    return Yt(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return Yt(this, "findLast", e, t, it, arguments);
  },
  findLastIndex(e, t) {
    return Yt(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return Yt(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return Ei(this, "includes", e);
  },
  indexOf(...e) {
    return Ei(this, "indexOf", e);
  },
  join(e) {
    return Zn(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return Ei(this, "lastIndexOf", e);
  },
  map(e, t) {
    return Yt(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return _r(this, "pop");
  },
  push(...e) {
    return _r(this, "push", e);
  },
  reduce(e, ...t) {
    return Js(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return Js(this, "reduceRight", e, t);
  },
  shift() {
    return _r(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return Yt(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return _r(this, "splice", e);
  },
  toReversed() {
    return Zn(this).toReversed();
  },
  toSorted(e) {
    return Zn(this).toSorted(e);
  },
  toSpliced(...e) {
    return Zn(this).toSpliced(...e);
  },
  unshift(...e) {
    return _r(this, "unshift", e);
  },
  values() {
    return Oi(this, "values", it);
  }
};
function Oi(e, t, o) {
  const i = Ko(e), a = i[t]();
  return i !== e && !Dt(e) && (a._next = a.next, a.next = () => {
    const l = a._next();
    return l.value && (l.value = o(l.value)), l;
  }), a;
}
const Ll = Array.prototype;
function Yt(e, t, o, i, a, l) {
  const f = Ko(e), p = f !== e && !Dt(e), m = f[t];
  if (m !== Ll[t]) {
    const R = m.apply(e, l);
    return p ? it(R) : R;
  }
  let P = o;
  f !== e && (p ? P = function(R, F) {
    return o.call(this, it(R), F, e);
  } : o.length > 2 && (P = function(R, F) {
    return o.call(this, R, F, e);
  }));
  const S = m.call(f, P, i);
  return p && a ? a(S) : S;
}
function Js(e, t, o, i) {
  const a = Ko(e);
  let l = o;
  return a !== e && (Dt(e) ? o.length > 3 && (l = function(f, p, m) {
    return o.call(this, f, p, m, e);
  }) : l = function(f, p, m) {
    return o.call(this, f, it(p), m, e);
  }), a[t](l, ...i);
}
function Ei(e, t, o) {
  const i = Ae(e);
  pt(i, "iterate", Dr);
  const a = i[t](...o);
  return (a === -1 || a === !1) && is(o[0]) ? (o[0] = Ae(o[0]), i[t](...o)) : a;
}
function _r(e, t, o = []) {
  rn(), Zi();
  const i = Ae(e)[t].apply(e, o);
  return es(), on(), i;
}
const Kl = /* @__PURE__ */ Gi("__proto__,__v_isRef,__isVue"), Ja = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Kt)
);
function Ml(e) {
  Kt(e) || (e = String(e));
  const t = Ae(this);
  return pt(t, "has", e), t.hasOwnProperty(e);
}
class Xa {
  constructor(t = !1, o = !1) {
    this._isReadonly = t, this._isShallow = o;
  }
  get(t, o, i) {
    if (o === "__v_skip") return t.__v_skip;
    const a = this._isReadonly, l = this._isShallow;
    if (o === "__v_isReactive")
      return !a;
    if (o === "__v_isReadonly")
      return a;
    if (o === "__v_isShallow")
      return l;
    if (o === "__v_raw")
      return i === (a ? l ? Gl : nu : l ? tu : eu).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0;
    const f = fe(t);
    if (!a) {
      let m;
      if (f && (m = jl[o]))
        return m;
      if (o === "hasOwnProperty")
        return Ml;
    }
    const p = Reflect.get(
      t,
      o,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Ye(t) ? t : i
    );
    return (Kt(o) ? Ja.has(o) : Kl(o)) || (a || pt(t, "get", o), l) ? p : Ye(p) ? f && Ji(o) ? p : p.value : qe(p) ? a ? ru(p) : Mo(p) : p;
  }
}
class Za extends Xa {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, o, i, a) {
    let l = t[o];
    if (!this._isShallow) {
      const m = On(l);
      if (!Dt(i) && !On(i) && (l = Ae(l), i = Ae(i)), !fe(t) && Ye(l) && !Ye(i))
        return m ? !1 : (l.value = i, !0);
    }
    const f = fe(t) && Ji(o) ? Number(o) < t.length : Ie(t, o), p = Reflect.set(
      t,
      o,
      i,
      Ye(t) ? t : a
    );
    return t === Ae(a) && (f ? xn(i, l) && Jt(t, "set", o, i) : Jt(t, "add", o, i)), p;
  }
  deleteProperty(t, o) {
    const i = Ie(t, o);
    t[o];
    const a = Reflect.deleteProperty(t, o);
    return a && i && Jt(t, "delete", o, void 0), a;
  }
  has(t, o) {
    const i = Reflect.has(t, o);
    return (!Kt(o) || !Ja.has(o)) && pt(t, "has", o), i;
  }
  ownKeys(t) {
    return pt(
      t,
      "iterate",
      fe(t) ? "length" : Fn
    ), Reflect.ownKeys(t);
  }
}
class Fl extends Xa {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, o) {
    return !0;
  }
  deleteProperty(t, o) {
    return !0;
  }
}
const $l = /* @__PURE__ */ new Za(), Bl = /* @__PURE__ */ new Fl(), ql = /* @__PURE__ */ new Za(!0);
const Ki = (e) => e, fo = (e) => Reflect.getPrototypeOf(e);
function Vl(e, t, o) {
  return function(...i) {
    const a = this.__v_raw, l = Ae(a), f = rr(l), p = e === "entries" || e === Symbol.iterator && f, m = e === "keys" && f, P = a[e](...i), S = o ? Ki : t ? xo : it;
    return !t && pt(
      l,
      "iterate",
      m ? Li : Fn
    ), {
      // iterator protocol
      next() {
        const { value: R, done: F } = P.next();
        return F ? { value: R, done: F } : {
          value: p ? [S(R[0]), S(R[1])] : S(R),
          done: F
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function po(e) {
  return function(...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function Ul(e, t) {
  const o = {
    get(a) {
      const l = this.__v_raw, f = Ae(l), p = Ae(a);
      e || (xn(a, p) && pt(f, "get", a), pt(f, "get", p));
      const { has: m } = fo(f), P = t ? Ki : e ? xo : it;
      if (m.call(f, a))
        return P(l.get(a));
      if (m.call(f, p))
        return P(l.get(p));
      l !== f && l.get(a);
    },
    get size() {
      const a = this.__v_raw;
      return !e && pt(Ae(a), "iterate", Fn), Reflect.get(a, "size", a);
    },
    has(a) {
      const l = this.__v_raw, f = Ae(l), p = Ae(a);
      return e || (xn(a, p) && pt(f, "has", a), pt(f, "has", p)), a === p ? l.has(a) : l.has(a) || l.has(p);
    },
    forEach(a, l) {
      const f = this, p = f.__v_raw, m = Ae(p), P = t ? Ki : e ? xo : it;
      return !e && pt(m, "iterate", Fn), p.forEach((S, R) => a.call(l, P(S), P(R), f));
    }
  };
  return mt(
    o,
    e ? {
      add: po("add"),
      set: po("set"),
      delete: po("delete"),
      clear: po("clear")
    } : {
      add(a) {
        !t && !Dt(a) && !On(a) && (a = Ae(a));
        const l = Ae(this);
        return fo(l).has.call(l, a) || (l.add(a), Jt(l, "add", a, a)), this;
      },
      set(a, l) {
        !t && !Dt(l) && !On(l) && (l = Ae(l));
        const f = Ae(this), { has: p, get: m } = fo(f);
        let P = p.call(f, a);
        P || (a = Ae(a), P = p.call(f, a));
        const S = m.call(f, a);
        return f.set(a, l), P ? xn(l, S) && Jt(f, "set", a, l) : Jt(f, "add", a, l), this;
      },
      delete(a) {
        const l = Ae(this), { has: f, get: p } = fo(l);
        let m = f.call(l, a);
        m || (a = Ae(a), m = f.call(l, a)), p && p.call(l, a);
        const P = l.delete(a);
        return m && Jt(l, "delete", a, void 0), P;
      },
      clear() {
        const a = Ae(this), l = a.size !== 0, f = a.clear();
        return l && Jt(
          a,
          "clear",
          void 0,
          void 0
        ), f;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((a) => {
    o[a] = Vl(a, e, t);
  }), o;
}
function rs(e, t) {
  const o = Ul(e, t);
  return (i, a, l) => a === "__v_isReactive" ? !e : a === "__v_isReadonly" ? e : a === "__v_raw" ? i : Reflect.get(
    Ie(o, a) && a in i ? o : i,
    a,
    l
  );
}
const Hl = {
  get: /* @__PURE__ */ rs(!1, !1)
}, Wl = {
  get: /* @__PURE__ */ rs(!1, !0)
}, zl = {
  get: /* @__PURE__ */ rs(!0, !1)
};
const eu = /* @__PURE__ */ new WeakMap(), tu = /* @__PURE__ */ new WeakMap(), nu = /* @__PURE__ */ new WeakMap(), Gl = /* @__PURE__ */ new WeakMap();
function Yl(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Ql(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Yl(wl(e));
}
function Mo(e) {
  return On(e) ? e : os(
    e,
    !1,
    $l,
    Hl,
    eu
  );
}
function Jl(e) {
  return os(
    e,
    !1,
    ql,
    Wl,
    tu
  );
}
function ru(e) {
  return os(
    e,
    !0,
    Bl,
    zl,
    nu
  );
}
function os(e, t, o, i, a) {
  if (!qe(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const l = Ql(e);
  if (l === 0)
    return e;
  const f = a.get(e);
  if (f)
    return f;
  const p = new Proxy(
    e,
    l === 2 ? i : o
  );
  return a.set(e, p), p;
}
function Sn(e) {
  return On(e) ? Sn(e.__v_raw) : !!(e && e.__v_isReactive);
}
function On(e) {
  return !!(e && e.__v_isReadonly);
}
function Dt(e) {
  return !!(e && e.__v_isShallow);
}
function is(e) {
  return e ? !!e.__v_raw : !1;
}
function Ae(e) {
  const t = e && e.__v_raw;
  return t ? Ae(t) : e;
}
function ss(e) {
  return !Ie(e, "__v_skip") && Object.isExtensible(e) && Ii(e, "__v_skip", !0), e;
}
const it = (e) => qe(e) ? Mo(e) : e, xo = (e) => qe(e) ? ru(e) : e;
function Ye(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Ze(e) {
  return Xl(e, !1);
}
function Xl(e, t) {
  return Ye(e) ? e : new Zl(e, t);
}
class Zl {
  constructor(t, o) {
    this.dep = new ns(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = o ? t : Ae(t), this._value = o ? t : it(t), this.__v_isShallow = o;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(t) {
    const o = this._rawValue, i = this.__v_isShallow || Dt(t) || On(t);
    t = i ? t : Ae(t), xn(t, o) && (this._rawValue = t, this._value = i ? t : it(t), this.dep.trigger());
  }
}
function Xe(e) {
  return Ye(e) ? e.value : e;
}
const ec = {
  get: (e, t, o) => t === "__v_raw" ? e : Xe(Reflect.get(e, t, o)),
  set: (e, t, o, i) => {
    const a = e[t];
    return Ye(a) && !Ye(o) ? (a.value = o, !0) : Reflect.set(e, t, o, i);
  }
};
function ou(e) {
  return Sn(e) ? e : new Proxy(e, ec);
}
function tc(e) {
  const t = fe(e) ? new Array(e.length) : {};
  for (const o in e)
    t[o] = rc(e, o);
  return t;
}
class nc {
  constructor(t, o, i) {
    this._object = t, this._key = o, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return Il(Ae(this._object), this._key);
  }
}
function rc(e, t, o) {
  const i = e[t];
  return Ye(i) ? i : new nc(e, t, o);
}
class oc {
  constructor(t, o, i) {
    this.fn = t, this.setter = o, this._value = void 0, this.dep = new ns(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Rr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !o, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Me !== this)
      return Ha(this, !0), !0;
  }
  get value() {
    const t = this.dep.track();
    return Ga(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter && this.setter(t);
  }
}
function ic(e, t, o = !1) {
  let i, a;
  return ge(e) ? i = e : (i = e.get, a = e.set), new oc(i, a, o);
}
const ho = {}, So = /* @__PURE__ */ new WeakMap();
let Kn;
function sc(e, t = !1, o = Kn) {
  if (o) {
    let i = So.get(o);
    i || So.set(o, i = []), i.push(e);
  }
}
function ac(e, t, o = Ke) {
  const { immediate: i, deep: a, once: l, scheduler: f, augmentJob: p, call: m } = o, P = (ue) => a ? ue : Dt(ue) || a === !1 || a === 0 ? Xt(ue, 1) : Xt(ue);
  let S, R, F, G, oe = !1, $ = !1;
  if (Ye(e) ? (R = () => e.value, oe = Dt(e)) : Sn(e) ? (R = () => P(e), oe = !0) : fe(e) ? ($ = !0, oe = e.some((ue) => Sn(ue) || Dt(ue)), R = () => e.map((ue) => {
    if (Ye(ue))
      return ue.value;
    if (Sn(ue))
      return P(ue);
    if (ge(ue))
      return m ? m(ue, 2) : ue();
  })) : ge(e) ? t ? R = m ? () => m(e, 2) : e : R = () => {
    if (F) {
      rn();
      try {
        F();
      } finally {
        on();
      }
    }
    const ue = Kn;
    Kn = S;
    try {
      return m ? m(e, 3, [G]) : e(G);
    } finally {
      Kn = ue;
    }
  } : R = Ut, t && a) {
    const ue = R, be = a === !0 ? 1 / 0 : a;
    R = () => Xt(ue(), be);
  }
  const O = qa(), I = () => {
    S.stop(), O && O.active && Qi(O.effects, S);
  };
  if (l && t) {
    const ue = t;
    t = (...be) => {
      ue(...be), I();
    };
  }
  let de = $ ? new Array(e.length).fill(ho) : ho;
  const Se = (ue) => {
    if (!(!(S.flags & 1) || !S.dirty && !ue))
      if (t) {
        const be = S.run();
        if (a || oe || ($ ? be.some((Le, Re) => xn(Le, de[Re])) : xn(be, de))) {
          F && F();
          const Le = Kn;
          Kn = S;
          try {
            const Re = [
              be,
              // pass undefined as the old value when it's changed for the first time
              de === ho ? void 0 : $ && de[0] === ho ? [] : de,
              G
            ];
            de = be, m ? m(t, 3, Re) : (
              // @ts-expect-error
              t(...Re)
            );
          } finally {
            Kn = Le;
          }
        }
      } else
        S.run();
  };
  return p && p(Se), S = new Va(R), S.scheduler = f ? () => f(Se, !1) : Se, G = (ue) => sc(ue, !1, S), F = S.onStop = () => {
    const ue = So.get(S);
    if (ue) {
      if (m)
        m(ue, 4);
      else
        for (const be of ue) be();
      So.delete(S);
    }
  }, t ? i ? Se(!0) : de = S.run() : f ? f(Se.bind(null, !0), !0) : S.run(), I.pause = S.pause.bind(S), I.resume = S.resume.bind(S), I.stop = I, I;
}
function Xt(e, t = 1 / 0, o) {
  if (t <= 0 || !qe(e) || e.__v_skip || (o = o || /* @__PURE__ */ new Set(), o.has(e)))
    return e;
  if (o.add(e), t--, Ye(e))
    Xt(e.value, t, o);
  else if (fe(e))
    for (let i = 0; i < e.length; i++)
      Xt(e[i], t, o);
  else if (ur(e) || rr(e))
    e.forEach((i) => {
      Xt(i, t, o);
    });
  else if (ja(e)) {
    for (const i in e)
      Xt(e[i], t, o);
    for (const i of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, i) && Xt(e[i], t, o);
  }
  return e;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Mr(e, t, o, i) {
  try {
    return i ? e(...i) : e();
  } catch (a) {
    Fo(a, t, o);
  }
}
function Ht(e, t, o, i) {
  if (ge(e)) {
    const a = Mr(e, t, o, i);
    return a && Da(a) && a.catch((l) => {
      Fo(l, t, o);
    }), a;
  }
  if (fe(e)) {
    const a = [];
    for (let l = 0; l < e.length; l++)
      a.push(Ht(e[l], t, o, i));
    return a;
  }
}
function Fo(e, t, o, i = !0) {
  const a = t ? t.vnode : null, { errorHandler: l, throwUnhandledErrorInProduction: f } = t && t.appContext.config || Ke;
  if (t) {
    let p = t.parent;
    const m = t.proxy, P = `https://vuejs.org/error-reference/#runtime-${o}`;
    for (; p; ) {
      const S = p.ec;
      if (S) {
        for (let R = 0; R < S.length; R++)
          if (S[R](e, m, P) === !1)
            return;
      }
      p = p.parent;
    }
    if (l) {
      rn(), Mr(l, null, 10, [
        e,
        m,
        P
      ]), on();
      return;
    }
  }
  uc(e, o, a, i, f);
}
function uc(e, t, o, i = !0, a = !1) {
  if (a)
    throw e;
  console.error(e);
}
const _t = [];
let qt = -1;
const or = [];
let _n = null, tr = 0;
const iu = /* @__PURE__ */ Promise.resolve();
let Co = null;
function as(e) {
  const t = Co || iu;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function lc(e) {
  let t = qt + 1, o = _t.length;
  for (; t < o; ) {
    const i = t + o >>> 1, a = _t[i], l = Ir(a);
    l < e || l === e && a.flags & 2 ? t = i + 1 : o = i;
  }
  return t;
}
function us(e) {
  if (!(e.flags & 1)) {
    const t = Ir(e), o = _t[_t.length - 1];
    !o || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= Ir(o) ? _t.push(e) : _t.splice(lc(t), 0, e), e.flags |= 1, su();
  }
}
function su() {
  Co || (Co = iu.then(uu));
}
function cc(e) {
  fe(e) ? or.push(...e) : _n && e.id === -1 ? _n.splice(tr + 1, 0, e) : e.flags & 1 || (or.push(e), e.flags |= 1), su();
}
function Xs(e, t, o = qt + 1) {
  for (; o < _t.length; o++) {
    const i = _t[o];
    if (i && i.flags & 2) {
      if (e && i.id !== e.uid)
        continue;
      _t.splice(o, 1), o--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function au(e) {
  if (or.length) {
    const t = [...new Set(or)].sort(
      (o, i) => Ir(o) - Ir(i)
    );
    if (or.length = 0, _n) {
      _n.push(...t);
      return;
    }
    for (_n = t, tr = 0; tr < _n.length; tr++) {
      const o = _n[tr];
      o.flags & 4 && (o.flags &= -2), o.flags & 8 || o(), o.flags &= -2;
    }
    _n = null, tr = 0;
  }
}
const Ir = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function uu(e) {
  try {
    for (qt = 0; qt < _t.length; qt++) {
      const t = _t[qt];
      t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Mr(
        t,
        t.i,
        t.i ? 15 : 14
      ), t.flags & 4 || (t.flags &= -2));
    }
  } finally {
    for (; qt < _t.length; qt++) {
      const t = _t[qt];
      t && (t.flags &= -2);
    }
    qt = -1, _t.length = 0, au(), Co = null, (_t.length || or.length) && uu();
  }
}
let st = null, lu = null;
function Oo(e) {
  const t = st;
  return st = e, lu = e && e.type.__scopeId || null, t;
}
function Mi(e, t = st, o) {
  if (!t || e._n)
    return e;
  const i = (...a) => {
    i._d && ua(-1);
    const l = Oo(t);
    let f;
    try {
      f = e(...a);
    } finally {
      Oo(l), i._d && ua(1);
    }
    return f;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function ot(e, t) {
  if (st === null)
    return e;
  const o = Vo(st), i = e.dirs || (e.dirs = []);
  for (let a = 0; a < t.length; a++) {
    let [l, f, p, m = Ke] = t[a];
    l && (ge(l) && (l = {
      mounted: l,
      updated: l
    }), l.deep && Xt(f), i.push({
      dir: l,
      instance: o,
      value: f,
      oldValue: void 0,
      arg: p,
      modifiers: m
    }));
  }
  return e;
}
function jn(e, t, o, i) {
  const a = e.dirs, l = t && t.dirs;
  for (let f = 0; f < a.length; f++) {
    const p = a[f];
    l && (p.oldValue = l[f].value);
    let m = p.dir[i];
    m && (rn(), Ht(m, o, 8, [
      e.el,
      p,
      e,
      t
    ]), on());
  }
}
const fc = Symbol("_vte"), dc = (e) => e.__isTeleport;
function ls(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, ls(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function an(e, t) {
  return ge(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    mt({ name: e.name }, t, { setup: e })
  ) : e;
}
function cu(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function Er(e, t, o, i, a = !1) {
  if (fe(e)) {
    e.forEach(
      (oe, $) => Er(
        oe,
        t && (fe(t) ? t[$] : t),
        o,
        i,
        a
      )
    );
    return;
  }
  if (ir(i) && !a) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && Er(e, t, o, i.component.subTree);
    return;
  }
  const l = i.shapeFlag & 4 ? Vo(i.component) : i.el, f = a ? null : l, { i: p, r: m } = e, P = t && t.r, S = p.refs === Ke ? p.refs = {} : p.refs, R = p.setupState, F = Ae(R), G = R === Ke ? () => !1 : (oe) => Ie(F, oe);
  if (P != null && P !== m && (Je(P) ? (S[P] = null, G(P) && (R[P] = null)) : Ye(P) && (P.value = null)), ge(m))
    Mr(m, p, 12, [f, S]);
  else {
    const oe = Je(m), $ = Ye(m);
    if (oe || $) {
      const O = () => {
        if (e.f) {
          const I = oe ? G(m) ? R[m] : S[m] : m.value;
          a ? fe(I) && Qi(I, l) : fe(I) ? I.includes(l) || I.push(l) : oe ? (S[m] = [l], G(m) && (R[m] = S[m])) : (m.value = [l], e.k && (S[e.k] = m.value));
        } else oe ? (S[m] = f, G(m) && (R[m] = f)) : $ && (m.value = f, e.k && (S[e.k] = f));
      };
      f ? (O.id = -1, Et(O, o)) : O();
    }
  }
}
jo().requestIdleCallback;
jo().cancelIdleCallback;
const ir = (e) => !!e.type.__asyncLoader, fu = (e) => e.type.__isKeepAlive;
function pc(e, t) {
  du(e, "a", t);
}
function hc(e, t) {
  du(e, "da", t);
}
function du(e, t, o = ht) {
  const i = e.__wdc || (e.__wdc = () => {
    let a = o;
    for (; a; ) {
      if (a.isDeactivated)
        return;
      a = a.parent;
    }
    return e();
  });
  if ($o(t, i, o), o) {
    let a = o.parent;
    for (; a && a.parent; )
      fu(a.parent.vnode) && mc(i, t, o, a), a = a.parent;
  }
}
function mc(e, t, o, i) {
  const a = $o(
    t,
    e,
    i,
    !0
    /* prepend */
  );
  cs(() => {
    Qi(i[t], a);
  }, o);
}
function $o(e, t, o = ht, i = !1) {
  if (o) {
    const a = o[e] || (o[e] = []), l = t.__weh || (t.__weh = (...f) => {
      rn();
      const p = Fr(o), m = Ht(t, o, e, f);
      return p(), on(), m;
    });
    return i ? a.unshift(l) : a.push(l), l;
  }
}
const un = (e) => (t, o = ht) => {
  (!Lr || e === "sp") && $o(e, (...i) => t(...i), o);
}, yc = un("bm"), pu = un("m"), vc = un(
  "bu"
), gc = un("u"), bc = un(
  "bum"
), cs = un("um"), _c = un(
  "sp"
), wc = un("rtg"), xc = un("rtc");
function Sc(e, t = ht) {
  $o("ec", e, t);
}
const Cc = Symbol.for("v-ndc");
function Rt(e, t, o, i) {
  let a;
  const l = o, f = fe(e);
  if (f || Je(e)) {
    const p = f && Sn(e);
    let m = !1, P = !1;
    p && (m = !Dt(e), P = On(e), e = Ko(e)), a = new Array(e.length);
    for (let S = 0, R = e.length; S < R; S++)
      a[S] = t(
        m ? P ? xo(it(e[S])) : it(e[S]) : e[S],
        S,
        void 0,
        l
      );
  } else if (typeof e == "number") {
    a = new Array(e);
    for (let p = 0; p < e; p++)
      a[p] = t(p + 1, p, void 0, l);
  } else if (qe(e))
    if (e[Symbol.iterator])
      a = Array.from(
        e,
        (p, m) => t(p, m, void 0, l)
      );
    else {
      const p = Object.keys(e);
      a = new Array(p.length);
      for (let m = 0, P = p.length; m < P; m++) {
        const S = p[m];
        a[m] = t(e[S], S, m, l);
      }
    }
  else
    a = [];
  return a;
}
function Zs(e, t, o = {}, i, a) {
  if (st.ce || st.parent && ir(st.parent) && st.parent.ce)
    return t !== "default" && (o.name = t), me(), Mn(
      Be,
      null,
      [wt("slot", o, i)],
      64
    );
  let l = e[t];
  l && l._c && (l._d = !1), me();
  const f = l && hu(l(o)), p = o.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  f && f.key, m = Mn(
    Be,
    {
      key: (p && !Kt(p) ? p : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!f && i ? "_fb" : "")
    },
    f || [],
    f && e._ === 1 ? 64 : -2
  );
  return l && l._c && (l._d = !0), m;
}
function hu(e) {
  return e.some((t) => ps(t) ? !(t.type === sn || t.type === Be && !hu(t.children)) : !0) ? e : null;
}
const Fi = (e) => e ? ju(e) ? Vo(e) : Fi(e.parent) : null, Pr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ mt(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Fi(e.parent),
    $root: (e) => Fi(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => yu(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      us(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = as.bind(e.proxy)),
    $watch: (e) => zc.bind(e)
  })
), Pi = (e, t) => e !== Ke && !e.__isScriptSetup && Ie(e, t), Oc = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return !0;
    const { ctx: o, setupState: i, data: a, props: l, accessCache: f, type: p, appContext: m } = e;
    let P;
    if (t[0] !== "$") {
      const G = f[t];
      if (G !== void 0)
        switch (G) {
          case 1:
            return i[t];
          case 2:
            return a[t];
          case 4:
            return o[t];
          case 3:
            return l[t];
        }
      else {
        if (Pi(i, t))
          return f[t] = 1, i[t];
        if (a !== Ke && Ie(a, t))
          return f[t] = 2, a[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (P = e.propsOptions[0]) && Ie(P, t)
        )
          return f[t] = 3, l[t];
        if (o !== Ke && Ie(o, t))
          return f[t] = 4, o[t];
        $i && (f[t] = 0);
      }
    }
    const S = Pr[t];
    let R, F;
    if (S)
      return t === "$attrs" && pt(e.attrs, "get", ""), S(e);
    if (
      // css module (injected by vue-loader)
      (R = p.__cssModules) && (R = R[t])
    )
      return R;
    if (o !== Ke && Ie(o, t))
      return f[t] = 4, o[t];
    if (
      // global properties
      F = m.config.globalProperties, Ie(F, t)
    )
      return F[t];
  },
  set({ _: e }, t, o) {
    const { data: i, setupState: a, ctx: l } = e;
    return Pi(a, t) ? (a[t] = o, !0) : i !== Ke && Ie(i, t) ? (i[t] = o, !0) : Ie(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (l[t] = o, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: o, ctx: i, appContext: a, propsOptions: l }
  }, f) {
    let p;
    return !!o[f] || e !== Ke && Ie(e, f) || Pi(t, f) || (p = l[0]) && Ie(p, f) || Ie(i, f) || Ie(Pr, f) || Ie(a.config.globalProperties, f);
  },
  defineProperty(e, t, o) {
    return o.get != null ? e._.accessCache[t] = 0 : Ie(o, "value") && this.set(e, t, o.value, null), Reflect.defineProperty(e, t, o);
  }
};
function ea(e) {
  return fe(e) ? e.reduce(
    (t, o) => (t[o] = null, t),
    {}
  ) : e;
}
let $i = !0;
function Ec(e) {
  const t = yu(e), o = e.proxy, i = e.ctx;
  $i = !1, t.beforeCreate && ta(t.beforeCreate, e, "bc");
  const {
    // state
    data: a,
    computed: l,
    methods: f,
    watch: p,
    provide: m,
    inject: P,
    // lifecycle
    created: S,
    beforeMount: R,
    mounted: F,
    beforeUpdate: G,
    updated: oe,
    activated: $,
    deactivated: O,
    beforeDestroy: I,
    beforeUnmount: de,
    destroyed: Se,
    unmounted: ue,
    render: be,
    renderTracked: Le,
    renderTriggered: Re,
    errorCaptured: we,
    serverPrefetch: Ee,
    // public API
    expose: Ue,
    inheritAttrs: yt,
    // assets
    components: at,
    directives: ut,
    filters: Pn
  } = t;
  if (P && Pc(P, i, null), f)
    for (const _e in f) {
      const Pe = f[_e];
      ge(Pe) && (i[_e] = Pe.bind(o));
    }
  if (a) {
    const _e = a.call(o, o);
    qe(_e) && (e.data = Mo(_e));
  }
  if ($i = !0, l)
    for (const _e in l) {
      const Pe = l[_e], xt = ge(Pe) ? Pe.bind(o, o) : ge(Pe.get) ? Pe.get.bind(o, o) : Ut, St = !ge(Pe) && ge(Pe.set) ? Pe.set.bind(o) : Ut, jt = kt({
        get: xt,
        set: St
      });
      Object.defineProperty(i, _e, {
        enumerable: !0,
        configurable: !0,
        get: () => jt.value,
        set: (Tt) => jt.value = Tt
      });
    }
  if (p)
    for (const _e in p)
      mu(p[_e], i, o, _e);
  if (m) {
    const _e = ge(m) ? m.call(o) : m;
    Reflect.ownKeys(_e).forEach((Pe) => {
      Dc(Pe, _e[Pe]);
    });
  }
  S && ta(S, e, "c");
  function Fe(_e, Pe) {
    fe(Pe) ? Pe.forEach((xt) => _e(xt.bind(o))) : Pe && _e(Pe.bind(o));
  }
  if (Fe(yc, R), Fe(pu, F), Fe(vc, G), Fe(gc, oe), Fe(pc, $), Fe(hc, O), Fe(Sc, we), Fe(xc, Le), Fe(wc, Re), Fe(bc, de), Fe(cs, ue), Fe(_c, Ee), fe(Ue))
    if (Ue.length) {
      const _e = e.exposed || (e.exposed = {});
      Ue.forEach((Pe) => {
        Object.defineProperty(_e, Pe, {
          get: () => o[Pe],
          set: (xt) => o[Pe] = xt
        });
      });
    } else e.exposed || (e.exposed = {});
  be && e.render === Ut && (e.render = be), yt != null && (e.inheritAttrs = yt), at && (e.components = at), ut && (e.directives = ut), Ee && cu(e);
}
function Pc(e, t, o = Ut) {
  fe(e) && (e = Bi(e));
  for (const i in e) {
    const a = e[i];
    let l;
    qe(a) ? "default" in a ? l = Tr(
      a.from || i,
      a.default,
      !0
    ) : l = Tr(a.from || i) : l = Tr(a), Ye(l) ? Object.defineProperty(t, i, {
      enumerable: !0,
      configurable: !0,
      get: () => l.value,
      set: (f) => l.value = f
    }) : t[i] = l;
  }
}
function ta(e, t, o) {
  Ht(
    fe(e) ? e.map((i) => i.bind(t.proxy)) : e.bind(t.proxy),
    t,
    o
  );
}
function mu(e, t, o, i) {
  let a = i.includes(".") ? Nu(o, i) : () => o[i];
  if (Je(e)) {
    const l = t[e];
    ge(l) && nn(a, l);
  } else if (ge(e))
    nn(a, e.bind(o));
  else if (qe(e))
    if (fe(e))
      e.forEach((l) => mu(l, t, o, i));
    else {
      const l = ge(e.handler) ? e.handler.bind(o) : t[e.handler];
      ge(l) && nn(a, l, e);
    }
}
function yu(e) {
  const t = e.type, { mixins: o, extends: i } = t, {
    mixins: a,
    optionsCache: l,
    config: { optionMergeStrategies: f }
  } = e.appContext, p = l.get(t);
  let m;
  return p ? m = p : !a.length && !o && !i ? m = t : (m = {}, a.length && a.forEach(
    (P) => Eo(m, P, f, !0)
  ), Eo(m, t, f)), qe(t) && l.set(t, m), m;
}
function Eo(e, t, o, i = !1) {
  const { mixins: a, extends: l } = t;
  l && Eo(e, l, o, !0), a && a.forEach(
    (f) => Eo(e, f, o, !0)
  );
  for (const f in t)
    if (!(i && f === "expose")) {
      const p = Tc[f] || o && o[f];
      e[f] = p ? p(e[f], t[f]) : t[f];
    }
  return e;
}
const Tc = {
  data: na,
  props: ra,
  emits: ra,
  // objects
  methods: xr,
  computed: xr,
  // lifecycle
  beforeCreate: bt,
  created: bt,
  beforeMount: bt,
  mounted: bt,
  beforeUpdate: bt,
  updated: bt,
  beforeDestroy: bt,
  beforeUnmount: bt,
  destroyed: bt,
  unmounted: bt,
  activated: bt,
  deactivated: bt,
  errorCaptured: bt,
  serverPrefetch: bt,
  // assets
  components: xr,
  directives: xr,
  // watch
  watch: Ac,
  // provide / inject
  provide: na,
  inject: Nc
};
function na(e, t) {
  return t ? e ? function() {
    return mt(
      ge(e) ? e.call(this, this) : e,
      ge(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function Nc(e, t) {
  return xr(Bi(e), Bi(t));
}
function Bi(e) {
  if (fe(e)) {
    const t = {};
    for (let o = 0; o < e.length; o++)
      t[e[o]] = e[o];
    return t;
  }
  return e;
}
function bt(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function xr(e, t) {
  return e ? mt(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function ra(e, t) {
  return e ? fe(e) && fe(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : mt(
    /* @__PURE__ */ Object.create(null),
    ea(e),
    ea(t ?? {})
  ) : t;
}
function Ac(e, t) {
  if (!e) return t;
  if (!t) return e;
  const o = mt(/* @__PURE__ */ Object.create(null), e);
  for (const i in t)
    o[i] = bt(e[i], t[i]);
  return o;
}
function vu() {
  return {
    app: null,
    config: {
      isNativeTag: bl,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let kc = 0;
function Rc(e, t) {
  return function(i, a = null) {
    ge(i) || (i = mt({}, i)), a != null && !qe(a) && (a = null);
    const l = vu(), f = /* @__PURE__ */ new WeakSet(), p = [];
    let m = !1;
    const P = l.app = {
      _uid: kc++,
      _component: i,
      _props: a,
      _container: null,
      _context: l,
      _instance: null,
      version: hf,
      get config() {
        return l.config;
      },
      set config(S) {
      },
      use(S, ...R) {
        return f.has(S) || (S && ge(S.install) ? (f.add(S), S.install(P, ...R)) : ge(S) && (f.add(S), S(P, ...R))), P;
      },
      mixin(S) {
        return l.mixins.includes(S) || l.mixins.push(S), P;
      },
      component(S, R) {
        return R ? (l.components[S] = R, P) : l.components[S];
      },
      directive(S, R) {
        return R ? (l.directives[S] = R, P) : l.directives[S];
      },
      mount(S, R, F) {
        if (!m) {
          const G = P._ceVNode || wt(i, a);
          return G.appContext = l, F === !0 ? F = "svg" : F === !1 && (F = void 0), e(G, S, F), m = !0, P._container = S, S.__vue_app__ = P, Vo(G.component);
        }
      },
      onUnmount(S) {
        p.push(S);
      },
      unmount() {
        m && (Ht(
          p,
          P._instance,
          16
        ), e(null, P._container), delete P._container.__vue_app__);
      },
      provide(S, R) {
        return l.provides[S] = R, P;
      },
      runWithContext(S) {
        const R = $n;
        $n = P;
        try {
          return S();
        } finally {
          $n = R;
        }
      }
    };
    return P;
  };
}
let $n = null;
function Dc(e, t) {
  if (ht) {
    let o = ht.provides;
    const i = ht.parent && ht.parent.provides;
    i === o && (o = ht.provides = Object.create(i)), o[e] = t;
  }
}
function Tr(e, t, o = !1) {
  const i = ht || st;
  if (i || $n) {
    let a = $n ? $n._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (a && e in a)
      return a[e];
    if (arguments.length > 1)
      return o && ge(t) ? t.call(i && i.proxy) : t;
  }
}
function Ic() {
  return !!(ht || st || $n);
}
const gu = {}, bu = () => Object.create(gu), _u = (e) => Object.getPrototypeOf(e) === gu;
function jc(e, t, o, i = !1) {
  const a = {}, l = bu();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), wu(e, t, a, l);
  for (const f in e.propsOptions[0])
    f in a || (a[f] = void 0);
  o ? e.props = i ? a : Jl(a) : e.type.props ? e.props = a : e.props = l, e.attrs = l;
}
function Lc(e, t, o, i) {
  const {
    props: a,
    attrs: l,
    vnode: { patchFlag: f }
  } = e, p = Ae(a), [m] = e.propsOptions;
  let P = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || f > 0) && !(f & 16)
  ) {
    if (f & 8) {
      const S = e.vnode.dynamicProps;
      for (let R = 0; R < S.length; R++) {
        let F = S[R];
        if (Bo(e.emitsOptions, F))
          continue;
        const G = t[F];
        if (m)
          if (Ie(l, F))
            G !== l[F] && (l[F] = G, P = !0);
          else {
            const oe = Cn(F);
            a[oe] = qi(
              m,
              p,
              oe,
              G,
              e,
              !1
            );
          }
        else
          G !== l[F] && (l[F] = G, P = !0);
      }
    }
  } else {
    wu(e, t, a, l) && (P = !0);
    let S;
    for (const R in p)
      (!t || // for camelCase
      !Ie(t, R) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((S = qn(R)) === R || !Ie(t, S))) && (m ? o && // for camelCase
      (o[R] !== void 0 || // for kebab-case
      o[S] !== void 0) && (a[R] = qi(
        m,
        p,
        R,
        void 0,
        e,
        !0
      )) : delete a[R]);
    if (l !== p)
      for (const R in l)
        (!t || !Ie(t, R)) && (delete l[R], P = !0);
  }
  P && Jt(e.attrs, "set", "");
}
function wu(e, t, o, i) {
  const [a, l] = e.propsOptions;
  let f = !1, p;
  if (t)
    for (let m in t) {
      if (Sr(m))
        continue;
      const P = t[m];
      let S;
      a && Ie(a, S = Cn(m)) ? !l || !l.includes(S) ? o[S] = P : (p || (p = {}))[S] = P : Bo(e.emitsOptions, m) || (!(m in i) || P !== i[m]) && (i[m] = P, f = !0);
    }
  if (l) {
    const m = Ae(o), P = p || Ke;
    for (let S = 0; S < l.length; S++) {
      const R = l[S];
      o[R] = qi(
        a,
        m,
        R,
        P[R],
        e,
        !Ie(P, R)
      );
    }
  }
  return f;
}
function qi(e, t, o, i, a, l) {
  const f = e[o];
  if (f != null) {
    const p = Ie(f, "default");
    if (p && i === void 0) {
      const m = f.default;
      if (f.type !== Function && !f.skipFactory && ge(m)) {
        const { propsDefaults: P } = a;
        if (o in P)
          i = P[o];
        else {
          const S = Fr(a);
          i = P[o] = m.call(
            null,
            t
          ), S();
        }
      } else
        i = m;
      a.ce && a.ce._setProp(o, i);
    }
    f[
      0
      /* shouldCast */
    ] && (l && !p ? i = !1 : f[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === qn(o)) && (i = !0));
  }
  return i;
}
const Kc = /* @__PURE__ */ new WeakMap();
function xu(e, t, o = !1) {
  const i = o ? Kc : t.propsCache, a = i.get(e);
  if (a)
    return a;
  const l = e.props, f = {}, p = [];
  let m = !1;
  if (!ge(e)) {
    const S = (R) => {
      m = !0;
      const [F, G] = xu(R, t, !0);
      mt(f, F), G && p.push(...G);
    };
    !o && t.mixins.length && t.mixins.forEach(S), e.extends && S(e.extends), e.mixins && e.mixins.forEach(S);
  }
  if (!l && !m)
    return qe(e) && i.set(e, nr), nr;
  if (fe(l))
    for (let S = 0; S < l.length; S++) {
      const R = Cn(l[S]);
      oa(R) && (f[R] = Ke);
    }
  else if (l)
    for (const S in l) {
      const R = Cn(S);
      if (oa(R)) {
        const F = l[S], G = f[R] = fe(F) || ge(F) ? { type: F } : mt({}, F), oe = G.type;
        let $ = !1, O = !0;
        if (fe(oe))
          for (let I = 0; I < oe.length; ++I) {
            const de = oe[I], Se = ge(de) && de.name;
            if (Se === "Boolean") {
              $ = !0;
              break;
            } else Se === "String" && (O = !1);
          }
        else
          $ = ge(oe) && oe.name === "Boolean";
        G[
          0
          /* shouldCast */
        ] = $, G[
          1
          /* shouldCastTrue */
        ] = O, ($ || Ie(G, "default")) && p.push(R);
      }
    }
  const P = [f, p];
  return qe(e) && i.set(e, P), P;
}
function oa(e) {
  return e[0] !== "$" && !Sr(e);
}
const fs = (e) => e[0] === "_" || e === "$stable", ds = (e) => fe(e) ? e.map(Vt) : [Vt(e)], Mc = (e, t, o) => {
  if (t._n)
    return t;
  const i = Mi((...a) => ds(t(...a)), o);
  return i._c = !1, i;
}, Su = (e, t, o) => {
  const i = e._ctx;
  for (const a in e) {
    if (fs(a)) continue;
    const l = e[a];
    if (ge(l))
      t[a] = Mc(a, l, i);
    else if (l != null) {
      const f = ds(l);
      t[a] = () => f;
    }
  }
}, Cu = (e, t) => {
  const o = ds(t);
  e.slots.default = () => o;
}, Ou = (e, t, o) => {
  for (const i in t)
    (o || !fs(i)) && (e[i] = t[i]);
}, Fc = (e, t, o) => {
  const i = e.slots = bu();
  if (e.vnode.shapeFlag & 32) {
    const a = t.__;
    a && Ii(i, "__", a, !0);
    const l = t._;
    l ? (Ou(i, t, o), o && Ii(i, "_", l, !0)) : Su(t, i);
  } else t && Cu(e, t);
}, $c = (e, t, o) => {
  const { vnode: i, slots: a } = e;
  let l = !0, f = Ke;
  if (i.shapeFlag & 32) {
    const p = t._;
    p ? o && p === 1 ? l = !1 : Ou(a, t, o) : (l = !t.$stable, Su(t, a)), f = t;
  } else t && (Cu(e, t), f = { default: 1 });
  if (l)
    for (const p in a)
      !fs(p) && f[p] == null && delete a[p];
}, Et = ef;
function Bc(e) {
  return qc(e);
}
function qc(e, t) {
  const o = jo();
  o.__VUE__ = !0;
  const {
    insert: i,
    remove: a,
    patchProp: l,
    createElement: f,
    createText: p,
    createComment: m,
    setText: P,
    setElementText: S,
    parentNode: R,
    nextSibling: F,
    setScopeId: G = Ut,
    insertStaticContent: oe
  } = e, $ = (y, w, M, V = null, q = null, U = null, ee = void 0, J = null, Y = !!w.dynamicChildren) => {
    if (y === w)
      return;
    y && !wr(y, w) && (V = cn(y), Tt(y, q, U, !0), y = null), w.patchFlag === -2 && (Y = !1, w.dynamicChildren = null);
    const { type: B, ref: le, shapeFlag: X } = w;
    switch (B) {
      case qo:
        O(y, w, M, V);
        break;
      case sn:
        I(y, w, M, V);
        break;
      case Ni:
        y == null && de(w, M, V, ee);
        break;
      case Be:
        at(
          y,
          w,
          M,
          V,
          q,
          U,
          ee,
          J,
          Y
        );
        break;
      default:
        X & 1 ? be(
          y,
          w,
          M,
          V,
          q,
          U,
          ee,
          J,
          Y
        ) : X & 6 ? ut(
          y,
          w,
          M,
          V,
          q,
          U,
          ee,
          J,
          Y
        ) : (X & 64 || X & 128) && B.process(
          y,
          w,
          M,
          V,
          q,
          U,
          ee,
          J,
          Y,
          fn
        );
    }
    le != null && q ? Er(le, y && y.ref, U, w || y, !w) : le == null && y && y.ref != null && Er(y.ref, null, U, y, !0);
  }, O = (y, w, M, V) => {
    if (y == null)
      i(
        w.el = p(w.children),
        M,
        V
      );
    else {
      const q = w.el = y.el;
      w.children !== y.children && P(q, w.children);
    }
  }, I = (y, w, M, V) => {
    y == null ? i(
      w.el = m(w.children || ""),
      M,
      V
    ) : w.el = y.el;
  }, de = (y, w, M, V) => {
    [y.el, y.anchor] = oe(
      y.children,
      w,
      M,
      V,
      y.el,
      y.anchor
    );
  }, Se = ({ el: y, anchor: w }, M, V) => {
    let q;
    for (; y && y !== w; )
      q = F(y), i(y, M, V), y = q;
    i(w, M, V);
  }, ue = ({ el: y, anchor: w }) => {
    let M;
    for (; y && y !== w; )
      M = F(y), a(y), y = M;
    a(w);
  }, be = (y, w, M, V, q, U, ee, J, Y) => {
    w.type === "svg" ? ee = "svg" : w.type === "math" && (ee = "mathml"), y == null ? Le(
      w,
      M,
      V,
      q,
      U,
      ee,
      J,
      Y
    ) : Ee(
      y,
      w,
      q,
      U,
      ee,
      J,
      Y
    );
  }, Le = (y, w, M, V, q, U, ee, J) => {
    let Y, B;
    const { props: le, shapeFlag: X, transition: ae, dirs: ce } = y;
    if (Y = y.el = f(
      y.type,
      U,
      le && le.is,
      le
    ), X & 8 ? S(Y, y.children) : X & 16 && we(
      y.children,
      Y,
      null,
      V,
      q,
      Ti(y, U),
      ee,
      J
    ), ce && jn(y, null, V, "created"), Re(Y, y, y.scopeId, ee, V), le) {
      for (const Te in le)
        Te !== "value" && !Sr(Te) && l(Y, Te, null, le[Te], U, V);
      "value" in le && l(Y, "value", null, le.value, U), (B = le.onVnodeBeforeMount) && Bt(B, V, y);
    }
    ce && jn(y, null, V, "beforeMount");
    const ye = Vc(q, ae);
    ye && ae.beforeEnter(Y), i(Y, w, M), ((B = le && le.onVnodeMounted) || ye || ce) && Et(() => {
      B && Bt(B, V, y), ye && ae.enter(Y), ce && jn(y, null, V, "mounted");
    }, q);
  }, Re = (y, w, M, V, q) => {
    if (M && G(y, M), V)
      for (let U = 0; U < V.length; U++)
        G(y, V[U]);
    if (q) {
      let U = q.subTree;
      if (w === U || ku(U.type) && (U.ssContent === w || U.ssFallback === w)) {
        const ee = q.vnode;
        Re(
          y,
          ee,
          ee.scopeId,
          ee.slotScopeIds,
          q.parent
        );
      }
    }
  }, we = (y, w, M, V, q, U, ee, J, Y = 0) => {
    for (let B = Y; B < y.length; B++) {
      const le = y[B] = J ? wn(y[B]) : Vt(y[B]);
      $(
        null,
        le,
        w,
        M,
        V,
        q,
        U,
        ee,
        J
      );
    }
  }, Ee = (y, w, M, V, q, U, ee) => {
    const J = w.el = y.el;
    let { patchFlag: Y, dynamicChildren: B, dirs: le } = w;
    Y |= y.patchFlag & 16;
    const X = y.props || Ke, ae = w.props || Ke;
    let ce;
    if (M && Ln(M, !1), (ce = ae.onVnodeBeforeUpdate) && Bt(ce, M, w, y), le && jn(w, y, M, "beforeUpdate"), M && Ln(M, !0), (X.innerHTML && ae.innerHTML == null || X.textContent && ae.textContent == null) && S(J, ""), B ? Ue(
      y.dynamicChildren,
      B,
      J,
      M,
      V,
      Ti(w, q),
      U
    ) : ee || Pe(
      y,
      w,
      J,
      null,
      M,
      V,
      Ti(w, q),
      U,
      !1
    ), Y > 0) {
      if (Y & 16)
        yt(J, X, ae, M, q);
      else if (Y & 2 && X.class !== ae.class && l(J, "class", null, ae.class, q), Y & 4 && l(J, "style", X.style, ae.style, q), Y & 8) {
        const ye = w.dynamicProps;
        for (let Te = 0; Te < ye.length; Te++) {
          const ke = ye[Te], Qe = X[ke], et = ae[ke];
          (et !== Qe || ke === "value") && l(J, ke, Qe, et, q, M);
        }
      }
      Y & 1 && y.children !== w.children && S(J, w.children);
    } else !ee && B == null && yt(J, X, ae, M, q);
    ((ce = ae.onVnodeUpdated) || le) && Et(() => {
      ce && Bt(ce, M, w, y), le && jn(w, y, M, "updated");
    }, V);
  }, Ue = (y, w, M, V, q, U, ee) => {
    for (let J = 0; J < w.length; J++) {
      const Y = y[J], B = w[J], le = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        Y.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (Y.type === Be || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !wr(Y, B) || // - In the case of a component, it could contain anything.
        Y.shapeFlag & 198) ? R(Y.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          M
        )
      );
      $(
        Y,
        B,
        le,
        null,
        V,
        q,
        U,
        ee,
        !0
      );
    }
  }, yt = (y, w, M, V, q) => {
    if (w !== M) {
      if (w !== Ke)
        for (const U in w)
          !Sr(U) && !(U in M) && l(
            y,
            U,
            w[U],
            null,
            q,
            V
          );
      for (const U in M) {
        if (Sr(U)) continue;
        const ee = M[U], J = w[U];
        ee !== J && U !== "value" && l(y, U, J, ee, q, V);
      }
      "value" in M && l(y, "value", w.value, M.value, q);
    }
  }, at = (y, w, M, V, q, U, ee, J, Y) => {
    const B = w.el = y ? y.el : p(""), le = w.anchor = y ? y.anchor : p("");
    let { patchFlag: X, dynamicChildren: ae, slotScopeIds: ce } = w;
    ce && (J = J ? J.concat(ce) : ce), y == null ? (i(B, M, V), i(le, M, V), we(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      w.children || [],
      M,
      le,
      q,
      U,
      ee,
      J,
      Y
    )) : X > 0 && X & 64 && ae && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    y.dynamicChildren ? (Ue(
      y.dynamicChildren,
      ae,
      M,
      q,
      U,
      ee,
      J
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (w.key != null || q && w === q.subTree) && Eu(
      y,
      w,
      !0
      /* shallow */
    )) : Pe(
      y,
      w,
      M,
      le,
      q,
      U,
      ee,
      J,
      Y
    );
  }, ut = (y, w, M, V, q, U, ee, J, Y) => {
    w.slotScopeIds = J, y == null ? w.shapeFlag & 512 ? q.ctx.activate(
      w,
      M,
      V,
      ee,
      Y
    ) : Pn(
      w,
      M,
      V,
      q,
      U,
      ee,
      Y
    ) : ln(y, w, Y);
  }, Pn = (y, w, M, V, q, U, ee) => {
    const J = y.component = uf(
      y,
      V,
      q
    );
    if (fu(y) && (J.ctx.renderer = fn), lf(J, !1, ee), J.asyncDep) {
      if (q && q.registerDep(J, Fe, ee), !y.el) {
        const Y = J.subTree = wt(sn);
        I(null, Y, w, M);
      }
    } else
      Fe(
        J,
        y,
        w,
        M,
        q,
        U,
        ee
      );
  }, ln = (y, w, M) => {
    const V = w.component = y.component;
    if (Xc(y, w, M))
      if (V.asyncDep && !V.asyncResolved) {
        _e(V, w, M);
        return;
      } else
        V.next = w, V.update();
    else
      w.el = y.el, V.vnode = w;
  }, Fe = (y, w, M, V, q, U, ee) => {
    const J = () => {
      if (y.isMounted) {
        let { next: X, bu: ae, u: ce, parent: ye, vnode: Te } = y;
        {
          const tt = Pu(y);
          if (tt) {
            X && (X.el = Te.el, _e(y, X, ee)), tt.asyncDep.then(() => {
              y.isUnmounted || J();
            });
            return;
          }
        }
        let ke = X, Qe;
        Ln(y, !1), X ? (X.el = Te.el, _e(y, X, ee)) : X = Te, ae && mo(ae), (Qe = X.props && X.props.onVnodeBeforeUpdate) && Bt(Qe, ye, X, Te), Ln(y, !0);
        const et = sa(y), vt = y.subTree;
        y.subTree = et, $(
          vt,
          et,
          // parent may have changed if it's in a teleport
          R(vt.el),
          // anchor may have changed if it's in a fragment
          cn(vt),
          y,
          q,
          U
        ), X.el = et.el, ke === null && Zc(y, et.el), ce && Et(ce, q), (Qe = X.props && X.props.onVnodeUpdated) && Et(
          () => Bt(Qe, ye, X, Te),
          q
        );
      } else {
        let X;
        const { el: ae, props: ce } = w, { bm: ye, m: Te, parent: ke, root: Qe, type: et } = y, vt = ir(w);
        Ln(y, !1), ye && mo(ye), !vt && (X = ce && ce.onVnodeBeforeMount) && Bt(X, ke, w), Ln(y, !0);
        {
          Qe.ce && // @ts-expect-error _def is private
          Qe.ce._def.shadowRoot !== !1 && Qe.ce._injectChildStyle(et);
          const tt = y.subTree = sa(y);
          $(
            null,
            tt,
            M,
            V,
            y,
            q,
            U
          ), w.el = tt.el;
        }
        if (Te && Et(Te, q), !vt && (X = ce && ce.onVnodeMounted)) {
          const tt = w;
          Et(
            () => Bt(X, ke, tt),
            q
          );
        }
        (w.shapeFlag & 256 || ke && ir(ke.vnode) && ke.vnode.shapeFlag & 256) && y.a && Et(y.a, q), y.isMounted = !0, w = M = V = null;
      }
    };
    y.scope.on();
    const Y = y.effect = new Va(J);
    y.scope.off();
    const B = y.update = Y.run.bind(Y), le = y.job = Y.runIfDirty.bind(Y);
    le.i = y, le.id = y.uid, Y.scheduler = () => us(le), Ln(y, !0), B();
  }, _e = (y, w, M) => {
    w.component = y;
    const V = y.vnode.props;
    y.vnode = w, y.next = null, Lc(y, w.props, V, M), $c(y, w.children, M), rn(), Xs(y), on();
  }, Pe = (y, w, M, V, q, U, ee, J, Y = !1) => {
    const B = y && y.children, le = y ? y.shapeFlag : 0, X = w.children, { patchFlag: ae, shapeFlag: ce } = w;
    if (ae > 0) {
      if (ae & 128) {
        St(
          B,
          X,
          M,
          V,
          q,
          U,
          ee,
          J,
          Y
        );
        return;
      } else if (ae & 256) {
        xt(
          B,
          X,
          M,
          V,
          q,
          U,
          ee,
          J,
          Y
        );
        return;
      }
    }
    ce & 8 ? (le & 16 && Nt(B, q, U), X !== B && S(M, X)) : le & 16 ? ce & 16 ? St(
      B,
      X,
      M,
      V,
      q,
      U,
      ee,
      J,
      Y
    ) : Nt(B, q, U, !0) : (le & 8 && S(M, ""), ce & 16 && we(
      X,
      M,
      V,
      q,
      U,
      ee,
      J,
      Y
    ));
  }, xt = (y, w, M, V, q, U, ee, J, Y) => {
    y = y || nr, w = w || nr;
    const B = y.length, le = w.length, X = Math.min(B, le);
    let ae;
    for (ae = 0; ae < X; ae++) {
      const ce = w[ae] = Y ? wn(w[ae]) : Vt(w[ae]);
      $(
        y[ae],
        ce,
        M,
        null,
        q,
        U,
        ee,
        J,
        Y
      );
    }
    B > le ? Nt(
      y,
      q,
      U,
      !0,
      !1,
      X
    ) : we(
      w,
      M,
      V,
      q,
      U,
      ee,
      J,
      Y,
      X
    );
  }, St = (y, w, M, V, q, U, ee, J, Y) => {
    let B = 0;
    const le = w.length;
    let X = y.length - 1, ae = le - 1;
    for (; B <= X && B <= ae; ) {
      const ce = y[B], ye = w[B] = Y ? wn(w[B]) : Vt(w[B]);
      if (wr(ce, ye))
        $(
          ce,
          ye,
          M,
          null,
          q,
          U,
          ee,
          J,
          Y
        );
      else
        break;
      B++;
    }
    for (; B <= X && B <= ae; ) {
      const ce = y[X], ye = w[ae] = Y ? wn(w[ae]) : Vt(w[ae]);
      if (wr(ce, ye))
        $(
          ce,
          ye,
          M,
          null,
          q,
          U,
          ee,
          J,
          Y
        );
      else
        break;
      X--, ae--;
    }
    if (B > X) {
      if (B <= ae) {
        const ce = ae + 1, ye = ce < le ? w[ce].el : V;
        for (; B <= ae; )
          $(
            null,
            w[B] = Y ? wn(w[B]) : Vt(w[B]),
            M,
            ye,
            q,
            U,
            ee,
            J,
            Y
          ), B++;
      }
    } else if (B > ae)
      for (; B <= X; )
        Tt(y[B], q, U, !0), B++;
    else {
      const ce = B, ye = B, Te = /* @__PURE__ */ new Map();
      for (B = ye; B <= ae; B++) {
        const He = w[B] = Y ? wn(w[B]) : Vt(w[B]);
        He.key != null && Te.set(He.key, B);
      }
      let ke, Qe = 0;
      const et = ae - ye + 1;
      let vt = !1, tt = 0;
      const Mt = new Array(et);
      for (B = 0; B < et; B++) Mt[B] = 0;
      for (B = ce; B <= X; B++) {
        const He = y[B];
        if (Qe >= et) {
          Tt(He, q, U, !0);
          continue;
        }
        let ie;
        if (He.key != null)
          ie = Te.get(He.key);
        else
          for (ke = ye; ke <= ae; ke++)
            if (Mt[ke - ye] === 0 && wr(He, w[ke])) {
              ie = ke;
              break;
            }
        ie === void 0 ? Tt(He, q, U, !0) : (Mt[ie - ye] = B + 1, ie >= tt ? tt = ie : vt = !0, $(
          He,
          w[ie],
          M,
          null,
          q,
          U,
          ee,
          J,
          Y
        ), Qe++);
      }
      const Un = vt ? Uc(Mt) : nr;
      for (ke = Un.length - 1, B = et - 1; B >= 0; B--) {
        const He = ye + B, ie = w[He], dn = He + 1 < le ? w[He + 1].el : V;
        Mt[B] === 0 ? $(
          null,
          ie,
          M,
          dn,
          q,
          U,
          ee,
          J,
          Y
        ) : vt && (ke < 0 || B !== Un[ke] ? jt(ie, M, dn, 2) : ke--);
      }
    }
  }, jt = (y, w, M, V, q = null) => {
    const { el: U, type: ee, transition: J, children: Y, shapeFlag: B } = y;
    if (B & 6) {
      jt(y.component.subTree, w, M, V);
      return;
    }
    if (B & 128) {
      y.suspense.move(w, M, V);
      return;
    }
    if (B & 64) {
      ee.move(y, w, M, fn);
      return;
    }
    if (ee === Be) {
      i(U, w, M);
      for (let X = 0; X < Y.length; X++)
        jt(Y[X], w, M, V);
      i(y.anchor, w, M);
      return;
    }
    if (ee === Ni) {
      Se(y, w, M);
      return;
    }
    if (V !== 2 && B & 1 && J)
      if (V === 0)
        J.beforeEnter(U), i(U, w, M), Et(() => J.enter(U), q);
      else {
        const { leave: X, delayLeave: ae, afterLeave: ce } = J, ye = () => {
          y.ctx.isUnmounted ? a(U) : i(U, w, M);
        }, Te = () => {
          X(U, () => {
            ye(), ce && ce();
          });
        };
        ae ? ae(U, ye, Te) : Te();
      }
    else
      i(U, w, M);
  }, Tt = (y, w, M, V = !1, q = !1) => {
    const {
      type: U,
      props: ee,
      ref: J,
      children: Y,
      dynamicChildren: B,
      shapeFlag: le,
      patchFlag: X,
      dirs: ae,
      cacheIndex: ce
    } = y;
    if (X === -2 && (q = !1), J != null && (rn(), Er(J, null, M, y, !0), on()), ce != null && (w.renderCache[ce] = void 0), le & 256) {
      w.ctx.deactivate(y);
      return;
    }
    const ye = le & 1 && ae, Te = !ir(y);
    let ke;
    if (Te && (ke = ee && ee.onVnodeBeforeUnmount) && Bt(ke, w, y), le & 6)
      Vn(y.component, M, V);
    else {
      if (le & 128) {
        y.suspense.unmount(M, V);
        return;
      }
      ye && jn(y, null, w, "beforeUnmount"), le & 64 ? y.type.remove(
        y,
        w,
        M,
        fn,
        V
      ) : B && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !B.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (U !== Be || X > 0 && X & 64) ? Nt(
        B,
        w,
        M,
        !1,
        !0
      ) : (U === Be && X & 384 || !q && le & 16) && Nt(Y, w, M), V && Wt(y);
    }
    (Te && (ke = ee && ee.onVnodeUnmounted) || ye) && Et(() => {
      ke && Bt(ke, w, y), ye && jn(y, null, w, "unmounted");
    }, M);
  }, Wt = (y) => {
    const { type: w, el: M, anchor: V, transition: q } = y;
    if (w === Be) {
      $r(M, V);
      return;
    }
    if (w === Ni) {
      ue(y);
      return;
    }
    const U = () => {
      a(M), q && !q.persisted && q.afterLeave && q.afterLeave();
    };
    if (y.shapeFlag & 1 && q && !q.persisted) {
      const { leave: ee, delayLeave: J } = q, Y = () => ee(M, U);
      J ? J(y.el, U, Y) : Y();
    } else
      U();
  }, $r = (y, w) => {
    let M;
    for (; y !== w; )
      M = F(y), a(y), y = M;
    a(w);
  }, Vn = (y, w, M) => {
    const {
      bum: V,
      scope: q,
      job: U,
      subTree: ee,
      um: J,
      m: Y,
      a: B,
      parent: le,
      slots: { __: X }
    } = y;
    ia(Y), ia(B), V && mo(V), le && fe(X) && X.forEach((ae) => {
      le.renderCache[ae] = void 0;
    }), q.stop(), U && (U.flags |= 8, Tt(ee, y, w, M)), J && Et(J, w), Et(() => {
      y.isUnmounted = !0;
    }, w), w && w.pendingBranch && !w.isUnmounted && y.asyncDep && !y.asyncResolved && y.suspenseId === w.pendingId && (w.deps--, w.deps === 0 && w.resolve());
  }, Nt = (y, w, M, V = !1, q = !1, U = 0) => {
    for (let ee = U; ee < y.length; ee++)
      Tt(y[ee], w, M, V, q);
  }, cn = (y) => {
    if (y.shapeFlag & 6)
      return cn(y.component.subTree);
    if (y.shapeFlag & 128)
      return y.suspense.next();
    const w = F(y.anchor || y.el), M = w && w[fc];
    return M ? F(M) : w;
  };
  let lr = !1;
  const se = (y, w, M) => {
    y == null ? w._vnode && Tt(w._vnode, null, null, !0) : $(
      w._vnode || null,
      y,
      w,
      null,
      null,
      null,
      M
    ), w._vnode = y, lr || (lr = !0, Xs(), au(), lr = !1);
  }, fn = {
    p: $,
    um: Tt,
    m: jt,
    r: Wt,
    mt: Pn,
    mc: we,
    pc: Pe,
    pbc: Ue,
    n: cn,
    o: e
  };
  return {
    render: se,
    hydrate: void 0,
    createApp: Rc(se)
  };
}
function Ti({ type: e, props: t }, o) {
  return o === "svg" && e === "foreignObject" || o === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : o;
}
function Ln({ effect: e, job: t }, o) {
  o ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function Vc(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function Eu(e, t, o = !1) {
  const i = e.children, a = t.children;
  if (fe(i) && fe(a))
    for (let l = 0; l < i.length; l++) {
      const f = i[l];
      let p = a[l];
      p.shapeFlag & 1 && !p.dynamicChildren && ((p.patchFlag <= 0 || p.patchFlag === 32) && (p = a[l] = wn(a[l]), p.el = f.el), !o && p.patchFlag !== -2 && Eu(f, p)), p.type === qo && (p.el = f.el), p.type === sn && !p.el && (p.el = f.el);
    }
}
function Uc(e) {
  const t = e.slice(), o = [0];
  let i, a, l, f, p;
  const m = e.length;
  for (i = 0; i < m; i++) {
    const P = e[i];
    if (P !== 0) {
      if (a = o[o.length - 1], e[a] < P) {
        t[i] = a, o.push(i);
        continue;
      }
      for (l = 0, f = o.length - 1; l < f; )
        p = l + f >> 1, e[o[p]] < P ? l = p + 1 : f = p;
      P < e[o[l]] && (l > 0 && (t[i] = o[l - 1]), o[l] = i);
    }
  }
  for (l = o.length, f = o[l - 1]; l-- > 0; )
    o[l] = f, f = t[f];
  return o;
}
function Pu(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : Pu(t);
}
function ia(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
const Hc = Symbol.for("v-scx"), Wc = () => Tr(Hc);
function nn(e, t, o) {
  return Tu(e, t, o);
}
function Tu(e, t, o = Ke) {
  const { immediate: i, deep: a, flush: l, once: f } = o, p = mt({}, o), m = t && i || !t && l !== "post";
  let P;
  if (Lr) {
    if (l === "sync") {
      const G = Wc();
      P = G.__watcherHandles || (G.__watcherHandles = []);
    } else if (!m) {
      const G = () => {
      };
      return G.stop = Ut, G.resume = Ut, G.pause = Ut, G;
    }
  }
  const S = ht;
  p.call = (G, oe, $) => Ht(G, S, oe, $);
  let R = !1;
  l === "post" ? p.scheduler = (G) => {
    Et(G, S && S.suspense);
  } : l !== "sync" && (R = !0, p.scheduler = (G, oe) => {
    oe ? G() : us(G);
  }), p.augmentJob = (G) => {
    t && (G.flags |= 4), R && (G.flags |= 2, S && (G.id = S.uid, G.i = S));
  };
  const F = ac(e, t, p);
  return Lr && (P ? P.push(F) : m && F()), F;
}
function zc(e, t, o) {
  const i = this.proxy, a = Je(e) ? e.includes(".") ? Nu(i, e) : () => i[e] : e.bind(i, i);
  let l;
  ge(t) ? l = t : (l = t.handler, o = t);
  const f = Fr(this), p = Tu(a, l.bind(i), o);
  return f(), p;
}
function Nu(e, t) {
  const o = t.split(".");
  return () => {
    let i = e;
    for (let a = 0; a < o.length && i; a++)
      i = i[o[a]];
    return i;
  };
}
const Gc = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Cn(t)}Modifiers`] || e[`${qn(t)}Modifiers`];
function Yc(e, t, ...o) {
  if (e.isUnmounted) return;
  const i = e.vnode.props || Ke;
  let a = o;
  const l = t.startsWith("update:"), f = l && Gc(i, t.slice(7));
  f && (f.trim && (a = o.map((S) => Je(S) ? S.trim() : S)), f.number && (a = o.map(_o)));
  let p, m = i[p = xi(t)] || // also try camelCase event handler (#2249)
  i[p = xi(Cn(t))];
  !m && l && (m = i[p = xi(qn(t))]), m && Ht(
    m,
    e,
    6,
    a
  );
  const P = i[p + "Once"];
  if (P) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[p])
      return;
    e.emitted[p] = !0, Ht(
      P,
      e,
      6,
      a
    );
  }
}
function Au(e, t, o = !1) {
  const i = t.emitsCache, a = i.get(e);
  if (a !== void 0)
    return a;
  const l = e.emits;
  let f = {}, p = !1;
  if (!ge(e)) {
    const m = (P) => {
      const S = Au(P, t, !0);
      S && (p = !0, mt(f, S));
    };
    !o && t.mixins.length && t.mixins.forEach(m), e.extends && m(e.extends), e.mixins && e.mixins.forEach(m);
  }
  return !l && !p ? (qe(e) && i.set(e, null), null) : (fe(l) ? l.forEach((m) => f[m] = null) : mt(f, l), qe(e) && i.set(e, f), f);
}
function Bo(e, t) {
  return !e || !Do(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Ie(e, t[0].toLowerCase() + t.slice(1)) || Ie(e, qn(t)) || Ie(e, t));
}
function sa(e) {
  const {
    type: t,
    vnode: o,
    proxy: i,
    withProxy: a,
    propsOptions: [l],
    slots: f,
    attrs: p,
    emit: m,
    render: P,
    renderCache: S,
    props: R,
    data: F,
    setupState: G,
    ctx: oe,
    inheritAttrs: $
  } = e, O = Oo(e);
  let I, de;
  try {
    if (o.shapeFlag & 4) {
      const ue = a || i, be = ue;
      I = Vt(
        P.call(
          be,
          ue,
          S,
          R,
          G,
          F,
          oe
        )
      ), de = p;
    } else {
      const ue = t;
      I = Vt(
        ue.length > 1 ? ue(
          R,
          { attrs: p, slots: f, emit: m }
        ) : ue(
          R,
          null
        )
      ), de = t.props ? p : Qc(p);
    }
  } catch (ue) {
    Nr.length = 0, Fo(ue, e, 1), I = wt(sn);
  }
  let Se = I;
  if (de && $ !== !1) {
    const ue = Object.keys(de), { shapeFlag: be } = Se;
    ue.length && be & 7 && (l && ue.some(Yi) && (de = Jc(
      de,
      l
    )), Se = sr(Se, de, !1, !0));
  }
  return o.dirs && (Se = sr(Se, null, !1, !0), Se.dirs = Se.dirs ? Se.dirs.concat(o.dirs) : o.dirs), o.transition && ls(Se, o.transition), I = Se, Oo(O), I;
}
const Qc = (e) => {
  let t;
  for (const o in e)
    (o === "class" || o === "style" || Do(o)) && ((t || (t = {}))[o] = e[o]);
  return t;
}, Jc = (e, t) => {
  const o = {};
  for (const i in e)
    (!Yi(i) || !(i.slice(9) in t)) && (o[i] = e[i]);
  return o;
};
function Xc(e, t, o) {
  const { props: i, children: a, component: l } = e, { props: f, children: p, patchFlag: m } = t, P = l.emitsOptions;
  if (t.dirs || t.transition)
    return !0;
  if (o && m >= 0) {
    if (m & 1024)
      return !0;
    if (m & 16)
      return i ? aa(i, f, P) : !!f;
    if (m & 8) {
      const S = t.dynamicProps;
      for (let R = 0; R < S.length; R++) {
        const F = S[R];
        if (f[F] !== i[F] && !Bo(P, F))
          return !0;
      }
    }
  } else
    return (a || p) && (!p || !p.$stable) ? !0 : i === f ? !1 : i ? f ? aa(i, f, P) : !0 : !!f;
  return !1;
}
function aa(e, t, o) {
  const i = Object.keys(t);
  if (i.length !== Object.keys(e).length)
    return !0;
  for (let a = 0; a < i.length; a++) {
    const l = i[a];
    if (t[l] !== e[l] && !Bo(o, l))
      return !0;
  }
  return !1;
}
function Zc({ vnode: e, parent: t }, o) {
  for (; t; ) {
    const i = t.subTree;
    if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e)
      (e = t.vnode).el = o, t = t.parent;
    else
      break;
  }
}
const ku = (e) => e.__isSuspense;
function ef(e, t) {
  t && t.pendingBranch ? fe(e) ? t.effects.push(...e) : t.effects.push(e) : cc(e);
}
const Be = Symbol.for("v-fgt"), qo = Symbol.for("v-txt"), sn = Symbol.for("v-cmt"), Ni = Symbol.for("v-stc"), Nr = [];
let Pt = null;
function me(e = !1) {
  Nr.push(Pt = e ? null : []);
}
function tf() {
  Nr.pop(), Pt = Nr[Nr.length - 1] || null;
}
let jr = 1;
function ua(e, t = !1) {
  jr += e, e < 0 && Pt && t && (Pt.hasOnce = !0);
}
function Ru(e) {
  return e.dynamicChildren = jr > 0 ? Pt || nr : null, tf(), jr > 0 && Pt && Pt.push(e), e;
}
function xe(e, t, o, i, a, l) {
  return Ru(
    K(
      e,
      t,
      o,
      i,
      a,
      l,
      !0
    )
  );
}
function Mn(e, t, o, i, a) {
  return Ru(
    wt(
      e,
      t,
      o,
      i,
      a,
      !0
    )
  );
}
function ps(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function wr(e, t) {
  return e.type === t.type && e.key === t.key;
}
const Du = ({ key: e }) => e ?? null, yo = ({
  ref: e,
  ref_key: t,
  ref_for: o
}) => (typeof e == "number" && (e = "" + e), e != null ? Je(e) || Ye(e) || ge(e) ? { i: st, r: e, k: t, f: !!o } : e : null);
function K(e, t = null, o = null, i = 0, a = null, l = e === Be ? 0 : 1, f = !1, p = !1) {
  const m = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Du(t),
    ref: t && yo(t),
    scopeId: lu,
    slotScopeIds: null,
    children: o,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: l,
    patchFlag: i,
    dynamicProps: a,
    dynamicChildren: null,
    appContext: null,
    ctx: st
  };
  return p ? (hs(m, o), l & 128 && e.normalize(m)) : o && (m.shapeFlag |= Je(o) ? 8 : 16), jr > 0 && // avoid a block node from tracking itself
  !f && // has current parent block
  Pt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (m.patchFlag > 0 || l & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  m.patchFlag !== 32 && Pt.push(m), m;
}
const wt = nf;
function nf(e, t = null, o = null, i = 0, a = null, l = !1) {
  if ((!e || e === Cc) && (e = sn), ps(e)) {
    const p = sr(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return o && hs(p, o), jr > 0 && !l && Pt && (p.shapeFlag & 6 ? Pt[Pt.indexOf(e)] = p : Pt.push(p)), p.patchFlag = -2, p;
  }
  if (pf(e) && (e = e.__vccOpts), t) {
    t = rf(t);
    let { class: p, style: m } = t;
    p && !Je(p) && (t.class = kr(p)), qe(m) && (is(m) && !fe(m) && (m = mt({}, m)), t.style = Lo(m));
  }
  const f = Je(e) ? 1 : ku(e) ? 128 : dc(e) ? 64 : qe(e) ? 4 : ge(e) ? 2 : 0;
  return K(
    e,
    t,
    o,
    i,
    a,
    f,
    l,
    !0
  );
}
function rf(e) {
  return e ? is(e) || _u(e) ? mt({}, e) : e : null;
}
function sr(e, t, o = !1, i = !1) {
  const { props: a, ref: l, patchFlag: f, children: p, transition: m } = e, P = t ? of(a || {}, t) : a, S = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: P,
    key: P && Du(P),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      o && l ? fe(l) ? l.concat(yo(t)) : [l, yo(t)] : yo(t)
    ) : l,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: p,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Be ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: m,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && sr(e.ssContent),
    ssFallback: e.ssFallback && sr(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return m && i && ls(
    S,
    m.clone(S)
  ), S;
}
function Iu(e = " ", t = 0) {
  return wt(qo, null, e, t);
}
function tn(e = "", t = !1) {
  return t ? (me(), Mn(sn, null, e)) : wt(sn, null, e);
}
function Vt(e) {
  return e == null || typeof e == "boolean" ? wt(sn) : fe(e) ? wt(
    Be,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : ps(e) ? wn(e) : wt(qo, null, String(e));
}
function wn(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : sr(e);
}
function hs(e, t) {
  let o = 0;
  const { shapeFlag: i } = e;
  if (t == null)
    t = null;
  else if (fe(t))
    o = 16;
  else if (typeof t == "object")
    if (i & 65) {
      const a = t.default;
      a && (a._c && (a._d = !1), hs(e, a()), a._c && (a._d = !0));
      return;
    } else {
      o = 32;
      const a = t._;
      !a && !_u(t) ? t._ctx = st : a === 3 && st && (st.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else ge(t) ? (t = { default: t, _ctx: st }, o = 32) : (t = String(t), i & 64 ? (o = 16, t = [Iu(t)]) : o = 8);
  e.children = t, e.shapeFlag |= o;
}
function of(...e) {
  const t = {};
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    for (const a in i)
      if (a === "class")
        t.class !== i.class && (t.class = kr([t.class, i.class]));
      else if (a === "style")
        t.style = Lo([t.style, i.style]);
      else if (Do(a)) {
        const l = t[a], f = i[a];
        f && l !== f && !(fe(l) && l.includes(f)) && (t[a] = l ? [].concat(l, f) : f);
      } else a !== "" && (t[a] = i[a]);
  }
  return t;
}
function Bt(e, t, o, i = null) {
  Ht(e, t, 7, [
    o,
    i
  ]);
}
const sf = vu();
let af = 0;
function uf(e, t, o) {
  const i = e.type, a = (t ? t.appContext : e.appContext) || sf, l = {
    uid: af++,
    vnode: e,
    type: i,
    parent: t,
    appContext: a,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new $a(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(a.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: xu(i, a),
    emitsOptions: Au(i, a),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Ke,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: Ke,
    data: Ke,
    props: Ke,
    attrs: Ke,
    slots: Ke,
    refs: Ke,
    setupState: Ke,
    setupContext: null,
    // suspense related
    suspense: o,
    suspenseId: o ? o.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return l.ctx = { _: l }, l.root = t ? t.root : l, l.emit = Yc.bind(null, l), e.ce && e.ce(l), l;
}
let ht = null, Po, Vi;
{
  const e = jo(), t = (o, i) => {
    let a;
    return (a = e[o]) || (a = e[o] = []), a.push(i), (l) => {
      a.length > 1 ? a.forEach((f) => f(l)) : a[0](l);
    };
  };
  Po = t(
    "__VUE_INSTANCE_SETTERS__",
    (o) => ht = o
  ), Vi = t(
    "__VUE_SSR_SETTERS__",
    (o) => Lr = o
  );
}
const Fr = (e) => {
  const t = ht;
  return Po(e), e.scope.on(), () => {
    e.scope.off(), Po(t);
  };
}, la = () => {
  ht && ht.scope.off(), Po(null);
};
function ju(e) {
  return e.vnode.shapeFlag & 4;
}
let Lr = !1;
function lf(e, t = !1, o = !1) {
  t && Vi(t);
  const { props: i, children: a } = e.vnode, l = ju(e);
  jc(e, i, l, t), Fc(e, a, o || t);
  const f = l ? cf(e, t) : void 0;
  return t && Vi(!1), f;
}
function cf(e, t) {
  const o = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, Oc);
  const { setup: i } = o;
  if (i) {
    rn();
    const a = e.setupContext = i.length > 1 ? df(e) : null, l = Fr(e), f = Mr(
      i,
      e,
      0,
      [
        e.props,
        a
      ]
    ), p = Da(f);
    if (on(), l(), (p || e.sp) && !ir(e) && cu(e), p) {
      if (f.then(la, la), t)
        return f.then((m) => {
          ca(e, m);
        }).catch((m) => {
          Fo(m, e, 0);
        });
      e.asyncDep = f;
    } else
      ca(e, f);
  } else
    Lu(e);
}
function ca(e, t, o) {
  ge(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : qe(t) && (e.setupState = ou(t)), Lu(e);
}
function Lu(e, t, o) {
  const i = e.type;
  e.render || (e.render = i.render || Ut);
  {
    const a = Fr(e);
    rn();
    try {
      Ec(e);
    } finally {
      on(), a();
    }
  }
}
const ff = {
  get(e, t) {
    return pt(e, "get", ""), e[t];
  }
};
function df(e) {
  const t = (o) => {
    e.exposed = o || {};
  };
  return {
    attrs: new Proxy(e.attrs, ff),
    slots: e.slots,
    emit: e.emit,
    expose: t
  };
}
function Vo(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(ou(ss(e.exposed)), {
    get(t, o) {
      if (o in t)
        return t[o];
      if (o in Pr)
        return Pr[o](e);
    },
    has(t, o) {
      return o in t || o in Pr;
    }
  })) : e.proxy;
}
function pf(e) {
  return ge(e) && "__vccOpts" in e;
}
const kt = (e, t) => ic(e, t, Lr), hf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Ui;
const fa = typeof window < "u" && window.trustedTypes;
if (fa)
  try {
    Ui = /* @__PURE__ */ fa.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const Ku = Ui ? (e) => Ui.createHTML(e) : (e) => e, mf = "http://www.w3.org/2000/svg", yf = "http://www.w3.org/1998/Math/MathML", Qt = typeof document < "u" ? document : null, da = Qt && /* @__PURE__ */ Qt.createElement("template"), vf = {
  insert: (e, t, o) => {
    t.insertBefore(e, o || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, o, i) => {
    const a = t === "svg" ? Qt.createElementNS(mf, e) : t === "mathml" ? Qt.createElementNS(yf, e) : o ? Qt.createElement(e, { is: o }) : Qt.createElement(e);
    return e === "select" && i && i.multiple != null && a.setAttribute("multiple", i.multiple), a;
  },
  createText: (e) => Qt.createTextNode(e),
  createComment: (e) => Qt.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Qt.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, o, i, a, l) {
    const f = o ? o.previousSibling : t.lastChild;
    if (a && (a === l || a.nextSibling))
      for (; t.insertBefore(a.cloneNode(!0), o), !(a === l || !(a = a.nextSibling)); )
        ;
    else {
      da.innerHTML = Ku(
        i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e
      );
      const p = da.content;
      if (i === "svg" || i === "mathml") {
        const m = p.firstChild;
        for (; m.firstChild; )
          p.appendChild(m.firstChild);
        p.removeChild(m);
      }
      t.insertBefore(p, o);
    }
    return [
      // first
      f ? f.nextSibling : t.firstChild,
      // last
      o ? o.previousSibling : t.lastChild
    ];
  }
}, gf = Symbol("_vtc");
function bf(e, t, o) {
  const i = e[gf];
  i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : o ? e.setAttribute("class", t) : e.className = t;
}
const pa = Symbol("_vod"), _f = Symbol("_vsh"), wf = Symbol(""), xf = /(^|;)\s*display\s*:/;
function Sf(e, t, o) {
  const i = e.style, a = Je(o);
  let l = !1;
  if (o && !a) {
    if (t)
      if (Je(t))
        for (const f of t.split(";")) {
          const p = f.slice(0, f.indexOf(":")).trim();
          o[p] == null && vo(i, p, "");
        }
      else
        for (const f in t)
          o[f] == null && vo(i, f, "");
    for (const f in o)
      f === "display" && (l = !0), vo(i, f, o[f]);
  } else if (a) {
    if (t !== o) {
      const f = i[wf];
      f && (o += ";" + f), i.cssText = o, l = xf.test(o);
    }
  } else t && e.removeAttribute("style");
  pa in e && (e[pa] = l ? i.display : "", e[_f] && (i.display = "none"));
}
const ha = /\s*!important$/;
function vo(e, t, o) {
  if (fe(o))
    o.forEach((i) => vo(e, t, i));
  else if (o == null && (o = ""), t.startsWith("--"))
    e.setProperty(t, o);
  else {
    const i = Cf(e, t);
    ha.test(o) ? e.setProperty(
      qn(i),
      o.replace(ha, ""),
      "important"
    ) : e[i] = o;
  }
}
const ma = ["Webkit", "Moz", "ms"], Ai = {};
function Cf(e, t) {
  const o = Ai[t];
  if (o)
    return o;
  let i = Cn(t);
  if (i !== "filter" && i in e)
    return Ai[t] = i;
  i = La(i);
  for (let a = 0; a < ma.length; a++) {
    const l = ma[a] + i;
    if (l in e)
      return Ai[t] = l;
  }
  return t;
}
const ya = "http://www.w3.org/1999/xlink";
function va(e, t, o, i, a, l = Nl(t)) {
  i && t.startsWith("xlink:") ? o == null ? e.removeAttributeNS(ya, t.slice(6, t.length)) : e.setAttributeNS(ya, t, o) : o == null || l && !Ka(o) ? e.removeAttribute(t) : e.setAttribute(
    t,
    l ? "" : Kt(o) ? String(o) : o
  );
}
function ga(e, t, o, i, a) {
  if (t === "innerHTML" || t === "textContent") {
    o != null && (e[t] = t === "innerHTML" ? Ku(o) : o);
    return;
  }
  const l = e.tagName;
  if (t === "value" && l !== "PROGRESS" && // custom elements may use _value internally
  !l.includes("-")) {
    const p = l === "OPTION" ? e.getAttribute("value") || "" : e.value, m = o == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(o);
    (p !== m || !("_value" in e)) && (e.value = m), o == null && e.removeAttribute(t), e._value = o;
    return;
  }
  let f = !1;
  if (o === "" || o == null) {
    const p = typeof e[t];
    p === "boolean" ? o = Ka(o) : o == null && p === "string" ? (o = "", f = !0) : p === "number" && (o = 0, f = !0);
  }
  try {
    e[t] = o;
  } catch {
  }
  f && e.removeAttribute(a || t);
}
function Zt(e, t, o, i) {
  e.addEventListener(t, o, i);
}
function Of(e, t, o, i) {
  e.removeEventListener(t, o, i);
}
const ba = Symbol("_vei");
function Ef(e, t, o, i, a = null) {
  const l = e[ba] || (e[ba] = {}), f = l[t];
  if (i && f)
    f.value = i;
  else {
    const [p, m] = Pf(t);
    if (i) {
      const P = l[t] = Af(
        i,
        a
      );
      Zt(e, p, P, m);
    } else f && (Of(e, p, f, m), l[t] = void 0);
  }
}
const _a = /(?:Once|Passive|Capture)$/;
function Pf(e) {
  let t;
  if (_a.test(e)) {
    t = {};
    let i;
    for (; i = e.match(_a); )
      e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : qn(e.slice(2)), t];
}
let ki = 0;
const Tf = /* @__PURE__ */ Promise.resolve(), Nf = () => ki || (Tf.then(() => ki = 0), ki = Date.now());
function Af(e, t) {
  const o = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= o.attached)
      return;
    Ht(
      kf(i, o.value),
      t,
      5,
      [i]
    );
  };
  return o.value = e, o.attached = Nf(), o;
}
function kf(e, t) {
  if (fe(t)) {
    const o = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      o.call(e), e._stopped = !0;
    }, t.map(
      (i) => (a) => !a._stopped && i && i(a)
    );
  } else
    return t;
}
const wa = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Rf = (e, t, o, i, a, l) => {
  const f = a === "svg";
  t === "class" ? bf(e, i, f) : t === "style" ? Sf(e, o, i) : Do(t) ? Yi(t) || Ef(e, t, o, i, l) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Df(e, t, i, f)) ? (ga(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && va(e, t, i, f, l, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !Je(i)) ? ga(e, Cn(t), i, l, t) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), va(e, t, i, f));
};
function Df(e, t, o, i) {
  if (i)
    return !!(t === "innerHTML" || t === "textContent" || t in e && wa(t) && ge(o));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (t === "width" || t === "height") {
    const a = e.tagName;
    if (a === "IMG" || a === "VIDEO" || a === "CANVAS" || a === "SOURCE")
      return !1;
  }
  return wa(t) && Je(o) ? !1 : t in e;
}
const En = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return fe(t) ? (o) => mo(t, o) : t;
};
function If(e) {
  e.target.composing = !0;
}
function xa(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const It = Symbol("_assign"), To = {
  created(e, { modifiers: { lazy: t, trim: o, number: i } }, a) {
    e[It] = En(a);
    const l = i || a.props && a.props.type === "number";
    Zt(e, t ? "change" : "input", (f) => {
      if (f.target.composing) return;
      let p = e.value;
      o && (p = p.trim()), l && (p = _o(p)), e[It](p);
    }), o && Zt(e, "change", () => {
      e.value = e.value.trim();
    }), t || (Zt(e, "compositionstart", If), Zt(e, "compositionend", xa), Zt(e, "change", xa));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, oldValue: o, modifiers: { lazy: i, trim: a, number: l } }, f) {
    if (e[It] = En(f), e.composing) return;
    const p = (l || e.type === "number") && !/^0\d/.test(e.value) ? _o(e.value) : e.value, m = t ?? "";
    p !== m && (document.activeElement === e && e.type !== "range" && (i && t === o || a && e.value.trim() === m) || (e.value = m));
  }
}, Sa = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, t, o) {
    e[It] = En(o), Zt(e, "change", () => {
      const i = e._modelValue, a = ar(e), l = e.checked, f = e[It];
      if (fe(i)) {
        const p = Xi(i, a), m = p !== -1;
        if (l && !m)
          f(i.concat(a));
        else if (!l && m) {
          const P = [...i];
          P.splice(p, 1), f(P);
        }
      } else if (ur(i)) {
        const p = new Set(i);
        l ? p.add(a) : p.delete(a), f(p);
      } else
        f(Mu(e, l));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Ca,
  beforeUpdate(e, t, o) {
    e[It] = En(o), Ca(e, t, o);
  }
};
function Ca(e, { value: t, oldValue: o }, i) {
  e._modelValue = t;
  let a;
  if (fe(t))
    a = Xi(t, i.props.value) > -1;
  else if (ur(t))
    a = t.has(i.props.value);
  else {
    if (t === o) return;
    a = Bn(t, Mu(e, !0));
  }
  e.checked !== a && (e.checked = a);
}
const Oa = {
  created(e, { value: t }, o) {
    e.checked = Bn(t, o.props.value), e[It] = En(o), Zt(e, "change", () => {
      e[It](ar(e));
    });
  },
  beforeUpdate(e, { value: t, oldValue: o }, i) {
    e[It] = En(i), t !== o && (e.checked = Bn(t, i.props.value));
  }
}, en = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(e, { value: t, modifiers: { number: o } }, i) {
    const a = ur(t);
    Zt(e, "change", () => {
      const l = Array.prototype.filter.call(e.options, (f) => f.selected).map(
        (f) => o ? _o(ar(f)) : ar(f)
      );
      e[It](
        e.multiple ? a ? new Set(l) : l : l[0]
      ), e._assigning = !0, as(() => {
        e._assigning = !1;
      });
    }), e[It] = En(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: t }) {
    Ea(e, t);
  },
  beforeUpdate(e, t, o) {
    e[It] = En(o);
  },
  updated(e, { value: t }) {
    e._assigning || Ea(e, t);
  }
};
function Ea(e, t) {
  const o = e.multiple, i = fe(t);
  if (!(o && !i && !ur(t))) {
    for (let a = 0, l = e.options.length; a < l; a++) {
      const f = e.options[a], p = ar(f);
      if (o)
        if (i) {
          const m = typeof p;
          m === "string" || m === "number" ? f.selected = t.some((P) => String(P) === String(p)) : f.selected = Xi(t, p) > -1;
        } else
          f.selected = t.has(p);
      else if (Bn(ar(f), t)) {
        e.selectedIndex !== a && (e.selectedIndex = a);
        return;
      }
    }
    !o && e.selectedIndex !== -1 && (e.selectedIndex = -1);
  }
}
function ar(e) {
  return "_value" in e ? e._value : e.value;
}
function Mu(e, t) {
  const o = t ? "_trueValue" : "_falseValue";
  return o in e ? e[o] : t;
}
const jf = /* @__PURE__ */ mt({ patchProp: Rf }, vf);
let Pa;
function Lf() {
  return Pa || (Pa = Bc(jf));
}
const Kf = (...e) => {
  const t = Lf().createApp(...e), { mount: o } = t;
  return t.mount = (i) => {
    const a = Ff(i);
    if (!a) return;
    const l = t._component;
    !ge(l) && !l.render && !l.template && (l.template = a.innerHTML), a.nodeType === 1 && (a.textContent = "");
    const f = o(a, !1, Mf(a));
    return a instanceof Element && (a.removeAttribute("v-cloak"), a.setAttribute("data-v-app", "")), f;
  }, t;
};
function Mf(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function Ff(e) {
  return Je(e) ? document.querySelector(e) : e;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Fu;
const Uo = (e) => Fu = e, $u = (
  /* istanbul ignore next */
  Symbol()
);
function Hi(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var Ar;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(Ar || (Ar = {}));
function $f() {
  const e = Ba(!0), t = e.run(() => Ze({}));
  let o = [], i = [];
  const a = ss({
    install(l) {
      Uo(a), a._a = l, l.provide($u, a), l.config.globalProperties.$pinia = a, i.forEach((f) => o.push(f)), i = [];
    },
    use(l) {
      return this._a ? o.push(l) : i.push(l), this;
    },
    _p: o,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: t
  });
  return a;
}
const Bu = () => {
};
function Ta(e, t, o, i = Bu) {
  e.push(t);
  const a = () => {
    const l = e.indexOf(t);
    l > -1 && (e.splice(l, 1), i());
  };
  return !o && qa() && kl(a), a;
}
function er(e, ...t) {
  e.slice().forEach((o) => {
    o(...t);
  });
}
const Bf = (e) => e(), Na = Symbol(), Ri = Symbol();
function Wi(e, t) {
  e instanceof Map && t instanceof Map ? t.forEach((o, i) => e.set(i, o)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
  for (const o in t) {
    if (!t.hasOwnProperty(o))
      continue;
    const i = t[o], a = e[o];
    Hi(a) && Hi(i) && e.hasOwnProperty(o) && !Ye(i) && !Sn(i) ? e[o] = Wi(a, i) : e[o] = i;
  }
  return e;
}
const qf = (
  /* istanbul ignore next */
  Symbol()
);
function Vf(e) {
  return !Hi(e) || !Object.prototype.hasOwnProperty.call(e, qf);
}
const { assign: bn } = Object;
function Uf(e) {
  return !!(Ye(e) && e.effect);
}
function Hf(e, t, o, i) {
  const { state: a, actions: l, getters: f } = t, p = o.state.value[e];
  let m;
  function P() {
    p || (o.state.value[e] = a ? a() : {});
    const S = tc(o.state.value[e]);
    return bn(S, l, Object.keys(f || {}).reduce((R, F) => (R[F] = ss(kt(() => {
      Uo(o);
      const G = o._s.get(e);
      return f[F].call(G, G);
    })), R), {}));
  }
  return m = qu(e, P, t, o, i, !0), m;
}
function qu(e, t, o = {}, i, a, l) {
  let f;
  const p = bn({ actions: {} }, o), m = { deep: !0 };
  let P, S, R = [], F = [], G;
  const oe = i.state.value[e];
  !l && !oe && (i.state.value[e] = {}), Ze({});
  let $;
  function O(we) {
    let Ee;
    P = S = !1, typeof we == "function" ? (we(i.state.value[e]), Ee = {
      type: Ar.patchFunction,
      storeId: e,
      events: G
    }) : (Wi(i.state.value[e], we), Ee = {
      type: Ar.patchObject,
      payload: we,
      storeId: e,
      events: G
    });
    const Ue = $ = Symbol();
    as().then(() => {
      $ === Ue && (P = !0);
    }), S = !0, er(R, Ee, i.state.value[e]);
  }
  const I = l ? function() {
    const { state: Ee } = o, Ue = Ee ? Ee() : {};
    this.$patch((yt) => {
      bn(yt, Ue);
    });
  } : (
    /* istanbul ignore next */
    Bu
  );
  function de() {
    f.stop(), R = [], F = [], i._s.delete(e);
  }
  const Se = (we, Ee = "") => {
    if (Na in we)
      return we[Ri] = Ee, we;
    const Ue = function() {
      Uo(i);
      const yt = Array.from(arguments), at = [], ut = [];
      function Pn(_e) {
        at.push(_e);
      }
      function ln(_e) {
        ut.push(_e);
      }
      er(F, {
        args: yt,
        name: Ue[Ri],
        store: be,
        after: Pn,
        onError: ln
      });
      let Fe;
      try {
        Fe = we.apply(this && this.$id === e ? this : be, yt);
      } catch (_e) {
        throw er(ut, _e), _e;
      }
      return Fe instanceof Promise ? Fe.then((_e) => (er(at, _e), _e)).catch((_e) => (er(ut, _e), Promise.reject(_e))) : (er(at, Fe), Fe);
    };
    return Ue[Na] = !0, Ue[Ri] = Ee, Ue;
  }, ue = {
    _p: i,
    // _s: scope,
    $id: e,
    $onAction: Ta.bind(null, F),
    $patch: O,
    $reset: I,
    $subscribe(we, Ee = {}) {
      const Ue = Ta(R, we, Ee.detached, () => yt()), yt = f.run(() => nn(() => i.state.value[e], (at) => {
        (Ee.flush === "sync" ? S : P) && we({
          storeId: e,
          type: Ar.direct,
          events: G
        }, at);
      }, bn({}, m, Ee)));
      return Ue;
    },
    $dispose: de
  }, be = Mo(ue);
  i._s.set(e, be);
  const Re = (i._a && i._a.runWithContext || Bf)(() => i._e.run(() => (f = Ba()).run(() => t({ action: Se }))));
  for (const we in Re) {
    const Ee = Re[we];
    if (Ye(Ee) && !Uf(Ee) || Sn(Ee))
      l || (oe && Vf(Ee) && (Ye(Ee) ? Ee.value = oe[we] : Wi(Ee, oe[we])), i.state.value[e][we] = Ee);
    else if (typeof Ee == "function") {
      const Ue = Se(Ee, we);
      Re[we] = Ue, p.actions[we] = Ee;
    }
  }
  return bn(be, Re), bn(Ae(be), Re), Object.defineProperty(be, "$state", {
    get: () => i.state.value[e],
    set: (we) => {
      O((Ee) => {
        bn(Ee, we);
      });
    }
  }), i._p.forEach((we) => {
    bn(be, f.run(() => we({
      store: be,
      app: i._a,
      pinia: i,
      options: p
    })));
  }), oe && l && o.hydrate && o.hydrate(be.$state, oe), P = !0, S = !0, be;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Wf(e, t, o) {
  let i;
  const a = typeof t == "function";
  i = a ? o : t;
  function l(f, p) {
    const m = Ic();
    return f = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    f || (m ? Tr($u, null) : null), f && Uo(f), f = Fu, f._s.has(e) || (a ? qu(e, t, i, f) : Hf(e, i, f)), f._s.get(e);
  }
  return l.$id = e, l;
}
var zf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Gf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var go = { exports: {} }, Yf = go.exports, Aa;
function Qf() {
  return Aa || (Aa = 1, function(e, t) {
    (function(o, i) {
      e.exports = i();
    })(Yf, function() {
      var o = function(n, r) {
        return (o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, u) {
          s.__proto__ = u;
        } || function(s, u) {
          for (var c in u) Object.prototype.hasOwnProperty.call(u, c) && (s[c] = u[c]);
        })(n, r);
      }, i = function() {
        return (i = Object.assign || function(n) {
          for (var r, s = 1, u = arguments.length; s < u; s++) for (var c in r = arguments[s]) Object.prototype.hasOwnProperty.call(r, c) && (n[c] = r[c]);
          return n;
        }).apply(this, arguments);
      };
      function a(n, r, s) {
        for (var u, c = 0, d = r.length; c < d; c++) !u && c in r || ((u = u || Array.prototype.slice.call(r, 0, c))[c] = r[c]);
        return n.concat(u || Array.prototype.slice.call(r));
      }
      var l = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : zf, f = Object.keys, p = Array.isArray;
      function m(n, r) {
        return typeof r != "object" || f(r).forEach(function(s) {
          n[s] = r[s];
        }), n;
      }
      typeof Promise > "u" || l.Promise || (l.Promise = Promise);
      var P = Object.getPrototypeOf, S = {}.hasOwnProperty;
      function R(n, r) {
        return S.call(n, r);
      }
      function F(n, r) {
        typeof r == "function" && (r = r(P(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(r).forEach(function(s) {
          oe(n, s, r[s]);
        });
      }
      var G = Object.defineProperty;
      function oe(n, r, s, u) {
        G(n, r, m(s && R(s, "get") && typeof s.get == "function" ? { get: s.get, set: s.set, configurable: !0 } : { value: s, configurable: !0, writable: !0 }, u));
      }
      function $(n) {
        return { from: function(r) {
          return n.prototype = Object.create(r.prototype), oe(n.prototype, "constructor", n), { extend: F.bind(null, n.prototype) };
        } };
      }
      var O = Object.getOwnPropertyDescriptor, I = [].slice;
      function de(n, r, s) {
        return I.call(n, r, s);
      }
      function Se(n, r) {
        return r(n);
      }
      function ue(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function be(n) {
        l.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function Le(n, r) {
        if (typeof r == "string" && R(n, r)) return n[r];
        if (!r) return n;
        if (typeof r != "string") {
          for (var s = [], u = 0, c = r.length; u < c; ++u) {
            var d = Le(n, r[u]);
            s.push(d);
          }
          return s;
        }
        var h = r.indexOf(".");
        if (h !== -1) {
          var v = n[r.substr(0, h)];
          return v == null ? void 0 : Le(v, r.substr(h + 1));
        }
      }
      function Re(n, r, s) {
        if (n && r !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof r != "string" && "length" in r) {
          ue(typeof s != "string" && "length" in s);
          for (var u = 0, c = r.length; u < c; ++u) Re(n, r[u], s[u]);
        } else {
          var d, h, v = r.indexOf(".");
          v !== -1 ? (d = r.substr(0, v), (h = r.substr(v + 1)) === "" ? s === void 0 ? p(n) && !isNaN(parseInt(d)) ? n.splice(d, 1) : delete n[d] : n[d] = s : Re(v = !(v = n[d]) || !R(n, d) ? n[d] = {} : v, h, s)) : s === void 0 ? p(n) && !isNaN(parseInt(r)) ? n.splice(r, 1) : delete n[r] : n[r] = s;
        }
      }
      function we(n) {
        var r, s = {};
        for (r in n) R(n, r) && (s[r] = n[r]);
        return s;
      }
      var Ee = [].concat;
      function Ue(n) {
        return Ee.apply([], n);
      }
      var ye = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Ue([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(r) {
          return r + n + "Array";
        });
      }))).filter(function(n) {
        return l[n];
      }), yt = new Set(ye.map(function(n) {
        return l[n];
      })), at = null;
      function ut(n) {
        return at = /* @__PURE__ */ new WeakMap(), n = function r(s) {
          if (!s || typeof s != "object") return s;
          var u = at.get(s);
          if (u) return u;
          if (p(s)) {
            u = [], at.set(s, u);
            for (var c = 0, d = s.length; c < d; ++c) u.push(r(s[c]));
          } else if (yt.has(s.constructor)) u = s;
          else {
            var h, v = P(s);
            for (h in u = v === Object.prototype ? {} : Object.create(v), at.set(s, u), s) R(s, h) && (u[h] = r(s[h]));
          }
          return u;
        }(n), at = null, n;
      }
      var Pn = {}.toString;
      function ln(n) {
        return Pn.call(n).slice(8, -1);
      }
      var Fe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", _e = typeof Fe == "symbol" ? function(n) {
        var r;
        return n != null && (r = n[Fe]) && r.apply(n);
      } : function() {
        return null;
      };
      function Pe(n, r) {
        return r = n.indexOf(r), 0 <= r && n.splice(r, 1), 0 <= r;
      }
      var xt = {};
      function St(n) {
        var r, s, u, c;
        if (arguments.length === 1) {
          if (p(n)) return n.slice();
          if (this === xt && typeof n == "string") return [n];
          if (c = _e(n)) {
            for (s = []; !(u = c.next()).done; ) s.push(u.value);
            return s;
          }
          if (n == null) return [n];
          if (typeof (r = n.length) != "number") return [n];
          for (s = new Array(r); r--; ) s[r] = n[r];
          return s;
        }
        for (r = arguments.length, s = new Array(r); r--; ) s[r] = arguments[r];
        return s;
      }
      var jt = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, ce = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], At = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(ce), Tt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Wt(n, r) {
        this.name = n, this.message = r;
      }
      function $r(n, r) {
        return n + ". Errors: " + Object.keys(r).map(function(s) {
          return r[s].toString();
        }).filter(function(s, u, c) {
          return c.indexOf(s) === u;
        }).join(`
`);
      }
      function Vn(n, r, s, u) {
        this.failures = r, this.failedKeys = u, this.successCount = s, this.message = $r(n, r);
      }
      function Nt(n, r) {
        this.name = "BulkError", this.failures = Object.keys(r).map(function(s) {
          return r[s];
        }), this.failuresByPos = r, this.message = $r(n, this.failures);
      }
      $(Wt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), $(Vn).from(Wt), $(Nt).from(Wt);
      var cn = At.reduce(function(n, r) {
        return n[r] = r + "Error", n;
      }, {}), lr = Wt, se = At.reduce(function(n, r) {
        var s = r + "Error";
        function u(c, d) {
          this.name = s, c ? typeof c == "string" ? (this.message = "".concat(c).concat(d ? `
 ` + d : ""), this.inner = d || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = Tt[r] || s, this.inner = null);
        }
        return $(u).from(lr), n[r] = u, n;
      }, {});
      se.Syntax = SyntaxError, se.Type = TypeError, se.Range = RangeError;
      var fn = ce.reduce(function(n, r) {
        return n[r + "Error"] = se[r], n;
      }, {}), cr = At.reduce(function(n, r) {
        return ["Syntax", "Type", "Range"].indexOf(r) === -1 && (n[r + "Error"] = se[r]), n;
      }, {});
      function y() {
      }
      function w(n) {
        return n;
      }
      function M(n, r) {
        return n == null || n === w ? r : function(s) {
          return r(n(s));
        };
      }
      function V(n, r) {
        return function() {
          n.apply(this, arguments), r.apply(this, arguments);
        };
      }
      function q(n, r) {
        return n === y ? r : function() {
          var s = n.apply(this, arguments);
          s !== void 0 && (arguments[0] = s);
          var u = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var d = r.apply(this, arguments);
          return u && (this.onsuccess = this.onsuccess ? V(u, this.onsuccess) : u), c && (this.onerror = this.onerror ? V(c, this.onerror) : c), d !== void 0 ? d : s;
        };
      }
      function U(n, r) {
        return n === y ? r : function() {
          n.apply(this, arguments);
          var s = this.onsuccess, u = this.onerror;
          this.onsuccess = this.onerror = null, r.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? V(s, this.onsuccess) : s), u && (this.onerror = this.onerror ? V(u, this.onerror) : u);
        };
      }
      function ee(n, r) {
        return n === y ? r : function(s) {
          var u = n.apply(this, arguments);
          m(s, u);
          var c = this.onsuccess, d = this.onerror;
          return this.onsuccess = null, this.onerror = null, s = r.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? V(c, this.onsuccess) : c), d && (this.onerror = this.onerror ? V(d, this.onerror) : d), u === void 0 ? s === void 0 ? void 0 : s : m(u, s);
        };
      }
      function J(n, r) {
        return n === y ? r : function() {
          return r.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Y(n, r) {
        return n === y ? r : function() {
          var s = n.apply(this, arguments);
          if (s && typeof s.then == "function") {
            for (var u = this, c = arguments.length, d = new Array(c); c--; ) d[c] = arguments[c];
            return s.then(function() {
              return r.apply(u, d);
            });
          }
          return r.apply(this, arguments);
        };
      }
      cr.ModifyError = Vn, cr.DexieError = Wt, cr.BulkError = Nt;
      var B = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function le(n) {
        B = n;
      }
      var X = {}, ae = 100, ye = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, P(n), n];
        var r = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [r, P(r), n];
      }(), ce = ye[0], At = ye[1], ye = ye[2], At = At && At.then, Te = ce && ce.constructor, ke = !!ye, Qe = function(n, r) {
        dn.push([n, r]), vt && (queueMicrotask(Yu), vt = !1);
      }, et = !0, vt = !0, tt = [], Mt = [], Un = w, He = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: y, pgp: !1, env: {}, finalize: y }, ie = He, dn = [], Tn = 0, Br = [];
      function ne(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var r = this._PSD = ie;
        if (typeof n != "function") {
          if (n !== X) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Wo(this, this._value));
        }
        this._state = null, this._value = null, ++r.ref, function s(u, c) {
          try {
            c(function(d) {
              if (u._state === null) {
                if (d === u) throw new TypeError("A promise cannot be resolved with itself.");
                var h = u._lib && Hn();
                d && typeof d.then == "function" ? s(u, function(v, b) {
                  d instanceof ne ? d._then(v, b) : d.then(v, b);
                }) : (u._state = !0, u._value = d, vs(u)), h && Wn();
              }
            }, Wo.bind(null, u));
          } catch (d) {
            Wo(u, d);
          }
        }(this, n);
      }
      var Ho = { get: function() {
        var n = ie, r = Hr;
        function s(u, c) {
          var d = this, h = !n.global && (n !== ie || r !== Hr), v = h && !hn(), b = new ne(function(x, E) {
            zo(d, new ys(bs(u, n, h, v), bs(c, n, h, v), x, E, n));
          });
          return this._consoleTask && (b._consoleTask = this._consoleTask), b;
        }
        return s.prototype = X, s;
      }, set: function(n) {
        oe(this, "then", n && n.prototype === X ? Ho : { get: function() {
          return n;
        }, set: Ho.set });
      } };
      function ys(n, r, s, u, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof r == "function" ? r : null, this.resolve = s, this.reject = u, this.psd = c;
      }
      function Wo(n, r) {
        var s, u;
        Mt.push(r), n._state === null && (s = n._lib && Hn(), r = Un(r), n._state = !1, n._value = r, u = n, tt.some(function(c) {
          return c._value === u._value;
        }) || tt.push(u), vs(n), s && Wn());
      }
      function vs(n) {
        var r = n._listeners;
        n._listeners = [];
        for (var s = 0, u = r.length; s < u; ++s) zo(n, r[s]);
        var c = n._PSD;
        --c.ref || c.finalize(), Tn === 0 && (++Tn, Qe(function() {
          --Tn == 0 && Go();
        }, []));
      }
      function zo(n, r) {
        if (n._state !== null) {
          var s = n._state ? r.onFulfilled : r.onRejected;
          if (s === null) return (n._state ? r.resolve : r.reject)(n._value);
          ++r.psd.ref, ++Tn, Qe(Gu, [s, n, r]);
        } else n._listeners.push(r);
      }
      function Gu(n, r, s) {
        try {
          var u, c = r._value;
          !r._state && Mt.length && (Mt = []), u = B && r._consoleTask ? r._consoleTask.run(function() {
            return n(c);
          }) : n(c), r._state || Mt.indexOf(c) !== -1 || function(d) {
            for (var h = tt.length; h; ) if (tt[--h]._value === d._value) return tt.splice(h, 1);
          }(r), s.resolve(u);
        } catch (d) {
          s.reject(d);
        } finally {
          --Tn == 0 && Go(), --s.psd.ref || s.psd.finalize();
        }
      }
      function Yu() {
        Nn(He, function() {
          Hn() && Wn();
        });
      }
      function Hn() {
        var n = et;
        return vt = et = !1, n;
      }
      function Wn() {
        var n, r, s;
        do
          for (; 0 < dn.length; ) for (n = dn, dn = [], s = n.length, r = 0; r < s; ++r) {
            var u = n[r];
            u[0].apply(null, u[1]);
          }
        while (0 < dn.length);
        vt = et = !0;
      }
      function Go() {
        var n = tt;
        tt = [], n.forEach(function(u) {
          u._PSD.onunhandled.call(null, u._value, u);
        });
        for (var r = Br.slice(0), s = r.length; s; ) r[--s]();
      }
      function qr(n) {
        return new ne(X, !1, n);
      }
      function Ve(n, r) {
        var s = ie;
        return function() {
          var u = Hn(), c = ie;
          try {
            return mn(s, !0), n.apply(this, arguments);
          } catch (d) {
            r && r(d);
          } finally {
            mn(c, !1), u && Wn();
          }
        };
      }
      F(ne.prototype, { then: Ho, _then: function(n, r) {
        zo(this, new ys(null, null, n, r, ie));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var r = n, s = arguments[1];
        return typeof r == "function" ? this.then(null, function(u) {
          return (u instanceof r ? s : qr)(u);
        }) : this.then(null, function(u) {
          return (u && u.name === r ? s : qr)(u);
        });
      }, finally: function(n) {
        return this.then(function(r) {
          return ne.resolve(n()).then(function() {
            return r;
          });
        }, function(r) {
          return ne.resolve(n()).then(function() {
            return qr(r);
          });
        });
      }, timeout: function(n, r) {
        var s = this;
        return n < 1 / 0 ? new ne(function(u, c) {
          var d = setTimeout(function() {
            return c(new se.Timeout(r));
          }, n);
          s.then(u, c).finally(clearTimeout.bind(null, d));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && oe(ne.prototype, Symbol.toStringTag, "Dexie.Promise"), He.env = gs(), F(ne, { all: function() {
        var n = St.apply(null, arguments).map(Wr);
        return new ne(function(r, s) {
          n.length === 0 && r([]);
          var u = n.length;
          n.forEach(function(c, d) {
            return ne.resolve(c).then(function(h) {
              n[d] = h, --u || r(n);
            }, s);
          });
        });
      }, resolve: function(n) {
        return n instanceof ne ? n : n && typeof n.then == "function" ? new ne(function(r, s) {
          n.then(r, s);
        }) : new ne(X, !0, n);
      }, reject: qr, race: function() {
        var n = St.apply(null, arguments).map(Wr);
        return new ne(function(r, s) {
          n.map(function(u) {
            return ne.resolve(u).then(r, s);
          });
        });
      }, PSD: { get: function() {
        return ie;
      }, set: function(n) {
        return ie = n;
      } }, totalEchoes: { get: function() {
        return Hr;
      } }, newPSD: pn, usePSD: Nn, scheduler: { get: function() {
        return Qe;
      }, set: function(n) {
        Qe = n;
      } }, rejectionMapper: { get: function() {
        return Un;
      }, set: function(n) {
        Un = n;
      } }, follow: function(n, r) {
        return new ne(function(s, u) {
          return pn(function(c, d) {
            var h = ie;
            h.unhandleds = [], h.onunhandled = d, h.finalize = V(function() {
              var v, b = this;
              v = function() {
                b.unhandleds.length === 0 ? c() : d(b.unhandleds[0]);
              }, Br.push(function x() {
                v(), Br.splice(Br.indexOf(x), 1);
              }), ++Tn, Qe(function() {
                --Tn == 0 && Go();
              }, []);
            }, h.finalize), n();
          }, r, s, u);
        });
      } }), Te && (Te.allSettled && oe(ne, "allSettled", function() {
        var n = St.apply(null, arguments).map(Wr);
        return new ne(function(r) {
          n.length === 0 && r([]);
          var s = n.length, u = new Array(s);
          n.forEach(function(c, d) {
            return ne.resolve(c).then(function(h) {
              return u[d] = { status: "fulfilled", value: h };
            }, function(h) {
              return u[d] = { status: "rejected", reason: h };
            }).then(function() {
              return --s || r(u);
            });
          });
        });
      }), Te.any && typeof AggregateError < "u" && oe(ne, "any", function() {
        var n = St.apply(null, arguments).map(Wr);
        return new ne(function(r, s) {
          n.length === 0 && s(new AggregateError([]));
          var u = n.length, c = new Array(u);
          n.forEach(function(d, h) {
            return ne.resolve(d).then(function(v) {
              return r(v);
            }, function(v) {
              c[h] = v, --u || s(new AggregateError(c));
            });
          });
        });
      }), Te.withResolvers && (ne.withResolvers = Te.withResolvers));
      var nt = { awaits: 0, echoes: 0, id: 0 }, Qu = 0, Vr = [], Ur = 0, Hr = 0, Ju = 0;
      function pn(n, r, s, u) {
        var c = ie, d = Object.create(c);
        return d.parent = c, d.ref = 0, d.global = !1, d.id = ++Ju, He.env, d.env = ke ? { Promise: ne, PromiseProp: { value: ne, configurable: !0, writable: !0 }, all: ne.all, race: ne.race, allSettled: ne.allSettled, any: ne.any, resolve: ne.resolve, reject: ne.reject } : {}, r && m(d, r), ++c.ref, d.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, u = Nn(d, n, s, u), d.ref === 0 && d.finalize(), u;
      }
      function zn() {
        return nt.id || (nt.id = ++Qu), ++nt.awaits, nt.echoes += ae, nt.id;
      }
      function hn() {
        return !!nt.awaits && (--nt.awaits == 0 && (nt.id = 0), nt.echoes = nt.awaits * ae, !0);
      }
      function Wr(n) {
        return nt.echoes && n && n.constructor === Te ? (zn(), n.then(function(r) {
          return hn(), r;
        }, function(r) {
          return hn(), ze(r);
        })) : n;
      }
      function Xu() {
        var n = Vr[Vr.length - 1];
        Vr.pop(), mn(n, !1);
      }
      function mn(n, r) {
        var s, u = ie;
        (r ? !nt.echoes || Ur++ && n === ie : !Ur || --Ur && n === ie) || queueMicrotask(r ? (function(c) {
          ++Hr, nt.echoes && --nt.echoes != 0 || (nt.echoes = nt.awaits = nt.id = 0), Vr.push(ie), mn(c, !0);
        }).bind(null, n) : Xu), n !== ie && (ie = n, u === He && (He.env = gs()), ke && (s = He.env.Promise, r = n.env, (u.global || n.global) && (Object.defineProperty(l, "Promise", r.PromiseProp), s.all = r.all, s.race = r.race, s.resolve = r.resolve, s.reject = r.reject, r.allSettled && (s.allSettled = r.allSettled), r.any && (s.any = r.any))));
      }
      function gs() {
        var n = l.Promise;
        return ke ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(l, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Nn(n, r, s, u, c) {
        var d = ie;
        try {
          return mn(n, !0), r(s, u, c);
        } finally {
          mn(d, !1);
        }
      }
      function bs(n, r, s, u) {
        return typeof n != "function" ? n : function() {
          var c = ie;
          s && zn(), mn(r, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            mn(c, !1), u && queueMicrotask(hn);
          }
        };
      }
      function Yo(n) {
        Promise === Te && nt.echoes === 0 ? Ur === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + At).indexOf("[native code]") === -1 && (zn = hn = y);
      var ze = ne.reject, An = "￿", zt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", _s = "String expected.", Gn = [], zr = "__dbnames", Qo = "readonly", Jo = "readwrite";
      function kn(n, r) {
        return n ? r ? function() {
          return n.apply(this, arguments) && r.apply(this, arguments);
        } : n : r;
      }
      var ws = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Gr(n) {
        return typeof n != "string" || /\./.test(n) ? function(r) {
          return r;
        } : function(r) {
          return r[n] === void 0 && n in r && delete (r = ut(r))[n], r;
        };
      }
      function xs() {
        throw se.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Ce(n, r) {
        try {
          var s = Ss(n), u = Ss(r);
          if (s !== u) return s === "Array" ? 1 : u === "Array" ? -1 : s === "binary" ? 1 : u === "binary" ? -1 : s === "string" ? 1 : u === "string" ? -1 : s === "Date" ? 1 : u !== "Date" ? NaN : -1;
          switch (s) {
            case "number":
            case "Date":
            case "string":
              return r < n ? 1 : n < r ? -1 : 0;
            case "binary":
              return function(c, d) {
                for (var h = c.length, v = d.length, b = h < v ? h : v, x = 0; x < b; ++x) if (c[x] !== d[x]) return c[x] < d[x] ? -1 : 1;
                return h === v ? 0 : h < v ? -1 : 1;
              }(Cs(n), Cs(r));
            case "Array":
              return function(c, d) {
                for (var h = c.length, v = d.length, b = h < v ? h : v, x = 0; x < b; ++x) {
                  var E = Ce(c[x], d[x]);
                  if (E !== 0) return E;
                }
                return h === v ? 0 : h < v ? -1 : 1;
              }(n, r);
          }
        } catch {
        }
        return NaN;
      }
      function Ss(n) {
        var r = typeof n;
        return r != "object" ? r : ArrayBuffer.isView(n) ? "binary" : (n = ln(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function Cs(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Yr(n, r, s) {
        var u = n.schema.yProps;
        return u ? (r && 0 < s.numFailures && (r = r.filter(function(c, d) {
          return !s.failures[d];
        })), Promise.all(u.map(function(c) {
          return c = c.updatesTable, r ? n.db.table(c).where("k").anyOf(r).delete() : n.db.table(c).clear();
        })).then(function() {
          return s;
        })) : s;
      }
      var Os = ($e.prototype._trans = function(n, r, s) {
        var u = this._tx || ie.trans, c = this.name, d = B && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function h(x, E, g) {
          if (!g.schema[c]) throw new se.NotFound("Table " + c + " not part of transaction");
          return r(g.idbtrans, g);
        }
        var v = Hn();
        try {
          var b = u && u.db._novip === this.db._novip ? u === ie.trans ? u._promise(n, h, s) : pn(function() {
            return u._promise(n, h, s);
          }, { trans: u, transless: ie.transless || ie }) : function x(E, g, A, _) {
            if (E.idbdb && (E._state.openComplete || ie.letThrough || E._vip)) {
              var C = E._createTransaction(g, A, E._dbSchema);
              try {
                C.create(), E._state.PR1398_maxLoop = 3;
              } catch (N) {
                return N.name === cn.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                  return x(E, g, A, _);
                })) : ze(N);
              }
              return C._promise(g, function(N, T) {
                return pn(function() {
                  return ie.trans = C, _(N, T, C);
                });
              }).then(function(N) {
                if (g === "readwrite") try {
                  C.idbtrans.commit();
                } catch {
                }
                return g === "readonly" ? N : C._completion.then(function() {
                  return N;
                });
              });
            }
            if (E._state.openComplete) return ze(new se.DatabaseClosed(E._state.dbOpenError));
            if (!E._state.isBeingOpened) {
              if (!E._state.autoOpen) return ze(new se.DatabaseClosed());
              E.open().catch(y);
            }
            return E._state.dbReadyPromise.then(function() {
              return x(E, g, A, _);
            });
          }(this.db, n, [this.name], h);
          return d && (b._consoleTask = d, b = b.catch(function(x) {
            return console.trace(x), ze(x);
          })), b;
        } finally {
          v && Wn();
        }
      }, $e.prototype.get = function(n, r) {
        var s = this;
        return n && n.constructor === Object ? this.where(n).first(r) : n == null ? ze(new se.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(u) {
          return s.core.get({ trans: u, key: n }).then(function(c) {
            return s.hook.reading.fire(c);
          });
        }).then(r);
      }, $e.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (p(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var r = f(n);
        if (r.length === 1) return this.where(r[0]).equals(n[r[0]]);
        var s = this.schema.indexes.concat(this.schema.primKey).filter(function(v) {
          if (v.compound && r.every(function(x) {
            return 0 <= v.keyPath.indexOf(x);
          })) {
            for (var b = 0; b < r.length; ++b) if (r.indexOf(v.keyPath[b]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(v, b) {
          return v.keyPath.length - b.keyPath.length;
        })[0];
        if (s && this.db._maxKey !== An) {
          var d = s.keyPath.slice(0, r.length);
          return this.where(d).equals(d.map(function(b) {
            return n[b];
          }));
        }
        !s && B && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(r.join("+"), "]"));
        var u = this.schema.idxByName;
        function c(v, b) {
          return Ce(v, b) === 0;
        }
        var h = r.reduce(function(g, b) {
          var x = g[0], E = g[1], g = u[b], A = n[b];
          return [x || g, x || !g ? kn(E, g && g.multi ? function(_) {
            return _ = Le(_, b), p(_) && _.some(function(C) {
              return c(A, C);
            });
          } : function(_) {
            return c(A, Le(_, b));
          }) : E];
        }, [null, null]), d = h[0], h = h[1];
        return d ? this.where(d.name).equals(n[d.keyPath]).filter(h) : s ? this.filter(h) : this.where(r).equals("");
      }, $e.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, $e.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, $e.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, $e.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, $e.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, $e.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, $e.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, $e.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, p(n) ? "[".concat(n.join("+"), "]") : n));
      }, $e.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, $e.prototype.mapToClass = function(n) {
        var r, s = this.db, u = this.name;
        function c() {
          return r !== null && r.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof xs && (function(b, x) {
          if (typeof x != "function" && x !== null) throw new TypeError("Class extends value " + String(x) + " is not a constructor or null");
          function E() {
            this.constructor = b;
          }
          o(b, x), b.prototype = x === null ? Object.create(x) : (E.prototype = x.prototype, new E());
        }(c, r = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return s;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return u;
        }, n = c);
        for (var d = /* @__PURE__ */ new Set(), h = n.prototype; h; h = P(h)) Object.getOwnPropertyNames(h).forEach(function(b) {
          return d.add(b);
        });
        function v(b) {
          if (!b) return b;
          var x, E = Object.create(n.prototype);
          for (x in b) if (!d.has(x)) try {
            E[x] = b[x];
          } catch {
          }
          return E;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = v, this.hook("reading", v), n;
      }, $e.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          m(this, n);
        });
      }, $e.prototype.add = function(n, r) {
        var s = this, u = this.schema.primKey, c = u.auto, d = u.keyPath, h = n;
        return d && c && (h = Gr(d)(n)), this._trans("readwrite", function(v) {
          return s.core.mutate({ trans: v, type: "add", keys: r != null ? [r] : null, values: [h] });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (d) try {
            Re(n, d, v);
          } catch {
          }
          return v;
        });
      }, $e.prototype.update = function(n, r) {
        return typeof n != "object" || p(n) ? this.where(":id").equals(n).modify(r) : (n = Le(n, this.schema.primKey.keyPath), n === void 0 ? ze(new se.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(r));
      }, $e.prototype.put = function(n, r) {
        var s = this, u = this.schema.primKey, c = u.auto, d = u.keyPath, h = n;
        return d && c && (h = Gr(d)(n)), this._trans("readwrite", function(v) {
          return s.core.mutate({ trans: v, type: "put", values: [h], keys: r != null ? [r] : null });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (d) try {
            Re(n, d, v);
          } catch {
          }
          return v;
        });
      }, $e.prototype.delete = function(n) {
        var r = this;
        return this._trans("readwrite", function(s) {
          return r.core.mutate({ trans: s, type: "delete", keys: [n] }).then(function(u) {
            return Yr(r, [n], u);
          }).then(function(u) {
            return u.numFailures ? ne.reject(u.failures[0]) : void 0;
          });
        });
      }, $e.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(r) {
          return n.core.mutate({ trans: r, type: "deleteRange", range: ws }).then(function(s) {
            return Yr(n, null, s);
          });
        }).then(function(r) {
          return r.numFailures ? ne.reject(r.failures[0]) : void 0;
        });
      }, $e.prototype.bulkGet = function(n) {
        var r = this;
        return this._trans("readonly", function(s) {
          return r.core.getMany({ keys: n, trans: s }).then(function(u) {
            return u.map(function(c) {
              return r.hook.reading.fire(c);
            });
          });
        });
      }, $e.prototype.bulkAdd = function(n, r, s) {
        var u = this, c = Array.isArray(r) ? r : void 0, d = (s = s || (c ? void 0 : r)) ? s.allKeys : void 0;
        return this._trans("readwrite", function(h) {
          var x = u.schema.primKey, v = x.auto, x = x.keyPath;
          if (x && c) throw new se.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new se.InvalidArgument("Arguments objects and keys must have the same length");
          var b = n.length, x = x && v ? n.map(Gr(x)) : n;
          return u.core.mutate({ trans: h, type: "add", keys: c, values: x, wantResults: d }).then(function(C) {
            var g = C.numFailures, A = C.results, _ = C.lastResult, C = C.failures;
            if (g === 0) return d ? A : _;
            throw new Nt("".concat(u.name, ".bulkAdd(): ").concat(g, " of ").concat(b, " operations failed"), C);
          });
        });
      }, $e.prototype.bulkPut = function(n, r, s) {
        var u = this, c = Array.isArray(r) ? r : void 0, d = (s = s || (c ? void 0 : r)) ? s.allKeys : void 0;
        return this._trans("readwrite", function(h) {
          var x = u.schema.primKey, v = x.auto, x = x.keyPath;
          if (x && c) throw new se.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new se.InvalidArgument("Arguments objects and keys must have the same length");
          var b = n.length, x = x && v ? n.map(Gr(x)) : n;
          return u.core.mutate({ trans: h, type: "put", keys: c, values: x, wantResults: d }).then(function(C) {
            var g = C.numFailures, A = C.results, _ = C.lastResult, C = C.failures;
            if (g === 0) return d ? A : _;
            throw new Nt("".concat(u.name, ".bulkPut(): ").concat(g, " of ").concat(b, " operations failed"), C);
          });
        });
      }, $e.prototype.bulkUpdate = function(n) {
        var r = this, s = this.core, u = n.map(function(h) {
          return h.key;
        }), c = n.map(function(h) {
          return h.changes;
        }), d = [];
        return this._trans("readwrite", function(h) {
          return s.getMany({ trans: h, keys: u, cache: "clone" }).then(function(v) {
            var b = [], x = [];
            n.forEach(function(g, A) {
              var _ = g.key, C = g.changes, N = v[A];
              if (N) {
                for (var T = 0, k = Object.keys(C); T < k.length; T++) {
                  var D = k[T], j = C[D];
                  if (D === r.schema.primKey.keyPath) {
                    if (Ce(j, _) !== 0) throw new se.Constraint("Cannot update primary key in bulkUpdate()");
                  } else Re(N, D, j);
                }
                d.push(A), b.push(_), x.push(N);
              }
            });
            var E = b.length;
            return s.mutate({ trans: h, type: "put", keys: b, values: x, updates: { keys: u, changeSpecs: c } }).then(function(g) {
              var A = g.numFailures, _ = g.failures;
              if (A === 0) return E;
              for (var C = 0, N = Object.keys(_); C < N.length; C++) {
                var T, k = N[C], D = d[Number(k)];
                D != null && (T = _[k], delete _[k], _[D] = T);
              }
              throw new Nt("".concat(r.name, ".bulkUpdate(): ").concat(A, " of ").concat(E, " operations failed"), _);
            });
          });
        });
      }, $e.prototype.bulkDelete = function(n) {
        var r = this, s = n.length;
        return this._trans("readwrite", function(u) {
          return r.core.mutate({ trans: u, type: "delete", keys: n }).then(function(c) {
            return Yr(r, n, c);
          });
        }).then(function(h) {
          var c = h.numFailures, d = h.lastResult, h = h.failures;
          if (c === 0) return d;
          throw new Nt("".concat(r.name, ".bulkDelete(): ").concat(c, " of ").concat(s, " operations failed"), h);
        });
      }, $e);
      function $e() {
      }
      function fr(n) {
        function r(h, v) {
          if (v) {
            for (var b = arguments.length, x = new Array(b - 1); --b; ) x[b - 1] = arguments[b];
            return s[h].subscribe.apply(null, x), n;
          }
          if (typeof h == "string") return s[h];
        }
        var s = {};
        r.addEventType = d;
        for (var u = 1, c = arguments.length; u < c; ++u) d(arguments[u]);
        return r;
        function d(h, v, b) {
          if (typeof h != "object") {
            var x;
            v = v || J;
            var E = { subscribers: [], fire: b = b || y, subscribe: function(g) {
              E.subscribers.indexOf(g) === -1 && (E.subscribers.push(g), E.fire = v(E.fire, g));
            }, unsubscribe: function(g) {
              E.subscribers = E.subscribers.filter(function(A) {
                return A !== g;
              }), E.fire = E.subscribers.reduce(v, b);
            } };
            return s[h] = r[h] = E;
          }
          f(x = h).forEach(function(g) {
            var A = x[g];
            if (p(A)) d(g, x[g][0], x[g][1]);
            else {
              if (A !== "asap") throw new se.InvalidArgument("Invalid event config");
              var _ = d(g, w, function() {
                for (var C = arguments.length, N = new Array(C); C--; ) N[C] = arguments[C];
                _.subscribers.forEach(function(T) {
                  be(function() {
                    T.apply(null, N);
                  });
                });
              });
            }
          });
        }
      }
      function dr(n, r) {
        return $(r).from({ prototype: n }), r;
      }
      function Yn(n, r) {
        return !(n.filter || n.algorithm || n.or) && (r ? n.justLimit : !n.replayFilter);
      }
      function Xo(n, r) {
        n.filter = kn(n.filter, r);
      }
      function Zo(n, r, s) {
        var u = n.replayFilter;
        n.replayFilter = u ? function() {
          return kn(u(), r());
        } : r, n.justLimit = s && !u;
      }
      function Qr(n, r) {
        if (n.isPrimKey) return r.primaryKey;
        var s = r.getIndexByKeyPath(n.index);
        if (!s) throw new se.Schema("KeyPath " + n.index + " on object store " + r.name + " is not indexed");
        return s;
      }
      function Es(n, r, s) {
        var u = Qr(n, r.schema);
        return r.openCursor({ trans: s, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: u, range: n.range } });
      }
      function Jr(n, r, s, u) {
        var c = n.replayFilter ? kn(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var d = {}, h = function(v, b, x) {
            var E, g;
            c && !c(b, x, function(A) {
              return b.stop(A);
            }, function(A) {
              return b.fail(A);
            }) || ((g = "" + (E = b.primaryKey)) == "[object ArrayBuffer]" && (g = "" + new Uint8Array(E)), R(d, g) || (d[g] = !0, r(v, b, x)));
          };
          return Promise.all([n.or._iterate(h, s), Ps(Es(n, u, s), n.algorithm, h, !n.keysOnly && n.valueMapper)]);
        }
        return Ps(Es(n, u, s), kn(n.algorithm, c), r, !n.keysOnly && n.valueMapper);
      }
      function Ps(n, r, s, u) {
        var c = Ve(u ? function(d, h, v) {
          return s(u(d), h, v);
        } : s);
        return n.then(function(d) {
          if (d) return d.start(function() {
            var h = function() {
              return d.continue();
            };
            r && !r(d, function(v) {
              return h = v;
            }, function(v) {
              d.stop(v), h = y;
            }, function(v) {
              d.fail(v), h = y;
            }) || c(d.value, d, function(v) {
              return h = v;
            }), h();
          });
        });
      }
      var pr = (Ts.prototype.execute = function(n) {
        var r = this["@@propmod"];
        if (r.add !== void 0) {
          var s = r.add;
          if (p(s)) return a(a([], p(n) ? n : [], !0), s).sort();
          if (typeof s == "number") return (Number(n) || 0) + s;
          if (typeof s == "bigint") try {
            return BigInt(n) + s;
          } catch {
            return BigInt(0) + s;
          }
          throw new TypeError("Invalid term ".concat(s));
        }
        if (r.remove !== void 0) {
          var u = r.remove;
          if (p(u)) return p(n) ? n.filter(function(c) {
            return !u.includes(c);
          }).sort() : [];
          if (typeof u == "number") return Number(n) - u;
          if (typeof u == "bigint") try {
            return BigInt(n) - u;
          } catch {
            return BigInt(0) - u;
          }
          throw new TypeError("Invalid subtrahend ".concat(u));
        }
        return s = (s = r.replacePrefix) === null || s === void 0 ? void 0 : s[0], s && typeof n == "string" && n.startsWith(s) ? r.replacePrefix[1] + n.substring(s.length) : n;
      }, Ts);
      function Ts(n) {
        this["@@propmod"] = n;
      }
      var Zu = (De.prototype._read = function(n, r) {
        var s = this._ctx;
        return s.error ? s.table._trans(null, ze.bind(null, s.error)) : s.table._trans("readonly", n).then(r);
      }, De.prototype._write = function(n) {
        var r = this._ctx;
        return r.error ? r.table._trans(null, ze.bind(null, r.error)) : r.table._trans("readwrite", n, "locked");
      }, De.prototype._addAlgorithm = function(n) {
        var r = this._ctx;
        r.algorithm = kn(r.algorithm, n);
      }, De.prototype._iterate = function(n, r) {
        return Jr(this._ctx, n, r, this._ctx.table.core);
      }, De.prototype.clone = function(n) {
        var r = Object.create(this.constructor.prototype), s = Object.create(this._ctx);
        return n && m(s, n), r._ctx = s, r;
      }, De.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, De.prototype.each = function(n) {
        var r = this._ctx;
        return this._read(function(s) {
          return Jr(r, n, s, r.table.core);
        });
      }, De.prototype.count = function(n) {
        var r = this;
        return this._read(function(s) {
          var u = r._ctx, c = u.table.core;
          if (Yn(u, !0)) return c.count({ trans: s, query: { index: Qr(u, c.schema), range: u.range } }).then(function(h) {
            return Math.min(h, u.limit);
          });
          var d = 0;
          return Jr(u, function() {
            return ++d, !1;
          }, s, c).then(function() {
            return d;
          });
        }).then(n);
      }, De.prototype.sortBy = function(n, r) {
        var s = n.split(".").reverse(), u = s[0], c = s.length - 1;
        function d(b, x) {
          return x ? d(b[s[x]], x - 1) : b[u];
        }
        var h = this._ctx.dir === "next" ? 1 : -1;
        function v(b, x) {
          return Ce(d(b, c), d(x, c)) * h;
        }
        return this.toArray(function(b) {
          return b.sort(v);
        }).then(r);
      }, De.prototype.toArray = function(n) {
        var r = this;
        return this._read(function(s) {
          var u = r._ctx;
          if (u.dir === "next" && Yn(u, !0) && 0 < u.limit) {
            var c = u.valueMapper, d = Qr(u, u.table.core.schema);
            return u.table.core.query({ trans: s, limit: u.limit, values: !0, query: { index: d, range: u.range } }).then(function(v) {
              return v = v.result, c ? v.map(c) : v;
            });
          }
          var h = [];
          return Jr(u, function(v) {
            return h.push(v);
          }, s, u.table.core).then(function() {
            return h;
          });
        }, n);
      }, De.prototype.offset = function(n) {
        var r = this._ctx;
        return n <= 0 || (r.offset += n, Yn(r) ? Zo(r, function() {
          var s = n;
          return function(u, c) {
            return s === 0 || (s === 1 ? --s : c(function() {
              u.advance(s), s = 0;
            }), !1);
          };
        }) : Zo(r, function() {
          var s = n;
          return function() {
            return --s < 0;
          };
        })), this;
      }, De.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), Zo(this._ctx, function() {
          var r = n;
          return function(s, u, c) {
            return --r <= 0 && u(c), 0 <= r;
          };
        }, !0), this;
      }, De.prototype.until = function(n, r) {
        return Xo(this._ctx, function(s, u, c) {
          return !n(s.value) || (u(c), r);
        }), this;
      }, De.prototype.first = function(n) {
        return this.limit(1).toArray(function(r) {
          return r[0];
        }).then(n);
      }, De.prototype.last = function(n) {
        return this.reverse().first(n);
      }, De.prototype.filter = function(n) {
        var r;
        return Xo(this._ctx, function(s) {
          return n(s.value);
        }), (r = this._ctx).isMatch = kn(r.isMatch, n), this;
      }, De.prototype.and = function(n) {
        return this.filter(n);
      }, De.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, De.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, De.prototype.desc = function() {
        return this.reverse();
      }, De.prototype.eachKey = function(n) {
        var r = this._ctx;
        return r.keysOnly = !r.isMatch, this.each(function(s, u) {
          n(u.key, u);
        });
      }, De.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, De.prototype.eachPrimaryKey = function(n) {
        var r = this._ctx;
        return r.keysOnly = !r.isMatch, this.each(function(s, u) {
          n(u.primaryKey, u);
        });
      }, De.prototype.keys = function(n) {
        var r = this._ctx;
        r.keysOnly = !r.isMatch;
        var s = [];
        return this.each(function(u, c) {
          s.push(c.key);
        }).then(function() {
          return s;
        }).then(n);
      }, De.prototype.primaryKeys = function(n) {
        var r = this._ctx;
        if (r.dir === "next" && Yn(r, !0) && 0 < r.limit) return this._read(function(u) {
          var c = Qr(r, r.table.core.schema);
          return r.table.core.query({ trans: u, values: !1, limit: r.limit, query: { index: c, range: r.range } });
        }).then(function(u) {
          return u.result;
        }).then(n);
        r.keysOnly = !r.isMatch;
        var s = [];
        return this.each(function(u, c) {
          s.push(c.primaryKey);
        }).then(function() {
          return s;
        }).then(n);
      }, De.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, De.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(r) {
          return r[0];
        }).then(n);
      }, De.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, De.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var r = {};
        return Xo(this._ctx, function(c) {
          var u = c.primaryKey.toString(), c = R(r, u);
          return r[u] = !0, !c;
        }), this;
      }, De.prototype.modify = function(n) {
        var r = this, s = this._ctx;
        return this._write(function(u) {
          var c, d, h;
          h = typeof n == "function" ? n : (c = f(n), d = c.length, function(k) {
            for (var D = !1, j = 0; j < d; ++j) {
              var L = c[j], H = n[L], Q = Le(k, L);
              H instanceof pr ? (Re(k, L, H.execute(Q)), D = !0) : Q !== H && (Re(k, L, H), D = !0);
            }
            return D;
          });
          var v = s.table.core, g = v.schema.primaryKey, b = g.outbound, x = g.extractKey, E = 200, g = r.db._options.modifyChunkSize;
          g && (E = typeof g == "object" ? g[v.name] || g["*"] || 200 : g);
          function A(k, L) {
            var j = L.failures, L = L.numFailures;
            C += k - L;
            for (var H = 0, Q = f(j); H < Q.length; H++) {
              var W = Q[H];
              _.push(j[W]);
            }
          }
          var _ = [], C = 0, N = [], T = n === Ns;
          return r.clone().primaryKeys().then(function(k) {
            function D(L) {
              var H = Math.min(E, k.length - L), Q = k.slice(L, L + H);
              return (T ? Promise.resolve([]) : v.getMany({ trans: u, keys: Q, cache: "immutable" })).then(function(W) {
                var z = [], te = [], Z = b ? [] : null, re = T ? Q : [];
                if (!T) for (var ve = 0; ve < H; ++ve) {
                  var Ne = W[ve], he = { value: ut(Ne), primKey: k[L + ve] };
                  h.call(he, he.value, he) !== !1 && (he.value == null ? re.push(k[L + ve]) : b || Ce(x(Ne), x(he.value)) === 0 ? (te.push(he.value), b && Z.push(k[L + ve])) : (re.push(k[L + ve]), z.push(he.value)));
                }
                return Promise.resolve(0 < z.length && v.mutate({ trans: u, type: "add", values: z }).then(function(We) {
                  for (var pe in We.failures) re.splice(parseInt(pe), 1);
                  A(z.length, We);
                })).then(function() {
                  return (0 < te.length || j && typeof n == "object") && v.mutate({ trans: u, type: "put", keys: Z, values: te, criteria: j, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < L }).then(function(We) {
                    return A(te.length, We);
                  });
                }).then(function() {
                  return (0 < re.length || j && T) && v.mutate({ trans: u, type: "delete", keys: re, criteria: j, isAdditionalChunk: 0 < L }).then(function(We) {
                    return Yr(s.table, re, We);
                  }).then(function(We) {
                    return A(re.length, We);
                  });
                }).then(function() {
                  return k.length > L + H && D(L + E);
                });
              });
            }
            var j = Yn(s) && s.limit === 1 / 0 && (typeof n != "function" || T) && { index: s.index, range: s.range };
            return D(0).then(function() {
              if (0 < _.length) throw new Vn("Error modifying one or more objects", _, C, N);
              return k.length;
            });
          });
        });
      }, De.prototype.delete = function() {
        var n = this._ctx, r = n.range;
        return !Yn(n) || n.table.schema.yProps || !n.isPrimKey && r.type !== 3 ? this.modify(Ns) : this._write(function(s) {
          var u = n.table.core.schema.primaryKey, c = r;
          return n.table.core.count({ trans: s, query: { index: u, range: c } }).then(function(d) {
            return n.table.core.mutate({ trans: s, type: "deleteRange", range: c }).then(function(b) {
              var v = b.failures, b = b.numFailures;
              if (b) throw new Vn("Could not delete some values", Object.keys(v).map(function(x) {
                return v[x];
              }), d - b);
              return d - b;
            });
          });
        });
      }, De);
      function De() {
      }
      var Ns = function(n, r) {
        return r.value = null;
      };
      function el(n, r) {
        return n < r ? -1 : n === r ? 0 : 1;
      }
      function tl(n, r) {
        return r < n ? -1 : n === r ? 0 : 1;
      }
      function Ot(n, r, s) {
        return n = n instanceof ks ? new n.Collection(n) : n, n._ctx.error = new (s || TypeError)(r), n;
      }
      function Qn(n) {
        return new n.Collection(n, function() {
          return As("");
        }).limit(0);
      }
      function Xr(n, r, s, u) {
        var c, d, h, v, b, x, E, g = s.length;
        if (!s.every(function(C) {
          return typeof C == "string";
        })) return Ot(n, _s);
        function A(C) {
          c = C === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, d = C === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, h = C === "next" ? el : tl;
          var N = s.map(function(T) {
            return { lower: d(T), upper: c(T) };
          }).sort(function(T, k) {
            return h(T.lower, k.lower);
          });
          v = N.map(function(T) {
            return T.upper;
          }), b = N.map(function(T) {
            return T.lower;
          }), E = (x = C) === "next" ? "" : u;
        }
        A("next"), n = new n.Collection(n, function() {
          return yn(v[0], b[g - 1] + u);
        }), n._ondirectionchange = function(C) {
          A(C);
        };
        var _ = 0;
        return n._addAlgorithm(function(C, N, T) {
          var k = C.key;
          if (typeof k != "string") return !1;
          var D = d(k);
          if (r(D, b, _)) return !0;
          for (var j = null, L = _; L < g; ++L) {
            var H = function(Q, W, z, te, Z, re) {
              for (var ve = Math.min(Q.length, te.length), Ne = -1, he = 0; he < ve; ++he) {
                var We = W[he];
                if (We !== te[he]) return Z(Q[he], z[he]) < 0 ? Q.substr(0, he) + z[he] + z.substr(he + 1) : Z(Q[he], te[he]) < 0 ? Q.substr(0, he) + te[he] + z.substr(he + 1) : 0 <= Ne ? Q.substr(0, Ne) + W[Ne] + z.substr(Ne + 1) : null;
                Z(Q[he], We) < 0 && (Ne = he);
              }
              return ve < te.length && re === "next" ? Q + z.substr(Q.length) : ve < Q.length && re === "prev" ? Q.substr(0, z.length) : Ne < 0 ? null : Q.substr(0, Ne) + te[Ne] + z.substr(Ne + 1);
            }(k, D, v[L], b[L], h, x);
            H === null && j === null ? _ = L + 1 : (j === null || 0 < h(j, H)) && (j = H);
          }
          return N(j !== null ? function() {
            C.continue(j + E);
          } : T), !1;
        }), n;
      }
      function yn(n, r, s, u) {
        return { type: 2, lower: n, upper: r, lowerOpen: s, upperOpen: u };
      }
      function As(n) {
        return { type: 1, lower: n, upper: n };
      }
      var ks = (Object.defineProperty(rt.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), rt.prototype.between = function(n, r, s, u) {
        s = s !== !1, u = u === !0;
        try {
          return 0 < this._cmp(n, r) || this._cmp(n, r) === 0 && (s || u) && (!s || !u) ? Qn(this) : new this.Collection(this, function() {
            return yn(n, r, !s, !u);
          });
        } catch {
          return Ot(this, zt);
        }
      }, rt.prototype.equals = function(n) {
        return n == null ? Ot(this, zt) : new this.Collection(this, function() {
          return As(n);
        });
      }, rt.prototype.above = function(n) {
        return n == null ? Ot(this, zt) : new this.Collection(this, function() {
          return yn(n, void 0, !0);
        });
      }, rt.prototype.aboveOrEqual = function(n) {
        return n == null ? Ot(this, zt) : new this.Collection(this, function() {
          return yn(n, void 0, !1);
        });
      }, rt.prototype.below = function(n) {
        return n == null ? Ot(this, zt) : new this.Collection(this, function() {
          return yn(void 0, n, !1, !0);
        });
      }, rt.prototype.belowOrEqual = function(n) {
        return n == null ? Ot(this, zt) : new this.Collection(this, function() {
          return yn(void 0, n);
        });
      }, rt.prototype.startsWith = function(n) {
        return typeof n != "string" ? Ot(this, _s) : this.between(n, n + An, !0, !0);
      }, rt.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : Xr(this, function(r, s) {
          return r.indexOf(s[0]) === 0;
        }, [n], An);
      }, rt.prototype.equalsIgnoreCase = function(n) {
        return Xr(this, function(r, s) {
          return r === s[0];
        }, [n], "");
      }, rt.prototype.anyOfIgnoreCase = function() {
        var n = St.apply(xt, arguments);
        return n.length === 0 ? Qn(this) : Xr(this, function(r, s) {
          return s.indexOf(r) !== -1;
        }, n, "");
      }, rt.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = St.apply(xt, arguments);
        return n.length === 0 ? Qn(this) : Xr(this, function(r, s) {
          return s.some(function(u) {
            return r.indexOf(u) === 0;
          });
        }, n, An);
      }, rt.prototype.anyOf = function() {
        var n = this, r = St.apply(xt, arguments), s = this._cmp;
        try {
          r.sort(s);
        } catch {
          return Ot(this, zt);
        }
        if (r.length === 0) return Qn(this);
        var u = new this.Collection(this, function() {
          return yn(r[0], r[r.length - 1]);
        });
        u._ondirectionchange = function(d) {
          s = d === "next" ? n._ascending : n._descending, r.sort(s);
        };
        var c = 0;
        return u._addAlgorithm(function(d, h, v) {
          for (var b = d.key; 0 < s(b, r[c]); ) if (++c === r.length) return h(v), !1;
          return s(b, r[c]) === 0 || (h(function() {
            d.continue(r[c]);
          }), !1);
        }), u;
      }, rt.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, rt.prototype.noneOf = function() {
        var n = St.apply(xt, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return Ot(this, zt);
        }
        var r = n.reduce(function(s, u) {
          return s ? s.concat([[s[s.length - 1][1], u]]) : [[-1 / 0, u]];
        }, null);
        return r.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 });
      }, rt.prototype.inAnyRange = function(k, r) {
        var s = this, u = this._cmp, c = this._ascending, d = this._descending, h = this._min, v = this._max;
        if (k.length === 0) return Qn(this);
        if (!k.every(function(D) {
          return D[0] !== void 0 && D[1] !== void 0 && c(D[0], D[1]) <= 0;
        })) return Ot(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", se.InvalidArgument);
        var b = !r || r.includeLowers !== !1, x = r && r.includeUppers === !0, E, g = c;
        function A(D, j) {
          return g(D[0], j[0]);
        }
        try {
          (E = k.reduce(function(D, j) {
            for (var L = 0, H = D.length; L < H; ++L) {
              var Q = D[L];
              if (u(j[0], Q[1]) < 0 && 0 < u(j[1], Q[0])) {
                Q[0] = h(Q[0], j[0]), Q[1] = v(Q[1], j[1]);
                break;
              }
            }
            return L === H && D.push(j), D;
          }, [])).sort(A);
        } catch {
          return Ot(this, zt);
        }
        var _ = 0, C = x ? function(D) {
          return 0 < c(D, E[_][1]);
        } : function(D) {
          return 0 <= c(D, E[_][1]);
        }, N = b ? function(D) {
          return 0 < d(D, E[_][0]);
        } : function(D) {
          return 0 <= d(D, E[_][0]);
        }, T = C, k = new this.Collection(this, function() {
          return yn(E[0][0], E[E.length - 1][1], !b, !x);
        });
        return k._ondirectionchange = function(D) {
          g = D === "next" ? (T = C, c) : (T = N, d), E.sort(A);
        }, k._addAlgorithm(function(D, j, L) {
          for (var H, Q = D.key; T(Q); ) if (++_ === E.length) return j(L), !1;
          return !C(H = Q) && !N(H) || (s._cmp(Q, E[_][1]) === 0 || s._cmp(Q, E[_][0]) === 0 || j(function() {
            g === c ? D.continue(E[_][0]) : D.continue(E[_][1]);
          }), !1);
        }), k;
      }, rt.prototype.startsWithAnyOf = function() {
        var n = St.apply(xt, arguments);
        return n.every(function(r) {
          return typeof r == "string";
        }) ? n.length === 0 ? Qn(this) : this.inAnyRange(n.map(function(r) {
          return [r, r + An];
        })) : Ot(this, "startsWithAnyOf() only works with strings");
      }, rt);
      function rt() {
      }
      function Ft(n) {
        return Ve(function(r) {
          return hr(r), n(r.target.error), !1;
        });
      }
      function hr(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var mr = "storagemutated", ei = "x-storagemutated-1", vn = fr(null, mr), nl = ($t.prototype._lock = function() {
        return ue(!ie.global), ++this._reculock, this._reculock !== 1 || ie.global || (ie.lockOwnerFor = this), this;
      }, $t.prototype._unlock = function() {
        if (ue(!ie.global), --this._reculock == 0) for (ie.global || (ie.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Nn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, $t.prototype._locked = function() {
        return this._reculock && ie.lockOwnerFor !== this;
      }, $t.prototype.create = function(n) {
        var r = this;
        if (!this.mode) return this;
        var s = this.db.idbdb, u = this.db._state.dbOpenError;
        if (ue(!this.idbtrans), !n && !s) switch (u && u.name) {
          case "DatabaseClosedError":
            throw new se.DatabaseClosed(u);
          case "MissingAPIError":
            throw new se.MissingAPI(u.message, u);
          default:
            throw new se.OpenFailed(u);
        }
        if (!this.active) throw new se.TransactionInactive();
        return ue(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || s).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ve(function(c) {
          hr(c), r._reject(n.error);
        }), n.onabort = Ve(function(c) {
          hr(c), r.active && r._reject(new se.Abort(n.error)), r.active = !1, r.on("abort").fire(c);
        }), n.oncomplete = Ve(function() {
          r.active = !1, r._resolve(), "mutatedParts" in n && vn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, $t.prototype._promise = function(n, r, s) {
        var u = this;
        if (n === "readwrite" && this.mode !== "readwrite") return ze(new se.ReadOnly("Transaction is readonly"));
        if (!this.active) return ze(new se.TransactionInactive());
        if (this._locked()) return new ne(function(d, h) {
          u._blockedFuncs.push([function() {
            u._promise(n, r, s).then(d, h);
          }, ie]);
        });
        if (s) return pn(function() {
          var d = new ne(function(h, v) {
            u._lock();
            var b = r(h, v, u);
            b && b.then && b.then(h, v);
          });
          return d.finally(function() {
            return u._unlock();
          }), d._lib = !0, d;
        });
        var c = new ne(function(d, h) {
          var v = r(d, h, u);
          v && v.then && v.then(d, h);
        });
        return c._lib = !0, c;
      }, $t.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, $t.prototype.waitFor = function(n) {
        var r, s = this._root(), u = ne.resolve(n);
        s._waitingFor ? s._waitingFor = s._waitingFor.then(function() {
          return u;
        }) : (s._waitingFor = u, s._waitingQueue = [], r = s.idbtrans.objectStore(s.storeNames[0]), function d() {
          for (++s._spinCount; s._waitingQueue.length; ) s._waitingQueue.shift()();
          s._waitingFor && (r.get(-1 / 0).onsuccess = d);
        }());
        var c = s._waitingFor;
        return new ne(function(d, h) {
          u.then(function(v) {
            return s._waitingQueue.push(Ve(d.bind(null, v)));
          }, function(v) {
            return s._waitingQueue.push(Ve(h.bind(null, v)));
          }).finally(function() {
            s._waitingFor === c && (s._waitingFor = null);
          });
        });
      }, $t.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new se.Abort()));
      }, $t.prototype.table = function(n) {
        var r = this._memoizedTables || (this._memoizedTables = {});
        if (R(r, n)) return r[n];
        var s = this.schema[n];
        if (!s) throw new se.NotFound("Table " + n + " not part of transaction");
        return s = new this.db.Table(n, s, this), s.core = this.db.core.table(n), r[n] = s;
      }, $t);
      function $t() {
      }
      function ti(n, r, s, u, c, d, h, v) {
        return { name: n, keyPath: r, unique: s, multi: u, auto: c, compound: d, src: (s && !h ? "&" : "") + (u ? "*" : "") + (c ? "++" : "") + Rs(r), type: v };
      }
      function Rs(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function ni(n, r, s) {
        return { name: n, primKey: r, indexes: s, mappedClass: null, idxByName: (u = function(c) {
          return [c.name, c];
        }, s.reduce(function(c, d, h) {
          return h = u(d, h), h && (c[h[0]] = h[1]), c;
        }, {})) };
        var u;
      }
      var yr = function(n) {
        try {
          return n.only([[]]), yr = function() {
            return [[]];
          }, [[]];
        } catch {
          return yr = function() {
            return An;
          }, An;
        }
      };
      function ri(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (r = n).split(".").length === 1 ? function(s) {
          return s[r];
        } : function(s) {
          return Le(s, r);
        } : function(s) {
          return Le(s, n);
        };
        var r;
      }
      function Ds(n) {
        return [].slice.call(n);
      }
      var rl = 0;
      function vr(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function ol(n, r, b) {
        function u(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var _ = T.lower, C = T.upper, N = T.lowerOpen, T = T.upperOpen;
          return _ === void 0 ? C === void 0 ? null : r.upperBound(C, !!T) : C === void 0 ? r.lowerBound(_, !!N) : r.bound(_, C, !!N, !!T);
        }
        function c(A) {
          var _, C = A.name;
          return { name: C, schema: A, mutate: function(N) {
            var T = N.trans, k = N.type, D = N.keys, j = N.values, L = N.range;
            return new Promise(function(H, Q) {
              H = Ve(H);
              var W = T.objectStore(C), z = W.keyPath == null, te = k === "put" || k === "add";
              if (!te && k !== "delete" && k !== "deleteRange") throw new Error("Invalid operation type: " + k);
              var Z, re = (D || j || { length: 1 }).length;
              if (D && j && D.length !== j.length) throw new Error("Given keys array must have same length as given values array.");
              if (re === 0) return H({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(gt) {
                ++We, hr(gt);
              }
              var Ne = [], he = [], We = 0;
              if (k === "deleteRange") {
                if (L.type === 4) return H({ numFailures: We, failures: he, results: [], lastResult: void 0 });
                L.type === 3 ? Ne.push(Z = W.clear()) : Ne.push(Z = W.delete(u(L)));
              } else {
                var z = te ? z ? [j, D] : [j, null] : [D, null], pe = z[0], ct = z[1];
                if (te) for (var ft = 0; ft < re; ++ft) Ne.push(Z = ct && ct[ft] !== void 0 ? W[k](pe[ft], ct[ft]) : W[k](pe[ft])), Z.onerror = ve;
                else for (ft = 0; ft < re; ++ft) Ne.push(Z = W[k](pe[ft])), Z.onerror = ve;
              }
              function co(gt) {
                gt = gt.target.result, Ne.forEach(function(In, wi) {
                  return In.error != null && (he[wi] = In.error);
                }), H({ numFailures: We, failures: he, results: k === "delete" ? D : Ne.map(function(In) {
                  return In.result;
                }), lastResult: gt });
              }
              Z.onerror = function(gt) {
                ve(gt), co(gt);
              }, Z.onsuccess = co;
            });
          }, getMany: function(N) {
            var T = N.trans, k = N.keys;
            return new Promise(function(D, j) {
              D = Ve(D);
              for (var L, H = T.objectStore(C), Q = k.length, W = new Array(Q), z = 0, te = 0, Z = function(Ne) {
                Ne = Ne.target, W[Ne._pos] = Ne.result, ++te === z && D(W);
              }, re = Ft(j), ve = 0; ve < Q; ++ve) k[ve] != null && ((L = H.get(k[ve]))._pos = ve, L.onsuccess = Z, L.onerror = re, ++z);
              z === 0 && D(W);
            });
          }, get: function(N) {
            var T = N.trans, k = N.key;
            return new Promise(function(D, j) {
              D = Ve(D);
              var L = T.objectStore(C).get(k);
              L.onsuccess = function(H) {
                return D(H.target.result);
              }, L.onerror = Ft(j);
            });
          }, query: (_ = x, function(N) {
            return new Promise(function(T, k) {
              T = Ve(T);
              var D, j, L, z = N.trans, H = N.values, Q = N.limit, Z = N.query, W = Q === 1 / 0 ? void 0 : Q, te = Z.index, Z = Z.range, z = z.objectStore(C), te = te.isPrimaryKey ? z : z.index(te.name), Z = u(Z);
              if (Q === 0) return T({ result: [] });
              _ ? ((W = H ? te.getAll(Z, W) : te.getAllKeys(Z, W)).onsuccess = function(re) {
                return T({ result: re.target.result });
              }, W.onerror = Ft(k)) : (D = 0, j = !H && "openKeyCursor" in te ? te.openKeyCursor(Z) : te.openCursor(Z), L = [], j.onsuccess = function(re) {
                var ve = j.result;
                return ve ? (L.push(H ? ve.value : ve.primaryKey), ++D === Q ? T({ result: L }) : void ve.continue()) : T({ result: L });
              }, j.onerror = Ft(k));
            });
          }), openCursor: function(N) {
            var T = N.trans, k = N.values, D = N.query, j = N.reverse, L = N.unique;
            return new Promise(function(H, Q) {
              H = Ve(H);
              var te = D.index, W = D.range, z = T.objectStore(C), z = te.isPrimaryKey ? z : z.index(te.name), te = j ? L ? "prevunique" : "prev" : L ? "nextunique" : "next", Z = !k && "openKeyCursor" in z ? z.openKeyCursor(u(W), te) : z.openCursor(u(W), te);
              Z.onerror = Ft(Q), Z.onsuccess = Ve(function(re) {
                var ve, Ne, he, We, pe = Z.result;
                pe ? (pe.___id = ++rl, pe.done = !1, ve = pe.continue.bind(pe), Ne = (Ne = pe.continuePrimaryKey) && Ne.bind(pe), he = pe.advance.bind(pe), We = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = T, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Ve(Q), pe.next = function() {
                  var ct = this, ft = 1;
                  return this.start(function() {
                    return ft-- ? ct.continue() : ct.stop();
                  }).then(function() {
                    return ct;
                  });
                }, pe.start = function(ct) {
                  function ft() {
                    if (Z.result) try {
                      ct();
                    } catch (gt) {
                      pe.fail(gt);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var co = new Promise(function(gt, In) {
                    gt = Ve(gt), Z.onerror = Ft(In), pe.fail = In, pe.stop = function(wi) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = We, gt(wi);
                    };
                  });
                  return Z.onsuccess = Ve(function(gt) {
                    Z.onsuccess = ft, ft();
                  }), pe.continue = ve, pe.continuePrimaryKey = Ne, pe.advance = he, ft(), co;
                }, H(pe)) : H(null);
              }, Q);
            });
          }, count: function(N) {
            var T = N.query, k = N.trans, D = T.index, j = T.range;
            return new Promise(function(L, H) {
              var Q = k.objectStore(C), W = D.isPrimaryKey ? Q : Q.index(D.name), Q = u(j), W = Q ? W.count(Q) : W.count();
              W.onsuccess = Ve(function(z) {
                return L(z.target.result);
              }), W.onerror = Ft(H);
            });
          } };
        }
        var d, h, v, E = (h = b, v = Ds((d = n).objectStoreNames), { schema: { name: d.name, tables: v.map(function(A) {
          return h.objectStore(A);
        }).map(function(A) {
          var _ = A.keyPath, T = A.autoIncrement, C = p(_), N = {}, T = { name: A.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: _ == null, compound: C, keyPath: _, autoIncrement: T, unique: !0, extractKey: ri(_) }, indexes: Ds(A.indexNames).map(function(k) {
            return A.index(k);
          }).map(function(L) {
            var D = L.name, j = L.unique, H = L.multiEntry, L = L.keyPath, H = { name: D, compound: p(L), keyPath: L, unique: j, multiEntry: H, extractKey: ri(L) };
            return N[vr(L)] = H;
          }), getIndexByKeyPath: function(k) {
            return N[vr(k)];
          } };
          return N[":id"] = T.primaryKey, _ != null && (N[vr(_)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < v.length && "getAll" in h.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), b = E.schema, x = E.hasGetAll, E = b.tables.map(c), g = {};
        return E.forEach(function(A) {
          return g[A.name] = A;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(A) {
          if (!g[A]) throw new Error("Table '".concat(A, "' not found"));
          return g[A];
        }, MIN_KEY: -1 / 0, MAX_KEY: yr(r), schema: b };
      }
      function il(n, r, s, u) {
        var c = s.IDBKeyRange;
        return s.indexedDB, { dbcore: (u = ol(r, c, u), n.dbcore.reduce(function(d, h) {
          return h = h.create, i(i({}, d), h(d));
        }, u)) };
      }
      function Zr(n, u) {
        var s = u.db, u = il(n._middlewares, s, n._deps, u);
        n.core = u.dbcore, n.tables.forEach(function(c) {
          var d = c.name;
          n.core.schema.tables.some(function(h) {
            return h.name === d;
          }) && (c.core = n.core.table(d), n[d] instanceof n.Table && (n[d].core = c.core));
        });
      }
      function eo(n, r, s, u) {
        s.forEach(function(c) {
          var d = u[c];
          r.forEach(function(h) {
            var v = function b(x, E) {
              return O(x, E) || (x = P(x)) && b(x, E);
            }(h, c);
            (!v || "value" in v && v.value === void 0) && (h === n.Transaction.prototype || h instanceof n.Transaction ? oe(h, c, { get: function() {
              return this.table(c);
            }, set: function(b) {
              G(this, c, { value: b, writable: !0, configurable: !0, enumerable: !0 });
            } }) : h[c] = new n.Table(c, d));
          });
        });
      }
      function oi(n, r) {
        r.forEach(function(s) {
          for (var u in s) s[u] instanceof n.Table && delete s[u];
        });
      }
      function sl(n, r) {
        return n._cfg.version - r._cfg.version;
      }
      function al(n, r, s, u) {
        var c = n._dbSchema;
        s.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = ni("$meta", js("")[0], []), n._storeNames.push("$meta"));
        var d = n._createTransaction("readwrite", n._storeNames, c);
        d.create(s), d._completion.catch(u);
        var h = d._reject.bind(d), v = ie.transless || ie;
        pn(function() {
          return ie.trans = d, ie.transless = v, r !== 0 ? (Zr(n, s), x = r, ((b = d).storeNames.includes("$meta") ? b.table("$meta").get("version").then(function(E) {
            return E ?? x;
          }) : ne.resolve(x)).then(function(E) {
            return A = E, _ = d, C = s, N = [], E = (g = n)._versions, T = g._dbSchema = no(0, g.idbdb, C), (E = E.filter(function(k) {
              return k._cfg.version >= A;
            })).length !== 0 ? (E.forEach(function(k) {
              N.push(function() {
                var D = T, j = k._cfg.dbschema;
                ro(g, D, C), ro(g, j, C), T = g._dbSchema = j;
                var L = ii(D, j);
                L.add.forEach(function(te) {
                  si(C, te[0], te[1].primKey, te[1].indexes);
                }), L.change.forEach(function(te) {
                  if (te.recreate) throw new se.Upgrade("Not yet support for changing primary key");
                  var Z = C.objectStore(te.name);
                  te.add.forEach(function(re) {
                    return to(Z, re);
                  }), te.change.forEach(function(re) {
                    Z.deleteIndex(re.name), to(Z, re);
                  }), te.del.forEach(function(re) {
                    return Z.deleteIndex(re);
                  });
                });
                var H = k._cfg.contentUpgrade;
                if (H && k._cfg.version > A) {
                  Zr(g, C), _._memoizedTables = {};
                  var Q = we(j);
                  L.del.forEach(function(te) {
                    Q[te] = D[te];
                  }), oi(g, [g.Transaction.prototype]), eo(g, [g.Transaction.prototype], f(Q), Q), _.schema = Q;
                  var W, z = jt(H);
                  return z && zn(), L = ne.follow(function() {
                    var te;
                    (W = H(_)) && z && (te = hn.bind(null, null), W.then(te, te));
                  }), W && typeof W.then == "function" ? ne.resolve(W) : L.then(function() {
                    return W;
                  });
                }
              }), N.push(function(D) {
                var j, L, H = k._cfg.dbschema;
                j = H, L = D, [].slice.call(L.db.objectStoreNames).forEach(function(Q) {
                  return j[Q] == null && L.db.deleteObjectStore(Q);
                }), oi(g, [g.Transaction.prototype]), eo(g, [g.Transaction.prototype], g._storeNames, g._dbSchema), _.schema = g._dbSchema;
              }), N.push(function(D) {
                g.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(g.idbdb.version / 10) === k._cfg.version ? (g.idbdb.deleteObjectStore("$meta"), delete g._dbSchema.$meta, g._storeNames = g._storeNames.filter(function(j) {
                  return j !== "$meta";
                })) : D.objectStore("$meta").put(k._cfg.version, "version"));
              });
            }), function k() {
              return N.length ? ne.resolve(N.shift()(_.idbtrans)).then(k) : ne.resolve();
            }().then(function() {
              Is(T, C);
            })) : ne.resolve();
            var g, A, _, C, N, T;
          }).catch(h)) : (f(c).forEach(function(E) {
            si(s, E, c[E].primKey, c[E].indexes);
          }), Zr(n, s), void ne.follow(function() {
            return n.on.populate.fire(d);
          }).catch(h));
          var b, x;
        });
      }
      function ul(n, r) {
        Is(n._dbSchema, r), r.db.version % 10 != 0 || r.objectStoreNames.contains("$meta") || r.db.createObjectStore("$meta").add(Math.ceil(r.db.version / 10 - 1), "version");
        var s = no(0, n.idbdb, r);
        ro(n, n._dbSchema, r);
        for (var u = 0, c = ii(s, n._dbSchema).change; u < c.length; u++) {
          var d = function(h) {
            if (h.change.length || h.recreate) return console.warn("Unable to patch indexes of table ".concat(h.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var v = r.objectStore(h.name);
            h.add.forEach(function(b) {
              B && console.debug("Dexie upgrade patch: Creating missing index ".concat(h.name, ".").concat(b.src)), to(v, b);
            });
          }(c[u]);
          if (typeof d == "object") return d.value;
        }
      }
      function ii(n, r) {
        var s, u = { del: [], add: [], change: [] };
        for (s in n) r[s] || u.del.push(s);
        for (s in r) {
          var c = n[s], d = r[s];
          if (c) {
            var h = { name: s, def: d, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (d.primKey.keyPath || "") || c.primKey.auto !== d.primKey.auto) h.recreate = !0, u.change.push(h);
            else {
              var v = c.idxByName, b = d.idxByName, x = void 0;
              for (x in v) b[x] || h.del.push(x);
              for (x in b) {
                var E = v[x], g = b[x];
                E ? E.src !== g.src && h.change.push(g) : h.add.push(g);
              }
              (0 < h.del.length || 0 < h.add.length || 0 < h.change.length) && u.change.push(h);
            }
          } else u.add.push([s, d]);
        }
        return u;
      }
      function si(n, r, s, u) {
        var c = n.db.createObjectStore(r, s.keyPath ? { keyPath: s.keyPath, autoIncrement: s.auto } : { autoIncrement: s.auto });
        return u.forEach(function(d) {
          return to(c, d);
        }), c;
      }
      function Is(n, r) {
        f(n).forEach(function(s) {
          r.db.objectStoreNames.contains(s) || (B && console.debug("Dexie: Creating missing table", s), si(r, s, n[s].primKey, n[s].indexes));
        });
      }
      function to(n, r) {
        n.createIndex(r.name, r.keyPath, { unique: r.unique, multiEntry: r.multi });
      }
      function no(n, r, s) {
        var u = {};
        return de(r.objectStoreNames, 0).forEach(function(c) {
          for (var d = s.objectStore(c), h = ti(Rs(x = d.keyPath), x || "", !0, !1, !!d.autoIncrement, x && typeof x != "string", !0), v = [], b = 0; b < d.indexNames.length; ++b) {
            var E = d.index(d.indexNames[b]), x = E.keyPath, E = ti(E.name, x, !!E.unique, !!E.multiEntry, !1, x && typeof x != "string", !1);
            v.push(E);
          }
          u[c] = ni(c, h, v);
        }), u;
      }
      function ro(n, r, s) {
        for (var u = s.db.objectStoreNames, c = 0; c < u.length; ++c) {
          var d = u[c], h = s.objectStore(d);
          n._hasGetAll = "getAll" in h;
          for (var v = 0; v < h.indexNames.length; ++v) {
            var b = h.indexNames[v], x = h.index(b).keyPath, E = typeof x == "string" ? x : "[" + de(x).join("+") + "]";
            !r[d] || (x = r[d].idxByName[E]) && (x.name = b, delete r[d].idxByName[E], r[d].idxByName[b] = x);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && l.WorkerGlobalScope && l instanceof l.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function js(n) {
        return n.split(",").map(function(r, s) {
          var d = r.split(":"), u = (c = d[1]) === null || c === void 0 ? void 0 : c.trim(), c = (r = d[0].trim()).replace(/([&*]|\+\+)/g, ""), d = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return ti(c, d || null, /\&/.test(r), /\*/.test(r), /\+\+/.test(r), p(d), s === 0, u);
        });
      }
      var ll = (Jn.prototype._createTableSchema = ni, Jn.prototype._parseIndexSyntax = js, Jn.prototype._parseStoresSpec = function(n, r) {
        var s = this;
        f(n).forEach(function(u) {
          if (n[u] !== null) {
            var c = s._parseIndexSyntax(n[u]), d = c.shift();
            if (!d) throw new se.Schema("Invalid schema for table " + u + ": " + n[u]);
            if (d.unique = !0, d.multi) throw new se.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(h) {
              if (h.auto) throw new se.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!h.keyPath) throw new se.Schema("Index must have a name and cannot be an empty string");
            }), c = s._createTableSchema(u, d, c), r[u] = c;
          }
        });
      }, Jn.prototype.stores = function(s) {
        var r = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? m(this._cfg.storesSource, s) : s;
        var s = r._versions, u = {}, c = {};
        return s.forEach(function(d) {
          m(u, d._cfg.storesSource), c = d._cfg.dbschema = {}, d._parseStoresSpec(u, c);
        }), r._dbSchema = c, oi(r, [r._allTables, r, r.Transaction.prototype]), eo(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], f(c), c), r._storeNames = f(c), this;
      }, Jn.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Y(this._cfg.contentUpgrade || y, n), this;
      }, Jn);
      function Jn() {
      }
      function ai(n, r) {
        var s = n._dbNamesDB;
        return s || (s = n._dbNamesDB = new Gt(zr, { addons: [], indexedDB: n, IDBKeyRange: r })).version(1).stores({ dbnames: "name" }), s.table("dbnames");
      }
      function ui(n) {
        return n && typeof n.databases == "function";
      }
      function li(n) {
        return pn(function() {
          return ie.letThrough = !0, n();
        });
      }
      function ci(n) {
        return !("from" in n);
      }
      var lt = function(n, r) {
        if (!this) {
          var s = new lt();
          return n && "d" in n && m(s, n), s;
        }
        m(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? r : n } : { d: 0 });
      };
      function gr(n, r, s) {
        var u = Ce(r, s);
        if (!isNaN(u)) {
          if (0 < u) throw RangeError();
          if (ci(n)) return m(n, { from: r, to: s, d: 1 });
          var c = n.l, u = n.r;
          if (Ce(s, n.from) < 0) return c ? gr(c, r, s) : n.l = { from: r, to: s, d: 1, l: null, r: null }, Ks(n);
          if (0 < Ce(r, n.to)) return u ? gr(u, r, s) : n.r = { from: r, to: s, d: 1, l: null, r: null }, Ks(n);
          Ce(r, n.from) < 0 && (n.from = r, n.l = null, n.d = u ? u.d + 1 : 1), 0 < Ce(s, n.to) && (n.to = s, n.r = null, n.d = n.l ? n.l.d + 1 : 1), s = !n.r, c && !n.l && br(n, c), u && s && br(n, u);
        }
      }
      function br(n, r) {
        ci(r) || function s(u, b) {
          var d = b.from, h = b.to, v = b.l, b = b.r;
          gr(u, d, h), v && s(u, v), b && s(u, b);
        }(n, r);
      }
      function Ls(n, r) {
        var s = oo(r), u = s.next();
        if (u.done) return !1;
        for (var c = u.value, d = oo(n), h = d.next(c.from), v = h.value; !u.done && !h.done; ) {
          if (Ce(v.from, c.to) <= 0 && 0 <= Ce(v.to, c.from)) return !0;
          Ce(c.from, v.from) < 0 ? c = (u = s.next(v.from)).value : v = (h = d.next(c.from)).value;
        }
        return !1;
      }
      function oo(n) {
        var r = ci(n) ? null : { s: 0, n };
        return { next: function(s) {
          for (var u = 0 < arguments.length; r; ) switch (r.s) {
            case 0:
              if (r.s = 1, u) for (; r.n.l && Ce(s, r.n.from) < 0; ) r = { up: r, n: r.n.l, s: 1 };
              else for (; r.n.l; ) r = { up: r, n: r.n.l, s: 1 };
            case 1:
              if (r.s = 2, !u || Ce(s, r.n.to) <= 0) return { value: r.n, done: !1 };
            case 2:
              if (r.n.r) {
                r.s = 3, r = { up: r, n: r.n.r, s: 0 };
                continue;
              }
            case 3:
              r = r.up;
          }
          return { done: !0 };
        } };
      }
      function Ks(n) {
        var r, s, u = (((r = n.r) === null || r === void 0 ? void 0 : r.d) || 0) - (((s = n.l) === null || s === void 0 ? void 0 : s.d) || 0), c = 1 < u ? "r" : u < -1 ? "l" : "";
        c && (r = c == "r" ? "l" : "r", s = i({}, n), u = n[c], n.from = u.from, n.to = u.to, n[c] = u[c], s[c] = u[r], (n[r] = s).d = Ms(s)), n.d = Ms(n);
      }
      function Ms(s) {
        var r = s.r, s = s.l;
        return (r ? s ? Math.max(r.d, s.d) : r.d : s ? s.d : 0) + 1;
      }
      function io(n, r) {
        return f(r).forEach(function(s) {
          n[s] ? br(n[s], r[s]) : n[s] = function u(c) {
            var d, h, v = {};
            for (d in c) R(c, d) && (h = c[d], v[d] = !h || typeof h != "object" || yt.has(h.constructor) ? h : u(h));
            return v;
          }(r[s]);
        }), n;
      }
      function fi(n, r) {
        return n.all || r.all || Object.keys(n).some(function(s) {
          return r[s] && Ls(r[s], n[s]);
        });
      }
      F(lt.prototype, ((At = { add: function(n) {
        return br(this, n), this;
      }, addKey: function(n) {
        return gr(this, n, n), this;
      }, addKeys: function(n) {
        var r = this;
        return n.forEach(function(s) {
          return gr(r, s, s);
        }), this;
      }, hasKey: function(n) {
        var r = oo(this).next(n).value;
        return r && Ce(r.from, n) <= 0 && 0 <= Ce(r.to, n);
      } })[Fe] = function() {
        return oo(this);
      }, At));
      var Rn = {}, di = {}, pi = !1;
      function so(n) {
        io(di, n), pi || (pi = !0, setTimeout(function() {
          pi = !1, hi(di, !(di = {}));
        }, 0));
      }
      function hi(n, r) {
        r === void 0 && (r = !1);
        var s = /* @__PURE__ */ new Set();
        if (n.all) for (var u = 0, c = Object.values(Rn); u < c.length; u++) Fs(h = c[u], n, s, r);
        else for (var d in n) {
          var h, v = /^idb\:\/\/(.*)\/(.*)\//.exec(d);
          v && (d = v[1], v = v[2], (h = Rn["idb://".concat(d, "/").concat(v)]) && Fs(h, n, s, r));
        }
        s.forEach(function(b) {
          return b();
        });
      }
      function Fs(n, r, s, u) {
        for (var c = [], d = 0, h = Object.entries(n.queries.query); d < h.length; d++) {
          for (var v = h[d], b = v[0], x = [], E = 0, g = v[1]; E < g.length; E++) {
            var A = g[E];
            fi(r, A.obsSet) ? A.subscribers.forEach(function(T) {
              return s.add(T);
            }) : u && x.push(A);
          }
          u && c.push([b, x]);
        }
        if (u) for (var _ = 0, C = c; _ < C.length; _++) {
          var N = C[_], b = N[0], x = N[1];
          n.queries.query[b] = x;
        }
      }
      function cl(n) {
        var r = n._state, s = n._deps.indexedDB;
        if (r.isBeingOpened || n.idbdb) return r.dbReadyPromise.then(function() {
          return r.dbOpenError ? ze(r.dbOpenError) : n;
        });
        r.isBeingOpened = !0, r.dbOpenError = null, r.openComplete = !1;
        var u = r.openCanceller, c = Math.round(10 * n.verno), d = !1;
        function h() {
          if (r.openCanceller !== u) throw new se.DatabaseClosed("db.open() was cancelled");
        }
        function v() {
          return new ne(function(A, _) {
            if (h(), !s) throw new se.MissingAPI();
            var C = n.name, N = r.autoSchema || !c ? s.open(C) : s.open(C, c);
            if (!N) throw new se.MissingAPI();
            N.onerror = Ft(_), N.onblocked = Ve(n._fireOnBlocked), N.onupgradeneeded = Ve(function(T) {
              var k;
              E = N.transaction, r.autoSchema && !n._options.allowEmptyDB ? (N.onerror = hr, E.abort(), N.result.close(), (k = s.deleteDatabase(C)).onsuccess = k.onerror = Ve(function() {
                _(new se.NoSuchDatabase("Database ".concat(C, " doesnt exist")));
              })) : (E.onerror = Ft(_), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, g = T < 1, n.idbdb = N.result, d && ul(n, E), al(n, T / 10, E, _));
            }, _), N.onsuccess = Ve(function() {
              E = null;
              var T, k, D, j, L, H = n.idbdb = N.result, Q = de(H.objectStoreNames);
              if (0 < Q.length) try {
                var W = H.transaction((j = Q).length === 1 ? j[0] : j, "readonly");
                if (r.autoSchema) k = H, D = W, (T = n).verno = k.version / 10, D = T._dbSchema = no(0, k, D), T._storeNames = de(k.objectStoreNames, 0), eo(T, [T._allTables], f(D), D);
                else if (ro(n, n._dbSchema, W), ((L = ii(no(0, (L = n).idbdb, W), L._dbSchema)).add.length || L.change.some(function(z) {
                  return z.add.length || z.change.length;
                })) && !d) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), H.close(), c = H.version + 1, d = !0, A(v());
                Zr(n, W);
              } catch {
              }
              Gn.push(n), H.onversionchange = Ve(function(z) {
                r.vcFired = !0, n.on("versionchange").fire(z);
              }), H.onclose = Ve(function(z) {
                n.on("close").fire(z);
              }), g && (L = n._deps, W = C, H = L.indexedDB, L = L.IDBKeyRange, ui(H) || W === zr || ai(H, L).put({ name: W }).catch(y)), A();
            }, _);
          }).catch(function(A) {
            switch (A?.name) {
              case "UnknownError":
                if (0 < r.PR1398_maxLoop) return r.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), v();
                break;
              case "VersionError":
                if (0 < c) return c = 0, v();
            }
            return ne.reject(A);
          });
        }
        var b, x = r.dbReadyResolve, E = null, g = !1;
        return ne.race([u, (typeof navigator > "u" ? ne.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(A) {
          function _() {
            return indexedDB.databases().finally(A);
          }
          b = setInterval(_, 100), _();
        }).finally(function() {
          return clearInterval(b);
        }) : Promise.resolve()).then(v)]).then(function() {
          return h(), r.onReadyBeingFired = [], ne.resolve(li(function() {
            return n.on.ready.fire(n.vip);
          })).then(function A() {
            if (0 < r.onReadyBeingFired.length) {
              var _ = r.onReadyBeingFired.reduce(Y, y);
              return r.onReadyBeingFired = [], ne.resolve(li(function() {
                return _(n.vip);
              })).then(A);
            }
          });
        }).finally(function() {
          r.openCanceller === u && (r.onReadyBeingFired = null, r.isBeingOpened = !1);
        }).catch(function(A) {
          r.dbOpenError = A;
          try {
            E && E.abort();
          } catch {
          }
          return u === r.openCanceller && n._close(), ze(A);
        }).finally(function() {
          r.openComplete = !0, x();
        }).then(function() {
          var A;
          return g && (A = {}, n.tables.forEach(function(_) {
            _.schema.indexes.forEach(function(C) {
              C.name && (A["idb://".concat(n.name, "/").concat(_.name, "/").concat(C.name)] = new lt(-1 / 0, [[[]]]));
            }), A["idb://".concat(n.name, "/").concat(_.name, "/")] = A["idb://".concat(n.name, "/").concat(_.name, "/:dels")] = new lt(-1 / 0, [[[]]]);
          }), vn(mr).fire(A), hi(A, !0)), n;
        });
      }
      function mi(n) {
        function r(d) {
          return n.next(d);
        }
        var s = c(r), u = c(function(d) {
          return n.throw(d);
        });
        function c(d) {
          return function(b) {
            var v = d(b), b = v.value;
            return v.done ? b : b && typeof b.then == "function" ? b.then(s, u) : p(b) ? Promise.all(b).then(s, u) : s(b);
          };
        }
        return c(r)();
      }
      function ao(n, r, s) {
        for (var u = p(n) ? n.slice() : [n], c = 0; c < s; ++c) u.push(r);
        return u;
      }
      var fl = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return i(i({}, n), { table: function(r) {
          var s = n.table(r), u = s.schema, c = {}, d = [];
          function h(g, A, _) {
            var C = vr(g), N = c[C] = c[C] || [], T = g == null ? 0 : typeof g == "string" ? 1 : g.length, k = 0 < A, k = i(i({}, _), { name: k ? "".concat(C, "(virtual-from:").concat(_.name, ")") : _.name, lowLevelIndex: _, isVirtual: k, keyTail: A, keyLength: T, extractKey: ri(g), unique: !k && _.unique });
            return N.push(k), k.isPrimaryKey || d.push(k), 1 < T && h(T === 2 ? g[0] : g.slice(0, T - 1), A + 1, _), N.sort(function(D, j) {
              return D.keyTail - j.keyTail;
            }), k;
          }
          r = h(u.primaryKey.keyPath, 0, u.primaryKey), c[":id"] = [r];
          for (var v = 0, b = u.indexes; v < b.length; v++) {
            var x = b[v];
            h(x.keyPath, 0, x);
          }
          function E(g) {
            var A, _ = g.query.index;
            return _.isVirtual ? i(i({}, g), { query: { index: _.lowLevelIndex, range: (A = g.query.range, _ = _.keyTail, { type: A.type === 1 ? 2 : A.type, lower: ao(A.lower, A.lowerOpen ? n.MAX_KEY : n.MIN_KEY, _), lowerOpen: !0, upper: ao(A.upper, A.upperOpen ? n.MIN_KEY : n.MAX_KEY, _), upperOpen: !0 }) } }) : g;
          }
          return i(i({}, s), { schema: i(i({}, u), { primaryKey: r, indexes: d, getIndexByKeyPath: function(g) {
            return (g = c[vr(g)]) && g[0];
          } }), count: function(g) {
            return s.count(E(g));
          }, query: function(g) {
            return s.query(E(g));
          }, openCursor: function(g) {
            var A = g.query.index, _ = A.keyTail, C = A.isVirtual, N = A.keyLength;
            return C ? s.openCursor(E(g)).then(function(k) {
              return k && T(k);
            }) : s.openCursor(g);
            function T(k) {
              return Object.create(k, { continue: { value: function(D) {
                D != null ? k.continue(ao(D, g.reverse ? n.MAX_KEY : n.MIN_KEY, _)) : g.unique ? k.continue(k.key.slice(0, N).concat(g.reverse ? n.MIN_KEY : n.MAX_KEY, _)) : k.continue();
              } }, continuePrimaryKey: { value: function(D, j) {
                k.continuePrimaryKey(ao(D, n.MAX_KEY, _), j);
              } }, primaryKey: { get: function() {
                return k.primaryKey;
              } }, key: { get: function() {
                var D = k.key;
                return N === 1 ? D[0] : D.slice(0, N);
              } }, value: { get: function() {
                return k.value;
              } } });
            }
          } });
        } });
      } };
      function yi(n, r, s, u) {
        return s = s || {}, u = u || "", f(n).forEach(function(c) {
          var d, h, v;
          R(r, c) ? (d = n[c], h = r[c], typeof d == "object" && typeof h == "object" && d && h ? (v = ln(d)) !== ln(h) ? s[u + c] = r[c] : v === "Object" ? yi(d, h, s, u + c + ".") : d !== h && (s[u + c] = r[c]) : d !== h && (s[u + c] = r[c])) : s[u + c] = void 0;
        }), f(r).forEach(function(c) {
          R(n, c) || (s[u + c] = r[c]);
        }), s;
      }
      function vi(n, r) {
        return r.type === "delete" ? r.keys : r.keys || r.values.map(n.extractKey);
      }
      var dl = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return i(i({}, n), { table: function(r) {
          var s = n.table(r), u = s.schema.primaryKey;
          return i(i({}, s), { mutate: function(c) {
            var d = ie.trans, h = d.table(r).hook, v = h.deleting, b = h.creating, x = h.updating;
            switch (c.type) {
              case "add":
                if (b.fire === y) break;
                return d._promise("readwrite", function() {
                  return E(c);
                }, !0);
              case "put":
                if (b.fire === y && x.fire === y) break;
                return d._promise("readwrite", function() {
                  return E(c);
                }, !0);
              case "delete":
                if (v.fire === y) break;
                return d._promise("readwrite", function() {
                  return E(c);
                }, !0);
              case "deleteRange":
                if (v.fire === y) break;
                return d._promise("readwrite", function() {
                  return function g(A, _, C) {
                    return s.query({ trans: A, values: !1, query: { index: u, range: _ }, limit: C }).then(function(N) {
                      var T = N.result;
                      return E({ type: "delete", keys: T, trans: A }).then(function(k) {
                        return 0 < k.numFailures ? Promise.reject(k.failures[0]) : T.length < C ? { failures: [], numFailures: 0, lastResult: void 0 } : g(A, i(i({}, _), { lower: T[T.length - 1], lowerOpen: !0 }), C);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return s.mutate(c);
            function E(g) {
              var A, _, C, N = ie.trans, T = g.keys || vi(u, g);
              if (!T) throw new Error("Keys missing");
              return (g = g.type === "add" || g.type === "put" ? i(i({}, g), { keys: T }) : i({}, g)).type !== "delete" && (g.values = a([], g.values)), g.keys && (g.keys = a([], g.keys)), A = s, C = T, ((_ = g).type === "add" ? Promise.resolve([]) : A.getMany({ trans: _.trans, keys: C, cache: "immutable" })).then(function(k) {
                var D = T.map(function(j, L) {
                  var H, Q, W, z = k[L], te = { onerror: null, onsuccess: null };
                  return g.type === "delete" ? v.fire.call(te, j, z, N) : g.type === "add" || z === void 0 ? (H = b.fire.call(te, j, g.values[L], N), j == null && H != null && (g.keys[L] = j = H, u.outbound || Re(g.values[L], u.keyPath, j))) : (H = yi(z, g.values[L]), (Q = x.fire.call(te, H, j, z, N)) && (W = g.values[L], Object.keys(Q).forEach(function(Z) {
                    R(W, Z) ? W[Z] = Q[Z] : Re(W, Z, Q[Z]);
                  }))), te;
                });
                return s.mutate(g).then(function(j) {
                  for (var L = j.failures, H = j.results, Q = j.numFailures, j = j.lastResult, W = 0; W < T.length; ++W) {
                    var z = (H || T)[W], te = D[W];
                    z == null ? te.onerror && te.onerror(L[W]) : te.onsuccess && te.onsuccess(g.type === "put" && k[W] ? g.values[W] : z);
                  }
                  return { failures: L, results: H, numFailures: Q, lastResult: j };
                }).catch(function(j) {
                  return D.forEach(function(L) {
                    return L.onerror && L.onerror(j);
                  }), Promise.reject(j);
                });
              });
            }
          } });
        } });
      } };
      function $s(n, r, s) {
        try {
          if (!r || r.keys.length < n.length) return null;
          for (var u = [], c = 0, d = 0; c < r.keys.length && d < n.length; ++c) Ce(r.keys[c], n[d]) === 0 && (u.push(s ? ut(r.values[c]) : r.values[c]), ++d);
          return u.length === n.length ? u : null;
        } catch {
          return null;
        }
      }
      var pl = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(r) {
          var s = n.table(r);
          return i(i({}, s), { getMany: function(u) {
            if (!u.cache) return s.getMany(u);
            var c = $s(u.keys, u.trans._cache, u.cache === "clone");
            return c ? ne.resolve(c) : s.getMany(u).then(function(d) {
              return u.trans._cache = { keys: u.keys, values: u.cache === "clone" ? ut(d) : d }, d;
            });
          }, mutate: function(u) {
            return u.type !== "add" && (u.trans._cache = null), s.mutate(u);
          } });
        } };
      } };
      function Bs(n, r) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !r.schema.primaryKey.outbound;
      }
      function qs(n, r) {
        switch (n) {
          case "query":
            return r.values && !r.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var hl = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var r = n.schema.name, s = new lt(n.MIN_KEY, n.MAX_KEY);
        return i(i({}, n), { transaction: function(u, c, d) {
          if (ie.subscr && c !== "readonly") throw new se.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ie.querier));
          return n.transaction(u, c, d);
        }, table: function(u) {
          var c = n.table(u), d = c.schema, h = d.primaryKey, g = d.indexes, v = h.extractKey, b = h.outbound, x = h.autoIncrement && g.filter(function(_) {
            return _.compound && _.keyPath.includes(h.keyPath);
          }), E = i(i({}, c), { mutate: function(_) {
            function C(Z) {
              return Z = "idb://".concat(r, "/").concat(u, "/").concat(Z), j[Z] || (j[Z] = new lt());
            }
            var N, T, k, D = _.trans, j = _.mutatedParts || (_.mutatedParts = {}), L = C(""), H = C(":dels"), Q = _.type, te = _.type === "deleteRange" ? [_.range] : _.type === "delete" ? [_.keys] : _.values.length < 50 ? [vi(h, _).filter(function(Z) {
              return Z;
            }), _.values] : [], W = te[0], z = te[1], te = _.trans._cache;
            return p(W) ? (L.addKeys(W), (te = Q === "delete" || W.length === z.length ? $s(W, te) : null) || H.addKeys(W), (te || z) && (N = C, T = te, k = z, d.indexes.forEach(function(Z) {
              var re = N(Z.name || "");
              function ve(he) {
                return he != null ? Z.extractKey(he) : null;
              }
              function Ne(he) {
                return Z.multiEntry && p(he) ? he.forEach(function(We) {
                  return re.addKey(We);
                }) : re.addKey(he);
              }
              (T || k).forEach(function(he, ct) {
                var pe = T && ve(T[ct]), ct = k && ve(k[ct]);
                Ce(pe, ct) !== 0 && (pe != null && Ne(pe), ct != null && Ne(ct));
              });
            }))) : W ? (z = { from: (z = W.lower) !== null && z !== void 0 ? z : n.MIN_KEY, to: (z = W.upper) !== null && z !== void 0 ? z : n.MAX_KEY }, H.add(z), L.add(z)) : (L.add(s), H.add(s), d.indexes.forEach(function(Z) {
              return C(Z.name).add(s);
            })), c.mutate(_).then(function(Z) {
              return !W || _.type !== "add" && _.type !== "put" || (L.addKeys(Z.results), x && x.forEach(function(re) {
                for (var ve = _.values.map(function(pe) {
                  return re.extractKey(pe);
                }), Ne = re.keyPath.findIndex(function(pe) {
                  return pe === h.keyPath;
                }), he = 0, We = Z.results.length; he < We; ++he) ve[he][Ne] = Z.results[he];
                C(re.name).addKeys(ve);
              })), D.mutatedParts = io(D.mutatedParts || {}, j), Z;
            });
          } }), g = function(C) {
            var N = C.query, C = N.index, N = N.range;
            return [C, new lt((C = N.lower) !== null && C !== void 0 ? C : n.MIN_KEY, (N = N.upper) !== null && N !== void 0 ? N : n.MAX_KEY)];
          }, A = { get: function(_) {
            return [h, new lt(_.key)];
          }, getMany: function(_) {
            return [h, new lt().addKeys(_.keys)];
          }, count: g, query: g, openCursor: g };
          return f(A).forEach(function(_) {
            E[_] = function(C) {
              var N = ie.subscr, T = !!N, k = Bs(ie, c) && qs(_, C) ? C.obsSet = {} : N;
              if (T) {
                var D = function(z) {
                  return z = "idb://".concat(r, "/").concat(u, "/").concat(z), k[z] || (k[z] = new lt());
                }, j = D(""), L = D(":dels"), N = A[_](C), T = N[0], N = N[1];
                if ((_ === "query" && T.isPrimaryKey && !C.values ? L : D(T.name || "")).add(N), !T.isPrimaryKey) {
                  if (_ !== "count") {
                    var H = _ === "query" && b && C.values && c.query(i(i({}, C), { values: !1 }));
                    return c[_].apply(this, arguments).then(function(z) {
                      if (_ === "query") {
                        if (b && C.values) return H.then(function(ve) {
                          return ve = ve.result, j.addKeys(ve), z;
                        });
                        var te = C.values ? z.result.map(v) : z.result;
                        (C.values ? j : L).addKeys(te);
                      } else if (_ === "openCursor") {
                        var Z = z, re = C.values;
                        return Z && Object.create(Z, { key: { get: function() {
                          return L.addKey(Z.primaryKey), Z.key;
                        } }, primaryKey: { get: function() {
                          var ve = Z.primaryKey;
                          return L.addKey(ve), ve;
                        } }, value: { get: function() {
                          return re && j.addKey(Z.primaryKey), Z.value;
                        } } });
                      }
                      return z;
                    });
                  }
                  L.add(s);
                }
              }
              return c[_].apply(this, arguments);
            };
          }), E;
        } });
      } };
      function Vs(n, r, s) {
        if (s.numFailures === 0) return r;
        if (r.type === "deleteRange") return null;
        var u = r.keys ? r.keys.length : "values" in r && r.values ? r.values.length : 1;
        return s.numFailures === u ? null : (r = i({}, r), p(r.keys) && (r.keys = r.keys.filter(function(c, d) {
          return !(d in s.failures);
        })), "values" in r && p(r.values) && (r.values = r.values.filter(function(c, d) {
          return !(d in s.failures);
        })), r);
      }
      function gi(n, r) {
        return s = n, ((u = r).lower === void 0 || (u.lowerOpen ? 0 < Ce(s, u.lower) : 0 <= Ce(s, u.lower))) && (n = n, (r = r).upper === void 0 || (r.upperOpen ? Ce(n, r.upper) < 0 : Ce(n, r.upper) <= 0));
        var s, u;
      }
      function Us(n, r, A, u, c, d) {
        if (!A || A.length === 0) return n;
        var h = r.query.index, v = h.multiEntry, b = r.query.range, x = u.schema.primaryKey.extractKey, E = h.extractKey, g = (h.lowLevelIndex || h).extractKey, A = A.reduce(function(_, C) {
          var N = _, T = [];
          if (C.type === "add" || C.type === "put") for (var k = new lt(), D = C.values.length - 1; 0 <= D; --D) {
            var j, L = C.values[D], H = x(L);
            k.hasKey(H) || (j = E(L), (v && p(j) ? j.some(function(Z) {
              return gi(Z, b);
            }) : gi(j, b)) && (k.addKey(H), T.push(L)));
          }
          switch (C.type) {
            case "add":
              var Q = new lt().addKeys(r.values ? _.map(function(re) {
                return x(re);
              }) : _), N = _.concat(r.values ? T.filter(function(re) {
                return re = x(re), !Q.hasKey(re) && (Q.addKey(re), !0);
              }) : T.map(function(re) {
                return x(re);
              }).filter(function(re) {
                return !Q.hasKey(re) && (Q.addKey(re), !0);
              }));
              break;
            case "put":
              var W = new lt().addKeys(C.values.map(function(re) {
                return x(re);
              }));
              N = _.filter(function(re) {
                return !W.hasKey(r.values ? x(re) : re);
              }).concat(r.values ? T : T.map(function(re) {
                return x(re);
              }));
              break;
            case "delete":
              var z = new lt().addKeys(C.keys);
              N = _.filter(function(re) {
                return !z.hasKey(r.values ? x(re) : re);
              });
              break;
            case "deleteRange":
              var te = C.range;
              N = _.filter(function(re) {
                return !gi(x(re), te);
              });
          }
          return N;
        }, n);
        return A === n ? n : (A.sort(function(_, C) {
          return Ce(g(_), g(C)) || Ce(x(_), x(C));
        }), r.limit && r.limit < 1 / 0 && (A.length > r.limit ? A.length = r.limit : n.length === r.limit && A.length < r.limit && (c.dirty = !0)), d ? Object.freeze(A) : A);
      }
      function Hs(n, r) {
        return Ce(n.lower, r.lower) === 0 && Ce(n.upper, r.upper) === 0 && !!n.lowerOpen == !!r.lowerOpen && !!n.upperOpen == !!r.upperOpen;
      }
      function ml(n, r) {
        return function(s, u, c, d) {
          if (s === void 0) return u !== void 0 ? -1 : 0;
          if (u === void 0) return 1;
          if ((u = Ce(s, u)) === 0) {
            if (c && d) return 0;
            if (c) return 1;
            if (d) return -1;
          }
          return u;
        }(n.lower, r.lower, n.lowerOpen, r.lowerOpen) <= 0 && 0 <= function(s, u, c, d) {
          if (s === void 0) return u !== void 0 ? 1 : 0;
          if (u === void 0) return -1;
          if ((u = Ce(s, u)) === 0) {
            if (c && d) return 0;
            if (c) return -1;
            if (d) return 1;
          }
          return u;
        }(n.upper, r.upper, n.upperOpen, r.upperOpen);
      }
      function yl(n, r, s, u) {
        n.subscribers.add(s), u.addEventListener("abort", function() {
          var c, d;
          n.subscribers.delete(s), n.subscribers.size === 0 && (c = n, d = r, setTimeout(function() {
            c.subscribers.size === 0 && Pe(d, c);
          }, 3e3));
        });
      }
      var vl = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var r = n.schema.name;
        return i(i({}, n), { transaction: function(s, u, c) {
          var d, h, v = n.transaction(s, u, c);
          return u === "readwrite" && (h = (d = new AbortController()).signal, c = function(b) {
            return function() {
              if (d.abort(), u === "readwrite") {
                for (var x = /* @__PURE__ */ new Set(), E = 0, g = s; E < g.length; E++) {
                  var A = g[E], _ = Rn["idb://".concat(r, "/").concat(A)];
                  if (_) {
                    var C = n.table(A), N = _.optimisticOps.filter(function(re) {
                      return re.trans === v;
                    });
                    if (v._explicit && b && v.mutatedParts) for (var T = 0, k = Object.values(_.queries.query); T < k.length; T++) for (var D = 0, j = (Q = k[T]).slice(); D < j.length; D++) fi((W = j[D]).obsSet, v.mutatedParts) && (Pe(Q, W), W.subscribers.forEach(function(re) {
                      return x.add(re);
                    }));
                    else if (0 < N.length) {
                      _.optimisticOps = _.optimisticOps.filter(function(re) {
                        return re.trans !== v;
                      });
                      for (var L = 0, H = Object.values(_.queries.query); L < H.length; L++) for (var Q, W, z, te = 0, Z = (Q = H[L]).slice(); te < Z.length; te++) (W = Z[te]).res != null && v.mutatedParts && (b && !W.dirty ? (z = Object.isFrozen(W.res), z = Us(W.res, W.req, N, C, W, z), W.dirty ? (Pe(Q, W), W.subscribers.forEach(function(re) {
                        return x.add(re);
                      })) : z !== W.res && (W.res = z, W.promise = ne.resolve({ result: z }))) : (W.dirty && Pe(Q, W), W.subscribers.forEach(function(re) {
                        return x.add(re);
                      })));
                    }
                  }
                }
                x.forEach(function(re) {
                  return re();
                });
              }
            };
          }, v.addEventListener("abort", c(!1), { signal: h }), v.addEventListener("error", c(!1), { signal: h }), v.addEventListener("complete", c(!0), { signal: h })), v;
        }, table: function(s) {
          var u = n.table(s), c = u.schema.primaryKey;
          return i(i({}, u), { mutate: function(d) {
            var h = ie.trans;
            if (c.outbound || h.db._options.cache === "disabled" || h.explicit || h.idbtrans.mode !== "readwrite") return u.mutate(d);
            var v = Rn["idb://".concat(r, "/").concat(s)];
            return v ? (h = u.mutate(d), d.type !== "add" && d.type !== "put" || !(50 <= d.values.length || vi(c, d).some(function(b) {
              return b == null;
            })) ? (v.optimisticOps.push(d), d.mutatedParts && so(d.mutatedParts), h.then(function(b) {
              0 < b.numFailures && (Pe(v.optimisticOps, d), (b = Vs(0, d, b)) && v.optimisticOps.push(b), d.mutatedParts && so(d.mutatedParts));
            }), h.catch(function() {
              Pe(v.optimisticOps, d), d.mutatedParts && so(d.mutatedParts);
            })) : h.then(function(b) {
              var x = Vs(0, i(i({}, d), { values: d.values.map(function(E, g) {
                var A;
                return b.failures[g] ? E : (E = (A = c.keyPath) !== null && A !== void 0 && A.includes(".") ? ut(E) : i({}, E), Re(E, c.keyPath, b.results[g]), E);
              }) }), b);
              v.optimisticOps.push(x), queueMicrotask(function() {
                return d.mutatedParts && so(d.mutatedParts);
              });
            }), h) : u.mutate(d);
          }, query: function(d) {
            if (!Bs(ie, u) || !qs("query", d)) return u.query(d);
            var h = ((x = ie.trans) === null || x === void 0 ? void 0 : x.db._options.cache) === "immutable", g = ie, v = g.requery, b = g.signal, x = function(C, N, T, k) {
              var D = Rn["idb://".concat(C, "/").concat(N)];
              if (!D) return [];
              if (!(N = D.queries[T])) return [null, !1, D, null];
              var j = N[(k.query ? k.query.index.name : null) || ""];
              if (!j) return [null, !1, D, null];
              switch (T) {
                case "query":
                  var L = j.find(function(H) {
                    return H.req.limit === k.limit && H.req.values === k.values && Hs(H.req.query.range, k.query.range);
                  });
                  return L ? [L, !0, D, j] : [j.find(function(H) {
                    return ("limit" in H.req ? H.req.limit : 1 / 0) >= k.limit && (!k.values || H.req.values) && ml(H.req.query.range, k.query.range);
                  }), !1, D, j];
                case "count":
                  return L = j.find(function(H) {
                    return Hs(H.req.query.range, k.query.range);
                  }), [L, !!L, D, j];
              }
            }(r, s, "query", d), E = x[0], g = x[1], A = x[2], _ = x[3];
            return E && g ? E.obsSet = d.obsSet : (g = u.query(d).then(function(C) {
              var N = C.result;
              if (E && (E.res = N), h) {
                for (var T = 0, k = N.length; T < k; ++T) Object.freeze(N[T]);
                Object.freeze(N);
              } else C.result = ut(N);
              return C;
            }).catch(function(C) {
              return _ && E && Pe(_, E), Promise.reject(C);
            }), E = { obsSet: d.obsSet, promise: g, subscribers: /* @__PURE__ */ new Set(), type: "query", req: d, dirty: !1 }, _ ? _.push(E) : (_ = [E], (A = A || (Rn["idb://".concat(r, "/").concat(s)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[d.query.index.name || ""] = _)), yl(E, _, v, b), E.promise.then(function(C) {
              return { result: Us(C.result, d, A?.optimisticOps, u, E, h) };
            });
          } });
        } });
      } };
      function uo(n, r) {
        return new Proxy(n, { get: function(s, u, c) {
          return u === "db" ? r : Reflect.get(s, u, c);
        } });
      }
      var Gt = (Ge.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new se.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new se.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var r = this._versions, s = r.filter(function(u) {
          return u._cfg.version === n;
        })[0];
        return s || (s = new this.Version(n), r.push(s), r.sort(sl), s.stores({}), this._state.autoSchema = !1, s);
      }, Ge.prototype._whenReady = function(n) {
        var r = this;
        return this.idbdb && (this._state.openComplete || ie.letThrough || this._vip) ? n() : new ne(function(s, u) {
          if (r._state.openComplete) return u(new se.DatabaseClosed(r._state.dbOpenError));
          if (!r._state.isBeingOpened) {
            if (!r._state.autoOpen) return void u(new se.DatabaseClosed());
            r.open().catch(y);
          }
          r._state.dbReadyPromise.then(s, u);
        }).then(n);
      }, Ge.prototype.use = function(n) {
        var r = n.stack, s = n.create, u = n.level, c = n.name;
        return c && this.unuse({ stack: r, name: c }), n = this._middlewares[r] || (this._middlewares[r] = []), n.push({ stack: r, create: s, level: u ?? 10, name: c }), n.sort(function(d, h) {
          return d.level - h.level;
        }), this;
      }, Ge.prototype.unuse = function(n) {
        var r = n.stack, s = n.name, u = n.create;
        return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function(c) {
          return u ? c.create !== u : !!s && c.name !== s;
        })), this;
      }, Ge.prototype.open = function() {
        var n = this;
        return Nn(He, function() {
          return cl(n);
        });
      }, Ge.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, r = Gn.indexOf(this);
        if (0 <= r && Gn.splice(r, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ne(function(s) {
          n.dbReadyResolve = s;
        }), n.openCanceller = new ne(function(s, u) {
          n.cancelOpen = u;
        }));
      }, Ge.prototype.close = function(s) {
        var r = (s === void 0 ? { disableAutoOpen: !0 } : s).disableAutoOpen, s = this._state;
        r ? (s.isBeingOpened && s.cancelOpen(new se.DatabaseClosed()), this._close(), s.autoOpen = !1, s.dbOpenError = new se.DatabaseClosed()) : (this._close(), s.autoOpen = this._options.autoOpen || s.isBeingOpened, s.openComplete = !1, s.dbOpenError = null);
      }, Ge.prototype.delete = function(n) {
        var r = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var s = 0 < arguments.length && typeof arguments[0] != "object", u = this._state;
        return new ne(function(c, d) {
          function h() {
            r.close(n);
            var v = r._deps.indexedDB.deleteDatabase(r.name);
            v.onsuccess = Ve(function() {
              var b, x, E;
              b = r._deps, x = r.name, E = b.indexedDB, b = b.IDBKeyRange, ui(E) || x === zr || ai(E, b).delete(x).catch(y), c();
            }), v.onerror = Ft(d), v.onblocked = r._fireOnBlocked;
          }
          if (s) throw new se.InvalidArgument("Invalid closeOptions argument to db.delete()");
          u.isBeingOpened ? u.dbReadyPromise.then(h) : h();
        });
      }, Ge.prototype.backendDB = function() {
        return this.idbdb;
      }, Ge.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Ge.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, Ge.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Ge.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Ge.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(r) {
          return n._allTables[r];
        });
      }, enumerable: !1, configurable: !0 }), Ge.prototype.transaction = function() {
        var n = (function(r, s, u) {
          var c = arguments.length;
          if (c < 2) throw new se.InvalidArgument("Too few arguments");
          for (var d = new Array(c - 1); --c; ) d[c - 1] = arguments[c];
          return u = d.pop(), [r, Ue(d), u];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, Ge.prototype._transaction = function(n, r, s) {
        var u = this, c = ie.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var d, h, v = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (h = r.map(function(x) {
            if (x = x instanceof u.Table ? x.name : x, typeof x != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return x;
          }), n == "r" || n === Qo) d = Qo;
          else {
            if (n != "rw" && n != Jo) throw new se.InvalidArgument("Invalid transaction mode: " + n);
            d = Jo;
          }
          if (c) {
            if (c.mode === Qo && d === Jo) {
              if (!v) throw new se.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && h.forEach(function(x) {
              if (c && c.storeNames.indexOf(x) === -1) {
                if (!v) throw new se.SubTransaction("Table " + x + " not included in parent transaction.");
                c = null;
              }
            }), v && c && !c.active && (c = null);
          }
        } catch (x) {
          return c ? c._promise(null, function(E, g) {
            g(x);
          }) : ze(x);
        }
        var b = (function x(E, g, A, _, C) {
          return ne.resolve().then(function() {
            var N = ie.transless || ie, T = E._createTransaction(g, A, E._dbSchema, _);
            if (T.explicit = !0, N = { trans: T, transless: N }, _) T.idbtrans = _.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, E._state.PR1398_maxLoop = 3;
            } catch (j) {
              return j.name === cn.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                return x(E, g, A, null, C);
              })) : ze(j);
            }
            var k, D = jt(C);
            return D && zn(), N = ne.follow(function() {
              var j;
              (k = C.call(T, T)) && (D ? (j = hn.bind(null, null), k.then(j, j)) : typeof k.next == "function" && typeof k.throw == "function" && (k = mi(k)));
            }, N), (k && typeof k.then == "function" ? ne.resolve(k).then(function(j) {
              return T.active ? j : ze(new se.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : N.then(function() {
              return k;
            })).then(function(j) {
              return _ && T._resolve(), T._completion.then(function() {
                return j;
              });
            }).catch(function(j) {
              return T._reject(j), ze(j);
            });
          });
        }).bind(null, this, d, h, c, s);
        return c ? c._promise(d, b, "lock") : ie.trans ? Nn(ie.transless, function() {
          return u._whenReady(b);
        }) : this._whenReady(b);
      }, Ge.prototype.table = function(n) {
        if (!R(this._allTables, n)) throw new se.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, Ge);
      function Ge(n, r) {
        var s = this;
        this._middlewares = {}, this.verno = 0;
        var u = Ge.dependencies;
        this._options = r = i({ addons: Ge.addons, autoOpen: !0, indexedDB: u.indexedDB, IDBKeyRange: u.IDBKeyRange, cache: "cloned" }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }, u = r.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, d, h, v, b, x = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: y, dbReadyPromise: null, cancelOpen: y, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: r.autoOpen };
        x.dbReadyPromise = new ne(function(g) {
          x.dbReadyResolve = g;
        }), x.openCanceller = new ne(function(g, A) {
          x.cancelOpen = A;
        }), this._state = x, this.name = n, this.on = fr(this, "populate", "blocked", "versionchange", "close", { ready: [Y, y] }), this.once = function(g, A) {
          var _ = function() {
            for (var C = [], N = 0; N < arguments.length; N++) C[N] = arguments[N];
            s.on(g).unsubscribe(_), A.apply(s, C);
          };
          return s.on(g, _);
        }, this.on.ready.subscribe = Se(this.on.ready.subscribe, function(g) {
          return function(A, _) {
            Ge.vip(function() {
              var C, N = s._state;
              N.openComplete ? (N.dbOpenError || ne.resolve().then(A), _ && g(A)) : N.onReadyBeingFired ? (N.onReadyBeingFired.push(A), _ && g(A)) : (g(A), C = s, _ || g(function T() {
                C.on.ready.unsubscribe(A), C.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (c = this, dr(Zu.prototype, function(k, T) {
          this.db = c;
          var _ = ws, C = null;
          if (T) try {
            _ = T();
          } catch (D) {
            C = D;
          }
          var N = k._ctx, T = N.table, k = T.hook.reading.fire;
          this._ctx = { table: T, index: N.index, isPrimKey: !N.index || T.schema.primKey.keyPath && N.index === T.schema.primKey.name, range: _, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: C, or: N.or, valueMapper: k !== w ? k : null };
        })), this.Table = (d = this, dr(Os.prototype, function(g, A, _) {
          this.db = d, this._tx = _, this.name = g, this.schema = A, this.hook = d._allTables[g] ? d._allTables[g].hook : fr(null, { creating: [q, y], reading: [M, w], updating: [ee, y], deleting: [U, y] });
        })), this.Transaction = (h = this, dr(nl.prototype, function(g, A, _, C, N) {
          var T = this;
          g !== "readonly" && A.forEach(function(k) {
            k = (k = _[k]) === null || k === void 0 ? void 0 : k.yProps, k && (A = A.concat(k.map(function(D) {
              return D.updatesTable;
            })));
          }), this.db = h, this.mode = g, this.storeNames = A, this.schema = _, this.chromeTransactionDurability = C, this.idbtrans = null, this.on = fr(this, "complete", "error", "abort"), this.parent = N || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ne(function(k, D) {
            T._resolve = k, T._reject = D;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(k) {
            var D = T.active;
            return T.active = !1, T.on.error.fire(k), T.parent ? T.parent._reject(k) : D && T.idbtrans && T.idbtrans.abort(), ze(k);
          });
        })), this.Version = (v = this, dr(ll.prototype, function(g) {
          this.db = v, this._cfg = { version: g, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (b = this, dr(ks.prototype, function(g, A, _) {
          if (this.db = b, this._ctx = { table: g, index: A === ":id" ? null : A, or: _ }, this._cmp = this._ascending = Ce, this._descending = function(C, N) {
            return Ce(N, C);
          }, this._max = function(C, N) {
            return 0 < Ce(C, N) ? C : N;
          }, this._min = function(C, N) {
            return Ce(C, N) < 0 ? C : N;
          }, this._IDBKeyRange = b._deps.IDBKeyRange, !this._IDBKeyRange) throw new se.MissingAPI();
        })), this.on("versionchange", function(g) {
          0 < g.newVersion ? console.warn("Another connection wants to upgrade database '".concat(s.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(s.name, "'. Closing db now to resume the delete request.")), s.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(g) {
          !g.newVersion || g.newVersion < g.oldVersion ? console.warn("Dexie.delete('".concat(s.name, "') was blocked")) : console.warn("Upgrade '".concat(s.name, "' blocked by other connection holding version ").concat(g.oldVersion / 10));
        }), this._maxKey = yr(r.IDBKeyRange), this._createTransaction = function(g, A, _, C) {
          return new s.Transaction(g, A, _, s._options.chromeTransactionDurability, C);
        }, this._fireOnBlocked = function(g) {
          s.on("blocked").fire(g), Gn.filter(function(A) {
            return A.name === s.name && A !== s && !A._state.vcFired;
          }).map(function(A) {
            return A.on("versionchange").fire(g);
          });
        }, this.use(pl), this.use(vl), this.use(hl), this.use(fl), this.use(dl);
        var E = new Proxy(this, { get: function(g, A, _) {
          if (A === "_vip") return !0;
          if (A === "table") return function(N) {
            return uo(s.table(N), E);
          };
          var C = Reflect.get(g, A, _);
          return C instanceof Os ? uo(C, E) : A === "tables" ? C.map(function(N) {
            return uo(N, E);
          }) : A === "_createTransaction" ? function() {
            return uo(C.apply(this, arguments), E);
          } : C;
        } });
        this.vip = E, u.forEach(function(g) {
          return g(s);
        });
      }
      var lo, At = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", gl = (bi.prototype.subscribe = function(n, r, s) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: r, complete: s });
      }, bi.prototype[At] = function() {
        return this;
      }, bi);
      function bi(n) {
        this._subscribe = n;
      }
      try {
        lo = { indexedDB: l.indexedDB || l.mozIndexedDB || l.webkitIndexedDB || l.msIndexedDB, IDBKeyRange: l.IDBKeyRange || l.webkitIDBKeyRange };
      } catch {
        lo = { indexedDB: null, IDBKeyRange: null };
      }
      function Ws(n) {
        var r, s = !1, u = new gl(function(c) {
          var d = jt(n), h, v = !1, b = {}, x = {}, E = { get closed() {
            return v;
          }, unsubscribe: function() {
            v || (v = !0, h && h.abort(), g && vn.storagemutated.unsubscribe(_));
          } };
          c.start && c.start(E);
          var g = !1, A = function() {
            return Yo(C);
          }, _ = function(N) {
            io(b, N), fi(x, b) && A();
          }, C = function() {
            var N, T, k;
            !v && lo.indexedDB && (b = {}, N = {}, h && h.abort(), h = new AbortController(), k = function(D) {
              var j = Hn();
              try {
                d && zn();
                var L = pn(n, D);
                return L = d ? L.finally(hn) : L;
              } finally {
                j && Wn();
              }
            }(T = { subscr: N, signal: h.signal, requery: A, querier: n, trans: null }), Promise.resolve(k).then(function(D) {
              s = !0, r = D, v || T.signal.aborted || (b = {}, function(j) {
                for (var L in j) if (R(j, L)) return;
                return 1;
              }(x = N) || g || (vn(mr, _), g = !0), Yo(function() {
                return !v && c.next && c.next(D);
              }));
            }, function(D) {
              s = !1, ["DatabaseClosedError", "AbortError"].includes(D?.name) || v || Yo(function() {
                v || c.error && c.error(D);
              });
            }));
          };
          return setTimeout(A, 0), E;
        });
        return u.hasValue = function() {
          return s;
        }, u.getValue = function() {
          return r;
        }, u;
      }
      var Dn = Gt;
      function _i(n) {
        var r = gn;
        try {
          gn = !0, vn.storagemutated.fire(n), hi(n, !0);
        } finally {
          gn = r;
        }
      }
      F(Dn, i(i({}, cr), { delete: function(n) {
        return new Dn(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new Dn(n, { addons: [] }).open().then(function(r) {
          return r.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return r = Dn.dependencies, s = r.indexedDB, r = r.IDBKeyRange, (ui(s) ? Promise.resolve(s.databases()).then(function(u) {
            return u.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== zr;
            });
          }) : ai(s, r).toCollection().primaryKeys()).then(n);
        } catch {
          return ze(new se.MissingAPI());
        }
        var r, s;
      }, defineClass: function() {
        return function(n) {
          m(this, n);
        };
      }, ignoreTransaction: function(n) {
        return ie.trans ? Nn(ie.transless, n) : n();
      }, vip: li, async: function(n) {
        return function() {
          try {
            var r = mi(n.apply(this, arguments));
            return r && typeof r.then == "function" ? r : ne.resolve(r);
          } catch (s) {
            return ze(s);
          }
        };
      }, spawn: function(n, r, s) {
        try {
          var u = mi(n.apply(s, r || []));
          return u && typeof u.then == "function" ? u : ne.resolve(u);
        } catch (c) {
          return ze(c);
        }
      }, currentTransaction: { get: function() {
        return ie.trans || null;
      } }, waitFor: function(n, r) {
        return r = ne.resolve(typeof n == "function" ? Dn.ignoreTransaction(n) : n).timeout(r || 6e4), ie.trans ? ie.trans.waitFor(r) : r;
      }, Promise: ne, debug: { get: function() {
        return B;
      }, set: function(n) {
        le(n);
      } }, derive: $, extend: m, props: F, override: Se, Events: fr, on: vn, liveQuery: Ws, extendObservabilitySet: io, getByKeyPath: Le, setByKeyPath: Re, delByKeyPath: function(n, r) {
        typeof r == "string" ? Re(n, r, void 0) : "length" in r && [].map.call(r, function(s) {
          Re(n, s, void 0);
        });
      }, shallowClone: we, deepClone: ut, getObjectDiff: yi, cmp: Ce, asap: be, minKey: -1 / 0, addons: [], connections: Gn, errnames: cn, dependencies: lo, cache: Rn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, r, s) {
        return n + r / Math.pow(10, 2 * s);
      }) })), Dn.maxKey = yr(Dn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (vn(mr, function(n) {
        gn || (n = new CustomEvent(ei, { detail: n }), gn = !0, dispatchEvent(n), gn = !1);
      }), addEventListener(ei, function(n) {
        n = n.detail, gn || _i(n);
      }));
      var Xn, gn = !1, zs = function() {
      };
      return typeof BroadcastChannel < "u" && ((zs = function() {
        (Xn = new BroadcastChannel(ei)).onmessage = function(n) {
          return n.data && _i(n.data);
        };
      })(), typeof Xn.unref == "function" && Xn.unref(), vn(mr, function(n) {
        gn || Xn.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!Gt.disableBfCache && n.persisted) {
          B && console.debug("Dexie: handling persisted pagehide"), Xn?.close();
          for (var r = 0, s = Gn; r < s.length; r++) s[r].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !Gt.disableBfCache && n.persisted && (B && console.debug("Dexie: handling persisted pageshow"), zs(), _i({ all: new lt(-1 / 0, [[]]) }));
      })), ne.rejectionMapper = function(n, r) {
        return !n || n instanceof Wt || n instanceof TypeError || n instanceof SyntaxError || !n.name || !fn[n.name] ? n : (r = new fn[n.name](r || n.message, n), "stack" in n && oe(r, "stack", { get: function() {
          return this.inner.stack;
        } }), r);
      }, le(B), i(Gt, Object.freeze({ __proto__: null, Dexie: Gt, liveQuery: Ws, Entity: xs, cmp: Ce, PropModification: pr, replacePrefix: function(n, r) {
        return new pr({ replacePrefix: [n, r] });
      }, add: function(n) {
        return new pr({ add: n });
      }, remove: function(n) {
        return new pr({ remove: n });
      }, default: Gt, RangeSet: lt, mergeRanges: br, rangesOverlap: Ls }), { default: Gt }), Gt;
    });
  }(go)), go.exports;
}
var Jf = Qf();
const zi = /* @__PURE__ */ Gf(Jf), ka = Symbol.for("Dexie"), No = globalThis[ka] || (globalThis[ka] = zi);
if (zi.semVer !== No.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${zi.semVer} and ${No.semVer}`);
const {
  liveQuery: Dp,
  mergeRanges: Ip,
  rangesOverlap: jp,
  RangeSet: Lp,
  cmp: Kp,
  Entity: Mp,
  PropModification: Fp,
  replacePrefix: $p,
  add: Bp,
  remove: qp,
  DexieYProvider: Vp
} = No;
var Ct = /* @__PURE__ */ ((e) => (e.GOOSE = "GOOSE", e.SMV = "SMV", e.REPORT = "Report", e.INTERNAL = "Internal", e.WIRED = "Wired", e.CONTROL = "Control", e))(Ct || {});
const Ao = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Internal: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: []
  // TODO
};
function Vu(e) {
  return {
    addRecord: t,
    findChildRecordsByTagName: i,
    ensureRelationship: o,
    findParentRecordsWithinDepthAndGivenTagName: a,
    db: e
  };
  async function t(l) {
    const f = {
      ...l,
      id: crypto.randomUUID()
    };
    try {
      const p = await e.table(f.tagName).add(f), m = await e.table(f.tagName).get(p);
      if (!m) {
        const P = { msg: "could not find added record", table: f.tagName, addedId: p };
        throw console.error(P), new Error(JSON.stringify(P));
      }
      return m;
    } catch (p) {
      const m = {
        msg: "could not add record",
        db: e.name,
        table: f.tagName,
        recordToAdd: f,
        err: p
      };
      throw console.error(m), new Error(JSON.stringify(m));
    }
  }
  async function o(l, f) {
    const p = l.children?.some(
      (P) => P.id === f.id && P.tagName === f.tagName
    ), m = f.parent?.id === l.id && f.parent?.tagName === l.tagName;
    p || (l.children || (l.children = []), l.children.push({
      id: f.id,
      tagName: f.tagName
    }), await e.table(l.tagName).update(l.id, l)), m || (f.parent = {
      id: l.id,
      tagName: l.tagName
    }, await e.table(f.tagName).update(f.id, f));
  }
  async function i(l, f) {
    return !l.children || l.children.length === 0 ? [] : await Promise.all(
      l.children.filter((m) => m.tagName === f).map(async (m) => {
        const P = m.tagName, S = m.id;
        return await e.table(P).get({ id: S });
      })
    );
  }
  async function a(l, f, p = []) {
    const m = [];
    let P = l;
    for (let S = 0; S < f; S++) {
      if (!P.parent)
        return m;
      const R = await e.table(P.parent.tagName).get(P.parent.id);
      if (!R) {
        const F = {
          msg: "Parent record not found",
          table: P.parent.tagName,
          id: P.parent.id
        };
        throw console.error(F), new Error(JSON.stringify(F));
      }
      (p.length == 0 || p.length > 0 && p.includes(R.tagName)) && m.push(R), P = R;
    }
    return m;
  }
}
function Xf(e, t) {
  return e.attributes?.find((o) => o.name === t);
}
function Oe(e, t) {
  return e?.attributes?.find((o) => o.name === t)?.value;
}
function Zf(e) {
  return {
    findAllEnrichedLNodes: t,
    findAllLNodeTypes: o,
    enrichWithDataObjectSpecifications: l
  };
  async function t() {
    const p = await f();
    return p.length ? await l(p) : [];
  }
  async function o() {
    const p = await e.table("LNodeType").toArray(), m = [];
    for (const P of p)
      m.push({
        id: P.id,
        typeId: Oe(P, "id") ?? "",
        lnClass: Oe(P, "lnClass") ?? "",
        dataObjects: await i(P)
      });
    return m;
  }
  async function i(p) {
    if (!p.children) return [];
    const m = [];
    for (const P of p.children) {
      if (P.tagName !== "DO") continue;
      const S = await e.table("DO").get(P.id);
      S && m.push({
        id: S.id,
        name: Oe(S, "name") ?? "",
        type: Oe(S, "type") ?? "",
        dataAttributes: await a(S),
        lnodeTypeId: p.id
      });
    }
    return m;
  }
  async function a(p) {
    const m = Oe(p, "type");
    if (!m) return [];
    const P = (await e.table("DOType").toArray()).find(
      (R) => R.attributes?.find((F) => F.name === "id" && F.value === m)
    );
    if (!P || !P.children) return [];
    const S = [];
    for (const R of P.children) {
      if (R.tagName !== "DA") continue;
      const F = await e.table("DA").get(R.id);
      F && S.push({
        id: F.id,
        name: Oe(F, "name") ?? "",
        type: Oe(F, "type") ?? "",
        bType: Oe(F, "bType") ?? "",
        fc: Oe(F, "fc") ?? "",
        dataObjectId: p.id
      });
    }
    return S;
  }
  async function l(p) {
    const m = await e.table("Private").toArray(), P = await e.table("DOS").toArray(), S = await e.table("DAS").toArray(), R = await e.table("SubscriberLNode").toArray();
    return Promise.all(
      p.map(async (F) => {
        const G = m.find(
          ($) => $.parent?.id === F.id && $.parent?.tagName === "LNode" && Oe($, "type") === "eIEC61850-6-100"
        );
        if (!G || !G.children)
          return { ...F, dataObjectSpecifications: [] };
        const oe = [];
        for (const $ of G.children) {
          if ($.tagName !== "DOS") continue;
          const O = P.find((de) => de.id === $.id);
          if (!O) continue;
          const I = [];
          if (O.children)
            for (const de of O.children) {
              if (de.tagName !== "DAS") continue;
              const Se = S.find((be) => be.id === de.id);
              if (!Se) continue;
              let ue;
              if (Se.children) {
                const be = Se.children.find((Le) => Le.tagName === "SubscriberLNode");
                if (be) {
                  const Le = R.find((Re) => Re.id === be.id);
                  Le && (ue = {
                    id: Le.id,
                    inputName: Oe(Le, "inputName") ?? "",
                    service: Uu(Le, "service"),
                    pLN: Oe(Le, "pLN") ?? ""
                  });
                }
              }
              I.push({
                id: Se.id,
                name: Oe(Se, "name") ?? "",
                desc: Oe(Se, "desc") ?? "",
                dataObjectSpecificationId: O.id,
                subscriberLNode: ue
              });
            }
          oe.push({
            id: O.id,
            name: Oe(O, "name") ?? "",
            desc: Oe(O, "desc") ?? "",
            dataAttributeSpecifications: I,
            lNodeId: F.id
          });
        }
        return { ...F, dataObjectSpecifications: oe };
      })
    );
  }
  async function f() {
    return (await e.table("LNode").toArray()).map((m) => ({
      id: m.id,
      uuid: Oe(m, "uuid") ?? "",
      iedName: Oe(m, "iedName") ?? "",
      prefix: Oe(m, "prefix") ?? "",
      lnClass: Oe(m, "lnClass") ?? "",
      lnInst: Oe(m, "lnInst") ?? "",
      lnType: Oe(m, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function Uu(e, t) {
  const o = e?.attributes?.find((a) => a.name === t)?.value;
  if (!o) return;
  switch (o.toUpperCase()) {
    case "GOOSE":
      return Ct.GOOSE;
    case "SMV":
      return Ct.SMV;
    case "REPORT":
      return Ct.REPORT;
    case "INTERNAL":
      return Ct.INTERNAL;
    case "WIRED":
      return Ct.WIRED;
    case "CONTROL":
      return Ct.CONTROL;
    default:
      return;
  }
}
async function ms(e) {
  try {
    const t = new No(e);
    return await t.open(), t;
  } catch (t) {
    throw console.error("Error opening database:", t), t;
  }
}
function ed(e) {
  const t = Vu(e);
  return {
    findAllExistingConnections: o,
    findAllExistingControlledConnections: i
  };
  async function o() {
    const a = await e.table("SourceRef").toArray();
    if (!a.length) return [];
    const l = [];
    for (const f of a) {
      if (!f.attributes) continue;
      const p = Oe(f, "sourceLNodeUuid"), m = await e.table("LNode").toArray().then(
        (R) => R.find(
          (F) => F.attributes?.some(
            (G) => G.name === "uuid" && G.value === p
          )
        )?.id
      ) || null, P = await t.findParentRecordsWithinDepthAndGivenTagName(
        f,
        3,
        ["LNode"]
      );
      if (P.length != 1) {
        const R = {
          msg: "LNode record not found for SourceRef id",
          id: f.id
        };
        throw console.error(R), new Error(JSON.stringify(R));
      }
      const S = {
        id: f.id,
        sourceLNodeId: m,
        destinationLNodeId: P[0].id,
        sourceDataObject: Oe(f, "sourceDoName") || "",
        sourceDataAttribute: Oe(f, "sourceDaName") || "",
        dataflowType: Uu(f, "service"),
        inputInstance: Oe(f, "inputInst") || "",
        input: Oe(f, "input") || "",
        preferredLNode: Oe(f, "pLN") || "",
        preferredDataObject: Oe(f, "pDO") || "",
        preferredDataAttribute: Oe(f, "pDA") || "",
        processResource: Oe(f, "resourceName") || ""
      };
      l.push(S);
    }
    return l;
  }
  async function i() {
    const a = await e.table("ControlRef").toArray();
    if (!a.length) return [];
    const l = [];
    for (const f of a) {
      if (!f.attributes) continue;
      const p = Oe(f, "controlledLNodeUuid"), m = Oe(f, "controlledDoName"), P = await e.table("LNode").toArray().then(
        (F) => F.find(
          (G) => G.attributes?.some(
            (oe) => oe.name === "uuid" && oe.value === p
          )
        )?.id
      ) || null, S = await t.findParentRecordsWithinDepthAndGivenTagName(
        f,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (S.length != 1) {
        const F = {
          msg: "LNode record not found for ControlRef id",
          id: f.id
        };
        throw console.error(F), new Error(JSON.stringify(F));
      }
      const R = {
        controllerLNodeId: S[0].id,
        controlledLNodeId: P,
        controlledDataObject: m || "",
        dataflowType: Ct.CONTROL,
        outputInstance: Oe(f, "outputInst") || "",
        outputName: Oe(f, "output") || ""
      };
      l.push(R);
    }
    return l;
  }
}
function ko(e) {
  return `${e.prefix} ${e.lnClass} ${e.lnInst}`;
}
const td = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, nd = { class: "col-start-1 col-span-1 self-center justify-self-end" }, rd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, od = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, id = ["data-testid"], sd = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, ad = { class: "col-start-5 col-span-1 self-center justify-self-start" }, ud = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, ld = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, cd = /* @__PURE__ */ an({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(e) {
    const t = e, o = kt(() => [...t.connections].sort((i, a) => i.dataflowType < a.dataflowType ? -1 : i.dataflowType > a.dataflowType ? 1 : 0));
    return (i, a) => (me(!0), xe(Be, null, Rt(o.value, (l, f) => (me(), xe("div", td, [
      K("div", nd, [
        K("span", rd, je(l.sourceDataObject), 1),
        K("span", od, je(l.sourceDataAttribute), 1)
      ]),
      a[0] || (a[0] = K("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      K("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-line-${f}`
      }, null, 8, id),
      a[1] || (a[1] = K("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        K("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      K("div", sd, je(l.dataflowType), 1),
      a[2] || (a[2] = K("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      K("div", ad, [
        K("span", ud, je(l.input), 1),
        K("span", ld, je(l.inputInstance), 1)
      ])
    ]))), 256));
  }
});
var Ro = /* @__PURE__ */ ((e) => (e.Connection = "connection", e.Placeholder = "placeholder", e))(Ro || {});
const Hu = /* @__PURE__ */ Wf("dataflow/sidebar", () => {
  const e = Ze(null);
  function t(o, i) {
    e.value = {
      type: o,
      element: i
    };
  }
  return {
    // state
    activeElement: e,
    // actions
    setActiveElement: t
  };
}), fd = ["onClick"], dd = ["data-testid"], pd = {
  height: "12",
  width: "8",
  class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
  xmlns: "http://www.w3.org/2000/svg"
}, hd = ["onClick"], md = { class: "col-start-5 col-span-1 self-center justify-self-start" }, yd = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, vd = /* @__PURE__ */ an({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(e) {
    const t = Hu();
    function o(a) {
      t.setActiveElement(Ro.Placeholder, a);
    }
    function i(a) {
      return t.activeElement?.type === Ro.Placeholder && t.activeElement?.element?.id === a.id;
    }
    return (a, l) => (me(!0), xe(Be, null, Rt(a.destinationPlaceHolderPorts, (f, p) => (me(), xe("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px] cursor-pointer",
      key: `destination-placeholder-port-${p}`
    }, [
      K("div", {
        class: "col-start-3 col-span-1 relative flex items-center row-start-1",
        onClick: (m) => o(f)
      }, [
        K("div", {
          class: kr(["h-[2px] bg-(--color-ocean-gray-100) absolute left-[80%] w-[20%]", {
            "bg-(--color-primary)": i(f)
          }]),
          "data-testid": `placeholder-line-${p}`
        }, null, 10, dd)
      ], 8, fd),
      (me(), xe("svg", pd, [
        K("polygon", {
          points: "0,0 8,6 0,12",
          style: Lo({
            fill: i(f) ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ])),
      K("div", {
        onClick: (m) => o(f),
        class: kr(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]", {
          "bg-(--color-primary)": i(f)
        }])
      }, null, 10, hd),
      K("div", md, [
        K("span", yd, je(f.input), 1)
      ])
    ]))), 128));
  }
});
function Wu(e) {
  const t = Vu(e);
  return {
    createConnection: o,
    createDestinationPlaceholder: i
  };
  async function o(a, l, f) {
    const p = await Ra(e, t, f);
    await gd(t, l, p, a);
  }
  async function i(a, l) {
    const f = await Ra(e, t, l), p = await bo(
      t,
      bd(a),
      f.namespace
    );
    await t.ensureRelationship(f, p);
  }
}
async function Ra(e, t, o) {
  const i = await e.table("LNode").get({ id: o.id });
  if (!i || !i.children || i.children.length == 0) {
    const p = {
      msg: `LNode element with uuid ${o.uuid} not found or empty`
    };
    throw console.error(p), new Error(JSON.stringify(p));
  }
  const a = await t.findChildRecordsByTagName(i, "Private");
  if (!a.filter((p) => Xf(p, "type")?.value === "eIEC61850-6-100").at(0)) {
    const p = {
      msg: `Private element of type 'eIEC61850-6-100' not found in LNode with uuid ${o.uuid}`
    };
    throw console.error(p), new Error(JSON.stringify(p));
  }
  const f = await t.findChildRecordsByTagName(
    a[0],
    "LNodeInputs"
  );
  if (f.length != 1) {
    const p = {
      msg: `LNodeInputs element not found or more than one element found in LNode with uuid ${o.uuid}`
    };
    throw console.error(p), new Error(JSON.stringify(p));
  }
  return f[0];
}
async function gd(e, t, o, i) {
  const a = await bo(
    e,
    Di(i, t),
    o.namespace
  );
  if (await e.ensureRelationship(o, a), i.includeQuality) {
    let l = structuredClone(Ae(i));
    l.attribute = "q";
    const f = await bo(
      e,
      Di(l, t),
      o.namespace
    );
    await e.ensureRelationship(o, f);
  }
  if (i.includeTimestamp) {
    let l = structuredClone(Ae(i));
    l.attribute = "t";
    const f = await bo(
      e,
      Di(l, t),
      o.namespace
    );
    await e.ensureRelationship(o, f);
  }
}
async function bo(e, t, o) {
  const i = {
    tagName: "SourceRef",
    namespace: o,
    attributes: [
      {
        name: "pLN",
        value: t.pLN
      },
      {
        name: "pDO",
        value: t.pDO
      },
      {
        name: "pDA",
        value: t.pDA
      },
      {
        name: "input",
        value: t.inputName
      },
      {
        name: "inputInst",
        value: t.inputInstance
      },
      {
        name: "service",
        value: t.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: t.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: t.sourceDoName
      },
      {
        name: "sourceDaName",
        value: t.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: t.resourceName
      },
      {
        name: "source",
        value: t.source
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(i);
}
function Di(e, t) {
  return {
    dataflowType: e.type,
    inputName: e.inputName,
    inputInstance: e.inputInstance,
    sourceLNodeUuid: t.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    source: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: e.signal,
    sourceDaName: e.attribute,
    pLN: t.lnClass,
    pDO: e.signal,
    pDA: e.attribute
  };
}
function bd(e) {
  return {
    dataflowType: e.dataflowType,
    inputName: e.inputName,
    inputInstance: "",
    sourceLNodeUuid: "",
    resourceName: e.processResource,
    source: "",
    sourceDoName: "",
    sourceDaName: "",
    pLN: e.preferredLNode,
    pDO: e.preferredDataObject,
    pDA: e.preferredDataAttribute
  };
}
const _d = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, wd = ["open"], xd = { class: "modal-box" }, Sd = { class: "grid grid-cols-2 gap-4 mt-4" }, Cd = { class: "grid grid-cols-2 gap-4 mt-4" }, Od = ["value", "disabled"], Ed = { class: "grid grid-cols-2 gap-4 mt-4" }, Pd = ["value"], Td = { class: "grid grid-cols-2 gap-4 mt-4" }, Nd = ["value"], Ad = { class: "grid grid-cols-2 gap-4 mt-4" }, kd = ["value"], Rd = { class: "grid grid-cols-2 gap-4 mt-4" }, Dd = /* @__PURE__ */ an({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["destinationPlaceholderCreated"],
  setup(e, { emit: t }) {
    const o = e, i = t, a = Ze(
      m()
    ), l = Ze(!1), f = kt(() => {
      const $ = o.lnodeTypes.find(
        (O) => O.lnClass === a.value.preferredLNode
      );
      return $ ? a.value.dataflowType ? $.dataObjects.filter(
        (O) => O.dataAttributes.some(
          (I) => Ao[a.value.dataflowType].includes(I.fc)
        )
      ).map((O) => O.name) : $.dataObjects.map((O) => O.name) : [];
    }), p = kt(() => {
      const $ = o.lnodeTypes.find(
        (I) => I.lnClass === a.value.preferredLNode
      );
      if (!$) return [];
      const O = $.dataObjects.find(
        (I) => I.name === a.value.preferredDataObject
      );
      return O ? a.value.dataflowType ? O.dataAttributes.filter(
        (I) => Ao[a.value.dataflowType].includes(I.fc)
      ).map((I) => I.name) : O.dataAttributes.map((I) => I.name) : [];
    });
    function m() {
      return {
        dataflowType: null,
        inputName: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    function P() {
      l.value = !0;
    }
    function S() {
      G(), l.value = !1;
    }
    async function R() {
      try {
        if (!F(a.value))
          return;
        const $ = localStorage.getItem("currentActiveFileDatabaseName");
        if (!$)
          throw new Error("no active file");
        const O = await ms($);
        await Wu(O).createDestinationPlaceholder(
          a.value,
          o.destinationLNode
        ), O.close(), i("destinationPlaceholderCreated"), S();
      } catch ($) {
        console.error("Error creating destination placeholder port:", $), alert(`Error creating placeholder: ${$ instanceof Error ? $.message : "Unknown error"}`);
      }
    }
    function F($) {
      return $.inputName ? !0 : (alert("Please enter an input name."), !1);
    }
    function G() {
      a.value = m();
    }
    function oe($) {
      for (const O of $)
        a.value[O] = "";
    }
    return ($, O) => (me(), xe("div", _d, [
      K("button", {
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center",
        onClick: P,
        "aria-label": "Add destination placeholder"
      }, O[9] || (O[9] = [
        K("svg", {
          width: "16px",
          height: "16px",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          K("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          K("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      K("dialog", {
        class: "modal",
        open: l.value
      }, [
        K("div", xd, [
          O[21] || (O[21] = K("h3", { class: "text-lg font-bold" }, "Create Placeholder - Receive data from", -1)),
          K("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: S,
            "aria-label": "Close destination placeholder creation"
          }, O[10] || (O[10] = [
            K("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              K("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          K("div", Sd, [
            O[11] || (O[11] = K("label", {
              for: "input-name-input",
              class: "col-start-1 self-center"
            }, "Input", -1)),
            ot(K("input", {
              id: "input-name-input",
              type: "text",
              placeholder: "Input Name",
              class: "input col-start-2",
              "onUpdate:modelValue": O[0] || (O[0] = (I) => a.value.inputName = I)
            }, null, 512), [
              [To, a.value.inputName]
            ])
          ]),
          K("div", Cd, [
            O[13] || (O[13] = K("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            ot(K("select", {
              id: "dataflow-type-select",
              class: "select col-start-2",
              "onUpdate:modelValue": O[1] || (O[1] = (I) => a.value.dataflowType = I),
              onChange: O[2] || (O[2] = (I) => oe(["preferredDataObject"]))
            }, [
              (me(!0), xe(Be, null, Rt(Object.values(Xe(Ct)), (I) => (me(), xe("option", {
                key: I,
                value: I,
                disabled: I === Xe(Ct).CONTROL
              }, je(I), 9, Od))), 128)),
              O[12] || (O[12] = K("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [en, a.value.dataflowType]
            ])
          ]),
          K("div", Ed, [
            O[15] || (O[15] = K("label", {
              for: "preferred-lnode-select",
              class: "col-start-1 self-center"
            }, "Preferred LNode", -1)),
            ot(K("select", {
              id: "preferred-lnode-select",
              class: "select col-start-2",
              "onUpdate:modelValue": O[3] || (O[3] = (I) => a.value.preferredLNode = I),
              onChange: O[4] || (O[4] = (I) => oe(["preferredDataObject"]))
            }, [
              (me(!0), xe(Be, null, Rt($.lnodeTypes, (I) => (me(), xe("option", {
                key: I.lnClass,
                value: I.lnClass
              }, je(I.lnClass), 9, Pd))), 128)),
              O[14] || (O[14] = K("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 544), [
              [en, a.value.preferredLNode]
            ])
          ]),
          K("div", Td, [
            O[17] || (O[17] = K("label", {
              for: "data-object-select",
              class: "col-start-1 self-center"
            }, "Preferred Data Object", -1)),
            ot(K("select", {
              id: "data-object-select",
              class: "select col-start-2",
              "onUpdate:modelValue": O[5] || (O[5] = (I) => a.value.preferredDataObject = I),
              onChange: O[6] || (O[6] = (I) => oe(["preferredDataAttribute"]))
            }, [
              (me(!0), xe(Be, null, Rt(f.value, (I) => (me(), xe("option", {
                key: I,
                value: I
              }, je(I), 9, Nd))), 128)),
              O[16] || (O[16] = K("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 544), [
              [en, a.value.preferredDataObject]
            ])
          ]),
          K("div", Ad, [
            O[19] || (O[19] = K("label", {
              for: "data-attribute-select",
              class: "col-start-1 self-center"
            }, "Preferred Data Attribute", -1)),
            ot(K("select", {
              id: "data-attribute-select",
              class: "select col-start-2",
              "onUpdate:modelValue": O[7] || (O[7] = (I) => a.value.preferredDataAttribute = I)
            }, [
              (me(!0), xe(Be, null, Rt(p.value, (I) => (me(), xe("option", {
                key: I,
                value: I
              }, je(I), 9, kd))), 128)),
              O[18] || (O[18] = K("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 512), [
              [en, a.value.preferredDataAttribute]
            ])
          ]),
          K("div", Rd, [
            O[20] || (O[20] = K("label", {
              for: "process-resource-input",
              class: "col-start-1 self-center"
            }, "Process Resource", -1)),
            ot(K("input", {
              id: "process-resource-input",
              type: "text",
              placeholder: "Process Resource",
              class: "input col-start-2",
              "onUpdate:modelValue": O[8] || (O[8] = (I) => a.value.processResource = I)
            }, null, 512), [
              [To, a.value.processResource]
            ])
          ]),
          K("div", { class: "modal-action" }, [
            K("button", {
              class: "btn bg-(--color-primary) border-none text-white",
              onClick: R
            }, " Save ")
          ])
        ])
      ], 8, wd)
    ]));
  }
}), Id = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, jd = { class: "col-start-1 col-span-1 self-center justify-self-end" }, Ld = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Kd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Md = ["data-testid"], Fd = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, $d = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Bd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, qd = /* @__PURE__ */ an({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(e) {
    return (t, o) => (me(!0), xe(Be, null, Rt(t.controlledConnections, (i, a) => (me(), xe("div", Id, [
      K("div", jd, [
        K("span", Ld, je(i.outputName), 1),
        K("span", Kd, je(i.outputInstance), 1)
      ]),
      o[0] || (o[0] = K("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      K("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-controlled-connection-line-${a}`
      }, null, 8, Md),
      o[1] || (o[1] = K("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        K("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      K("div", Fd, je(i.dataflowType), 1),
      o[2] || (o[2] = K("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      K("div", $d, [
        K("span", Bd, je(i.controlledDataObject), 1)
      ])
    ]))), 256));
  }
}), Vd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, Ud = ["value"], Hd = ["value"], Wd = ["value"], zd = ["value"], Gd = { class: "col-span-full row-start-2" }, Yd = /* @__PURE__ */ an({
  __name: "dataflow-visualisation",
  props: {
    lnodes: {},
    connections: {},
    lnodeTypes: {},
    controlledConnections: {}
  },
  emits: ["sourceLNodeChange", "destinationLNodeChange", "destinationPlaceholderCreated"],
  setup(e, { emit: t }) {
    const o = t, i = e;
    nn(
      () => i.lnodes,
      () => {
        a.value = void 0, l.value = void 0;
      }
    );
    const a = Ze(), l = Ze(), f = Ze(), p = Ze(), m = kt(
      () => i.lnodes.filter((O) => O.id !== l.value)
    ), P = kt(
      () => i.lnodes.filter((O) => O.id !== a.value)
    ), S = kt(() => !a.value || !l.value ? [] : i.connections.filter(
      (O) => O.sourceLNodeId === a.value && O.destinationLNodeId === l.value
    )), R = kt(() => !a.value || !l.value ? [] : i.controlledConnections.filter(
      (O) => O.controllerLNodeId === a.value && O.controlledLNodeId === l.value
    )), F = kt(() => l.value ? i.connections.filter(
      (O) => O.destinationLNodeId === l.value && !O.sourceLNodeId
    ) : []);
    function G(O) {
      return i.lnodes.find((I) => I.id === O) ?? void 0;
    }
    function oe(O) {
      a.value = O, f.value = G(O), o("sourceLNodeChange", O);
    }
    function $(O) {
      l.value = O, p.value = G(O), o("destinationLNodeChange", O);
    }
    return (O, I) => (me(), xe("div", Vd, [
      I[6] || (I[6] = K("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      K("select", {
        value: a.value ?? "",
        onChange: I[0] || (I[0] = (de) => oe(de.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        I[3] || (I[3] = Iu(" > ")),
        I[4] || (I[4] = K("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (me(!0), xe(Be, null, Rt(m.value, (de) => (me(), xe("option", {
          key: de.id,
          value: de.id
        }, je(Xe(ko)(de)), 9, Hd))), 128))
      ], 40, Ud),
      I[7] || (I[7] = K("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      K("select", {
        value: l.value ?? "",
        onChange: I[1] || (I[1] = (de) => $(de.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        I[5] || (I[5] = K("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (me(!0), xe(Be, null, Rt(P.value, (de) => (me(), xe("option", {
          key: de.id,
          value: de.id
        }, je(Xe(ko)(de)), 9, zd))), 128))
      ], 40, Wd),
      K("div", Gd, [
        S.value.length > 0 ? (me(), Mn(cd, {
          key: 0,
          connections: S.value
        }, null, 8, ["connections"])) : tn("", !0),
        R.value.length > 0 ? (me(), Mn(qd, {
          key: 1,
          controlledConnections: R.value
        }, null, 8, ["controlledConnections"])) : tn("", !0),
        F.value.length > 0 ? (me(), Mn(vd, {
          key: 2,
          destinationPlaceHolderPorts: F.value
        }, null, 8, ["destinationPlaceHolderPorts"])) : tn("", !0)
      ]),
      p.value ? (me(), Mn(Dd, {
        key: 0,
        destinationLNode: p.value,
        class: "col-span-full row-start-3",
        lnodeTypes: O.lnodeTypes,
        onDestinationPlaceholderCreated: I[2] || (I[2] = (de) => o("destinationPlaceholderCreated"))
      }, null, 8, ["destinationLNode", "lnodeTypes"])) : tn("", !0)
    ]));
  }
}), Qd = ["disabled"], Jd = ["open"], Xd = { class: "modal-box" }, Zd = { class: "grid grid-cols-2 gap-4 mt-4" }, ep = ["value"], tp = { class: "grid grid-cols-2 gap-4 mt-4" }, np = ["value"], rp = { class: "grid grid-cols-2 gap-4 mt-4" }, op = ["value"], ip = { class: "grid grid-cols-2 gap-4 mt-4" }, sp = ["value"], ap = { class: "grid grid-cols-2 gap-4 mt-4" }, up = ["value"], lp = { class: "grid grid-cols-2 gap-4 mt-4" }, cp = { class: "grid grid-cols-2 gap-4 mt-4" }, fp = { class: "mt-4" }, dp = { class: "mt-4" }, pp = /* @__PURE__ */ an({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const o = e, i = t, a = Ze(P()), l = Ze(!1);
    nn(
      () => a.value.signal,
      ($, O) => {
        a.value.inputName = $;
      }
    ), nn(
      () => a.value.inputName,
      () => {
        a.value.inputInstance = "1";
      }
    ), nn(
      () => a.value.type,
      () => {
        switch (a.value.type) {
          case Ct.GOOSE:
          case Ct.SMV:
            a.value.includeQuality = !0, a.value.includeTimestamp = !1;
            break;
          case Ct.REPORT:
            a.value.includeQuality = !0, a.value.includeTimestamp = !0;
            break;
          default:
            a.value.includeQuality = !1, a.value.includeTimestamp = !1;
        }
      }
    );
    const f = kt(() => !a.value.type || !o.sourceLNode ? [] : o.lnodeTypes.find(($) => $.typeId === o.sourceLNode?.lnType)?.dataObjects.filter(
      ($) => $.dataAttributes.some(
        (O) => Ao[a.value.type].includes(
          O.fc
        )
      )
    ).map(($) => $.name)), p = kt(() => !a.value.type || !o.sourceLNode ? [] : o.lnodeTypes.find(($) => $.typeId === o.sourceLNode?.lnType)?.dataObjects.find(($) => $.name === a.value.signal)?.dataAttributes.filter(
      ($) => Ao[a.value.type].includes(
        $.fc
      )
    ).filter(($) => $.name !== "t" && $.name !== "q").map(($) => $.name) || []);
    function m() {
      l.value = !0;
    }
    function P() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function S($) {
      for (const O of $)
        a.value[O] = "";
    }
    function R() {
      oe(), l.value = !1;
    }
    async function F() {
      try {
        if (!G(a.value))
          return;
        const $ = localStorage.getItem("currentActiveFileDatabaseName");
        if (!$)
          throw new Error("no active file");
        const O = await ms($);
        await Wu(O).createConnection(
          a.value,
          o.sourceLNode,
          o.destinationLNode
        ), O.close(), i("connectionCreated"), R();
      } catch ($) {
        console.error("Error creating dataflow:", $), alert(`Error creating dataflow: ${$ instanceof Error ? $.message : "Unknown error"}`);
      }
    }
    function G($) {
      return o.sourceLNode ? o.destinationLNode ? $.type ? $.signal ? $.attribute ? $.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1) : (alert("Please select a destination LNode."), !1) : (alert("Please select a source LNode."), !1);
    }
    function oe() {
      a.value = P();
    }
    return ($, O) => (me(), xe(Be, null, [
      K("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: m,
        disabled: !o.sourceLNode || !o.destinationLNode,
        "aria-label": "Add connection"
      }, " + ", 8, Qd),
      o.sourceLNode && o.destinationLNode ? (me(), xe("dialog", {
        key: 0,
        class: "modal",
        open: l.value
      }, [
        K("div", Xd, [
          O[24] || (O[24] = K("h3", { class: "text-lg font-bold" }, "Create Connection", -1)),
          K("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: R,
            "aria-label": "Close dataflow creation"
          }, O[11] || (O[11] = [
            K("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              K("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          K("div", Zd, [
            O[13] || (O[13] = K("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            ot(K("select", {
              id: "dataflow-type-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": O[0] || (O[0] = (I) => a.value.type = I),
              onChange: O[1] || (O[1] = (I) => S(["signal", "attribute"]))
            }, [
              (me(!0), xe(Be, null, Rt(Object.values(Xe(Ct)), (I) => (me(), xe("option", {
                key: I,
                value: I
              }, je(I), 9, ep))), 128)),
              O[12] || (O[12] = K("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [en, a.value.type]
            ])
          ]),
          O[25] || (O[25] = K("hr", { class: "solid mt-4" }, null, -1)),
          K("div", tp, [
            O[14] || (O[14] = K("label", {
              for: "source-select",
              class: "col-start-1 self-center"
            }, "Source", -1)),
            ot(K("select", {
              id: "source-select",
              required: "",
              disabled: "",
              class: "select col-start-2",
              "onUpdate:modelValue": O[2] || (O[2] = (I) => o.sourceLNode.id = I)
            }, [
              K("option", {
                value: o.sourceLNode.id
              }, je(Xe(ko)($.sourceLNode)), 9, np)
            ], 512), [
              [en, o.sourceLNode.id]
            ])
          ]),
          K("div", rp, [
            O[16] || (O[16] = K("label", {
              for: "data-object-select",
              class: "col-start-1 self-center"
            }, "Signal (DO)", -1)),
            ot(K("select", {
              id: "data-object-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": O[3] || (O[3] = (I) => a.value.signal = I),
              onChange: O[4] || (O[4] = (I) => S(["attribute"]))
            }, [
              (me(!0), xe(Be, null, Rt(f.value, (I) => (me(), xe("option", {
                key: I,
                value: I
              }, je(I), 9, op))), 128)),
              O[15] || (O[15] = K("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 544), [
              [en, a.value.signal]
            ])
          ]),
          K("div", ip, [
            O[18] || (O[18] = K("label", {
              for: "data-attribute-select",
              class: "col-start-1 self-center"
            }, "Attribute (DA)", -1)),
            ot(K("select", {
              id: "data-attribute-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": O[5] || (O[5] = (I) => a.value.attribute = I)
            }, [
              (me(!0), xe(Be, null, Rt(p.value, (I) => (me(), xe("option", {
                key: I,
                value: I
              }, je(I), 9, sp))), 128)),
              O[17] || (O[17] = K("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 512), [
              [en, a.value.attribute]
            ])
          ]),
          O[26] || (O[26] = K("hr", { class: "solid mt-4" }, null, -1)),
          K("div", ap, [
            O[19] || (O[19] = K("label", {
              for: "destination-select",
              class: "col-start-1 self-center"
            }, "Destination", -1)),
            ot(K("select", {
              id: "destination-select",
              required: "",
              disabled: "",
              class: "select col-start-2",
              "onUpdate:modelValue": O[6] || (O[6] = (I) => o.destinationLNode.id = I)
            }, [
              K("option", {
                value: o.destinationLNode.id
              }, je(Xe(ko)($.destinationLNode)), 9, up)
            ], 512), [
              [en, o.destinationLNode.id]
            ])
          ]),
          K("div", lp, [
            O[20] || (O[20] = K("label", {
              for: "input-name-input",
              class: "col-start-1 self-center"
            }, "Input Name", -1)),
            ot(K("input", {
              id: "input-name-input",
              required: "",
              type: "text",
              placeholder: "Input Name",
              class: "input col-start-2",
              "onUpdate:modelValue": O[7] || (O[7] = (I) => a.value.inputName = I)
            }, null, 512), [
              [To, a.value.inputName]
            ])
          ]),
          K("div", cp, [
            O[21] || (O[21] = K("label", {
              for: "input-instance-input",
              class: "col-start-1 self-center"
            }, "Input Instance", -1)),
            ot(K("input", {
              id: "input-instance-input",
              required: "",
              disabled: "",
              type: "text",
              class: "input col-start-2",
              "onUpdate:modelValue": O[8] || (O[8] = (I) => a.value.inputInstance = I)
            }, null, 512), [
              [To, a.value.inputInstance]
            ])
          ]),
          O[27] || (O[27] = K("hr", { class: "solid mt-4" }, null, -1)),
          K("div", fp, [
            ot(K("input", {
              type: "checkbox",
              "onUpdate:modelValue": O[9] || (O[9] = (I) => a.value.includeQuality = I),
              class: "checkbox mr-2",
              id: "checkbox-include-quality"
            }, null, 512), [
              [Sa, a.value.includeQuality]
            ]),
            O[22] || (O[22] = K("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
          ]),
          K("div", dp, [
            ot(K("input", {
              type: "checkbox",
              "onUpdate:modelValue": O[10] || (O[10] = (I) => a.value.includeTimestamp = I),
              class: "checkbox mr-2",
              id: "checkbox-include-timestamp"
            }, null, 512), [
              [Sa, a.value.includeTimestamp]
            ]),
            O[23] || (O[23] = K("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
          ]),
          K("div", { class: "modal-action" }, [
            K("button", {
              class: "btn bg-(--color-primary) border-none text-white",
              onClick: F
            }, " Save ")
          ])
        ])
      ], 8, Jd)) : tn("", !0)
    ], 64));
  }
}), hp = { class: "flex flex-col items-center justify-center w-full" }, mp = /* @__PURE__ */ an({
  __name: "dataflow-view",
  props: {
    sdks: {}
  },
  setup(e) {
    const t = e, o = Ze(), i = Ze(), a = Ze([]), l = Ze([]), f = Ze([]), p = Ze([]);
    nn(
      () => t.sdks,
      () => {
        m(), P(), S();
      },
      { immediate: !0 }
    );
    async function m() {
      t.sdks && (a.value = await t.sdks.lnodeSDK.findAllEnrichedLNodes(), l.value = await t.sdks.lnodeSDK.findAllLNodeTypes());
    }
    async function P() {
      t.sdks && (f.value = await t.sdks.connectionSDK.findAllExistingConnections());
    }
    async function S() {
      t.sdks && (p.value = await t.sdks.connectionSDK.findAllExistingControlledConnections());
    }
    function R(oe) {
      o.value = G(oe);
    }
    function F(oe) {
      i.value = G(oe);
    }
    function G(oe) {
      return a.value.find(($) => $.id === oe) ?? void 0;
    }
    return (oe, $) => (me(), xe("div", hp, [
      wt(Yd, {
        connections: f.value,
        controlledConnections: p.value,
        lnodes: a.value,
        lnodeTypes: l.value,
        onSourceLNodeChange: R,
        onDestinationLNodeChange: F,
        onDestinationPlaceholderCreated: P
      }, null, 8, ["connections", "controlledConnections", "lnodes", "lnodeTypes"]),
      wt(pp, {
        sourceLNode: o.value,
        destinationLNode: i.value,
        lnodeTypes: l.value,
        onConnectionCreated: P
      }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes"])
    ]));
  }
}), zu = (e, t) => {
  const o = e.__vccOpts || e;
  for (const [i, a] of t)
    o[i] = a;
  return o;
}, yp = {}, vp = { class: "layout" }, gp = { class: "main" }, bp = { class: "sidebar" };
function _p(e, t) {
  return me(), xe("div", vp, [
    K("div", gp, [
      Zs(e.$slots, "main", {}, void 0)
    ]),
    K("div", bp, [
      Zs(e.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const wp = /* @__PURE__ */ zu(yp, [["render", _p], ["__scopeId", "data-v-86088f9f"]]), xp = {
  name: "sidebar",
  class: "root"
}, Sp = { class: "tabs tabs-box" }, Cp = { key: 0 }, Op = { key: 0 }, Ep = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, Pp = { key: 1 }, Tp = /* @__PURE__ */ an({
  __name: "sidebar",
  setup(e) {
    const t = Ze("details"), o = Hu();
    return (i, a) => (me(), xe("div", xp, [
      K("div", Sp, [
        ot(K("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": a[0] || (a[0] = (l) => t.value = l),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [Oa, t.value]
        ]),
        ot(K("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": a[1] || (a[1] = (l) => t.value = l),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [Oa, t.value]
        ])
      ]),
      K("div", null, [
        t.value === "details" ? (me(), xe("div", Cp, [
          Xe(o).activeElement?.type === Xe(Ro).Placeholder ? (me(), xe("div", Op, [
            a[2] || (a[2] = K("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
            Xe(o).activeElement.element.dataflowType ? (me(), xe("span", Ep, je(Xe(o).activeElement.element.dataflowType), 1)) : tn("", !0),
            K("p", null, "Input: " + je(Xe(o).activeElement.element.input), 1),
            K("p", null, "Preferred LNode: " + je(Xe(o).activeElement.element.preferredLNode || "-"), 1),
            K("p", null, "Preferred DO: " + je(Xe(o).activeElement.element.preferredDataObject || "-"), 1),
            K("p", null, "Preferred DA: " + je(Xe(o).activeElement.element.preferredDataAttribute || "-"), 1),
            K("p", null, "Process Resource: " + je(Xe(o).activeElement.element.processResource || "-"), 1)
          ])) : tn("", !0)
        ])) : tn("", !0),
        t.value === "advanced" ? (me(), xe("div", Pp)) : tn("", !0)
      ])
    ]));
  }
}), Np = /* @__PURE__ */ zu(Tp, [["__scopeId", "data-v-d560451c"]]), Ap = ["id"], kp = { class: "p-10" }, Rp = /* @__PURE__ */ an({
  __name: "app",
  props: {
    api: {}
  },
  setup(e) {
    const t = "dataflow";
    let o = Ze();
    pu(() => {
      window.addEventListener("storage", i), a();
    }), cs(() => {
      window.removeEventListener("storage", i);
    });
    async function i(f) {
      if (f.key !== "currentActiveFileDatabaseName")
        return;
      const p = f.newValue;
      if (!p)
        throw new Error("incorrect active file name: " + p);
      await l(p);
    }
    async function a() {
      const f = localStorage.getItem("currentActiveFileDatabaseName");
      f && await l(f);
    }
    async function l(f) {
      o.value && o.value.db.close();
      const p = await ms(f);
      if (!p) throw new Error("database is not initialized.");
      o.value = {
        db: p,
        lnodeSDK: Zf(p),
        connectionSDK: ed(p)
      };
    }
    return (f, p) => (me(), xe("article", {
      id: Xe(t),
      style: { height: "100%" }
    }, [
      wt(wp, null, {
        main: Mi(() => [
          K("div", kp, [
            wt(mp, { sdks: Xe(o) }, null, 8, ["sdks"])
          ])
        ]),
        sidebar: Mi(() => [
          wt(Np)
        ]),
        _: 1
      })
    ], 8, Ap));
  }
});
function Up(e, t) {
  if (!document.getElementById(e)) {
    console.error({ msg: "could not found root element", rootId: e });
    return;
  }
  const i = Kf(Rp, { api: t });
  return i.use($f()), i.mount(`#${e}`), i.unmount;
}
export {
  Up as default
};
