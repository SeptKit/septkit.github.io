(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-86088f9f]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-86088f9f]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-86088f9f]{padding:1rem;height:100%}.root[data-v-d560451c]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-d560451c]{transition:all .2s}.tabs[data-v-d560451c]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-\\[1\\.5rem\\]{top:1.5rem}.right-\\[1\\.5rem\\]{right:1.5rem}.left-\\[80\\%\\]{left:80%}.-z-1{z-index:-1}.z-1{z-index:1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.min-h-\\[450px\\]{min-height:450px}.w-\\[20\\%\\]{width:20%}.w-\\[20px\\]{width:20px}.w-full{width:100%}.cursor-pointer{cursor:pointer}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-1{grid-template-rows:repeat(1,minmax(0,1fr))}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-white{color:var(--color-white)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Yi(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const o of e.split(",")) t[o] = 1;
  return (o) => o in t;
}
const Me = {}, nr = [], Ht = () => {
}, wu = () => !1, ko = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), Qi = (e) => e.startsWith("onUpdate:"), yt = Object.assign, Ji = (e, t) => {
  const o = e.indexOf(t);
  o > -1 && e.splice(o, 1);
}, xu = Object.prototype.hasOwnProperty, je = (e, t) => xu.call(e, t), fe = Array.isArray, rr = (e) => Fr(e) === "[object Map]", cr = (e) => Fr(e) === "[object Set]", Js = (e) => Fr(e) === "[object Date]", ge = (e) => typeof e == "function", Ze = (e) => typeof e == "string", Kt = (e) => typeof e == "symbol", qe = (e) => e !== null && typeof e == "object", La = (e) => (qe(e) || ge(e)) && ge(e.then) && ge(e.catch), Ka = Object.prototype.toString, Fr = (e) => Ka.call(e), Su = (e) => Fr(e).slice(8, -1), Ma = (e) => Fr(e) === "[object Object]", Xi = (e) => Ze(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Or = /* @__PURE__ */ Yi(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Io = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (o) => t[o] || (t[o] = e(o));
}, Cu = /-(\w)/g, On = Io(
  (e) => e.replace(Cu, (t, o) => o ? o.toUpperCase() : "")
), Ou = /\B([A-Z])/g, qn = Io(
  (e) => e.replace(Ou, "-$1").toLowerCase()
), Fa = Io((e) => e.charAt(0).toUpperCase() + e.slice(1)), Si = Io(
  (e) => e ? `on${Fa(e)}` : ""
), Sn = (e, t) => !Object.is(e, t), vo = (e, ...t) => {
  for (let o = 0; o < e.length; o++)
    e[o](...t);
}, ji = (e, t, o, i = !1) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: o
  });
}, xo = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
};
let Xs;
const jo = () => Xs || (Xs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Lo(e) {
  if (fe(e)) {
    const t = {};
    for (let o = 0; o < e.length; o++) {
      const i = e[o], a = Ze(i) ? Pu(i) : Lo(i);
      if (a)
        for (const u in a)
          t[u] = a[u];
    }
    return t;
  } else if (Ze(e) || qe(e))
    return e;
}
const Nu = /;(?![^(]*\))/g, Eu = /:([^]+)/, Tu = /\/\*[^]*?\*\//g;
function Pu(e) {
  const t = {};
  return e.replace(Tu, "").split(Nu).forEach((o) => {
    if (o) {
      const i = o.split(Eu);
      i.length > 1 && (t[i[0].trim()] = i[1].trim());
    }
  }), t;
}
function kr(e) {
  let t = "";
  if (Ze(e))
    t = e;
  else if (fe(e))
    for (let o = 0; o < e.length; o++) {
      const i = kr(e[o]);
      i && (t += i + " ");
    }
  else if (qe(e))
    for (const o in e)
      e[o] && (t += o + " ");
  return t.trim();
}
const Au = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Ru = /* @__PURE__ */ Yi(Au);
function $a(e) {
  return !!e || e === "";
}
function Du(e, t) {
  if (e.length !== t.length) return !1;
  let o = !0;
  for (let i = 0; o && i < e.length; i++)
    o = Bn(e[i], t[i]);
  return o;
}
function Bn(e, t) {
  if (e === t) return !0;
  let o = Js(e), i = Js(t);
  if (o || i)
    return o && i ? e.getTime() === t.getTime() : !1;
  if (o = Kt(e), i = Kt(t), o || i)
    return e === t;
  if (o = fe(e), i = fe(t), o || i)
    return o && i ? Du(e, t) : !1;
  if (o = qe(e), i = qe(t), o || i) {
    if (!o || !i)
      return !1;
    const a = Object.keys(e).length, u = Object.keys(t).length;
    if (a !== u)
      return !1;
    for (const f in e) {
      const p = e.hasOwnProperty(f), h = t.hasOwnProperty(f);
      if (p && !h || !p && h || !Bn(e[f], t[f]))
        return !1;
    }
  }
  return String(e) === String(t);
}
function Zi(e, t) {
  return e.findIndex((o) => Bn(o, t));
}
const Ba = (e) => !!(e && e.__v_isRef === !0), Ie = (e) => Ze(e) ? e : e == null ? "" : fe(e) || qe(e) && (e.toString === Ka || !ge(e.toString)) ? Ba(e) ? Ie(e.value) : JSON.stringify(e, qa, 2) : String(e), qa = (e, t) => Ba(t) ? qa(e, t.value) : rr(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (o, [i, a], u) => (o[Ci(i, u) + " =>"] = a, o),
    {}
  )
} : cr(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((o) => Ci(o))
} : Kt(t) ? Ci(t) : qe(t) && !fe(t) && !Ma(t) ? String(t) : t, Ci = (e, t = "") => {
  var o;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Kt(e) ? `Symbol(${(o = e.description) != null ? o : t})` : e
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let pt;
class Ua {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = pt, !t && pt && (this.index = (pt.scopes || (pt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, o;
      if (this.scopes)
        for (t = 0, o = this.scopes.length; t < o; t++)
          this.scopes[t].pause();
      for (t = 0, o = this.effects.length; t < o; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, o;
      if (this.scopes)
        for (t = 0, o = this.scopes.length; t < o; t++)
          this.scopes[t].resume();
      for (t = 0, o = this.effects.length; t < o; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const o = pt;
      try {
        return pt = this, t();
      } finally {
        pt = o;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = pt, pt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (pt = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let o, i;
      for (o = 0, i = this.effects.length; o < i; o++)
        this.effects[o].stop();
      for (this.effects.length = 0, o = 0, i = this.cleanups.length; o < i; o++)
        this.cleanups[o]();
      if (this.cleanups.length = 0, this.scopes) {
        for (o = 0, i = this.scopes.length; o < i; o++)
          this.scopes[o].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const a = this.parent.scopes.pop();
        a && a !== this && (this.parent.scopes[this.index] = a, a.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Va(e) {
  return new Ua(e);
}
function Ha() {
  return pt;
}
function ku(e, t = !1) {
  pt && pt.cleanups.push(e);
}
let Fe;
const Oi = /* @__PURE__ */ new WeakSet();
class Wa {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, pt && pt.active && pt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Oi.has(this) && (Oi.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Ga(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Zs(this), Ya(this);
    const t = Fe, o = Lt;
    Fe = this, Lt = !0;
    try {
      return this.fn();
    } finally {
      Qa(this), Fe = t, Lt = o, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        ns(t);
      this.deps = this.depsTail = void 0, Zs(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Oi.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Li(this) && this.run();
  }
  get dirty() {
    return Li(this);
  }
}
let za = 0, Nr, Er;
function Ga(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = Er, Er = e;
    return;
  }
  e.next = Nr, Nr = e;
}
function es() {
  za++;
}
function ts() {
  if (--za > 0)
    return;
  if (Er) {
    let t = Er;
    for (Er = void 0; t; ) {
      const o = t.next;
      t.next = void 0, t.flags &= -9, t = o;
    }
  }
  let e;
  for (; Nr; ) {
    let t = Nr;
    for (Nr = void 0; t; ) {
      const o = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (i) {
          e || (e = i);
        }
      t = o;
    }
  }
  if (e) throw e;
}
function Ya(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function Qa(e) {
  let t, o = e.depsTail, i = o;
  for (; i; ) {
    const a = i.prevDep;
    i.version === -1 ? (i === o && (o = a), ns(i), Iu(i)) : t = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = a;
  }
  e.deps = t, e.depsTail = o;
}
function Li(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (Ja(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function Ja(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Ir) || (e.globalVersion = Ir, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Li(e))))
    return;
  e.flags |= 2;
  const t = e.dep, o = Fe, i = Lt;
  Fe = e, Lt = !0;
  try {
    Ya(e);
    const a = e.fn(e._value);
    (t.version === 0 || Sn(a, e._value)) && (e.flags |= 128, e._value = a, t.version++);
  } catch (a) {
    throw t.version++, a;
  } finally {
    Fe = o, Lt = i, Qa(e), e.flags &= -3;
  }
}
function ns(e, t = !1) {
  const { dep: o, prevSub: i, nextSub: a } = e;
  if (i && (i.nextSub = a, e.prevSub = void 0), a && (a.prevSub = i, e.nextSub = void 0), o.subs === e && (o.subs = i, !i && o.computed)) {
    o.computed.flags &= -5;
    for (let u = o.computed.deps; u; u = u.nextDep)
      ns(u, !0);
  }
  !t && !--o.sc && o.map && o.map.delete(o.key);
}
function Iu(e) {
  const { prevDep: t, nextDep: o } = e;
  t && (t.nextDep = o, e.prevDep = void 0), o && (o.prevDep = t, e.nextDep = void 0);
}
let Lt = !0;
const Xa = [];
function on() {
  Xa.push(Lt), Lt = !1;
}
function sn() {
  const e = Xa.pop();
  Lt = e === void 0 ? !0 : e;
}
function Zs(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const o = Fe;
    Fe = void 0;
    try {
      t();
    } finally {
      Fe = o;
    }
  }
}
let Ir = 0;
class ju {
  constructor(t, o) {
    this.sub = t, this.dep = o, this.version = o.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class rs {
  // TODO isolatedDeclarations "__v_skip"
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(t) {
    if (!Fe || !Lt || Fe === this.computed)
      return;
    let o = this.activeLink;
    if (o === void 0 || o.sub !== Fe)
      o = this.activeLink = new ju(Fe, this), Fe.deps ? (o.prevDep = Fe.depsTail, Fe.depsTail.nextDep = o, Fe.depsTail = o) : Fe.deps = Fe.depsTail = o, Za(o);
    else if (o.version === -1 && (o.version = this.version, o.nextDep)) {
      const i = o.nextDep;
      i.prevDep = o.prevDep, o.prevDep && (o.prevDep.nextDep = i), o.prevDep = Fe.depsTail, o.nextDep = void 0, Fe.depsTail.nextDep = o, Fe.depsTail = o, Fe.deps === o && (Fe.deps = i);
    }
    return o;
  }
  trigger(t) {
    this.version++, Ir++, this.notify(t);
  }
  notify(t) {
    es();
    try {
      for (let o = this.subs; o; o = o.prevSub)
        o.sub.notify() && o.sub.dep.notify();
    } finally {
      ts();
    }
  }
}
function Za(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let i = t.deps; i; i = i.nextDep)
        Za(i);
    }
    const o = e.dep.subs;
    o !== e && (e.prevSub = o, o && (o.nextSub = e)), e.dep.subs = e;
  }
}
const So = /* @__PURE__ */ new WeakMap(), Fn = Symbol(
  ""
), Ki = Symbol(
  ""
), jr = Symbol(
  ""
);
function ht(e, t, o) {
  if (Lt && Fe) {
    let i = So.get(e);
    i || So.set(e, i = /* @__PURE__ */ new Map());
    let a = i.get(o);
    a || (i.set(o, a = new rs()), a.map = i, a.key = o), a.track();
  }
}
function Xt(e, t, o, i, a, u) {
  const f = So.get(e);
  if (!f) {
    Ir++;
    return;
  }
  const p = (h) => {
    h && h.trigger();
  };
  if (es(), t === "clear")
    f.forEach(p);
  else {
    const h = fe(e), N = h && Xi(o);
    if (h && o === "length") {
      const b = Number(i);
      f.forEach((C, A) => {
        (A === "length" || A === jr || !Kt(A) && A >= b) && p(C);
      });
    } else
      switch ((o !== void 0 || f.has(void 0)) && p(f.get(o)), N && p(f.get(jr)), t) {
        case "add":
          h ? N && p(f.get("length")) : (p(f.get(Fn)), rr(e) && p(f.get(Ki)));
          break;
        case "delete":
          h || (p(f.get(Fn)), rr(e) && p(f.get(Ki)));
          break;
        case "set":
          rr(e) && p(f.get(Fn));
          break;
      }
  }
  ts();
}
function Lu(e, t) {
  const o = So.get(e);
  return o && o.get(t);
}
function Zn(e) {
  const t = Ae(e);
  return t === e ? t : (ht(t, "iterate", jr), kt(e) ? t : t.map(it));
}
function Ko(e) {
  return ht(e = Ae(e), "iterate", jr), e;
}
const Ku = {
  __proto__: null,
  [Symbol.iterator]() {
    return Ni(this, Symbol.iterator, it);
  },
  concat(...e) {
    return Zn(this).concat(
      ...e.map((t) => fe(t) ? Zn(t) : t)
    );
  },
  entries() {
    return Ni(this, "entries", (e) => (e[1] = it(e[1]), e));
  },
  every(e, t) {
    return Qt(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return Qt(this, "filter", e, t, (o) => o.map(it), arguments);
  },
  find(e, t) {
    return Qt(this, "find", e, t, it, arguments);
  },
  findIndex(e, t) {
    return Qt(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return Qt(this, "findLast", e, t, it, arguments);
  },
  findLastIndex(e, t) {
    return Qt(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return Qt(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return Ei(this, "includes", e);
  },
  indexOf(...e) {
    return Ei(this, "indexOf", e);
  },
  join(e) {
    return Zn(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return Ei(this, "lastIndexOf", e);
  },
  map(e, t) {
    return Qt(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return xr(this, "pop");
  },
  push(...e) {
    return xr(this, "push", e);
  },
  reduce(e, ...t) {
    return ea(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return ea(this, "reduceRight", e, t);
  },
  shift() {
    return xr(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return Qt(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return xr(this, "splice", e);
  },
  toReversed() {
    return Zn(this).toReversed();
  },
  toSorted(e) {
    return Zn(this).toSorted(e);
  },
  toSpliced(...e) {
    return Zn(this).toSpliced(...e);
  },
  unshift(...e) {
    return xr(this, "unshift", e);
  },
  values() {
    return Ni(this, "values", it);
  }
};
function Ni(e, t, o) {
  const i = Ko(e), a = i[t]();
  return i !== e && !kt(e) && (a._next = a.next, a.next = () => {
    const u = a._next();
    return u.value && (u.value = o(u.value)), u;
  }), a;
}
const Mu = Array.prototype;
function Qt(e, t, o, i, a, u) {
  const f = Ko(e), p = f !== e && !kt(e), h = f[t];
  if (h !== Mu[t]) {
    const C = h.apply(e, u);
    return p ? it(C) : C;
  }
  let N = o;
  f !== e && (p ? N = function(C, A) {
    return o.call(this, it(C), A, e);
  } : o.length > 2 && (N = function(C, A) {
    return o.call(this, C, A, e);
  }));
  const b = h.call(f, N, i);
  return p && a ? a(b) : b;
}
function ea(e, t, o, i) {
  const a = Ko(e);
  let u = o;
  return a !== e && (kt(e) ? o.length > 3 && (u = function(f, p, h) {
    return o.call(this, f, p, h, e);
  }) : u = function(f, p, h) {
    return o.call(this, f, it(p), h, e);
  }), a[t](u, ...i);
}
function Ei(e, t, o) {
  const i = Ae(e);
  ht(i, "iterate", jr);
  const a = i[t](...o);
  return (a === -1 || a === !1) && ss(o[0]) ? (o[0] = Ae(o[0]), i[t](...o)) : a;
}
function xr(e, t, o = []) {
  on(), es();
  const i = Ae(e)[t].apply(e, o);
  return ts(), sn(), i;
}
const Fu = /* @__PURE__ */ Yi("__proto__,__v_isRef,__isVue"), el = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Kt)
);
function $u(e) {
  Kt(e) || (e = String(e));
  const t = Ae(this);
  return ht(t, "has", e), t.hasOwnProperty(e);
}
class tl {
  constructor(t = !1, o = !1) {
    this._isReadonly = t, this._isShallow = o;
  }
  get(t, o, i) {
    if (o === "__v_skip") return t.__v_skip;
    const a = this._isReadonly, u = this._isShallow;
    if (o === "__v_isReactive")
      return !a;
    if (o === "__v_isReadonly")
      return a;
    if (o === "__v_isShallow")
      return u;
    if (o === "__v_raw")
      return i === (a ? u ? Qu : il : u ? ol : rl).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0;
    const f = fe(t);
    if (!a) {
      let h;
      if (f && (h = Ku[o]))
        return h;
      if (o === "hasOwnProperty")
        return $u;
    }
    const p = Reflect.get(
      t,
      o,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Je(t) ? t : i
    );
    return (Kt(o) ? el.has(o) : Fu(o)) || (a || ht(t, "get", o), u) ? p : Je(p) ? f && Xi(o) ? p : p.value : qe(p) ? a ? sl(p) : Mo(p) : p;
  }
}
class nl extends tl {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, o, i, a) {
    let u = t[o];
    if (!this._isShallow) {
      const h = Nn(u);
      if (!kt(i) && !Nn(i) && (u = Ae(u), i = Ae(i)), !fe(t) && Je(u) && !Je(i))
        return h ? !1 : (u.value = i, !0);
    }
    const f = fe(t) && Xi(o) ? Number(o) < t.length : je(t, o), p = Reflect.set(
      t,
      o,
      i,
      Je(t) ? t : a
    );
    return t === Ae(a) && (f ? Sn(i, u) && Xt(t, "set", o, i) : Xt(t, "add", o, i)), p;
  }
  deleteProperty(t, o) {
    const i = je(t, o);
    t[o];
    const a = Reflect.deleteProperty(t, o);
    return a && i && Xt(t, "delete", o, void 0), a;
  }
  has(t, o) {
    const i = Reflect.has(t, o);
    return (!Kt(o) || !el.has(o)) && ht(t, "has", o), i;
  }
  ownKeys(t) {
    return ht(
      t,
      "iterate",
      fe(t) ? "length" : Fn
    ), Reflect.ownKeys(t);
  }
}
class Bu extends tl {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, o) {
    return !0;
  }
  deleteProperty(t, o) {
    return !0;
  }
}
const qu = /* @__PURE__ */ new nl(), Uu = /* @__PURE__ */ new Bu(), Vu = /* @__PURE__ */ new nl(!0);
const Mi = (e) => e, ho = (e) => Reflect.getPrototypeOf(e);
function Hu(e, t, o) {
  return function(...i) {
    const a = this.__v_raw, u = Ae(a), f = rr(u), p = e === "entries" || e === Symbol.iterator && f, h = e === "keys" && f, N = a[e](...i), b = o ? Mi : t ? Co : it;
    return !t && ht(
      u,
      "iterate",
      h ? Ki : Fn
    ), {
      // iterator protocol
      next() {
        const { value: C, done: A } = N.next();
        return A ? { value: C, done: A } : {
          value: p ? [b(C[0]), b(C[1])] : b(C),
          done: A
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function mo(e) {
  return function(...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function Wu(e, t) {
  const o = {
    get(a) {
      const u = this.__v_raw, f = Ae(u), p = Ae(a);
      e || (Sn(a, p) && ht(f, "get", a), ht(f, "get", p));
      const { has: h } = ho(f), N = t ? Mi : e ? Co : it;
      if (h.call(f, a))
        return N(u.get(a));
      if (h.call(f, p))
        return N(u.get(p));
      u !== f && u.get(a);
    },
    get size() {
      const a = this.__v_raw;
      return !e && ht(Ae(a), "iterate", Fn), Reflect.get(a, "size", a);
    },
    has(a) {
      const u = this.__v_raw, f = Ae(u), p = Ae(a);
      return e || (Sn(a, p) && ht(f, "has", a), ht(f, "has", p)), a === p ? u.has(a) : u.has(a) || u.has(p);
    },
    forEach(a, u) {
      const f = this, p = f.__v_raw, h = Ae(p), N = t ? Mi : e ? Co : it;
      return !e && ht(h, "iterate", Fn), p.forEach((b, C) => a.call(u, N(b), N(C), f));
    }
  };
  return yt(
    o,
    e ? {
      add: mo("add"),
      set: mo("set"),
      delete: mo("delete"),
      clear: mo("clear")
    } : {
      add(a) {
        !t && !kt(a) && !Nn(a) && (a = Ae(a));
        const u = Ae(this);
        return ho(u).has.call(u, a) || (u.add(a), Xt(u, "add", a, a)), this;
      },
      set(a, u) {
        !t && !kt(u) && !Nn(u) && (u = Ae(u));
        const f = Ae(this), { has: p, get: h } = ho(f);
        let N = p.call(f, a);
        N || (a = Ae(a), N = p.call(f, a));
        const b = h.call(f, a);
        return f.set(a, u), N ? Sn(u, b) && Xt(f, "set", a, u) : Xt(f, "add", a, u), this;
      },
      delete(a) {
        const u = Ae(this), { has: f, get: p } = ho(u);
        let h = f.call(u, a);
        h || (a = Ae(a), h = f.call(u, a)), p && p.call(u, a);
        const N = u.delete(a);
        return h && Xt(u, "delete", a, void 0), N;
      },
      clear() {
        const a = Ae(this), u = a.size !== 0, f = a.clear();
        return u && Xt(
          a,
          "clear",
          void 0,
          void 0
        ), f;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((a) => {
    o[a] = Hu(a, e, t);
  }), o;
}
function os(e, t) {
  const o = Wu(e, t);
  return (i, a, u) => a === "__v_isReactive" ? !e : a === "__v_isReadonly" ? e : a === "__v_raw" ? i : Reflect.get(
    je(o, a) && a in i ? o : i,
    a,
    u
  );
}
const zu = {
  get: /* @__PURE__ */ os(!1, !1)
}, Gu = {
  get: /* @__PURE__ */ os(!1, !0)
}, Yu = {
  get: /* @__PURE__ */ os(!0, !1)
};
const rl = /* @__PURE__ */ new WeakMap(), ol = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), Qu = /* @__PURE__ */ new WeakMap();
function Ju(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Xu(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : Ju(Su(e));
}
function Mo(e) {
  return Nn(e) ? e : is(
    e,
    !1,
    qu,
    zu,
    rl
  );
}
function Zu(e) {
  return is(
    e,
    !1,
    Vu,
    Gu,
    ol
  );
}
function sl(e) {
  return is(
    e,
    !0,
    Uu,
    Yu,
    il
  );
}
function is(e, t, o, i, a) {
  if (!qe(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const u = Xu(e);
  if (u === 0)
    return e;
  const f = a.get(e);
  if (f)
    return f;
  const p = new Proxy(
    e,
    u === 2 ? i : o
  );
  return a.set(e, p), p;
}
function Cn(e) {
  return Nn(e) ? Cn(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Nn(e) {
  return !!(e && e.__v_isReadonly);
}
function kt(e) {
  return !!(e && e.__v_isShallow);
}
function ss(e) {
  return e ? !!e.__v_raw : !1;
}
function Ae(e) {
  const t = e && e.__v_raw;
  return t ? Ae(t) : e;
}
function as(e) {
  return !je(e, "__v_skip") && Object.isExtensible(e) && ji(e, "__v_skip", !0), e;
}
const it = (e) => qe(e) ? Mo(e) : e, Co = (e) => qe(e) ? sl(e) : e;
function Je(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Qe(e) {
  return ec(e, !1);
}
function ec(e, t) {
  return Je(e) ? e : new tc(e, t);
}
class tc {
  constructor(t, o) {
    this.dep = new rs(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = o ? t : Ae(t), this._value = o ? t : it(t), this.__v_isShallow = o;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(t) {
    const o = this._rawValue, i = this.__v_isShallow || kt(t) || Nn(t);
    t = i ? t : Ae(t), Sn(t, o) && (this._rawValue = t, this._value = i ? t : it(t), this.dep.trigger());
  }
}
function He(e) {
  return Je(e) ? e.value : e;
}
const nc = {
  get: (e, t, o) => t === "__v_raw" ? e : He(Reflect.get(e, t, o)),
  set: (e, t, o, i) => {
    const a = e[t];
    return Je(a) && !Je(o) ? (a.value = o, !0) : Reflect.set(e, t, o, i);
  }
};
function al(e) {
  return Cn(e) ? e : new Proxy(e, nc);
}
function rc(e) {
  const t = fe(e) ? new Array(e.length) : {};
  for (const o in e)
    t[o] = ic(e, o);
  return t;
}
class oc {
  constructor(t, o, i) {
    this._object = t, this._key = o, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return Lu(Ae(this._object), this._key);
  }
}
function ic(e, t, o) {
  const i = e[t];
  return Je(i) ? i : new oc(e, t, o);
}
class sc {
  constructor(t, o, i) {
    this.fn = t, this.setter = o, this._value = void 0, this.dep = new rs(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Ir - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !o, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Fe !== this)
      return Ga(this, !0), !0;
  }
  get value() {
    const t = this.dep.track();
    return Ja(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter && this.setter(t);
  }
}
function ac(e, t, o = !1) {
  let i, a;
  return ge(e) ? i = e : (i = e.get, a = e.set), new sc(i, a, o);
}
const yo = {}, Oo = /* @__PURE__ */ new WeakMap();
let Mn;
function lc(e, t = !1, o = Mn) {
  if (o) {
    let i = Oo.get(o);
    i || Oo.set(o, i = []), i.push(e);
  }
}
function uc(e, t, o = Me) {
  const { immediate: i, deep: a, once: u, scheduler: f, augmentJob: p, call: h } = o, N = (le) => a ? le : kt(le) || a === !1 || a === 0 ? Zt(le, 1) : Zt(le);
  let b, C, A, I, G = !1, re = !1;
  if (Je(e) ? (C = () => e.value, G = kt(e)) : Cn(e) ? (C = () => N(e), G = !0) : fe(e) ? (re = !0, G = e.some((le) => Cn(le) || kt(le)), C = () => e.map((le) => {
    if (Je(le))
      return le.value;
    if (Cn(le))
      return N(le);
    if (ge(le))
      return h ? h(le, 2) : le();
  })) : ge(e) ? t ? C = h ? () => h(e, 2) : e : C = () => {
    if (A) {
      on();
      try {
        A();
      } finally {
        sn();
      }
    }
    const le = Mn;
    Mn = b;
    try {
      return h ? h(e, 3, [I]) : e(I);
    } finally {
      Mn = le;
    }
  } : C = Ht, t && a) {
    const le = C, _e = a === !0 ? 1 / 0 : a;
    C = () => Zt(le(), _e);
  }
  const F = Ha(), U = () => {
    b.stop(), F && F.active && Ji(F.effects, b);
  };
  if (u && t) {
    const le = t;
    t = (..._e) => {
      le(..._e), U();
    };
  }
  let pe = re ? new Array(e.length).fill(yo) : yo;
  const Se = (le) => {
    if (!(!(b.flags & 1) || !b.dirty && !le))
      if (t) {
        const _e = b.run();
        if (a || G || (re ? _e.some((Ke, De) => Sn(Ke, pe[De])) : Sn(_e, pe))) {
          A && A();
          const Ke = Mn;
          Mn = b;
          try {
            const De = [
              _e,
              // pass undefined as the old value when it's changed for the first time
              pe === yo ? void 0 : re && pe[0] === yo ? [] : pe,
              I
            ];
            pe = _e, h ? h(t, 3, De) : (
              // @ts-expect-error
              t(...De)
            );
          } finally {
            Mn = Ke;
          }
        }
      } else
        b.run();
  };
  return p && p(Se), b = new Wa(C), b.scheduler = f ? () => f(Se, !1) : Se, I = (le) => lc(le, !1, b), A = b.onStop = () => {
    const le = Oo.get(b);
    if (le) {
      if (h)
        h(le, 4);
      else
        for (const _e of le) _e();
      Oo.delete(b);
    }
  }, t ? i ? Se(!0) : pe = b.run() : f ? f(Se.bind(null, !0), !0) : b.run(), U.pause = b.pause.bind(b), U.resume = b.resume.bind(b), U.stop = U, U;
}
function Zt(e, t = 1 / 0, o) {
  if (t <= 0 || !qe(e) || e.__v_skip || (o = o || /* @__PURE__ */ new Set(), o.has(e)))
    return e;
  if (o.add(e), t--, Je(e))
    Zt(e.value, t, o);
  else if (fe(e))
    for (let i = 0; i < e.length; i++)
      Zt(e[i], t, o);
  else if (cr(e) || rr(e))
    e.forEach((i) => {
      Zt(i, t, o);
    });
  else if (Ma(e)) {
    for (const i in e)
      Zt(e[i], t, o);
    for (const i of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, i) && Zt(e[i], t, o);
  }
  return e;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function $r(e, t, o, i) {
  try {
    return i ? e(...i) : e();
  } catch (a) {
    Fo(a, t, o);
  }
}
function Wt(e, t, o, i) {
  if (ge(e)) {
    const a = $r(e, t, o, i);
    return a && La(a) && a.catch((u) => {
      Fo(u, t, o);
    }), a;
  }
  if (fe(e)) {
    const a = [];
    for (let u = 0; u < e.length; u++)
      a.push(Wt(e[u], t, o, i));
    return a;
  }
}
function Fo(e, t, o, i = !0) {
  const a = t ? t.vnode : null, { errorHandler: u, throwUnhandledErrorInProduction: f } = t && t.appContext.config || Me;
  if (t) {
    let p = t.parent;
    const h = t.proxy, N = `https://vuejs.org/error-reference/#runtime-${o}`;
    for (; p; ) {
      const b = p.ec;
      if (b) {
        for (let C = 0; C < b.length; C++)
          if (b[C](e, h, N) === !1)
            return;
      }
      p = p.parent;
    }
    if (u) {
      on(), $r(u, null, 10, [
        e,
        h,
        N
      ]), sn();
      return;
    }
  }
  cc(e, o, a, i, f);
}
function cc(e, t, o, i = !0, a = !1) {
  if (a)
    throw e;
  console.error(e);
}
const wt = [];
let Ut = -1;
const or = [];
let _n = null, tr = 0;
const ll = /* @__PURE__ */ Promise.resolve();
let No = null;
function ls(e) {
  const t = No || ll;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function fc(e) {
  let t = Ut + 1, o = wt.length;
  for (; t < o; ) {
    const i = t + o >>> 1, a = wt[i], u = Lr(a);
    u < e || u === e && a.flags & 2 ? t = i + 1 : o = i;
  }
  return t;
}
function us(e) {
  if (!(e.flags & 1)) {
    const t = Lr(e), o = wt[wt.length - 1];
    !o || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= Lr(o) ? wt.push(e) : wt.splice(fc(t), 0, e), e.flags |= 1, ul();
  }
}
function ul() {
  No || (No = ll.then(fl));
}
function dc(e) {
  fe(e) ? or.push(...e) : _n && e.id === -1 ? _n.splice(tr + 1, 0, e) : e.flags & 1 || (or.push(e), e.flags |= 1), ul();
}
function ta(e, t, o = Ut + 1) {
  for (; o < wt.length; o++) {
    const i = wt[o];
    if (i && i.flags & 2) {
      if (e && i.id !== e.uid)
        continue;
      wt.splice(o, 1), o--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function cl(e) {
  if (or.length) {
    const t = [...new Set(or)].sort(
      (o, i) => Lr(o) - Lr(i)
    );
    if (or.length = 0, _n) {
      _n.push(...t);
      return;
    }
    for (_n = t, tr = 0; tr < _n.length; tr++) {
      const o = _n[tr];
      o.flags & 4 && (o.flags &= -2), o.flags & 8 || o(), o.flags &= -2;
    }
    _n = null, tr = 0;
  }
}
const Lr = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function fl(e) {
  try {
    for (Ut = 0; Ut < wt.length; Ut++) {
      const t = wt[Ut];
      t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), $r(
        t,
        t.i,
        t.i ? 15 : 14
      ), t.flags & 4 || (t.flags &= -2));
    }
  } finally {
    for (; Ut < wt.length; Ut++) {
      const t = wt[Ut];
      t && (t.flags &= -2);
    }
    Ut = -1, wt.length = 0, cl(), No = null, (wt.length || or.length) && fl();
  }
}
let at = null, dl = null;
function Eo(e) {
  const t = at;
  return at = e, dl = e && e.type.__scopeId || null, t;
}
function Fi(e, t = at, o) {
  if (!t || e._n)
    return e;
  const i = (...a) => {
    i._d && fa(-1);
    const u = Eo(t);
    let f;
    try {
      f = e(...a);
    } finally {
      Eo(u), i._d && fa(1);
    }
    return f;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function ot(e, t) {
  if (at === null)
    return e;
  const o = Uo(at), i = e.dirs || (e.dirs = []);
  for (let a = 0; a < t.length; a++) {
    let [u, f, p, h = Me] = t[a];
    u && (ge(u) && (u = {
      mounted: u,
      updated: u
    }), u.deep && Zt(f), i.push({
      dir: u,
      instance: o,
      value: f,
      oldValue: void 0,
      arg: p,
      modifiers: h
    }));
  }
  return e;
}
function Ln(e, t, o, i) {
  const a = e.dirs, u = t && t.dirs;
  for (let f = 0; f < a.length; f++) {
    const p = a[f];
    u && (p.oldValue = u[f].value);
    let h = p.dir[i];
    h && (on(), Wt(h, o, 8, [
      e.el,
      p,
      e,
      t
    ]), sn());
  }
}
const pc = Symbol("_vte"), hc = (e) => e.__isTeleport;
function cs(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, cs(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Mt(e, t) {
  return ge(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    yt({ name: e.name }, t, { setup: e })
  ) : e;
}
function pl(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function Tr(e, t, o, i, a = !1) {
  if (fe(e)) {
    e.forEach(
      (G, re) => Tr(
        G,
        t && (fe(t) ? t[re] : t),
        o,
        i,
        a
      )
    );
    return;
  }
  if (ir(i) && !a) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && Tr(e, t, o, i.component.subTree);
    return;
  }
  const u = i.shapeFlag & 4 ? Uo(i.component) : i.el, f = a ? null : u, { i: p, r: h } = e, N = t && t.r, b = p.refs === Me ? p.refs = {} : p.refs, C = p.setupState, A = Ae(C), I = C === Me ? () => !1 : (G) => je(A, G);
  if (N != null && N !== h && (Ze(N) ? (b[N] = null, I(N) && (C[N] = null)) : Je(N) && (N.value = null)), ge(h))
    $r(h, p, 12, [f, b]);
  else {
    const G = Ze(h), re = Je(h);
    if (G || re) {
      const F = () => {
        if (e.f) {
          const U = G ? I(h) ? C[h] : b[h] : h.value;
          a ? fe(U) && Ji(U, u) : fe(U) ? U.includes(u) || U.push(u) : G ? (b[h] = [u], I(h) && (C[h] = b[h])) : (h.value = [u], e.k && (b[e.k] = h.value));
        } else G ? (b[h] = f, I(h) && (C[h] = f)) : re && (h.value = f, e.k && (b[e.k] = f));
      };
      f ? (F.id = -1, Et(F, o)) : F();
    }
  }
}
jo().requestIdleCallback;
jo().cancelIdleCallback;
const ir = (e) => !!e.type.__asyncLoader, hl = (e) => e.type.__isKeepAlive;
function mc(e, t) {
  ml(e, "a", t);
}
function yc(e, t) {
  ml(e, "da", t);
}
function ml(e, t, o = mt) {
  const i = e.__wdc || (e.__wdc = () => {
    let a = o;
    for (; a; ) {
      if (a.isDeactivated)
        return;
      a = a.parent;
    }
    return e();
  });
  if ($o(t, i, o), o) {
    let a = o.parent;
    for (; a && a.parent; )
      hl(a.parent.vnode) && vc(i, t, o, a), a = a.parent;
  }
}
function vc(e, t, o, i) {
  const a = $o(
    t,
    e,
    i,
    !0
    /* prepend */
  );
  fs(() => {
    Ji(i[t], a);
  }, o);
}
function $o(e, t, o = mt, i = !1) {
  if (o) {
    const a = o[e] || (o[e] = []), u = t.__weh || (t.__weh = (...f) => {
      on();
      const p = Br(o), h = Wt(t, o, e, f);
      return p(), sn(), h;
    });
    return i ? a.unshift(u) : a.push(u), u;
  }
}
const ln = (e) => (t, o = mt) => {
  (!Mr || e === "sp") && $o(e, (...i) => t(...i), o);
}, gc = ln("bm"), yl = ln("m"), bc = ln(
  "bu"
), _c = ln("u"), wc = ln(
  "bum"
), fs = ln("um"), xc = ln(
  "sp"
), Sc = ln("rtg"), Cc = ln("rtc");
function Oc(e, t = mt) {
  $o("ec", e, t);
}
const Nc = Symbol.for("v-ndc");
function Tt(e, t, o, i) {
  let a;
  const u = o, f = fe(e);
  if (f || Ze(e)) {
    const p = f && Cn(e);
    let h = !1, N = !1;
    p && (h = !kt(e), N = Nn(e), e = Ko(e)), a = new Array(e.length);
    for (let b = 0, C = e.length; b < C; b++)
      a[b] = t(
        h ? N ? Co(it(e[b])) : it(e[b]) : e[b],
        b,
        void 0,
        u
      );
  } else if (typeof e == "number") {
    a = new Array(e);
    for (let p = 0; p < e; p++)
      a[p] = t(p + 1, p, void 0, u);
  } else if (qe(e))
    if (e[Symbol.iterator])
      a = Array.from(
        e,
        (p, h) => t(p, h, void 0, u)
      );
    else {
      const p = Object.keys(e);
      a = new Array(p.length);
      for (let h = 0, N = p.length; h < N; h++) {
        const b = p[h];
        a[h] = t(e[b], b, h, u);
      }
    }
  else
    a = [];
  return a;
}
function na(e, t, o = {}, i, a) {
  if (at.ce || at.parent && ir(at.parent) && at.parent.ce)
    return t !== "default" && (o.name = t), de(), tn(
      Le,
      null,
      [xt("slot", o, i)],
      64
    );
  let u = e[t];
  u && u._c && (u._d = !1), de();
  const f = u && vl(u(o)), p = o.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  f && f.key, h = tn(
    Le,
    {
      key: (p && !Kt(p) ? p : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!f && i ? "_fb" : "")
    },
    f || [],
    f && e._ === 1 ? 64 : -2
  );
  return u && u._c && (u._d = !0), h;
}
function vl(e) {
  return e.some((t) => ms(t) ? !(t.type === an || t.type === Le && !vl(t.children)) : !0) ? e : null;
}
const $i = (e) => e ? Ml(e) ? Uo(e) : $i(e.parent) : null, Pr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ yt(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => $i(e.parent),
    $root: (e) => $i(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => bl(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      us(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = ls.bind(e.proxy)),
    $watch: (e) => Yc.bind(e)
  })
), Ti = (e, t) => e !== Me && !e.__isScriptSetup && je(e, t), Ec = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return !0;
    const { ctx: o, setupState: i, data: a, props: u, accessCache: f, type: p, appContext: h } = e;
    let N;
    if (t[0] !== "$") {
      const I = f[t];
      if (I !== void 0)
        switch (I) {
          case 1:
            return i[t];
          case 2:
            return a[t];
          case 4:
            return o[t];
          case 3:
            return u[t];
        }
      else {
        if (Ti(i, t))
          return f[t] = 1, i[t];
        if (a !== Me && je(a, t))
          return f[t] = 2, a[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (N = e.propsOptions[0]) && je(N, t)
        )
          return f[t] = 3, u[t];
        if (o !== Me && je(o, t))
          return f[t] = 4, o[t];
        Bi && (f[t] = 0);
      }
    }
    const b = Pr[t];
    let C, A;
    if (b)
      return t === "$attrs" && ht(e.attrs, "get", ""), b(e);
    if (
      // css module (injected by vue-loader)
      (C = p.__cssModules) && (C = C[t])
    )
      return C;
    if (o !== Me && je(o, t))
      return f[t] = 4, o[t];
    if (
      // global properties
      A = h.config.globalProperties, je(A, t)
    )
      return A[t];
  },
  set({ _: e }, t, o) {
    const { data: i, setupState: a, ctx: u } = e;
    return Ti(a, t) ? (a[t] = o, !0) : i !== Me && je(i, t) ? (i[t] = o, !0) : je(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (u[t] = o, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: o, ctx: i, appContext: a, propsOptions: u }
  }, f) {
    let p;
    return !!o[f] || e !== Me && je(e, f) || Ti(t, f) || (p = u[0]) && je(p, f) || je(i, f) || je(Pr, f) || je(a.config.globalProperties, f);
  },
  defineProperty(e, t, o) {
    return o.get != null ? e._.accessCache[t] = 0 : je(o, "value") && this.set(e, t, o.value, null), Reflect.defineProperty(e, t, o);
  }
};
function ra(e) {
  return fe(e) ? e.reduce(
    (t, o) => (t[o] = null, t),
    {}
  ) : e;
}
let Bi = !0;
function Tc(e) {
  const t = bl(e), o = e.proxy, i = e.ctx;
  Bi = !1, t.beforeCreate && oa(t.beforeCreate, e, "bc");
  const {
    // state
    data: a,
    computed: u,
    methods: f,
    watch: p,
    provide: h,
    inject: N,
    // lifecycle
    created: b,
    beforeMount: C,
    mounted: A,
    beforeUpdate: I,
    updated: G,
    activated: re,
    deactivated: F,
    beforeDestroy: U,
    beforeUnmount: pe,
    destroyed: Se,
    unmounted: le,
    render: _e,
    renderTracked: Ke,
    renderTriggered: De,
    errorCaptured: xe,
    serverPrefetch: Ne,
    // public API
    expose: Ve,
    inheritAttrs: vt,
    // assets
    components: lt,
    directives: ut,
    filters: Tn
  } = t;
  if (N && Pc(N, i, null), f)
    for (const we in f) {
      const Ee = f[we];
      ge(Ee) && (i[we] = Ee.bind(o));
    }
  if (a) {
    const we = a.call(o, o);
    qe(we) && (e.data = Mo(we));
  }
  if (Bi = !0, u)
    for (const we in u) {
      const Ee = u[we], St = ge(Ee) ? Ee.bind(o, o) : ge(Ee.get) ? Ee.get.bind(o, o) : Ht, Ct = !ge(Ee) && ge(Ee.set) ? Ee.set.bind(o) : Ht, jt = Ot({
        get: St,
        set: Ct
      });
      Object.defineProperty(i, we, {
        enumerable: !0,
        configurable: !0,
        get: () => jt.value,
        set: (At) => jt.value = At
      });
    }
  if (p)
    for (const we in p)
      gl(p[we], i, o, we);
  if (h) {
    const we = ge(h) ? h.call(o) : h;
    Reflect.ownKeys(we).forEach((Ee) => {
      jc(Ee, we[Ee]);
    });
  }
  b && oa(b, e, "c");
  function $e(we, Ee) {
    fe(Ee) ? Ee.forEach((St) => we(St.bind(o))) : Ee && we(Ee.bind(o));
  }
  if ($e(gc, C), $e(yl, A), $e(bc, I), $e(_c, G), $e(mc, re), $e(yc, F), $e(Oc, xe), $e(Cc, Ke), $e(Sc, De), $e(wc, pe), $e(fs, le), $e(xc, Ne), fe(Ve))
    if (Ve.length) {
      const we = e.exposed || (e.exposed = {});
      Ve.forEach((Ee) => {
        Object.defineProperty(we, Ee, {
          get: () => o[Ee],
          set: (St) => o[Ee] = St
        });
      });
    } else e.exposed || (e.exposed = {});
  _e && e.render === Ht && (e.render = _e), vt != null && (e.inheritAttrs = vt), lt && (e.components = lt), ut && (e.directives = ut), Ne && pl(e);
}
function Pc(e, t, o = Ht) {
  fe(e) && (e = qi(e));
  for (const i in e) {
    const a = e[i];
    let u;
    qe(a) ? "default" in a ? u = Ar(
      a.from || i,
      a.default,
      !0
    ) : u = Ar(a.from || i) : u = Ar(a), Je(u) ? Object.defineProperty(t, i, {
      enumerable: !0,
      configurable: !0,
      get: () => u.value,
      set: (f) => u.value = f
    }) : t[i] = u;
  }
}
function oa(e, t, o) {
  Wt(
    fe(e) ? e.map((i) => i.bind(t.proxy)) : e.bind(t.proxy),
    t,
    o
  );
}
function gl(e, t, o, i) {
  let a = i.includes(".") ? Dl(o, i) : () => o[i];
  if (Ze(e)) {
    const u = t[e];
    ge(u) && rn(a, u);
  } else if (ge(e))
    rn(a, e.bind(o));
  else if (qe(e))
    if (fe(e))
      e.forEach((u) => gl(u, t, o, i));
    else {
      const u = ge(e.handler) ? e.handler.bind(o) : t[e.handler];
      ge(u) && rn(a, u, e);
    }
}
function bl(e) {
  const t = e.type, { mixins: o, extends: i } = t, {
    mixins: a,
    optionsCache: u,
    config: { optionMergeStrategies: f }
  } = e.appContext, p = u.get(t);
  let h;
  return p ? h = p : !a.length && !o && !i ? h = t : (h = {}, a.length && a.forEach(
    (N) => To(h, N, f, !0)
  ), To(h, t, f)), qe(t) && u.set(t, h), h;
}
function To(e, t, o, i = !1) {
  const { mixins: a, extends: u } = t;
  u && To(e, u, o, !0), a && a.forEach(
    (f) => To(e, f, o, !0)
  );
  for (const f in t)
    if (!(i && f === "expose")) {
      const p = Ac[f] || o && o[f];
      e[f] = p ? p(e[f], t[f]) : t[f];
    }
  return e;
}
const Ac = {
  data: ia,
  props: sa,
  emits: sa,
  // objects
  methods: Cr,
  computed: Cr,
  // lifecycle
  beforeCreate: _t,
  created: _t,
  beforeMount: _t,
  mounted: _t,
  beforeUpdate: _t,
  updated: _t,
  beforeDestroy: _t,
  beforeUnmount: _t,
  destroyed: _t,
  unmounted: _t,
  activated: _t,
  deactivated: _t,
  errorCaptured: _t,
  serverPrefetch: _t,
  // assets
  components: Cr,
  directives: Cr,
  // watch
  watch: Dc,
  // provide / inject
  provide: ia,
  inject: Rc
};
function ia(e, t) {
  return t ? e ? function() {
    return yt(
      ge(e) ? e.call(this, this) : e,
      ge(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function Rc(e, t) {
  return Cr(qi(e), qi(t));
}
function qi(e) {
  if (fe(e)) {
    const t = {};
    for (let o = 0; o < e.length; o++)
      t[e[o]] = e[o];
    return t;
  }
  return e;
}
function _t(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Cr(e, t) {
  return e ? yt(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function sa(e, t) {
  return e ? fe(e) && fe(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : yt(
    /* @__PURE__ */ Object.create(null),
    ra(e),
    ra(t ?? {})
  ) : t;
}
function Dc(e, t) {
  if (!e) return t;
  if (!t) return e;
  const o = yt(/* @__PURE__ */ Object.create(null), e);
  for (const i in t)
    o[i] = _t(e[i], t[i]);
  return o;
}
function _l() {
  return {
    app: null,
    config: {
      isNativeTag: wu,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let kc = 0;
function Ic(e, t) {
  return function(i, a = null) {
    ge(i) || (i = yt({}, i)), a != null && !qe(a) && (a = null);
    const u = _l(), f = /* @__PURE__ */ new WeakSet(), p = [];
    let h = !1;
    const N = u.app = {
      _uid: kc++,
      _component: i,
      _props: a,
      _container: null,
      _context: u,
      _instance: null,
      version: yf,
      get config() {
        return u.config;
      },
      set config(b) {
      },
      use(b, ...C) {
        return f.has(b) || (b && ge(b.install) ? (f.add(b), b.install(N, ...C)) : ge(b) && (f.add(b), b(N, ...C))), N;
      },
      mixin(b) {
        return u.mixins.includes(b) || u.mixins.push(b), N;
      },
      component(b, C) {
        return C ? (u.components[b] = C, N) : u.components[b];
      },
      directive(b, C) {
        return C ? (u.directives[b] = C, N) : u.directives[b];
      },
      mount(b, C, A) {
        if (!h) {
          const I = N._ceVNode || xt(i, a);
          return I.appContext = u, A === !0 ? A = "svg" : A === !1 && (A = void 0), e(I, b, A), h = !0, N._container = b, b.__vue_app__ = N, Uo(I.component);
        }
      },
      onUnmount(b) {
        p.push(b);
      },
      unmount() {
        h && (Wt(
          p,
          N._instance,
          16
        ), e(null, N._container), delete N._container.__vue_app__);
      },
      provide(b, C) {
        return u.provides[b] = C, N;
      },
      runWithContext(b) {
        const C = $n;
        $n = N;
        try {
          return b();
        } finally {
          $n = C;
        }
      }
    };
    return N;
  };
}
let $n = null;
function jc(e, t) {
  if (mt) {
    let o = mt.provides;
    const i = mt.parent && mt.parent.provides;
    i === o && (o = mt.provides = Object.create(i)), o[e] = t;
  }
}
function Ar(e, t, o = !1) {
  const i = mt || at;
  if (i || $n) {
    let a = $n ? $n._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (a && e in a)
      return a[e];
    if (arguments.length > 1)
      return o && ge(t) ? t.call(i && i.proxy) : t;
  }
}
function Lc() {
  return !!(mt || at || $n);
}
const wl = {}, xl = () => Object.create(wl), Sl = (e) => Object.getPrototypeOf(e) === wl;
function Kc(e, t, o, i = !1) {
  const a = {}, u = xl();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), Cl(e, t, a, u);
  for (const f in e.propsOptions[0])
    f in a || (a[f] = void 0);
  o ? e.props = i ? a : Zu(a) : e.type.props ? e.props = a : e.props = u, e.attrs = u;
}
function Mc(e, t, o, i) {
  const {
    props: a,
    attrs: u,
    vnode: { patchFlag: f }
  } = e, p = Ae(a), [h] = e.propsOptions;
  let N = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || f > 0) && !(f & 16)
  ) {
    if (f & 8) {
      const b = e.vnode.dynamicProps;
      for (let C = 0; C < b.length; C++) {
        let A = b[C];
        if (Bo(e.emitsOptions, A))
          continue;
        const I = t[A];
        if (h)
          if (je(u, A))
            I !== u[A] && (u[A] = I, N = !0);
          else {
            const G = On(A);
            a[G] = Ui(
              h,
              p,
              G,
              I,
              e,
              !1
            );
          }
        else
          I !== u[A] && (u[A] = I, N = !0);
      }
    }
  } else {
    Cl(e, t, a, u) && (N = !0);
    let b;
    for (const C in p)
      (!t || // for camelCase
      !je(t, C) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((b = qn(C)) === C || !je(t, b))) && (h ? o && // for camelCase
      (o[C] !== void 0 || // for kebab-case
      o[b] !== void 0) && (a[C] = Ui(
        h,
        p,
        C,
        void 0,
        e,
        !0
      )) : delete a[C]);
    if (u !== p)
      for (const C in u)
        (!t || !je(t, C)) && (delete u[C], N = !0);
  }
  N && Xt(e.attrs, "set", "");
}
function Cl(e, t, o, i) {
  const [a, u] = e.propsOptions;
  let f = !1, p;
  if (t)
    for (let h in t) {
      if (Or(h))
        continue;
      const N = t[h];
      let b;
      a && je(a, b = On(h)) ? !u || !u.includes(b) ? o[b] = N : (p || (p = {}))[b] = N : Bo(e.emitsOptions, h) || (!(h in i) || N !== i[h]) && (i[h] = N, f = !0);
    }
  if (u) {
    const h = Ae(o), N = p || Me;
    for (let b = 0; b < u.length; b++) {
      const C = u[b];
      o[C] = Ui(
        a,
        h,
        C,
        N[C],
        e,
        !je(N, C)
      );
    }
  }
  return f;
}
function Ui(e, t, o, i, a, u) {
  const f = e[o];
  if (f != null) {
    const p = je(f, "default");
    if (p && i === void 0) {
      const h = f.default;
      if (f.type !== Function && !f.skipFactory && ge(h)) {
        const { propsDefaults: N } = a;
        if (o in N)
          i = N[o];
        else {
          const b = Br(a);
          i = N[o] = h.call(
            null,
            t
          ), b();
        }
      } else
        i = h;
      a.ce && a.ce._setProp(o, i);
    }
    f[
      0
      /* shouldCast */
    ] && (u && !p ? i = !1 : f[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === qn(o)) && (i = !0));
  }
  return i;
}
const Fc = /* @__PURE__ */ new WeakMap();
function Ol(e, t, o = !1) {
  const i = o ? Fc : t.propsCache, a = i.get(e);
  if (a)
    return a;
  const u = e.props, f = {}, p = [];
  let h = !1;
  if (!ge(e)) {
    const b = (C) => {
      h = !0;
      const [A, I] = Ol(C, t, !0);
      yt(f, A), I && p.push(...I);
    };
    !o && t.mixins.length && t.mixins.forEach(b), e.extends && b(e.extends), e.mixins && e.mixins.forEach(b);
  }
  if (!u && !h)
    return qe(e) && i.set(e, nr), nr;
  if (fe(u))
    for (let b = 0; b < u.length; b++) {
      const C = On(u[b]);
      aa(C) && (f[C] = Me);
    }
  else if (u)
    for (const b in u) {
      const C = On(b);
      if (aa(C)) {
        const A = u[b], I = f[C] = fe(A) || ge(A) ? { type: A } : yt({}, A), G = I.type;
        let re = !1, F = !0;
        if (fe(G))
          for (let U = 0; U < G.length; ++U) {
            const pe = G[U], Se = ge(pe) && pe.name;
            if (Se === "Boolean") {
              re = !0;
              break;
            } else Se === "String" && (F = !1);
          }
        else
          re = ge(G) && G.name === "Boolean";
        I[
          0
          /* shouldCast */
        ] = re, I[
          1
          /* shouldCastTrue */
        ] = F, (re || je(I, "default")) && p.push(C);
      }
    }
  const N = [f, p];
  return qe(e) && i.set(e, N), N;
}
function aa(e) {
  return e[0] !== "$" && !Or(e);
}
const ds = (e) => e[0] === "_" || e === "$stable", ps = (e) => fe(e) ? e.map(Vt) : [Vt(e)], $c = (e, t, o) => {
  if (t._n)
    return t;
  const i = Fi((...a) => ps(t(...a)), o);
  return i._c = !1, i;
}, Nl = (e, t, o) => {
  const i = e._ctx;
  for (const a in e) {
    if (ds(a)) continue;
    const u = e[a];
    if (ge(u))
      t[a] = $c(a, u, i);
    else if (u != null) {
      const f = ps(u);
      t[a] = () => f;
    }
  }
}, El = (e, t) => {
  const o = ps(t);
  e.slots.default = () => o;
}, Tl = (e, t, o) => {
  for (const i in t)
    (o || !ds(i)) && (e[i] = t[i]);
}, Bc = (e, t, o) => {
  const i = e.slots = xl();
  if (e.vnode.shapeFlag & 32) {
    const a = t.__;
    a && ji(i, "__", a, !0);
    const u = t._;
    u ? (Tl(i, t, o), o && ji(i, "_", u, !0)) : Nl(t, i);
  } else t && El(e, t);
}, qc = (e, t, o) => {
  const { vnode: i, slots: a } = e;
  let u = !0, f = Me;
  if (i.shapeFlag & 32) {
    const p = t._;
    p ? o && p === 1 ? u = !1 : Tl(a, t, o) : (u = !t.$stable, Nl(t, a)), f = t;
  } else t && (El(e, t), f = { default: 1 });
  if (u)
    for (const p in a)
      !ds(p) && f[p] == null && delete a[p];
}, Et = nf;
function Uc(e) {
  return Vc(e);
}
function Vc(e, t) {
  const o = jo();
  o.__VUE__ = !0;
  const {
    insert: i,
    remove: a,
    patchProp: u,
    createElement: f,
    createText: p,
    createComment: h,
    setText: N,
    setElementText: b,
    parentNode: C,
    nextSibling: A,
    setScopeId: I = Ht,
    insertStaticContent: G
  } = e, re = (y, x, M, q = null, B = null, V = null, ee = void 0, J = null, Y = !!x.dynamicChildren) => {
    if (y === x)
      return;
    y && !Sr(y, x) && (q = cn(y), At(y, B, V, !0), y = null), x.patchFlag === -2 && (Y = !1, x.dynamicChildren = null);
    const { type: $, ref: ue, shapeFlag: X } = x;
    switch ($) {
      case qo:
        F(y, x, M, q);
        break;
      case an:
        U(y, x, M, q);
        break;
      case Ai:
        y == null && pe(x, M, q, ee);
        break;
      case Le:
        lt(
          y,
          x,
          M,
          q,
          B,
          V,
          ee,
          J,
          Y
        );
        break;
      default:
        X & 1 ? _e(
          y,
          x,
          M,
          q,
          B,
          V,
          ee,
          J,
          Y
        ) : X & 6 ? ut(
          y,
          x,
          M,
          q,
          B,
          V,
          ee,
          J,
          Y
        ) : (X & 64 || X & 128) && $.process(
          y,
          x,
          M,
          q,
          B,
          V,
          ee,
          J,
          Y,
          fn
        );
    }
    ue != null && B ? Tr(ue, y && y.ref, V, x || y, !x) : ue == null && y && y.ref != null && Tr(y.ref, null, V, y, !0);
  }, F = (y, x, M, q) => {
    if (y == null)
      i(
        x.el = p(x.children),
        M,
        q
      );
    else {
      const B = x.el = y.el;
      x.children !== y.children && N(B, x.children);
    }
  }, U = (y, x, M, q) => {
    y == null ? i(
      x.el = h(x.children || ""),
      M,
      q
    ) : x.el = y.el;
  }, pe = (y, x, M, q) => {
    [y.el, y.anchor] = G(
      y.children,
      x,
      M,
      q,
      y.el,
      y.anchor
    );
  }, Se = ({ el: y, anchor: x }, M, q) => {
    let B;
    for (; y && y !== x; )
      B = A(y), i(y, M, q), y = B;
    i(x, M, q);
  }, le = ({ el: y, anchor: x }) => {
    let M;
    for (; y && y !== x; )
      M = A(y), a(y), y = M;
    a(x);
  }, _e = (y, x, M, q, B, V, ee, J, Y) => {
    x.type === "svg" ? ee = "svg" : x.type === "math" && (ee = "mathml"), y == null ? Ke(
      x,
      M,
      q,
      B,
      V,
      ee,
      J,
      Y
    ) : Ne(
      y,
      x,
      B,
      V,
      ee,
      J,
      Y
    );
  }, Ke = (y, x, M, q, B, V, ee, J) => {
    let Y, $;
    const { props: ue, shapeFlag: X, transition: ae, dirs: ce } = y;
    if (Y = y.el = f(
      y.type,
      V,
      ue && ue.is,
      ue
    ), X & 8 ? b(Y, y.children) : X & 16 && xe(
      y.children,
      Y,
      null,
      q,
      B,
      Pi(y, V),
      ee,
      J
    ), ce && Ln(y, null, q, "created"), De(Y, y, y.scopeId, ee, q), ue) {
      for (const Te in ue)
        Te !== "value" && !Or(Te) && u(Y, Te, null, ue[Te], V, q);
      "value" in ue && u(Y, "value", null, ue.value, V), ($ = ue.onVnodeBeforeMount) && qt($, q, y);
    }
    ce && Ln(y, null, q, "beforeMount");
    const ye = Hc(B, ae);
    ye && ae.beforeEnter(Y), i(Y, x, M), (($ = ue && ue.onVnodeMounted) || ye || ce) && Et(() => {
      $ && qt($, q, y), ye && ae.enter(Y), ce && Ln(y, null, q, "mounted");
    }, B);
  }, De = (y, x, M, q, B) => {
    if (M && I(y, M), q)
      for (let V = 0; V < q.length; V++)
        I(y, q[V]);
    if (B) {
      let V = B.subTree;
      if (x === V || Il(V.type) && (V.ssContent === x || V.ssFallback === x)) {
        const ee = B.vnode;
        De(
          y,
          ee,
          ee.scopeId,
          ee.slotScopeIds,
          B.parent
        );
      }
    }
  }, xe = (y, x, M, q, B, V, ee, J, Y = 0) => {
    for (let $ = Y; $ < y.length; $++) {
      const ue = y[$] = J ? wn(y[$]) : Vt(y[$]);
      re(
        null,
        ue,
        x,
        M,
        q,
        B,
        V,
        ee,
        J
      );
    }
  }, Ne = (y, x, M, q, B, V, ee) => {
    const J = x.el = y.el;
    let { patchFlag: Y, dynamicChildren: $, dirs: ue } = x;
    Y |= y.patchFlag & 16;
    const X = y.props || Me, ae = x.props || Me;
    let ce;
    if (M && Kn(M, !1), (ce = ae.onVnodeBeforeUpdate) && qt(ce, M, x, y), ue && Ln(x, y, M, "beforeUpdate"), M && Kn(M, !0), (X.innerHTML && ae.innerHTML == null || X.textContent && ae.textContent == null) && b(J, ""), $ ? Ve(
      y.dynamicChildren,
      $,
      J,
      M,
      q,
      Pi(x, B),
      V
    ) : ee || Ee(
      y,
      x,
      J,
      null,
      M,
      q,
      Pi(x, B),
      V,
      !1
    ), Y > 0) {
      if (Y & 16)
        vt(J, X, ae, M, B);
      else if (Y & 2 && X.class !== ae.class && u(J, "class", null, ae.class, B), Y & 4 && u(J, "style", X.style, ae.style, B), Y & 8) {
        const ye = x.dynamicProps;
        for (let Te = 0; Te < ye.length; Te++) {
          const Re = ye[Te], Xe = X[Re], et = ae[Re];
          (et !== Xe || Re === "value") && u(J, Re, Xe, et, B, M);
        }
      }
      Y & 1 && y.children !== x.children && b(J, x.children);
    } else !ee && $ == null && vt(J, X, ae, M, B);
    ((ce = ae.onVnodeUpdated) || ue) && Et(() => {
      ce && qt(ce, M, x, y), ue && Ln(x, y, M, "updated");
    }, q);
  }, Ve = (y, x, M, q, B, V, ee) => {
    for (let J = 0; J < x.length; J++) {
      const Y = y[J], $ = x[J], ue = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        Y.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (Y.type === Le || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Sr(Y, $) || // - In the case of a component, it could contain anything.
        Y.shapeFlag & 198) ? C(Y.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          M
        )
      );
      re(
        Y,
        $,
        ue,
        null,
        q,
        B,
        V,
        ee,
        !0
      );
    }
  }, vt = (y, x, M, q, B) => {
    if (x !== M) {
      if (x !== Me)
        for (const V in x)
          !Or(V) && !(V in M) && u(
            y,
            V,
            x[V],
            null,
            B,
            q
          );
      for (const V in M) {
        if (Or(V)) continue;
        const ee = M[V], J = x[V];
        ee !== J && V !== "value" && u(y, V, J, ee, B, q);
      }
      "value" in M && u(y, "value", x.value, M.value, B);
    }
  }, lt = (y, x, M, q, B, V, ee, J, Y) => {
    const $ = x.el = y ? y.el : p(""), ue = x.anchor = y ? y.anchor : p("");
    let { patchFlag: X, dynamicChildren: ae, slotScopeIds: ce } = x;
    ce && (J = J ? J.concat(ce) : ce), y == null ? (i($, M, q), i(ue, M, q), xe(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      x.children || [],
      M,
      ue,
      B,
      V,
      ee,
      J,
      Y
    )) : X > 0 && X & 64 && ae && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    y.dynamicChildren ? (Ve(
      y.dynamicChildren,
      ae,
      M,
      B,
      V,
      ee,
      J
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (x.key != null || B && x === B.subTree) && Pl(
      y,
      x,
      !0
      /* shallow */
    )) : Ee(
      y,
      x,
      M,
      ue,
      B,
      V,
      ee,
      J,
      Y
    );
  }, ut = (y, x, M, q, B, V, ee, J, Y) => {
    x.slotScopeIds = J, y == null ? x.shapeFlag & 512 ? B.ctx.activate(
      x,
      M,
      q,
      ee,
      Y
    ) : Tn(
      x,
      M,
      q,
      B,
      V,
      ee,
      Y
    ) : un(y, x, Y);
  }, Tn = (y, x, M, q, B, V, ee) => {
    const J = y.component = cf(
      y,
      q,
      B
    );
    if (hl(y) && (J.ctx.renderer = fn), ff(J, !1, ee), J.asyncDep) {
      if (B && B.registerDep(J, $e, ee), !y.el) {
        const Y = J.subTree = xt(an);
        U(null, Y, x, M);
      }
    } else
      $e(
        J,
        y,
        x,
        M,
        B,
        V,
        ee
      );
  }, un = (y, x, M) => {
    const q = x.component = y.component;
    if (ef(y, x, M))
      if (q.asyncDep && !q.asyncResolved) {
        we(q, x, M);
        return;
      } else
        q.next = x, q.update();
    else
      x.el = y.el, q.vnode = x;
  }, $e = (y, x, M, q, B, V, ee) => {
    const J = () => {
      if (y.isMounted) {
        let { next: X, bu: ae, u: ce, parent: ye, vnode: Te } = y;
        {
          const tt = Al(y);
          if (tt) {
            X && (X.el = Te.el, we(y, X, ee)), tt.asyncDep.then(() => {
              y.isUnmounted || J();
            });
            return;
          }
        }
        let Re = X, Xe;
        Kn(y, !1), X ? (X.el = Te.el, we(y, X, ee)) : X = Te, ae && vo(ae), (Xe = X.props && X.props.onVnodeBeforeUpdate) && qt(Xe, ye, X, Te), Kn(y, !0);
        const et = ua(y), gt = y.subTree;
        y.subTree = et, re(
          gt,
          et,
          // parent may have changed if it's in a teleport
          C(gt.el),
          // anchor may have changed if it's in a fragment
          cn(gt),
          y,
          B,
          V
        ), X.el = et.el, Re === null && tf(y, et.el), ce && Et(ce, B), (Xe = X.props && X.props.onVnodeUpdated) && Et(
          () => qt(Xe, ye, X, Te),
          B
        );
      } else {
        let X;
        const { el: ae, props: ce } = x, { bm: ye, m: Te, parent: Re, root: Xe, type: et } = y, gt = ir(x);
        Kn(y, !1), ye && vo(ye), !gt && (X = ce && ce.onVnodeBeforeMount) && qt(X, Re, x), Kn(y, !0);
        {
          Xe.ce && // @ts-expect-error _def is private
          Xe.ce._def.shadowRoot !== !1 && Xe.ce._injectChildStyle(et);
          const tt = y.subTree = ua(y);
          re(
            null,
            tt,
            M,
            q,
            y,
            B,
            V
          ), x.el = tt.el;
        }
        if (Te && Et(Te, B), !gt && (X = ce && ce.onVnodeMounted)) {
          const tt = x;
          Et(
            () => qt(X, Re, tt),
            B
          );
        }
        (x.shapeFlag & 256 || Re && ir(Re.vnode) && Re.vnode.shapeFlag & 256) && y.a && Et(y.a, B), y.isMounted = !0, x = M = q = null;
      }
    };
    y.scope.on();
    const Y = y.effect = new Wa(J);
    y.scope.off();
    const $ = y.update = Y.run.bind(Y), ue = y.job = Y.runIfDirty.bind(Y);
    ue.i = y, ue.id = y.uid, Y.scheduler = () => us(ue), Kn(y, !0), $();
  }, we = (y, x, M) => {
    x.component = y;
    const q = y.vnode.props;
    y.vnode = x, y.next = null, Mc(y, x.props, q, M), qc(y, x.children, M), on(), ta(y), sn();
  }, Ee = (y, x, M, q, B, V, ee, J, Y = !1) => {
    const $ = y && y.children, ue = y ? y.shapeFlag : 0, X = x.children, { patchFlag: ae, shapeFlag: ce } = x;
    if (ae > 0) {
      if (ae & 128) {
        Ct(
          $,
          X,
          M,
          q,
          B,
          V,
          ee,
          J,
          Y
        );
        return;
      } else if (ae & 256) {
        St(
          $,
          X,
          M,
          q,
          B,
          V,
          ee,
          J,
          Y
        );
        return;
      }
    }
    ce & 8 ? (ue & 16 && Rt($, B, V), X !== $ && b(M, X)) : ue & 16 ? ce & 16 ? Ct(
      $,
      X,
      M,
      q,
      B,
      V,
      ee,
      J,
      Y
    ) : Rt($, B, V, !0) : (ue & 8 && b(M, ""), ce & 16 && xe(
      X,
      M,
      q,
      B,
      V,
      ee,
      J,
      Y
    ));
  }, St = (y, x, M, q, B, V, ee, J, Y) => {
    y = y || nr, x = x || nr;
    const $ = y.length, ue = x.length, X = Math.min($, ue);
    let ae;
    for (ae = 0; ae < X; ae++) {
      const ce = x[ae] = Y ? wn(x[ae]) : Vt(x[ae]);
      re(
        y[ae],
        ce,
        M,
        null,
        B,
        V,
        ee,
        J,
        Y
      );
    }
    $ > ue ? Rt(
      y,
      B,
      V,
      !0,
      !1,
      X
    ) : xe(
      x,
      M,
      q,
      B,
      V,
      ee,
      J,
      Y,
      X
    );
  }, Ct = (y, x, M, q, B, V, ee, J, Y) => {
    let $ = 0;
    const ue = x.length;
    let X = y.length - 1, ae = ue - 1;
    for (; $ <= X && $ <= ae; ) {
      const ce = y[$], ye = x[$] = Y ? wn(x[$]) : Vt(x[$]);
      if (Sr(ce, ye))
        re(
          ce,
          ye,
          M,
          null,
          B,
          V,
          ee,
          J,
          Y
        );
      else
        break;
      $++;
    }
    for (; $ <= X && $ <= ae; ) {
      const ce = y[X], ye = x[ae] = Y ? wn(x[ae]) : Vt(x[ae]);
      if (Sr(ce, ye))
        re(
          ce,
          ye,
          M,
          null,
          B,
          V,
          ee,
          J,
          Y
        );
      else
        break;
      X--, ae--;
    }
    if ($ > X) {
      if ($ <= ae) {
        const ce = ae + 1, ye = ce < ue ? x[ce].el : q;
        for (; $ <= ae; )
          re(
            null,
            x[$] = Y ? wn(x[$]) : Vt(x[$]),
            M,
            ye,
            B,
            V,
            ee,
            J,
            Y
          ), $++;
      }
    } else if ($ > ae)
      for (; $ <= X; )
        At(y[$], B, V, !0), $++;
    else {
      const ce = $, ye = $, Te = /* @__PURE__ */ new Map();
      for ($ = ye; $ <= ae; $++) {
        const We = x[$] = Y ? wn(x[$]) : Vt(x[$]);
        We.key != null && Te.set(We.key, $);
      }
      let Re, Xe = 0;
      const et = ae - ye + 1;
      let gt = !1, tt = 0;
      const Ft = new Array(et);
      for ($ = 0; $ < et; $++) Ft[$] = 0;
      for ($ = ce; $ <= X; $++) {
        const We = y[$];
        if (Xe >= et) {
          At(We, B, V, !0);
          continue;
        }
        let ie;
        if (We.key != null)
          ie = Te.get(We.key);
        else
          for (Re = ye; Re <= ae; Re++)
            if (Ft[Re - ye] === 0 && Sr(We, x[Re])) {
              ie = Re;
              break;
            }
        ie === void 0 ? At(We, B, V, !0) : (Ft[ie - ye] = $ + 1, ie >= tt ? tt = ie : gt = !0, re(
          We,
          x[ie],
          M,
          null,
          B,
          V,
          ee,
          J,
          Y
        ), Xe++);
      }
      const Vn = gt ? Wc(Ft) : nr;
      for (Re = Vn.length - 1, $ = et - 1; $ >= 0; $--) {
        const We = ye + $, ie = x[We], dn = We + 1 < ue ? x[We + 1].el : q;
        Ft[$] === 0 ? re(
          null,
          ie,
          M,
          dn,
          B,
          V,
          ee,
          J,
          Y
        ) : gt && (Re < 0 || $ !== Vn[Re] ? jt(ie, M, dn, 2) : Re--);
      }
    }
  }, jt = (y, x, M, q, B = null) => {
    const { el: V, type: ee, transition: J, children: Y, shapeFlag: $ } = y;
    if ($ & 6) {
      jt(y.component.subTree, x, M, q);
      return;
    }
    if ($ & 128) {
      y.suspense.move(x, M, q);
      return;
    }
    if ($ & 64) {
      ee.move(y, x, M, fn);
      return;
    }
    if (ee === Le) {
      i(V, x, M);
      for (let X = 0; X < Y.length; X++)
        jt(Y[X], x, M, q);
      i(y.anchor, x, M);
      return;
    }
    if (ee === Ai) {
      Se(y, x, M);
      return;
    }
    if (q !== 2 && $ & 1 && J)
      if (q === 0)
        J.beforeEnter(V), i(V, x, M), Et(() => J.enter(V), B);
      else {
        const { leave: X, delayLeave: ae, afterLeave: ce } = J, ye = () => {
          y.ctx.isUnmounted ? a(V) : i(V, x, M);
        }, Te = () => {
          X(V, () => {
            ye(), ce && ce();
          });
        };
        ae ? ae(V, ye, Te) : Te();
      }
    else
      i(V, x, M);
  }, At = (y, x, M, q = !1, B = !1) => {
    const {
      type: V,
      props: ee,
      ref: J,
      children: Y,
      dynamicChildren: $,
      shapeFlag: ue,
      patchFlag: X,
      dirs: ae,
      cacheIndex: ce
    } = y;
    if (X === -2 && (B = !1), J != null && (on(), Tr(J, null, M, y, !0), sn()), ce != null && (x.renderCache[ce] = void 0), ue & 256) {
      x.ctx.deactivate(y);
      return;
    }
    const ye = ue & 1 && ae, Te = !ir(y);
    let Re;
    if (Te && (Re = ee && ee.onVnodeBeforeUnmount) && qt(Re, x, y), ue & 6)
      Un(y.component, M, q);
    else {
      if (ue & 128) {
        y.suspense.unmount(M, q);
        return;
      }
      ye && Ln(y, null, x, "beforeUnmount"), ue & 64 ? y.type.remove(
        y,
        x,
        M,
        fn,
        q
      ) : $ && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !$.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (V !== Le || X > 0 && X & 64) ? Rt(
        $,
        x,
        M,
        !1,
        !0
      ) : (V === Le && X & 384 || !B && ue & 16) && Rt(Y, x, M), q && zt(y);
    }
    (Te && (Re = ee && ee.onVnodeUnmounted) || ye) && Et(() => {
      Re && qt(Re, x, y), ye && Ln(y, null, x, "unmounted");
    }, M);
  }, zt = (y) => {
    const { type: x, el: M, anchor: q, transition: B } = y;
    if (x === Le) {
      qr(M, q);
      return;
    }
    if (x === Ai) {
      le(y);
      return;
    }
    const V = () => {
      a(M), B && !B.persisted && B.afterLeave && B.afterLeave();
    };
    if (y.shapeFlag & 1 && B && !B.persisted) {
      const { leave: ee, delayLeave: J } = B, Y = () => ee(M, V);
      J ? J(y.el, V, Y) : Y();
    } else
      V();
  }, qr = (y, x) => {
    let M;
    for (; y !== x; )
      M = A(y), a(y), y = M;
    a(x);
  }, Un = (y, x, M) => {
    const {
      bum: q,
      scope: B,
      job: V,
      subTree: ee,
      um: J,
      m: Y,
      a: $,
      parent: ue,
      slots: { __: X }
    } = y;
    la(Y), la($), q && vo(q), ue && fe(X) && X.forEach((ae) => {
      ue.renderCache[ae] = void 0;
    }), B.stop(), V && (V.flags |= 8, At(ee, y, x, M)), J && Et(J, x), Et(() => {
      y.isUnmounted = !0;
    }, x), x && x.pendingBranch && !x.isUnmounted && y.asyncDep && !y.asyncResolved && y.suspenseId === x.pendingId && (x.deps--, x.deps === 0 && x.resolve());
  }, Rt = (y, x, M, q = !1, B = !1, V = 0) => {
    for (let ee = V; ee < y.length; ee++)
      At(y[ee], x, M, q, B);
  }, cn = (y) => {
    if (y.shapeFlag & 6)
      return cn(y.component.subTree);
    if (y.shapeFlag & 128)
      return y.suspense.next();
    const x = A(y.anchor || y.el), M = x && x[pc];
    return M ? A(M) : x;
  };
  let fr = !1;
  const se = (y, x, M) => {
    y == null ? x._vnode && At(x._vnode, null, null, !0) : re(
      x._vnode || null,
      y,
      x,
      null,
      null,
      null,
      M
    ), x._vnode = y, fr || (fr = !0, ta(), cl(), fr = !1);
  }, fn = {
    p: re,
    um: At,
    m: jt,
    r: zt,
    mt: Tn,
    mc: xe,
    pc: Ee,
    pbc: Ve,
    n: cn,
    o: e
  };
  return {
    render: se,
    hydrate: void 0,
    createApp: Ic(se)
  };
}
function Pi({ type: e, props: t }, o) {
  return o === "svg" && e === "foreignObject" || o === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : o;
}
function Kn({ effect: e, job: t }, o) {
  o ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function Hc(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function Pl(e, t, o = !1) {
  const i = e.children, a = t.children;
  if (fe(i) && fe(a))
    for (let u = 0; u < i.length; u++) {
      const f = i[u];
      let p = a[u];
      p.shapeFlag & 1 && !p.dynamicChildren && ((p.patchFlag <= 0 || p.patchFlag === 32) && (p = a[u] = wn(a[u]), p.el = f.el), !o && p.patchFlag !== -2 && Pl(f, p)), p.type === qo && (p.el = f.el), p.type === an && !p.el && (p.el = f.el);
    }
}
function Wc(e) {
  const t = e.slice(), o = [0];
  let i, a, u, f, p;
  const h = e.length;
  for (i = 0; i < h; i++) {
    const N = e[i];
    if (N !== 0) {
      if (a = o[o.length - 1], e[a] < N) {
        t[i] = a, o.push(i);
        continue;
      }
      for (u = 0, f = o.length - 1; u < f; )
        p = u + f >> 1, e[o[p]] < N ? u = p + 1 : f = p;
      N < e[o[u]] && (u > 0 && (t[i] = o[u - 1]), o[u] = i);
    }
  }
  for (u = o.length, f = o[u - 1]; u-- > 0; )
    o[u] = f, f = t[f];
  return o;
}
function Al(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : Al(t);
}
function la(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
const zc = Symbol.for("v-scx"), Gc = () => Ar(zc);
function Rl(e, t) {
  return hs(e, null, t);
}
function rn(e, t, o) {
  return hs(e, t, o);
}
function hs(e, t, o = Me) {
  const { immediate: i, deep: a, flush: u, once: f } = o, p = yt({}, o), h = t && i || !t && u !== "post";
  let N;
  if (Mr) {
    if (u === "sync") {
      const I = Gc();
      N = I.__watcherHandles || (I.__watcherHandles = []);
    } else if (!h) {
      const I = () => {
      };
      return I.stop = Ht, I.resume = Ht, I.pause = Ht, I;
    }
  }
  const b = mt;
  p.call = (I, G, re) => Wt(I, b, G, re);
  let C = !1;
  u === "post" ? p.scheduler = (I) => {
    Et(I, b && b.suspense);
  } : u !== "sync" && (C = !0, p.scheduler = (I, G) => {
    G ? I() : us(I);
  }), p.augmentJob = (I) => {
    t && (I.flags |= 4), C && (I.flags |= 2, b && (I.id = b.uid, I.i = b));
  };
  const A = uc(e, t, p);
  return Mr && (N ? N.push(A) : h && A()), A;
}
function Yc(e, t, o) {
  const i = this.proxy, a = Ze(e) ? e.includes(".") ? Dl(i, e) : () => i[e] : e.bind(i, i);
  let u;
  ge(t) ? u = t : (u = t.handler, o = t);
  const f = Br(this), p = hs(a, u.bind(i), o);
  return f(), p;
}
function Dl(e, t) {
  const o = t.split(".");
  return () => {
    let i = e;
    for (let a = 0; a < o.length && i; a++)
      i = i[o[a]];
    return i;
  };
}
const Qc = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${On(t)}Modifiers`] || e[`${qn(t)}Modifiers`];
function Jc(e, t, ...o) {
  if (e.isUnmounted) return;
  const i = e.vnode.props || Me;
  let a = o;
  const u = t.startsWith("update:"), f = u && Qc(i, t.slice(7));
  f && (f.trim && (a = o.map((b) => Ze(b) ? b.trim() : b)), f.number && (a = o.map(xo)));
  let p, h = i[p = Si(t)] || // also try camelCase event handler (#2249)
  i[p = Si(On(t))];
  !h && u && (h = i[p = Si(qn(t))]), h && Wt(
    h,
    e,
    6,
    a
  );
  const N = i[p + "Once"];
  if (N) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[p])
      return;
    e.emitted[p] = !0, Wt(
      N,
      e,
      6,
      a
    );
  }
}
function kl(e, t, o = !1) {
  const i = t.emitsCache, a = i.get(e);
  if (a !== void 0)
    return a;
  const u = e.emits;
  let f = {}, p = !1;
  if (!ge(e)) {
    const h = (N) => {
      const b = kl(N, t, !0);
      b && (p = !0, yt(f, b));
    };
    !o && t.mixins.length && t.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h);
  }
  return !u && !p ? (qe(e) && i.set(e, null), null) : (fe(u) ? u.forEach((h) => f[h] = null) : yt(f, u), qe(e) && i.set(e, f), f);
}
function Bo(e, t) {
  return !e || !ko(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), je(e, t[0].toLowerCase() + t.slice(1)) || je(e, qn(t)) || je(e, t));
}
function ua(e) {
  const {
    type: t,
    vnode: o,
    proxy: i,
    withProxy: a,
    propsOptions: [u],
    slots: f,
    attrs: p,
    emit: h,
    render: N,
    renderCache: b,
    props: C,
    data: A,
    setupState: I,
    ctx: G,
    inheritAttrs: re
  } = e, F = Eo(e);
  let U, pe;
  try {
    if (o.shapeFlag & 4) {
      const le = a || i, _e = le;
      U = Vt(
        N.call(
          _e,
          le,
          b,
          C,
          I,
          A,
          G
        )
      ), pe = p;
    } else {
      const le = t;
      U = Vt(
        le.length > 1 ? le(
          C,
          { attrs: p, slots: f, emit: h }
        ) : le(
          C,
          null
        )
      ), pe = t.props ? p : Xc(p);
    }
  } catch (le) {
    Rr.length = 0, Fo(le, e, 1), U = xt(an);
  }
  let Se = U;
  if (pe && re !== !1) {
    const le = Object.keys(pe), { shapeFlag: _e } = Se;
    le.length && _e & 7 && (u && le.some(Qi) && (pe = Zc(
      pe,
      u
    )), Se = sr(Se, pe, !1, !0));
  }
  return o.dirs && (Se = sr(Se, null, !1, !0), Se.dirs = Se.dirs ? Se.dirs.concat(o.dirs) : o.dirs), o.transition && cs(Se, o.transition), U = Se, Eo(F), U;
}
const Xc = (e) => {
  let t;
  for (const o in e)
    (o === "class" || o === "style" || ko(o)) && ((t || (t = {}))[o] = e[o]);
  return t;
}, Zc = (e, t) => {
  const o = {};
  for (const i in e)
    (!Qi(i) || !(i.slice(9) in t)) && (o[i] = e[i]);
  return o;
};
function ef(e, t, o) {
  const { props: i, children: a, component: u } = e, { props: f, children: p, patchFlag: h } = t, N = u.emitsOptions;
  if (t.dirs || t.transition)
    return !0;
  if (o && h >= 0) {
    if (h & 1024)
      return !0;
    if (h & 16)
      return i ? ca(i, f, N) : !!f;
    if (h & 8) {
      const b = t.dynamicProps;
      for (let C = 0; C < b.length; C++) {
        const A = b[C];
        if (f[A] !== i[A] && !Bo(N, A))
          return !0;
      }
    }
  } else
    return (a || p) && (!p || !p.$stable) ? !0 : i === f ? !1 : i ? f ? ca(i, f, N) : !0 : !!f;
  return !1;
}
function ca(e, t, o) {
  const i = Object.keys(t);
  if (i.length !== Object.keys(e).length)
    return !0;
  for (let a = 0; a < i.length; a++) {
    const u = i[a];
    if (t[u] !== e[u] && !Bo(o, u))
      return !0;
  }
  return !1;
}
function tf({ vnode: e, parent: t }, o) {
  for (; t; ) {
    const i = t.subTree;
    if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e)
      (e = t.vnode).el = o, t = t.parent;
    else
      break;
  }
}
const Il = (e) => e.__isSuspense;
function nf(e, t) {
  t && t.pendingBranch ? fe(e) ? t.effects.push(...e) : t.effects.push(e) : dc(e);
}
const Le = Symbol.for("v-fgt"), qo = Symbol.for("v-txt"), an = Symbol.for("v-cmt"), Ai = Symbol.for("v-stc"), Rr = [];
let Pt = null;
function de(e = !1) {
  Rr.push(Pt = e ? null : []);
}
function rf() {
  Rr.pop(), Pt = Rr[Rr.length - 1] || null;
}
let Kr = 1;
function fa(e, t = !1) {
  Kr += e, e < 0 && Pt && t && (Pt.hasOnce = !0);
}
function jl(e) {
  return e.dynamicChildren = Kr > 0 ? Pt || nr : null, rf(), Kr > 0 && Pt && Pt.push(e), e;
}
function be(e, t, o, i, a, u) {
  return jl(
    k(
      e,
      t,
      o,
      i,
      a,
      u,
      !0
    )
  );
}
function tn(e, t, o, i, a) {
  return jl(
    xt(
      e,
      t,
      o,
      i,
      a,
      !0
    )
  );
}
function ms(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function Sr(e, t) {
  return e.type === t.type && e.key === t.key;
}
const Ll = ({ key: e }) => e ?? null, go = ({
  ref: e,
  ref_key: t,
  ref_for: o
}) => (typeof e == "number" && (e = "" + e), e != null ? Ze(e) || Je(e) || ge(e) ? { i: at, r: e, k: t, f: !!o } : e : null);
function k(e, t = null, o = null, i = 0, a = null, u = e === Le ? 0 : 1, f = !1, p = !1) {
  const h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Ll(t),
    ref: t && go(t),
    scopeId: dl,
    slotScopeIds: null,
    children: o,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: u,
    patchFlag: i,
    dynamicProps: a,
    dynamicChildren: null,
    appContext: null,
    ctx: at
  };
  return p ? (ys(h, o), u & 128 && e.normalize(h)) : o && (h.shapeFlag |= Ze(o) ? 8 : 16), Kr > 0 && // avoid a block node from tracking itself
  !f && // has current parent block
  Pt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (h.patchFlag > 0 || u & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  h.patchFlag !== 32 && Pt.push(h), h;
}
const xt = of;
function of(e, t = null, o = null, i = 0, a = null, u = !1) {
  if ((!e || e === Nc) && (e = an), ms(e)) {
    const p = sr(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return o && ys(p, o), Kr > 0 && !u && Pt && (p.shapeFlag & 6 ? Pt[Pt.indexOf(e)] = p : Pt.push(p)), p.patchFlag = -2, p;
  }
  if (mf(e) && (e = e.__vccOpts), t) {
    t = sf(t);
    let { class: p, style: h } = t;
    p && !Ze(p) && (t.class = kr(p)), qe(h) && (ss(h) && !fe(h) && (h = yt({}, h)), t.style = Lo(h));
  }
  const f = Ze(e) ? 1 : Il(e) ? 128 : hc(e) ? 64 : qe(e) ? 4 : ge(e) ? 2 : 0;
  return k(
    e,
    t,
    o,
    i,
    a,
    f,
    u,
    !0
  );
}
function sf(e) {
  return e ? ss(e) || Sl(e) ? yt({}, e) : e : null;
}
function sr(e, t, o = !1, i = !1) {
  const { props: a, ref: u, patchFlag: f, children: p, transition: h } = e, N = t ? af(a || {}, t) : a, b = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: N,
    key: N && Ll(N),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      o && u ? fe(u) ? u.concat(go(t)) : [u, go(t)] : go(t)
    ) : u,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: p,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Le ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: h,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && sr(e.ssContent),
    ssFallback: e.ssFallback && sr(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return h && i && cs(
    b,
    h.clone(b)
  ), b;
}
function Kl(e = " ", t = 0) {
  return xt(qo, null, e, t);
}
function nn(e = "", t = !1) {
  return t ? (de(), tn(an, null, e)) : xt(an, null, e);
}
function Vt(e) {
  return e == null || typeof e == "boolean" ? xt(an) : fe(e) ? xt(
    Le,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : ms(e) ? wn(e) : xt(qo, null, String(e));
}
function wn(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : sr(e);
}
function ys(e, t) {
  let o = 0;
  const { shapeFlag: i } = e;
  if (t == null)
    t = null;
  else if (fe(t))
    o = 16;
  else if (typeof t == "object")
    if (i & 65) {
      const a = t.default;
      a && (a._c && (a._d = !1), ys(e, a()), a._c && (a._d = !0));
      return;
    } else {
      o = 32;
      const a = t._;
      !a && !Sl(t) ? t._ctx = at : a === 3 && at && (at.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else ge(t) ? (t = { default: t, _ctx: at }, o = 32) : (t = String(t), i & 64 ? (o = 16, t = [Kl(t)]) : o = 8);
  e.children = t, e.shapeFlag |= o;
}
function af(...e) {
  const t = {};
  for (let o = 0; o < e.length; o++) {
    const i = e[o];
    for (const a in i)
      if (a === "class")
        t.class !== i.class && (t.class = kr([t.class, i.class]));
      else if (a === "style")
        t.style = Lo([t.style, i.style]);
      else if (ko(a)) {
        const u = t[a], f = i[a];
        f && u !== f && !(fe(u) && u.includes(f)) && (t[a] = u ? [].concat(u, f) : f);
      } else a !== "" && (t[a] = i[a]);
  }
  return t;
}
function qt(e, t, o, i = null) {
  Wt(e, t, 7, [
    o,
    i
  ]);
}
const lf = _l();
let uf = 0;
function cf(e, t, o) {
  const i = e.type, a = (t ? t.appContext : e.appContext) || lf, u = {
    uid: uf++,
    vnode: e,
    type: i,
    parent: t,
    appContext: a,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Ua(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(a.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Ol(i, a),
    emitsOptions: kl(i, a),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Me,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: Me,
    data: Me,
    props: Me,
    attrs: Me,
    slots: Me,
    refs: Me,
    setupState: Me,
    setupContext: null,
    // suspense related
    suspense: o,
    suspenseId: o ? o.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return u.ctx = { _: u }, u.root = t ? t.root : u, u.emit = Jc.bind(null, u), e.ce && e.ce(u), u;
}
let mt = null, Po, Vi;
{
  const e = jo(), t = (o, i) => {
    let a;
    return (a = e[o]) || (a = e[o] = []), a.push(i), (u) => {
      a.length > 1 ? a.forEach((f) => f(u)) : a[0](u);
    };
  };
  Po = t(
    "__VUE_INSTANCE_SETTERS__",
    (o) => mt = o
  ), Vi = t(
    "__VUE_SSR_SETTERS__",
    (o) => Mr = o
  );
}
const Br = (e) => {
  const t = mt;
  return Po(e), e.scope.on(), () => {
    e.scope.off(), Po(t);
  };
}, da = () => {
  mt && mt.scope.off(), Po(null);
};
function Ml(e) {
  return e.vnode.shapeFlag & 4;
}
let Mr = !1;
function ff(e, t = !1, o = !1) {
  t && Vi(t);
  const { props: i, children: a } = e.vnode, u = Ml(e);
  Kc(e, i, u, t), Bc(e, a, o || t);
  const f = u ? df(e, t) : void 0;
  return t && Vi(!1), f;
}
function df(e, t) {
  const o = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, Ec);
  const { setup: i } = o;
  if (i) {
    on();
    const a = e.setupContext = i.length > 1 ? hf(e) : null, u = Br(e), f = $r(
      i,
      e,
      0,
      [
        e.props,
        a
      ]
    ), p = La(f);
    if (sn(), u(), (p || e.sp) && !ir(e) && pl(e), p) {
      if (f.then(da, da), t)
        return f.then((h) => {
          pa(e, h);
        }).catch((h) => {
          Fo(h, e, 0);
        });
      e.asyncDep = f;
    } else
      pa(e, f);
  } else
    Fl(e);
}
function pa(e, t, o) {
  ge(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : qe(t) && (e.setupState = al(t)), Fl(e);
}
function Fl(e, t, o) {
  const i = e.type;
  e.render || (e.render = i.render || Ht);
  {
    const a = Br(e);
    on();
    try {
      Tc(e);
    } finally {
      sn(), a();
    }
  }
}
const pf = {
  get(e, t) {
    return ht(e, "get", ""), e[t];
  }
};
function hf(e) {
  const t = (o) => {
    e.exposed = o || {};
  };
  return {
    attrs: new Proxy(e.attrs, pf),
    slots: e.slots,
    emit: e.emit,
    expose: t
  };
}
function Uo(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(al(as(e.exposed)), {
    get(t, o) {
      if (o in t)
        return t[o];
      if (o in Pr)
        return Pr[o](e);
    },
    has(t, o) {
      return o in t || o in Pr;
    }
  })) : e.proxy;
}
function mf(e) {
  return ge(e) && "__vccOpts" in e;
}
const Ot = (e, t) => ac(e, t, Mr), yf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Hi;
const ha = typeof window < "u" && window.trustedTypes;
if (ha)
  try {
    Hi = /* @__PURE__ */ ha.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const $l = Hi ? (e) => Hi.createHTML(e) : (e) => e, vf = "http://www.w3.org/2000/svg", gf = "http://www.w3.org/1998/Math/MathML", Jt = typeof document < "u" ? document : null, ma = Jt && /* @__PURE__ */ Jt.createElement("template"), bf = {
  insert: (e, t, o) => {
    t.insertBefore(e, o || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, o, i) => {
    const a = t === "svg" ? Jt.createElementNS(vf, e) : t === "mathml" ? Jt.createElementNS(gf, e) : o ? Jt.createElement(e, { is: o }) : Jt.createElement(e);
    return e === "select" && i && i.multiple != null && a.setAttribute("multiple", i.multiple), a;
  },
  createText: (e) => Jt.createTextNode(e),
  createComment: (e) => Jt.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => Jt.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, o, i, a, u) {
    const f = o ? o.previousSibling : t.lastChild;
    if (a && (a === u || a.nextSibling))
      for (; t.insertBefore(a.cloneNode(!0), o), !(a === u || !(a = a.nextSibling)); )
        ;
    else {
      ma.innerHTML = $l(
        i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e
      );
      const p = ma.content;
      if (i === "svg" || i === "mathml") {
        const h = p.firstChild;
        for (; h.firstChild; )
          p.appendChild(h.firstChild);
        p.removeChild(h);
      }
      t.insertBefore(p, o);
    }
    return [
      // first
      f ? f.nextSibling : t.firstChild,
      // last
      o ? o.previousSibling : t.lastChild
    ];
  }
}, _f = Symbol("_vtc");
function wf(e, t, o) {
  const i = e[_f];
  i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : o ? e.setAttribute("class", t) : e.className = t;
}
const ya = Symbol("_vod"), xf = Symbol("_vsh"), Sf = Symbol(""), Cf = /(^|;)\s*display\s*:/;
function Of(e, t, o) {
  const i = e.style, a = Ze(o);
  let u = !1;
  if (o && !a) {
    if (t)
      if (Ze(t))
        for (const f of t.split(";")) {
          const p = f.slice(0, f.indexOf(":")).trim();
          o[p] == null && bo(i, p, "");
        }
      else
        for (const f in t)
          o[f] == null && bo(i, f, "");
    for (const f in o)
      f === "display" && (u = !0), bo(i, f, o[f]);
  } else if (a) {
    if (t !== o) {
      const f = i[Sf];
      f && (o += ";" + f), i.cssText = o, u = Cf.test(o);
    }
  } else t && e.removeAttribute("style");
  ya in e && (e[ya] = u ? i.display : "", e[xf] && (i.display = "none"));
}
const va = /\s*!important$/;
function bo(e, t, o) {
  if (fe(o))
    o.forEach((i) => bo(e, t, i));
  else if (o == null && (o = ""), t.startsWith("--"))
    e.setProperty(t, o);
  else {
    const i = Nf(e, t);
    va.test(o) ? e.setProperty(
      qn(i),
      o.replace(va, ""),
      "important"
    ) : e[i] = o;
  }
}
const ga = ["Webkit", "Moz", "ms"], Ri = {};
function Nf(e, t) {
  const o = Ri[t];
  if (o)
    return o;
  let i = On(t);
  if (i !== "filter" && i in e)
    return Ri[t] = i;
  i = Fa(i);
  for (let a = 0; a < ga.length; a++) {
    const u = ga[a] + i;
    if (u in e)
      return Ri[t] = u;
  }
  return t;
}
const ba = "http://www.w3.org/1999/xlink";
function _a(e, t, o, i, a, u = Ru(t)) {
  i && t.startsWith("xlink:") ? o == null ? e.removeAttributeNS(ba, t.slice(6, t.length)) : e.setAttributeNS(ba, t, o) : o == null || u && !$a(o) ? e.removeAttribute(t) : e.setAttribute(
    t,
    u ? "" : Kt(o) ? String(o) : o
  );
}
function wa(e, t, o, i, a) {
  if (t === "innerHTML" || t === "textContent") {
    o != null && (e[t] = t === "innerHTML" ? $l(o) : o);
    return;
  }
  const u = e.tagName;
  if (t === "value" && u !== "PROGRESS" && // custom elements may use _value internally
  !u.includes("-")) {
    const p = u === "OPTION" ? e.getAttribute("value") || "" : e.value, h = o == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(o);
    (p !== h || !("_value" in e)) && (e.value = h), o == null && e.removeAttribute(t), e._value = o;
    return;
  }
  let f = !1;
  if (o === "" || o == null) {
    const p = typeof e[t];
    p === "boolean" ? o = $a(o) : o == null && p === "string" ? (o = "", f = !0) : p === "number" && (o = 0, f = !0);
  }
  try {
    e[t] = o;
  } catch {
  }
  f && e.removeAttribute(a || t);
}
function en(e, t, o, i) {
  e.addEventListener(t, o, i);
}
function Ef(e, t, o, i) {
  e.removeEventListener(t, o, i);
}
const xa = Symbol("_vei");
function Tf(e, t, o, i, a = null) {
  const u = e[xa] || (e[xa] = {}), f = u[t];
  if (i && f)
    f.value = i;
  else {
    const [p, h] = Pf(t);
    if (i) {
      const N = u[t] = Df(
        i,
        a
      );
      en(e, p, N, h);
    } else f && (Ef(e, p, f, h), u[t] = void 0);
  }
}
const Sa = /(?:Once|Passive|Capture)$/;
function Pf(e) {
  let t;
  if (Sa.test(e)) {
    t = {};
    let i;
    for (; i = e.match(Sa); )
      e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : qn(e.slice(2)), t];
}
let Di = 0;
const Af = /* @__PURE__ */ Promise.resolve(), Rf = () => Di || (Af.then(() => Di = 0), Di = Date.now());
function Df(e, t) {
  const o = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= o.attached)
      return;
    Wt(
      kf(i, o.value),
      t,
      5,
      [i]
    );
  };
  return o.value = e, o.attached = Rf(), o;
}
function kf(e, t) {
  if (fe(t)) {
    const o = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      o.call(e), e._stopped = !0;
    }, t.map(
      (i) => (a) => !a._stopped && i && i(a)
    );
  } else
    return t;
}
const Ca = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, If = (e, t, o, i, a, u) => {
  const f = a === "svg";
  t === "class" ? wf(e, i, f) : t === "style" ? Of(e, o, i) : ko(t) ? Qi(t) || Tf(e, t, o, i, u) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : jf(e, t, i, f)) ? (wa(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && _a(e, t, i, f, u, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !Ze(i)) ? wa(e, On(t), i, u, t) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), _a(e, t, i, f));
};
function jf(e, t, o, i) {
  if (i)
    return !!(t === "innerHTML" || t === "textContent" || t in e && Ca(t) && ge(o));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (t === "width" || t === "height") {
    const a = e.tagName;
    if (a === "IMG" || a === "VIDEO" || a === "CANVAS" || a === "SOURCE")
      return !1;
  }
  return Ca(t) && Ze(o) ? !1 : t in e;
}
const En = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return fe(t) ? (o) => vo(t, o) : t;
};
function Lf(e) {
  e.target.composing = !0;
}
function Oa(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const It = Symbol("_assign"), ar = {
  created(e, { modifiers: { lazy: t, trim: o, number: i } }, a) {
    e[It] = En(a);
    const u = i || a.props && a.props.type === "number";
    en(e, t ? "change" : "input", (f) => {
      if (f.target.composing) return;
      let p = e.value;
      o && (p = p.trim()), u && (p = xo(p)), e[It](p);
    }), o && en(e, "change", () => {
      e.value = e.value.trim();
    }), t || (en(e, "compositionstart", Lf), en(e, "compositionend", Oa), en(e, "change", Oa));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, oldValue: o, modifiers: { lazy: i, trim: a, number: u } }, f) {
    if (e[It] = En(f), e.composing) return;
    const p = (u || e.type === "number") && !/^0\d/.test(e.value) ? xo(e.value) : e.value, h = t ?? "";
    p !== h && (document.activeElement === e && e.type !== "range" && (i && t === o || a && e.value.trim() === h) || (e.value = h));
  }
}, Na = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, t, o) {
    e[It] = En(o), en(e, "change", () => {
      const i = e._modelValue, a = lr(e), u = e.checked, f = e[It];
      if (fe(i)) {
        const p = Zi(i, a), h = p !== -1;
        if (u && !h)
          f(i.concat(a));
        else if (!u && h) {
          const N = [...i];
          N.splice(p, 1), f(N);
        }
      } else if (cr(i)) {
        const p = new Set(i);
        u ? p.add(a) : p.delete(a), f(p);
      } else
        f(Bl(e, u));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Ea,
  beforeUpdate(e, t, o) {
    e[It] = En(o), Ea(e, t, o);
  }
};
function Ea(e, { value: t, oldValue: o }, i) {
  e._modelValue = t;
  let a;
  if (fe(t))
    a = Zi(t, i.props.value) > -1;
  else if (cr(t))
    a = t.has(i.props.value);
  else {
    if (t === o) return;
    a = Bn(t, Bl(e, !0));
  }
  e.checked !== a && (e.checked = a);
}
const Ta = {
  created(e, { value: t }, o) {
    e.checked = Bn(t, o.props.value), e[It] = En(o), en(e, "change", () => {
      e[It](lr(e));
    });
  },
  beforeUpdate(e, { value: t, oldValue: o }, i) {
    e[It] = En(i), t !== o && (e.checked = Bn(t, i.props.value));
  }
}, xn = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(e, { value: t, modifiers: { number: o } }, i) {
    const a = cr(t);
    en(e, "change", () => {
      const u = Array.prototype.filter.call(e.options, (f) => f.selected).map(
        (f) => o ? xo(lr(f)) : lr(f)
      );
      e[It](
        e.multiple ? a ? new Set(u) : u : u[0]
      ), e._assigning = !0, ls(() => {
        e._assigning = !1;
      });
    }), e[It] = En(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: t }) {
    Pa(e, t);
  },
  beforeUpdate(e, t, o) {
    e[It] = En(o);
  },
  updated(e, { value: t }) {
    e._assigning || Pa(e, t);
  }
};
function Pa(e, t) {
  const o = e.multiple, i = fe(t);
  if (!(o && !i && !cr(t))) {
    for (let a = 0, u = e.options.length; a < u; a++) {
      const f = e.options[a], p = lr(f);
      if (o)
        if (i) {
          const h = typeof p;
          h === "string" || h === "number" ? f.selected = t.some((N) => String(N) === String(p)) : f.selected = Zi(t, p) > -1;
        } else
          f.selected = t.has(p);
      else if (Bn(lr(f), t)) {
        e.selectedIndex !== a && (e.selectedIndex = a);
        return;
      }
    }
    !o && e.selectedIndex !== -1 && (e.selectedIndex = -1);
  }
}
function lr(e) {
  return "_value" in e ? e._value : e.value;
}
function Bl(e, t) {
  const o = t ? "_trueValue" : "_falseValue";
  return o in e ? e[o] : t;
}
const Kf = /* @__PURE__ */ yt({ patchProp: If }, bf);
let Aa;
function Mf() {
  return Aa || (Aa = Uc(Kf));
}
const Ff = (...e) => {
  const t = Mf().createApp(...e), { mount: o } = t;
  return t.mount = (i) => {
    const a = Bf(i);
    if (!a) return;
    const u = t._component;
    !ge(u) && !u.render && !u.template && (u.template = a.innerHTML), a.nodeType === 1 && (a.textContent = "");
    const f = o(a, !1, $f(a));
    return a instanceof Element && (a.removeAttribute("v-cloak"), a.setAttribute("data-v-app", "")), f;
  }, t;
};
function $f(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function Bf(e) {
  return Ze(e) ? document.querySelector(e) : e;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let ql;
const Vo = (e) => ql = e, Ul = (
  /* istanbul ignore next */
  Symbol()
);
function Wi(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var Dr;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(Dr || (Dr = {}));
function qf() {
  const e = Va(!0), t = e.run(() => Qe({}));
  let o = [], i = [];
  const a = as({
    install(u) {
      Vo(a), a._a = u, u.provide(Ul, a), u.config.globalProperties.$pinia = a, i.forEach((f) => o.push(f)), i = [];
    },
    use(u) {
      return this._a ? o.push(u) : i.push(u), this;
    },
    _p: o,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: t
  });
  return a;
}
const Vl = () => {
};
function Ra(e, t, o, i = Vl) {
  e.push(t);
  const a = () => {
    const u = e.indexOf(t);
    u > -1 && (e.splice(u, 1), i());
  };
  return !o && Ha() && ku(a), a;
}
function er(e, ...t) {
  e.slice().forEach((o) => {
    o(...t);
  });
}
const Uf = (e) => e(), Da = Symbol(), ki = Symbol();
function zi(e, t) {
  e instanceof Map && t instanceof Map ? t.forEach((o, i) => e.set(i, o)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
  for (const o in t) {
    if (!t.hasOwnProperty(o))
      continue;
    const i = t[o], a = e[o];
    Wi(a) && Wi(i) && e.hasOwnProperty(o) && !Je(i) && !Cn(i) ? e[o] = zi(a, i) : e[o] = i;
  }
  return e;
}
const Vf = (
  /* istanbul ignore next */
  Symbol()
);
function Hf(e) {
  return !Wi(e) || !Object.prototype.hasOwnProperty.call(e, Vf);
}
const { assign: bn } = Object;
function Wf(e) {
  return !!(Je(e) && e.effect);
}
function zf(e, t, o, i) {
  const { state: a, actions: u, getters: f } = t, p = o.state.value[e];
  let h;
  function N() {
    p || (o.state.value[e] = a ? a() : {});
    const b = rc(o.state.value[e]);
    return bn(b, u, Object.keys(f || {}).reduce((C, A) => (C[A] = as(Ot(() => {
      Vo(o);
      const I = o._s.get(e);
      return f[A].call(I, I);
    })), C), {}));
  }
  return h = Hl(e, N, t, o, i, !0), h;
}
function Hl(e, t, o = {}, i, a, u) {
  let f;
  const p = bn({ actions: {} }, o), h = { deep: !0 };
  let N, b, C = [], A = [], I;
  const G = i.state.value[e];
  !u && !G && (i.state.value[e] = {}), Qe({});
  let re;
  function F(xe) {
    let Ne;
    N = b = !1, typeof xe == "function" ? (xe(i.state.value[e]), Ne = {
      type: Dr.patchFunction,
      storeId: e,
      events: I
    }) : (zi(i.state.value[e], xe), Ne = {
      type: Dr.patchObject,
      payload: xe,
      storeId: e,
      events: I
    });
    const Ve = re = Symbol();
    ls().then(() => {
      re === Ve && (N = !0);
    }), b = !0, er(C, Ne, i.state.value[e]);
  }
  const U = u ? function() {
    const { state: Ne } = o, Ve = Ne ? Ne() : {};
    this.$patch((vt) => {
      bn(vt, Ve);
    });
  } : (
    /* istanbul ignore next */
    Vl
  );
  function pe() {
    f.stop(), C = [], A = [], i._s.delete(e);
  }
  const Se = (xe, Ne = "") => {
    if (Da in xe)
      return xe[ki] = Ne, xe;
    const Ve = function() {
      Vo(i);
      const vt = Array.from(arguments), lt = [], ut = [];
      function Tn(we) {
        lt.push(we);
      }
      function un(we) {
        ut.push(we);
      }
      er(A, {
        args: vt,
        name: Ve[ki],
        store: _e,
        after: Tn,
        onError: un
      });
      let $e;
      try {
        $e = xe.apply(this && this.$id === e ? this : _e, vt);
      } catch (we) {
        throw er(ut, we), we;
      }
      return $e instanceof Promise ? $e.then((we) => (er(lt, we), we)).catch((we) => (er(ut, we), Promise.reject(we))) : (er(lt, $e), $e);
    };
    return Ve[Da] = !0, Ve[ki] = Ne, Ve;
  }, le = {
    _p: i,
    // _s: scope,
    $id: e,
    $onAction: Ra.bind(null, A),
    $patch: F,
    $reset: U,
    $subscribe(xe, Ne = {}) {
      const Ve = Ra(C, xe, Ne.detached, () => vt()), vt = f.run(() => rn(() => i.state.value[e], (lt) => {
        (Ne.flush === "sync" ? b : N) && xe({
          storeId: e,
          type: Dr.direct,
          events: I
        }, lt);
      }, bn({}, h, Ne)));
      return Ve;
    },
    $dispose: pe
  }, _e = Mo(le);
  i._s.set(e, _e);
  const De = (i._a && i._a.runWithContext || Uf)(() => i._e.run(() => (f = Va()).run(() => t({ action: Se }))));
  for (const xe in De) {
    const Ne = De[xe];
    if (Je(Ne) && !Wf(Ne) || Cn(Ne))
      u || (G && Hf(Ne) && (Je(Ne) ? Ne.value = G[xe] : zi(Ne, G[xe])), i.state.value[e][xe] = Ne);
    else if (typeof Ne == "function") {
      const Ve = Se(Ne, xe);
      De[xe] = Ve, p.actions[xe] = Ne;
    }
  }
  return bn(_e, De), bn(Ae(_e), De), Object.defineProperty(_e, "$state", {
    get: () => i.state.value[e],
    set: (xe) => {
      F((Ne) => {
        bn(Ne, xe);
      });
    }
  }), i._p.forEach((xe) => {
    bn(_e, f.run(() => xe({
      store: _e,
      app: i._a,
      pinia: i,
      options: p
    })));
  }), G && u && o.hydrate && o.hydrate(_e.$state, G), N = !0, b = !0, _e;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Gf(e, t, o) {
  let i;
  const a = typeof t == "function";
  i = a ? o : t;
  function u(f, p) {
    const h = Lc();
    return f = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    f || (h ? Ar(Ul, null) : null), f && Vo(f), f = ql, f._s.has(e) || (a ? Hl(e, t, i, f) : zf(e, i, f)), f._s.get(e);
  }
  return u.$id = e, u;
}
var Yf = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Qf(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _o = { exports: {} }, Jf = _o.exports, ka;
function Xf() {
  return ka || (ka = 1, function(e, t) {
    (function(o, i) {
      e.exports = i();
    })(Jf, function() {
      var o = function(n, r) {
        return (o = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, l) {
          s.__proto__ = l;
        } || function(s, l) {
          for (var c in l) Object.prototype.hasOwnProperty.call(l, c) && (s[c] = l[c]);
        })(n, r);
      }, i = function() {
        return (i = Object.assign || function(n) {
          for (var r, s = 1, l = arguments.length; s < l; s++) for (var c in r = arguments[s]) Object.prototype.hasOwnProperty.call(r, c) && (n[c] = r[c]);
          return n;
        }).apply(this, arguments);
      };
      function a(n, r, s) {
        for (var l, c = 0, d = r.length; c < d; c++) !l && c in r || ((l = l || Array.prototype.slice.call(r, 0, c))[c] = r[c]);
        return n.concat(l || Array.prototype.slice.call(r));
      }
      var u = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Yf, f = Object.keys, p = Array.isArray;
      function h(n, r) {
        return typeof r != "object" || f(r).forEach(function(s) {
          n[s] = r[s];
        }), n;
      }
      typeof Promise > "u" || u.Promise || (u.Promise = Promise);
      var N = Object.getPrototypeOf, b = {}.hasOwnProperty;
      function C(n, r) {
        return b.call(n, r);
      }
      function A(n, r) {
        typeof r == "function" && (r = r(N(n))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(r).forEach(function(s) {
          G(n, s, r[s]);
        });
      }
      var I = Object.defineProperty;
      function G(n, r, s, l) {
        I(n, r, h(s && C(s, "get") && typeof s.get == "function" ? { get: s.get, set: s.set, configurable: !0 } : { value: s, configurable: !0, writable: !0 }, l));
      }
      function re(n) {
        return { from: function(r) {
          return n.prototype = Object.create(r.prototype), G(n.prototype, "constructor", n), { extend: A.bind(null, n.prototype) };
        } };
      }
      var F = Object.getOwnPropertyDescriptor, U = [].slice;
      function pe(n, r, s) {
        return U.call(n, r, s);
      }
      function Se(n, r) {
        return r(n);
      }
      function le(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function _e(n) {
        u.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function Ke(n, r) {
        if (typeof r == "string" && C(n, r)) return n[r];
        if (!r) return n;
        if (typeof r != "string") {
          for (var s = [], l = 0, c = r.length; l < c; ++l) {
            var d = Ke(n, r[l]);
            s.push(d);
          }
          return s;
        }
        var m = r.indexOf(".");
        if (m !== -1) {
          var v = n[r.substr(0, m)];
          return v == null ? void 0 : Ke(v, r.substr(m + 1));
        }
      }
      function De(n, r, s) {
        if (n && r !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof r != "string" && "length" in r) {
          le(typeof s != "string" && "length" in s);
          for (var l = 0, c = r.length; l < c; ++l) De(n, r[l], s[l]);
        } else {
          var d, m, v = r.indexOf(".");
          v !== -1 ? (d = r.substr(0, v), (m = r.substr(v + 1)) === "" ? s === void 0 ? p(n) && !isNaN(parseInt(d)) ? n.splice(d, 1) : delete n[d] : n[d] = s : De(v = !(v = n[d]) || !C(n, d) ? n[d] = {} : v, m, s)) : s === void 0 ? p(n) && !isNaN(parseInt(r)) ? n.splice(r, 1) : delete n[r] : n[r] = s;
        }
      }
      function xe(n) {
        var r, s = {};
        for (r in n) C(n, r) && (s[r] = n[r]);
        return s;
      }
      var Ne = [].concat;
      function Ve(n) {
        return Ne.apply([], n);
      }
      var ye = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Ve([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(r) {
          return r + n + "Array";
        });
      }))).filter(function(n) {
        return u[n];
      }), vt = new Set(ye.map(function(n) {
        return u[n];
      })), lt = null;
      function ut(n) {
        return lt = /* @__PURE__ */ new WeakMap(), n = function r(s) {
          if (!s || typeof s != "object") return s;
          var l = lt.get(s);
          if (l) return l;
          if (p(s)) {
            l = [], lt.set(s, l);
            for (var c = 0, d = s.length; c < d; ++c) l.push(r(s[c]));
          } else if (vt.has(s.constructor)) l = s;
          else {
            var m, v = N(s);
            for (m in l = v === Object.prototype ? {} : Object.create(v), lt.set(s, l), s) C(s, m) && (l[m] = r(s[m]));
          }
          return l;
        }(n), lt = null, n;
      }
      var Tn = {}.toString;
      function un(n) {
        return Tn.call(n).slice(8, -1);
      }
      var $e = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", we = typeof $e == "symbol" ? function(n) {
        var r;
        return n != null && (r = n[$e]) && r.apply(n);
      } : function() {
        return null;
      };
      function Ee(n, r) {
        return r = n.indexOf(r), 0 <= r && n.splice(r, 1), 0 <= r;
      }
      var St = {};
      function Ct(n) {
        var r, s, l, c;
        if (arguments.length === 1) {
          if (p(n)) return n.slice();
          if (this === St && typeof n == "string") return [n];
          if (c = we(n)) {
            for (s = []; !(l = c.next()).done; ) s.push(l.value);
            return s;
          }
          if (n == null) return [n];
          if (typeof (r = n.length) != "number") return [n];
          for (s = new Array(r); r--; ) s[r] = n[r];
          return s;
        }
        for (r = arguments.length, s = new Array(r); r--; ) s[r] = arguments[r];
        return s;
      }
      var jt = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, ce = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Dt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(ce), At = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function zt(n, r) {
        this.name = n, this.message = r;
      }
      function qr(n, r) {
        return n + ". Errors: " + Object.keys(r).map(function(s) {
          return r[s].toString();
        }).filter(function(s, l, c) {
          return c.indexOf(s) === l;
        }).join(`
`);
      }
      function Un(n, r, s, l) {
        this.failures = r, this.failedKeys = l, this.successCount = s, this.message = qr(n, r);
      }
      function Rt(n, r) {
        this.name = "BulkError", this.failures = Object.keys(r).map(function(s) {
          return r[s];
        }), this.failuresByPos = r, this.message = qr(n, this.failures);
      }
      re(zt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), re(Un).from(zt), re(Rt).from(zt);
      var cn = Dt.reduce(function(n, r) {
        return n[r] = r + "Error", n;
      }, {}), fr = zt, se = Dt.reduce(function(n, r) {
        var s = r + "Error";
        function l(c, d) {
          this.name = s, c ? typeof c == "string" ? (this.message = "".concat(c).concat(d ? `
 ` + d : ""), this.inner = d || null) : typeof c == "object" && (this.message = "".concat(c.name, " ").concat(c.message), this.inner = c) : (this.message = At[r] || s, this.inner = null);
        }
        return re(l).from(fr), n[r] = l, n;
      }, {});
      se.Syntax = SyntaxError, se.Type = TypeError, se.Range = RangeError;
      var fn = ce.reduce(function(n, r) {
        return n[r + "Error"] = se[r], n;
      }, {}), dr = Dt.reduce(function(n, r) {
        return ["Syntax", "Type", "Range"].indexOf(r) === -1 && (n[r + "Error"] = se[r]), n;
      }, {});
      function y() {
      }
      function x(n) {
        return n;
      }
      function M(n, r) {
        return n == null || n === x ? r : function(s) {
          return r(n(s));
        };
      }
      function q(n, r) {
        return function() {
          n.apply(this, arguments), r.apply(this, arguments);
        };
      }
      function B(n, r) {
        return n === y ? r : function() {
          var s = n.apply(this, arguments);
          s !== void 0 && (arguments[0] = s);
          var l = this.onsuccess, c = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var d = r.apply(this, arguments);
          return l && (this.onsuccess = this.onsuccess ? q(l, this.onsuccess) : l), c && (this.onerror = this.onerror ? q(c, this.onerror) : c), d !== void 0 ? d : s;
        };
      }
      function V(n, r) {
        return n === y ? r : function() {
          n.apply(this, arguments);
          var s = this.onsuccess, l = this.onerror;
          this.onsuccess = this.onerror = null, r.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? q(s, this.onsuccess) : s), l && (this.onerror = this.onerror ? q(l, this.onerror) : l);
        };
      }
      function ee(n, r) {
        return n === y ? r : function(s) {
          var l = n.apply(this, arguments);
          h(s, l);
          var c = this.onsuccess, d = this.onerror;
          return this.onsuccess = null, this.onerror = null, s = r.apply(this, arguments), c && (this.onsuccess = this.onsuccess ? q(c, this.onsuccess) : c), d && (this.onerror = this.onerror ? q(d, this.onerror) : d), l === void 0 ? s === void 0 ? void 0 : s : h(l, s);
        };
      }
      function J(n, r) {
        return n === y ? r : function() {
          return r.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function Y(n, r) {
        return n === y ? r : function() {
          var s = n.apply(this, arguments);
          if (s && typeof s.then == "function") {
            for (var l = this, c = arguments.length, d = new Array(c); c--; ) d[c] = arguments[c];
            return s.then(function() {
              return r.apply(l, d);
            });
          }
          return r.apply(this, arguments);
        };
      }
      dr.ModifyError = Un, dr.DexieError = zt, dr.BulkError = Rt;
      var $ = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function ue(n) {
        $ = n;
      }
      var X = {}, ae = 100, ye = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, N(n), n];
        var r = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [r, N(r), n];
      }(), ce = ye[0], Dt = ye[1], ye = ye[2], Dt = Dt && Dt.then, Te = ce && ce.constructor, Re = !!ye, Xe = function(n, r) {
        dn.push([n, r]), gt && (queueMicrotask(Jl), gt = !1);
      }, et = !0, gt = !0, tt = [], Ft = [], Vn = x, We = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: y, pgp: !1, env: {}, finalize: y }, ie = We, dn = [], Pn = 0, Ur = [];
      function ne(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var r = this._PSD = ie;
        if (typeof n != "function") {
          if (n !== X) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && zo(this, this._value));
        }
        this._state = null, this._value = null, ++r.ref, function s(l, c) {
          try {
            c(function(d) {
              if (l._state === null) {
                if (d === l) throw new TypeError("A promise cannot be resolved with itself.");
                var m = l._lib && Hn();
                d && typeof d.then == "function" ? s(l, function(v, _) {
                  d instanceof ne ? d._then(v, _) : d.then(v, _);
                }) : (l._state = !0, l._value = d, _s(l)), m && Wn();
              }
            }, zo.bind(null, l));
          } catch (d) {
            zo(l, d);
          }
        }(this, n);
      }
      var Wo = { get: function() {
        var n = ie, r = zr;
        function s(l, c) {
          var d = this, m = !n.global && (n !== ie || r !== zr), v = m && !hn(), _ = new ne(function(S, E) {
            Go(d, new bs(xs(l, n, m, v), xs(c, n, m, v), S, E, n));
          });
          return this._consoleTask && (_._consoleTask = this._consoleTask), _;
        }
        return s.prototype = X, s;
      }, set: function(n) {
        G(this, "then", n && n.prototype === X ? Wo : { get: function() {
          return n;
        }, set: Wo.set });
      } };
      function bs(n, r, s, l, c) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof r == "function" ? r : null, this.resolve = s, this.reject = l, this.psd = c;
      }
      function zo(n, r) {
        var s, l;
        Ft.push(r), n._state === null && (s = n._lib && Hn(), r = Vn(r), n._state = !1, n._value = r, l = n, tt.some(function(c) {
          return c._value === l._value;
        }) || tt.push(l), _s(n), s && Wn());
      }
      function _s(n) {
        var r = n._listeners;
        n._listeners = [];
        for (var s = 0, l = r.length; s < l; ++s) Go(n, r[s]);
        var c = n._PSD;
        --c.ref || c.finalize(), Pn === 0 && (++Pn, Xe(function() {
          --Pn == 0 && Yo();
        }, []));
      }
      function Go(n, r) {
        if (n._state !== null) {
          var s = n._state ? r.onFulfilled : r.onRejected;
          if (s === null) return (n._state ? r.resolve : r.reject)(n._value);
          ++r.psd.ref, ++Pn, Xe(Ql, [s, n, r]);
        } else n._listeners.push(r);
      }
      function Ql(n, r, s) {
        try {
          var l, c = r._value;
          !r._state && Ft.length && (Ft = []), l = $ && r._consoleTask ? r._consoleTask.run(function() {
            return n(c);
          }) : n(c), r._state || Ft.indexOf(c) !== -1 || function(d) {
            for (var m = tt.length; m; ) if (tt[--m]._value === d._value) return tt.splice(m, 1);
          }(r), s.resolve(l);
        } catch (d) {
          s.reject(d);
        } finally {
          --Pn == 0 && Yo(), --s.psd.ref || s.psd.finalize();
        }
      }
      function Jl() {
        An(We, function() {
          Hn() && Wn();
        });
      }
      function Hn() {
        var n = et;
        return gt = et = !1, n;
      }
      function Wn() {
        var n, r, s;
        do
          for (; 0 < dn.length; ) for (n = dn, dn = [], s = n.length, r = 0; r < s; ++r) {
            var l = n[r];
            l[0].apply(null, l[1]);
          }
        while (0 < dn.length);
        gt = et = !0;
      }
      function Yo() {
        var n = tt;
        tt = [], n.forEach(function(l) {
          l._PSD.onunhandled.call(null, l._value, l);
        });
        for (var r = Ur.slice(0), s = r.length; s; ) r[--s]();
      }
      function Vr(n) {
        return new ne(X, !1, n);
      }
      function Ue(n, r) {
        var s = ie;
        return function() {
          var l = Hn(), c = ie;
          try {
            return mn(s, !0), n.apply(this, arguments);
          } catch (d) {
            r && r(d);
          } finally {
            mn(c, !1), l && Wn();
          }
        };
      }
      A(ne.prototype, { then: Wo, _then: function(n, r) {
        Go(this, new bs(null, null, n, r, ie));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var r = n, s = arguments[1];
        return typeof r == "function" ? this.then(null, function(l) {
          return (l instanceof r ? s : Vr)(l);
        }) : this.then(null, function(l) {
          return (l && l.name === r ? s : Vr)(l);
        });
      }, finally: function(n) {
        return this.then(function(r) {
          return ne.resolve(n()).then(function() {
            return r;
          });
        }, function(r) {
          return ne.resolve(n()).then(function() {
            return Vr(r);
          });
        });
      }, timeout: function(n, r) {
        var s = this;
        return n < 1 / 0 ? new ne(function(l, c) {
          var d = setTimeout(function() {
            return c(new se.Timeout(r));
          }, n);
          s.then(l, c).finally(clearTimeout.bind(null, d));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && G(ne.prototype, Symbol.toStringTag, "Dexie.Promise"), We.env = ws(), A(ne, { all: function() {
        var n = Ct.apply(null, arguments).map(Gr);
        return new ne(function(r, s) {
          n.length === 0 && r([]);
          var l = n.length;
          n.forEach(function(c, d) {
            return ne.resolve(c).then(function(m) {
              n[d] = m, --l || r(n);
            }, s);
          });
        });
      }, resolve: function(n) {
        return n instanceof ne ? n : n && typeof n.then == "function" ? new ne(function(r, s) {
          n.then(r, s);
        }) : new ne(X, !0, n);
      }, reject: Vr, race: function() {
        var n = Ct.apply(null, arguments).map(Gr);
        return new ne(function(r, s) {
          n.map(function(l) {
            return ne.resolve(l).then(r, s);
          });
        });
      }, PSD: { get: function() {
        return ie;
      }, set: function(n) {
        return ie = n;
      } }, totalEchoes: { get: function() {
        return zr;
      } }, newPSD: pn, usePSD: An, scheduler: { get: function() {
        return Xe;
      }, set: function(n) {
        Xe = n;
      } }, rejectionMapper: { get: function() {
        return Vn;
      }, set: function(n) {
        Vn = n;
      } }, follow: function(n, r) {
        return new ne(function(s, l) {
          return pn(function(c, d) {
            var m = ie;
            m.unhandleds = [], m.onunhandled = d, m.finalize = q(function() {
              var v, _ = this;
              v = function() {
                _.unhandleds.length === 0 ? c() : d(_.unhandleds[0]);
              }, Ur.push(function S() {
                v(), Ur.splice(Ur.indexOf(S), 1);
              }), ++Pn, Xe(function() {
                --Pn == 0 && Yo();
              }, []);
            }, m.finalize), n();
          }, r, s, l);
        });
      } }), Te && (Te.allSettled && G(ne, "allSettled", function() {
        var n = Ct.apply(null, arguments).map(Gr);
        return new ne(function(r) {
          n.length === 0 && r([]);
          var s = n.length, l = new Array(s);
          n.forEach(function(c, d) {
            return ne.resolve(c).then(function(m) {
              return l[d] = { status: "fulfilled", value: m };
            }, function(m) {
              return l[d] = { status: "rejected", reason: m };
            }).then(function() {
              return --s || r(l);
            });
          });
        });
      }), Te.any && typeof AggregateError < "u" && G(ne, "any", function() {
        var n = Ct.apply(null, arguments).map(Gr);
        return new ne(function(r, s) {
          n.length === 0 && s(new AggregateError([]));
          var l = n.length, c = new Array(l);
          n.forEach(function(d, m) {
            return ne.resolve(d).then(function(v) {
              return r(v);
            }, function(v) {
              c[m] = v, --l || s(new AggregateError(c));
            });
          });
        });
      }), Te.withResolvers && (ne.withResolvers = Te.withResolvers));
      var nt = { awaits: 0, echoes: 0, id: 0 }, Xl = 0, Hr = [], Wr = 0, zr = 0, Zl = 0;
      function pn(n, r, s, l) {
        var c = ie, d = Object.create(c);
        return d.parent = c, d.ref = 0, d.global = !1, d.id = ++Zl, We.env, d.env = Re ? { Promise: ne, PromiseProp: { value: ne, configurable: !0, writable: !0 }, all: ne.all, race: ne.race, allSettled: ne.allSettled, any: ne.any, resolve: ne.resolve, reject: ne.reject } : {}, r && h(d, r), ++c.ref, d.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, l = An(d, n, s, l), d.ref === 0 && d.finalize(), l;
      }
      function zn() {
        return nt.id || (nt.id = ++Xl), ++nt.awaits, nt.echoes += ae, nt.id;
      }
      function hn() {
        return !!nt.awaits && (--nt.awaits == 0 && (nt.id = 0), nt.echoes = nt.awaits * ae, !0);
      }
      function Gr(n) {
        return nt.echoes && n && n.constructor === Te ? (zn(), n.then(function(r) {
          return hn(), r;
        }, function(r) {
          return hn(), Ge(r);
        })) : n;
      }
      function eu() {
        var n = Hr[Hr.length - 1];
        Hr.pop(), mn(n, !1);
      }
      function mn(n, r) {
        var s, l = ie;
        (r ? !nt.echoes || Wr++ && n === ie : !Wr || --Wr && n === ie) || queueMicrotask(r ? (function(c) {
          ++zr, nt.echoes && --nt.echoes != 0 || (nt.echoes = nt.awaits = nt.id = 0), Hr.push(ie), mn(c, !0);
        }).bind(null, n) : eu), n !== ie && (ie = n, l === We && (We.env = ws()), Re && (s = We.env.Promise, r = n.env, (l.global || n.global) && (Object.defineProperty(u, "Promise", r.PromiseProp), s.all = r.all, s.race = r.race, s.resolve = r.resolve, s.reject = r.reject, r.allSettled && (s.allSettled = r.allSettled), r.any && (s.any = r.any))));
      }
      function ws() {
        var n = u.Promise;
        return Re ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(u, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function An(n, r, s, l, c) {
        var d = ie;
        try {
          return mn(n, !0), r(s, l, c);
        } finally {
          mn(d, !1);
        }
      }
      function xs(n, r, s, l) {
        return typeof n != "function" ? n : function() {
          var c = ie;
          s && zn(), mn(r, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            mn(c, !1), l && queueMicrotask(hn);
          }
        };
      }
      function Qo(n) {
        Promise === Te && nt.echoes === 0 ? Wr === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + Dt).indexOf("[native code]") === -1 && (zn = hn = y);
      var Ge = ne.reject, Rn = "￿", Gt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ss = "String expected.", Gn = [], Yr = "__dbnames", Jo = "readonly", Xo = "readwrite";
      function Dn(n, r) {
        return n ? r ? function() {
          return n.apply(this, arguments) && r.apply(this, arguments);
        } : n : r;
      }
      var Cs = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Qr(n) {
        return typeof n != "string" || /\./.test(n) ? function(r) {
          return r;
        } : function(r) {
          return r[n] === void 0 && n in r && delete (r = ut(r))[n], r;
        };
      }
      function Os() {
        throw se.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Ce(n, r) {
        try {
          var s = Ns(n), l = Ns(r);
          if (s !== l) return s === "Array" ? 1 : l === "Array" ? -1 : s === "binary" ? 1 : l === "binary" ? -1 : s === "string" ? 1 : l === "string" ? -1 : s === "Date" ? 1 : l !== "Date" ? NaN : -1;
          switch (s) {
            case "number":
            case "Date":
            case "string":
              return r < n ? 1 : n < r ? -1 : 0;
            case "binary":
              return function(c, d) {
                for (var m = c.length, v = d.length, _ = m < v ? m : v, S = 0; S < _; ++S) if (c[S] !== d[S]) return c[S] < d[S] ? -1 : 1;
                return m === v ? 0 : m < v ? -1 : 1;
              }(Es(n), Es(r));
            case "Array":
              return function(c, d) {
                for (var m = c.length, v = d.length, _ = m < v ? m : v, S = 0; S < _; ++S) {
                  var E = Ce(c[S], d[S]);
                  if (E !== 0) return E;
                }
                return m === v ? 0 : m < v ? -1 : 1;
              }(n, r);
          }
        } catch {
        }
        return NaN;
      }
      function Ns(n) {
        var r = typeof n;
        return r != "object" ? r : ArrayBuffer.isView(n) ? "binary" : (n = un(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function Es(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Jr(n, r, s) {
        var l = n.schema.yProps;
        return l ? (r && 0 < s.numFailures && (r = r.filter(function(c, d) {
          return !s.failures[d];
        })), Promise.all(l.map(function(c) {
          return c = c.updatesTable, r ? n.db.table(c).where("k").anyOf(r).delete() : n.db.table(c).clear();
        })).then(function() {
          return s;
        })) : s;
      }
      var Ts = (Be.prototype._trans = function(n, r, s) {
        var l = this._tx || ie.trans, c = this.name, d = $ && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function m(S, E, g) {
          if (!g.schema[c]) throw new se.NotFound("Table " + c + " not part of transaction");
          return r(g.idbtrans, g);
        }
        var v = Hn();
        try {
          var _ = l && l.db._novip === this.db._novip ? l === ie.trans ? l._promise(n, m, s) : pn(function() {
            return l._promise(n, m, s);
          }, { trans: l, transless: ie.transless || ie }) : function S(E, g, R, w) {
            if (E.idbdb && (E._state.openComplete || ie.letThrough || E._vip)) {
              var O = E._createTransaction(g, R, E._dbSchema);
              try {
                O.create(), E._state.PR1398_maxLoop = 3;
              } catch (P) {
                return P.name === cn.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                  return S(E, g, R, w);
                })) : Ge(P);
              }
              return O._promise(g, function(P, T) {
                return pn(function() {
                  return ie.trans = O, w(P, T, O);
                });
              }).then(function(P) {
                if (g === "readwrite") try {
                  O.idbtrans.commit();
                } catch {
                }
                return g === "readonly" ? P : O._completion.then(function() {
                  return P;
                });
              });
            }
            if (E._state.openComplete) return Ge(new se.DatabaseClosed(E._state.dbOpenError));
            if (!E._state.isBeingOpened) {
              if (!E._state.autoOpen) return Ge(new se.DatabaseClosed());
              E.open().catch(y);
            }
            return E._state.dbReadyPromise.then(function() {
              return S(E, g, R, w);
            });
          }(this.db, n, [this.name], m);
          return d && (_._consoleTask = d, _ = _.catch(function(S) {
            return console.trace(S), Ge(S);
          })), _;
        } finally {
          v && Wn();
        }
      }, Be.prototype.get = function(n, r) {
        var s = this;
        return n && n.constructor === Object ? this.where(n).first(r) : n == null ? Ge(new se.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(l) {
          return s.core.get({ trans: l, key: n }).then(function(c) {
            return s.hook.reading.fire(c);
          });
        }).then(r);
      }, Be.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (p(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var r = f(n);
        if (r.length === 1) return this.where(r[0]).equals(n[r[0]]);
        var s = this.schema.indexes.concat(this.schema.primKey).filter(function(v) {
          if (v.compound && r.every(function(S) {
            return 0 <= v.keyPath.indexOf(S);
          })) {
            for (var _ = 0; _ < r.length; ++_) if (r.indexOf(v.keyPath[_]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(v, _) {
          return v.keyPath.length - _.keyPath.length;
        })[0];
        if (s && this.db._maxKey !== Rn) {
          var d = s.keyPath.slice(0, r.length);
          return this.where(d).equals(d.map(function(_) {
            return n[_];
          }));
        }
        !s && $ && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(r.join("+"), "]"));
        var l = this.schema.idxByName;
        function c(v, _) {
          return Ce(v, _) === 0;
        }
        var m = r.reduce(function(g, _) {
          var S = g[0], E = g[1], g = l[_], R = n[_];
          return [S || g, S || !g ? Dn(E, g && g.multi ? function(w) {
            return w = Ke(w, _), p(w) && w.some(function(O) {
              return c(R, O);
            });
          } : function(w) {
            return c(R, Ke(w, _));
          }) : E];
        }, [null, null]), d = m[0], m = m[1];
        return d ? this.where(d.name).equals(n[d.keyPath]).filter(m) : s ? this.filter(m) : this.where(r).equals("");
      }, Be.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Be.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Be.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Be.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Be.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Be.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Be.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Be.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, p(n) ? "[".concat(n.join("+"), "]") : n));
      }, Be.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Be.prototype.mapToClass = function(n) {
        var r, s = this.db, l = this.name;
        function c() {
          return r !== null && r.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof Os && (function(_, S) {
          if (typeof S != "function" && S !== null) throw new TypeError("Class extends value " + String(S) + " is not a constructor or null");
          function E() {
            this.constructor = _;
          }
          o(_, S), _.prototype = S === null ? Object.create(S) : (E.prototype = S.prototype, new E());
        }(c, r = n), Object.defineProperty(c.prototype, "db", { get: function() {
          return s;
        }, enumerable: !1, configurable: !0 }), c.prototype.table = function() {
          return l;
        }, n = c);
        for (var d = /* @__PURE__ */ new Set(), m = n.prototype; m; m = N(m)) Object.getOwnPropertyNames(m).forEach(function(_) {
          return d.add(_);
        });
        function v(_) {
          if (!_) return _;
          var S, E = Object.create(n.prototype);
          for (S in _) if (!d.has(S)) try {
            E[S] = _[S];
          } catch {
          }
          return E;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = v, this.hook("reading", v), n;
      }, Be.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Be.prototype.add = function(n, r) {
        var s = this, l = this.schema.primKey, c = l.auto, d = l.keyPath, m = n;
        return d && c && (m = Qr(d)(n)), this._trans("readwrite", function(v) {
          return s.core.mutate({ trans: v, type: "add", keys: r != null ? [r] : null, values: [m] });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (d) try {
            De(n, d, v);
          } catch {
          }
          return v;
        });
      }, Be.prototype.update = function(n, r) {
        return typeof n != "object" || p(n) ? this.where(":id").equals(n).modify(r) : (n = Ke(n, this.schema.primKey.keyPath), n === void 0 ? Ge(new se.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(r));
      }, Be.prototype.put = function(n, r) {
        var s = this, l = this.schema.primKey, c = l.auto, d = l.keyPath, m = n;
        return d && c && (m = Qr(d)(n)), this._trans("readwrite", function(v) {
          return s.core.mutate({ trans: v, type: "put", values: [m], keys: r != null ? [r] : null });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (d) try {
            De(n, d, v);
          } catch {
          }
          return v;
        });
      }, Be.prototype.delete = function(n) {
        var r = this;
        return this._trans("readwrite", function(s) {
          return r.core.mutate({ trans: s, type: "delete", keys: [n] }).then(function(l) {
            return Jr(r, [n], l);
          }).then(function(l) {
            return l.numFailures ? ne.reject(l.failures[0]) : void 0;
          });
        });
      }, Be.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(r) {
          return n.core.mutate({ trans: r, type: "deleteRange", range: Cs }).then(function(s) {
            return Jr(n, null, s);
          });
        }).then(function(r) {
          return r.numFailures ? ne.reject(r.failures[0]) : void 0;
        });
      }, Be.prototype.bulkGet = function(n) {
        var r = this;
        return this._trans("readonly", function(s) {
          return r.core.getMany({ keys: n, trans: s }).then(function(l) {
            return l.map(function(c) {
              return r.hook.reading.fire(c);
            });
          });
        });
      }, Be.prototype.bulkAdd = function(n, r, s) {
        var l = this, c = Array.isArray(r) ? r : void 0, d = (s = s || (c ? void 0 : r)) ? s.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var S = l.schema.primKey, v = S.auto, S = S.keyPath;
          if (S && c) throw new se.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new se.InvalidArgument("Arguments objects and keys must have the same length");
          var _ = n.length, S = S && v ? n.map(Qr(S)) : n;
          return l.core.mutate({ trans: m, type: "add", keys: c, values: S, wantResults: d }).then(function(O) {
            var g = O.numFailures, R = O.results, w = O.lastResult, O = O.failures;
            if (g === 0) return d ? R : w;
            throw new Rt("".concat(l.name, ".bulkAdd(): ").concat(g, " of ").concat(_, " operations failed"), O);
          });
        });
      }, Be.prototype.bulkPut = function(n, r, s) {
        var l = this, c = Array.isArray(r) ? r : void 0, d = (s = s || (c ? void 0 : r)) ? s.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var S = l.schema.primKey, v = S.auto, S = S.keyPath;
          if (S && c) throw new se.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (c && c.length !== n.length) throw new se.InvalidArgument("Arguments objects and keys must have the same length");
          var _ = n.length, S = S && v ? n.map(Qr(S)) : n;
          return l.core.mutate({ trans: m, type: "put", keys: c, values: S, wantResults: d }).then(function(O) {
            var g = O.numFailures, R = O.results, w = O.lastResult, O = O.failures;
            if (g === 0) return d ? R : w;
            throw new Rt("".concat(l.name, ".bulkPut(): ").concat(g, " of ").concat(_, " operations failed"), O);
          });
        });
      }, Be.prototype.bulkUpdate = function(n) {
        var r = this, s = this.core, l = n.map(function(m) {
          return m.key;
        }), c = n.map(function(m) {
          return m.changes;
        }), d = [];
        return this._trans("readwrite", function(m) {
          return s.getMany({ trans: m, keys: l, cache: "clone" }).then(function(v) {
            var _ = [], S = [];
            n.forEach(function(g, R) {
              var w = g.key, O = g.changes, P = v[R];
              if (P) {
                for (var T = 0, D = Object.keys(O); T < D.length; T++) {
                  var j = D[T], L = O[j];
                  if (j === r.schema.primKey.keyPath) {
                    if (Ce(L, w) !== 0) throw new se.Constraint("Cannot update primary key in bulkUpdate()");
                  } else De(P, j, L);
                }
                d.push(R), _.push(w), S.push(P);
              }
            });
            var E = _.length;
            return s.mutate({ trans: m, type: "put", keys: _, values: S, updates: { keys: l, changeSpecs: c } }).then(function(g) {
              var R = g.numFailures, w = g.failures;
              if (R === 0) return E;
              for (var O = 0, P = Object.keys(w); O < P.length; O++) {
                var T, D = P[O], j = d[Number(D)];
                j != null && (T = w[D], delete w[D], w[j] = T);
              }
              throw new Rt("".concat(r.name, ".bulkUpdate(): ").concat(R, " of ").concat(E, " operations failed"), w);
            });
          });
        });
      }, Be.prototype.bulkDelete = function(n) {
        var r = this, s = n.length;
        return this._trans("readwrite", function(l) {
          return r.core.mutate({ trans: l, type: "delete", keys: n }).then(function(c) {
            return Jr(r, n, c);
          });
        }).then(function(m) {
          var c = m.numFailures, d = m.lastResult, m = m.failures;
          if (c === 0) return d;
          throw new Rt("".concat(r.name, ".bulkDelete(): ").concat(c, " of ").concat(s, " operations failed"), m);
        });
      }, Be);
      function Be() {
      }
      function pr(n) {
        function r(m, v) {
          if (v) {
            for (var _ = arguments.length, S = new Array(_ - 1); --_; ) S[_ - 1] = arguments[_];
            return s[m].subscribe.apply(null, S), n;
          }
          if (typeof m == "string") return s[m];
        }
        var s = {};
        r.addEventType = d;
        for (var l = 1, c = arguments.length; l < c; ++l) d(arguments[l]);
        return r;
        function d(m, v, _) {
          if (typeof m != "object") {
            var S;
            v = v || J;
            var E = { subscribers: [], fire: _ = _ || y, subscribe: function(g) {
              E.subscribers.indexOf(g) === -1 && (E.subscribers.push(g), E.fire = v(E.fire, g));
            }, unsubscribe: function(g) {
              E.subscribers = E.subscribers.filter(function(R) {
                return R !== g;
              }), E.fire = E.subscribers.reduce(v, _);
            } };
            return s[m] = r[m] = E;
          }
          f(S = m).forEach(function(g) {
            var R = S[g];
            if (p(R)) d(g, S[g][0], S[g][1]);
            else {
              if (R !== "asap") throw new se.InvalidArgument("Invalid event config");
              var w = d(g, x, function() {
                for (var O = arguments.length, P = new Array(O); O--; ) P[O] = arguments[O];
                w.subscribers.forEach(function(T) {
                  _e(function() {
                    T.apply(null, P);
                  });
                });
              });
            }
          });
        }
      }
      function hr(n, r) {
        return re(r).from({ prototype: n }), r;
      }
      function Yn(n, r) {
        return !(n.filter || n.algorithm || n.or) && (r ? n.justLimit : !n.replayFilter);
      }
      function Zo(n, r) {
        n.filter = Dn(n.filter, r);
      }
      function ei(n, r, s) {
        var l = n.replayFilter;
        n.replayFilter = l ? function() {
          return Dn(l(), r());
        } : r, n.justLimit = s && !l;
      }
      function Xr(n, r) {
        if (n.isPrimKey) return r.primaryKey;
        var s = r.getIndexByKeyPath(n.index);
        if (!s) throw new se.Schema("KeyPath " + n.index + " on object store " + r.name + " is not indexed");
        return s;
      }
      function Ps(n, r, s) {
        var l = Xr(n, r.schema);
        return r.openCursor({ trans: s, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: l, range: n.range } });
      }
      function Zr(n, r, s, l) {
        var c = n.replayFilter ? Dn(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var d = {}, m = function(v, _, S) {
            var E, g;
            c && !c(_, S, function(R) {
              return _.stop(R);
            }, function(R) {
              return _.fail(R);
            }) || ((g = "" + (E = _.primaryKey)) == "[object ArrayBuffer]" && (g = "" + new Uint8Array(E)), C(d, g) || (d[g] = !0, r(v, _, S)));
          };
          return Promise.all([n.or._iterate(m, s), As(Ps(n, l, s), n.algorithm, m, !n.keysOnly && n.valueMapper)]);
        }
        return As(Ps(n, l, s), Dn(n.algorithm, c), r, !n.keysOnly && n.valueMapper);
      }
      function As(n, r, s, l) {
        var c = Ue(l ? function(d, m, v) {
          return s(l(d), m, v);
        } : s);
        return n.then(function(d) {
          if (d) return d.start(function() {
            var m = function() {
              return d.continue();
            };
            r && !r(d, function(v) {
              return m = v;
            }, function(v) {
              d.stop(v), m = y;
            }, function(v) {
              d.fail(v), m = y;
            }) || c(d.value, d, function(v) {
              return m = v;
            }), m();
          });
        });
      }
      var mr = (Rs.prototype.execute = function(n) {
        var r = this["@@propmod"];
        if (r.add !== void 0) {
          var s = r.add;
          if (p(s)) return a(a([], p(n) ? n : [], !0), s).sort();
          if (typeof s == "number") return (Number(n) || 0) + s;
          if (typeof s == "bigint") try {
            return BigInt(n) + s;
          } catch {
            return BigInt(0) + s;
          }
          throw new TypeError("Invalid term ".concat(s));
        }
        if (r.remove !== void 0) {
          var l = r.remove;
          if (p(l)) return p(n) ? n.filter(function(c) {
            return !l.includes(c);
          }).sort() : [];
          if (typeof l == "number") return Number(n) - l;
          if (typeof l == "bigint") try {
            return BigInt(n) - l;
          } catch {
            return BigInt(0) - l;
          }
          throw new TypeError("Invalid subtrahend ".concat(l));
        }
        return s = (s = r.replacePrefix) === null || s === void 0 ? void 0 : s[0], s && typeof n == "string" && n.startsWith(s) ? r.replacePrefix[1] + n.substring(s.length) : n;
      }, Rs);
      function Rs(n) {
        this["@@propmod"] = n;
      }
      var tu = (ke.prototype._read = function(n, r) {
        var s = this._ctx;
        return s.error ? s.table._trans(null, Ge.bind(null, s.error)) : s.table._trans("readonly", n).then(r);
      }, ke.prototype._write = function(n) {
        var r = this._ctx;
        return r.error ? r.table._trans(null, Ge.bind(null, r.error)) : r.table._trans("readwrite", n, "locked");
      }, ke.prototype._addAlgorithm = function(n) {
        var r = this._ctx;
        r.algorithm = Dn(r.algorithm, n);
      }, ke.prototype._iterate = function(n, r) {
        return Zr(this._ctx, n, r, this._ctx.table.core);
      }, ke.prototype.clone = function(n) {
        var r = Object.create(this.constructor.prototype), s = Object.create(this._ctx);
        return n && h(s, n), r._ctx = s, r;
      }, ke.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, ke.prototype.each = function(n) {
        var r = this._ctx;
        return this._read(function(s) {
          return Zr(r, n, s, r.table.core);
        });
      }, ke.prototype.count = function(n) {
        var r = this;
        return this._read(function(s) {
          var l = r._ctx, c = l.table.core;
          if (Yn(l, !0)) return c.count({ trans: s, query: { index: Xr(l, c.schema), range: l.range } }).then(function(m) {
            return Math.min(m, l.limit);
          });
          var d = 0;
          return Zr(l, function() {
            return ++d, !1;
          }, s, c).then(function() {
            return d;
          });
        }).then(n);
      }, ke.prototype.sortBy = function(n, r) {
        var s = n.split(".").reverse(), l = s[0], c = s.length - 1;
        function d(_, S) {
          return S ? d(_[s[S]], S - 1) : _[l];
        }
        var m = this._ctx.dir === "next" ? 1 : -1;
        function v(_, S) {
          return Ce(d(_, c), d(S, c)) * m;
        }
        return this.toArray(function(_) {
          return _.sort(v);
        }).then(r);
      }, ke.prototype.toArray = function(n) {
        var r = this;
        return this._read(function(s) {
          var l = r._ctx;
          if (l.dir === "next" && Yn(l, !0) && 0 < l.limit) {
            var c = l.valueMapper, d = Xr(l, l.table.core.schema);
            return l.table.core.query({ trans: s, limit: l.limit, values: !0, query: { index: d, range: l.range } }).then(function(v) {
              return v = v.result, c ? v.map(c) : v;
            });
          }
          var m = [];
          return Zr(l, function(v) {
            return m.push(v);
          }, s, l.table.core).then(function() {
            return m;
          });
        }, n);
      }, ke.prototype.offset = function(n) {
        var r = this._ctx;
        return n <= 0 || (r.offset += n, Yn(r) ? ei(r, function() {
          var s = n;
          return function(l, c) {
            return s === 0 || (s === 1 ? --s : c(function() {
              l.advance(s), s = 0;
            }), !1);
          };
        }) : ei(r, function() {
          var s = n;
          return function() {
            return --s < 0;
          };
        })), this;
      }, ke.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), ei(this._ctx, function() {
          var r = n;
          return function(s, l, c) {
            return --r <= 0 && l(c), 0 <= r;
          };
        }, !0), this;
      }, ke.prototype.until = function(n, r) {
        return Zo(this._ctx, function(s, l, c) {
          return !n(s.value) || (l(c), r);
        }), this;
      }, ke.prototype.first = function(n) {
        return this.limit(1).toArray(function(r) {
          return r[0];
        }).then(n);
      }, ke.prototype.last = function(n) {
        return this.reverse().first(n);
      }, ke.prototype.filter = function(n) {
        var r;
        return Zo(this._ctx, function(s) {
          return n(s.value);
        }), (r = this._ctx).isMatch = Dn(r.isMatch, n), this;
      }, ke.prototype.and = function(n) {
        return this.filter(n);
      }, ke.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, ke.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, ke.prototype.desc = function() {
        return this.reverse();
      }, ke.prototype.eachKey = function(n) {
        var r = this._ctx;
        return r.keysOnly = !r.isMatch, this.each(function(s, l) {
          n(l.key, l);
        });
      }, ke.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, ke.prototype.eachPrimaryKey = function(n) {
        var r = this._ctx;
        return r.keysOnly = !r.isMatch, this.each(function(s, l) {
          n(l.primaryKey, l);
        });
      }, ke.prototype.keys = function(n) {
        var r = this._ctx;
        r.keysOnly = !r.isMatch;
        var s = [];
        return this.each(function(l, c) {
          s.push(c.key);
        }).then(function() {
          return s;
        }).then(n);
      }, ke.prototype.primaryKeys = function(n) {
        var r = this._ctx;
        if (r.dir === "next" && Yn(r, !0) && 0 < r.limit) return this._read(function(l) {
          var c = Xr(r, r.table.core.schema);
          return r.table.core.query({ trans: l, values: !1, limit: r.limit, query: { index: c, range: r.range } });
        }).then(function(l) {
          return l.result;
        }).then(n);
        r.keysOnly = !r.isMatch;
        var s = [];
        return this.each(function(l, c) {
          s.push(c.primaryKey);
        }).then(function() {
          return s;
        }).then(n);
      }, ke.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, ke.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(r) {
          return r[0];
        }).then(n);
      }, ke.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, ke.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var r = {};
        return Zo(this._ctx, function(c) {
          var l = c.primaryKey.toString(), c = C(r, l);
          return r[l] = !0, !c;
        }), this;
      }, ke.prototype.modify = function(n) {
        var r = this, s = this._ctx;
        return this._write(function(l) {
          var c, d, m;
          m = typeof n == "function" ? n : (c = f(n), d = c.length, function(D) {
            for (var j = !1, L = 0; L < d; ++L) {
              var K = c[L], H = n[K], Q = Ke(D, K);
              H instanceof mr ? (De(D, K, H.execute(Q)), j = !0) : Q !== H && (De(D, K, H), j = !0);
            }
            return j;
          });
          var v = s.table.core, g = v.schema.primaryKey, _ = g.outbound, S = g.extractKey, E = 200, g = r.db._options.modifyChunkSize;
          g && (E = typeof g == "object" ? g[v.name] || g["*"] || 200 : g);
          function R(D, K) {
            var L = K.failures, K = K.numFailures;
            O += D - K;
            for (var H = 0, Q = f(L); H < Q.length; H++) {
              var W = Q[H];
              w.push(L[W]);
            }
          }
          var w = [], O = 0, P = [], T = n === Ds;
          return r.clone().primaryKeys().then(function(D) {
            function j(K) {
              var H = Math.min(E, D.length - K), Q = D.slice(K, K + H);
              return (T ? Promise.resolve([]) : v.getMany({ trans: l, keys: Q, cache: "immutable" })).then(function(W) {
                var z = [], te = [], Z = _ ? [] : null, oe = T ? Q : [];
                if (!T) for (var ve = 0; ve < H; ++ve) {
                  var Pe = W[ve], me = { value: ut(Pe), primKey: D[K + ve] };
                  m.call(me, me.value, me) !== !1 && (me.value == null ? oe.push(D[K + ve]) : _ || Ce(S(Pe), S(me.value)) === 0 ? (te.push(me.value), _ && Z.push(D[K + ve])) : (oe.push(D[K + ve]), z.push(me.value)));
                }
                return Promise.resolve(0 < z.length && v.mutate({ trans: l, type: "add", values: z }).then(function(ze) {
                  for (var he in ze.failures) oe.splice(parseInt(he), 1);
                  R(z.length, ze);
                })).then(function() {
                  return (0 < te.length || L && typeof n == "object") && v.mutate({ trans: l, type: "put", keys: Z, values: te, criteria: L, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < K }).then(function(ze) {
                    return R(te.length, ze);
                  });
                }).then(function() {
                  return (0 < oe.length || L && T) && v.mutate({ trans: l, type: "delete", keys: oe, criteria: L, isAdditionalChunk: 0 < K }).then(function(ze) {
                    return Jr(s.table, oe, ze);
                  }).then(function(ze) {
                    return R(oe.length, ze);
                  });
                }).then(function() {
                  return D.length > K + H && j(K + E);
                });
              });
            }
            var L = Yn(s) && s.limit === 1 / 0 && (typeof n != "function" || T) && { index: s.index, range: s.range };
            return j(0).then(function() {
              if (0 < w.length) throw new Un("Error modifying one or more objects", w, O, P);
              return D.length;
            });
          });
        });
      }, ke.prototype.delete = function() {
        var n = this._ctx, r = n.range;
        return !Yn(n) || n.table.schema.yProps || !n.isPrimKey && r.type !== 3 ? this.modify(Ds) : this._write(function(s) {
          var l = n.table.core.schema.primaryKey, c = r;
          return n.table.core.count({ trans: s, query: { index: l, range: c } }).then(function(d) {
            return n.table.core.mutate({ trans: s, type: "deleteRange", range: c }).then(function(_) {
              var v = _.failures, _ = _.numFailures;
              if (_) throw new Un("Could not delete some values", Object.keys(v).map(function(S) {
                return v[S];
              }), d - _);
              return d - _;
            });
          });
        });
      }, ke);
      function ke() {
      }
      var Ds = function(n, r) {
        return r.value = null;
      };
      function nu(n, r) {
        return n < r ? -1 : n === r ? 0 : 1;
      }
      function ru(n, r) {
        return r < n ? -1 : n === r ? 0 : 1;
      }
      function Nt(n, r, s) {
        return n = n instanceof Is ? new n.Collection(n) : n, n._ctx.error = new (s || TypeError)(r), n;
      }
      function Qn(n) {
        return new n.Collection(n, function() {
          return ks("");
        }).limit(0);
      }
      function eo(n, r, s, l) {
        var c, d, m, v, _, S, E, g = s.length;
        if (!s.every(function(O) {
          return typeof O == "string";
        })) return Nt(n, Ss);
        function R(O) {
          c = O === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, d = O === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, m = O === "next" ? nu : ru;
          var P = s.map(function(T) {
            return { lower: d(T), upper: c(T) };
          }).sort(function(T, D) {
            return m(T.lower, D.lower);
          });
          v = P.map(function(T) {
            return T.upper;
          }), _ = P.map(function(T) {
            return T.lower;
          }), E = (S = O) === "next" ? "" : l;
        }
        R("next"), n = new n.Collection(n, function() {
          return yn(v[0], _[g - 1] + l);
        }), n._ondirectionchange = function(O) {
          R(O);
        };
        var w = 0;
        return n._addAlgorithm(function(O, P, T) {
          var D = O.key;
          if (typeof D != "string") return !1;
          var j = d(D);
          if (r(j, _, w)) return !0;
          for (var L = null, K = w; K < g; ++K) {
            var H = function(Q, W, z, te, Z, oe) {
              for (var ve = Math.min(Q.length, te.length), Pe = -1, me = 0; me < ve; ++me) {
                var ze = W[me];
                if (ze !== te[me]) return Z(Q[me], z[me]) < 0 ? Q.substr(0, me) + z[me] + z.substr(me + 1) : Z(Q[me], te[me]) < 0 ? Q.substr(0, me) + te[me] + z.substr(me + 1) : 0 <= Pe ? Q.substr(0, Pe) + W[Pe] + z.substr(Pe + 1) : null;
                Z(Q[me], ze) < 0 && (Pe = me);
              }
              return ve < te.length && oe === "next" ? Q + z.substr(Q.length) : ve < Q.length && oe === "prev" ? Q.substr(0, z.length) : Pe < 0 ? null : Q.substr(0, Pe) + te[Pe] + z.substr(Pe + 1);
            }(D, j, v[K], _[K], m, S);
            H === null && L === null ? w = K + 1 : (L === null || 0 < m(L, H)) && (L = H);
          }
          return P(L !== null ? function() {
            O.continue(L + E);
          } : T), !1;
        }), n;
      }
      function yn(n, r, s, l) {
        return { type: 2, lower: n, upper: r, lowerOpen: s, upperOpen: l };
      }
      function ks(n) {
        return { type: 1, lower: n, upper: n };
      }
      var Is = (Object.defineProperty(rt.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), rt.prototype.between = function(n, r, s, l) {
        s = s !== !1, l = l === !0;
        try {
          return 0 < this._cmp(n, r) || this._cmp(n, r) === 0 && (s || l) && (!s || !l) ? Qn(this) : new this.Collection(this, function() {
            return yn(n, r, !s, !l);
          });
        } catch {
          return Nt(this, Gt);
        }
      }, rt.prototype.equals = function(n) {
        return n == null ? Nt(this, Gt) : new this.Collection(this, function() {
          return ks(n);
        });
      }, rt.prototype.above = function(n) {
        return n == null ? Nt(this, Gt) : new this.Collection(this, function() {
          return yn(n, void 0, !0);
        });
      }, rt.prototype.aboveOrEqual = function(n) {
        return n == null ? Nt(this, Gt) : new this.Collection(this, function() {
          return yn(n, void 0, !1);
        });
      }, rt.prototype.below = function(n) {
        return n == null ? Nt(this, Gt) : new this.Collection(this, function() {
          return yn(void 0, n, !1, !0);
        });
      }, rt.prototype.belowOrEqual = function(n) {
        return n == null ? Nt(this, Gt) : new this.Collection(this, function() {
          return yn(void 0, n);
        });
      }, rt.prototype.startsWith = function(n) {
        return typeof n != "string" ? Nt(this, Ss) : this.between(n, n + Rn, !0, !0);
      }, rt.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : eo(this, function(r, s) {
          return r.indexOf(s[0]) === 0;
        }, [n], Rn);
      }, rt.prototype.equalsIgnoreCase = function(n) {
        return eo(this, function(r, s) {
          return r === s[0];
        }, [n], "");
      }, rt.prototype.anyOfIgnoreCase = function() {
        var n = Ct.apply(St, arguments);
        return n.length === 0 ? Qn(this) : eo(this, function(r, s) {
          return s.indexOf(r) !== -1;
        }, n, "");
      }, rt.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Ct.apply(St, arguments);
        return n.length === 0 ? Qn(this) : eo(this, function(r, s) {
          return s.some(function(l) {
            return r.indexOf(l) === 0;
          });
        }, n, Rn);
      }, rt.prototype.anyOf = function() {
        var n = this, r = Ct.apply(St, arguments), s = this._cmp;
        try {
          r.sort(s);
        } catch {
          return Nt(this, Gt);
        }
        if (r.length === 0) return Qn(this);
        var l = new this.Collection(this, function() {
          return yn(r[0], r[r.length - 1]);
        });
        l._ondirectionchange = function(d) {
          s = d === "next" ? n._ascending : n._descending, r.sort(s);
        };
        var c = 0;
        return l._addAlgorithm(function(d, m, v) {
          for (var _ = d.key; 0 < s(_, r[c]); ) if (++c === r.length) return m(v), !1;
          return s(_, r[c]) === 0 || (m(function() {
            d.continue(r[c]);
          }), !1);
        }), l;
      }, rt.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, rt.prototype.noneOf = function() {
        var n = Ct.apply(St, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return Nt(this, Gt);
        }
        var r = n.reduce(function(s, l) {
          return s ? s.concat([[s[s.length - 1][1], l]]) : [[-1 / 0, l]];
        }, null);
        return r.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(r, { includeLowers: !1, includeUppers: !1 });
      }, rt.prototype.inAnyRange = function(D, r) {
        var s = this, l = this._cmp, c = this._ascending, d = this._descending, m = this._min, v = this._max;
        if (D.length === 0) return Qn(this);
        if (!D.every(function(j) {
          return j[0] !== void 0 && j[1] !== void 0 && c(j[0], j[1]) <= 0;
        })) return Nt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", se.InvalidArgument);
        var _ = !r || r.includeLowers !== !1, S = r && r.includeUppers === !0, E, g = c;
        function R(j, L) {
          return g(j[0], L[0]);
        }
        try {
          (E = D.reduce(function(j, L) {
            for (var K = 0, H = j.length; K < H; ++K) {
              var Q = j[K];
              if (l(L[0], Q[1]) < 0 && 0 < l(L[1], Q[0])) {
                Q[0] = m(Q[0], L[0]), Q[1] = v(Q[1], L[1]);
                break;
              }
            }
            return K === H && j.push(L), j;
          }, [])).sort(R);
        } catch {
          return Nt(this, Gt);
        }
        var w = 0, O = S ? function(j) {
          return 0 < c(j, E[w][1]);
        } : function(j) {
          return 0 <= c(j, E[w][1]);
        }, P = _ ? function(j) {
          return 0 < d(j, E[w][0]);
        } : function(j) {
          return 0 <= d(j, E[w][0]);
        }, T = O, D = new this.Collection(this, function() {
          return yn(E[0][0], E[E.length - 1][1], !_, !S);
        });
        return D._ondirectionchange = function(j) {
          g = j === "next" ? (T = O, c) : (T = P, d), E.sort(R);
        }, D._addAlgorithm(function(j, L, K) {
          for (var H, Q = j.key; T(Q); ) if (++w === E.length) return L(K), !1;
          return !O(H = Q) && !P(H) || (s._cmp(Q, E[w][1]) === 0 || s._cmp(Q, E[w][0]) === 0 || L(function() {
            g === c ? j.continue(E[w][0]) : j.continue(E[w][1]);
          }), !1);
        }), D;
      }, rt.prototype.startsWithAnyOf = function() {
        var n = Ct.apply(St, arguments);
        return n.every(function(r) {
          return typeof r == "string";
        }) ? n.length === 0 ? Qn(this) : this.inAnyRange(n.map(function(r) {
          return [r, r + Rn];
        })) : Nt(this, "startsWithAnyOf() only works with strings");
      }, rt);
      function rt() {
      }
      function $t(n) {
        return Ue(function(r) {
          return yr(r), n(r.target.error), !1;
        });
      }
      function yr(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var vr = "storagemutated", ti = "x-storagemutated-1", vn = pr(null, vr), ou = (Bt.prototype._lock = function() {
        return le(!ie.global), ++this._reculock, this._reculock !== 1 || ie.global || (ie.lockOwnerFor = this), this;
      }, Bt.prototype._unlock = function() {
        if (le(!ie.global), --this._reculock == 0) for (ie.global || (ie.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            An(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, Bt.prototype._locked = function() {
        return this._reculock && ie.lockOwnerFor !== this;
      }, Bt.prototype.create = function(n) {
        var r = this;
        if (!this.mode) return this;
        var s = this.db.idbdb, l = this.db._state.dbOpenError;
        if (le(!this.idbtrans), !n && !s) switch (l && l.name) {
          case "DatabaseClosedError":
            throw new se.DatabaseClosed(l);
          case "MissingAPIError":
            throw new se.MissingAPI(l.message, l);
          default:
            throw new se.OpenFailed(l);
        }
        if (!this.active) throw new se.TransactionInactive();
        return le(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || s).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ue(function(c) {
          yr(c), r._reject(n.error);
        }), n.onabort = Ue(function(c) {
          yr(c), r.active && r._reject(new se.Abort(n.error)), r.active = !1, r.on("abort").fire(c);
        }), n.oncomplete = Ue(function() {
          r.active = !1, r._resolve(), "mutatedParts" in n && vn.storagemutated.fire(n.mutatedParts);
        }), this;
      }, Bt.prototype._promise = function(n, r, s) {
        var l = this;
        if (n === "readwrite" && this.mode !== "readwrite") return Ge(new se.ReadOnly("Transaction is readonly"));
        if (!this.active) return Ge(new se.TransactionInactive());
        if (this._locked()) return new ne(function(d, m) {
          l._blockedFuncs.push([function() {
            l._promise(n, r, s).then(d, m);
          }, ie]);
        });
        if (s) return pn(function() {
          var d = new ne(function(m, v) {
            l._lock();
            var _ = r(m, v, l);
            _ && _.then && _.then(m, v);
          });
          return d.finally(function() {
            return l._unlock();
          }), d._lib = !0, d;
        });
        var c = new ne(function(d, m) {
          var v = r(d, m, l);
          v && v.then && v.then(d, m);
        });
        return c._lib = !0, c;
      }, Bt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Bt.prototype.waitFor = function(n) {
        var r, s = this._root(), l = ne.resolve(n);
        s._waitingFor ? s._waitingFor = s._waitingFor.then(function() {
          return l;
        }) : (s._waitingFor = l, s._waitingQueue = [], r = s.idbtrans.objectStore(s.storeNames[0]), function d() {
          for (++s._spinCount; s._waitingQueue.length; ) s._waitingQueue.shift()();
          s._waitingFor && (r.get(-1 / 0).onsuccess = d);
        }());
        var c = s._waitingFor;
        return new ne(function(d, m) {
          l.then(function(v) {
            return s._waitingQueue.push(Ue(d.bind(null, v)));
          }, function(v) {
            return s._waitingQueue.push(Ue(m.bind(null, v)));
          }).finally(function() {
            s._waitingFor === c && (s._waitingFor = null);
          });
        });
      }, Bt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new se.Abort()));
      }, Bt.prototype.table = function(n) {
        var r = this._memoizedTables || (this._memoizedTables = {});
        if (C(r, n)) return r[n];
        var s = this.schema[n];
        if (!s) throw new se.NotFound("Table " + n + " not part of transaction");
        return s = new this.db.Table(n, s, this), s.core = this.db.core.table(n), r[n] = s;
      }, Bt);
      function Bt() {
      }
      function ni(n, r, s, l, c, d, m, v) {
        return { name: n, keyPath: r, unique: s, multi: l, auto: c, compound: d, src: (s && !m ? "&" : "") + (l ? "*" : "") + (c ? "++" : "") + js(r), type: v };
      }
      function js(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function ri(n, r, s) {
        return { name: n, primKey: r, indexes: s, mappedClass: null, idxByName: (l = function(c) {
          return [c.name, c];
        }, s.reduce(function(c, d, m) {
          return m = l(d, m), m && (c[m[0]] = m[1]), c;
        }, {})) };
        var l;
      }
      var gr = function(n) {
        try {
          return n.only([[]]), gr = function() {
            return [[]];
          }, [[]];
        } catch {
          return gr = function() {
            return Rn;
          }, Rn;
        }
      };
      function oi(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (r = n).split(".").length === 1 ? function(s) {
          return s[r];
        } : function(s) {
          return Ke(s, r);
        } : function(s) {
          return Ke(s, n);
        };
        var r;
      }
      function Ls(n) {
        return [].slice.call(n);
      }
      var iu = 0;
      function br(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function su(n, r, _) {
        function l(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var w = T.lower, O = T.upper, P = T.lowerOpen, T = T.upperOpen;
          return w === void 0 ? O === void 0 ? null : r.upperBound(O, !!T) : O === void 0 ? r.lowerBound(w, !!P) : r.bound(w, O, !!P, !!T);
        }
        function c(R) {
          var w, O = R.name;
          return { name: O, schema: R, mutate: function(P) {
            var T = P.trans, D = P.type, j = P.keys, L = P.values, K = P.range;
            return new Promise(function(H, Q) {
              H = Ue(H);
              var W = T.objectStore(O), z = W.keyPath == null, te = D === "put" || D === "add";
              if (!te && D !== "delete" && D !== "deleteRange") throw new Error("Invalid operation type: " + D);
              var Z, oe = (j || L || { length: 1 }).length;
              if (j && L && j.length !== L.length) throw new Error("Given keys array must have same length as given values array.");
              if (oe === 0) return H({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ve(bt) {
                ++ze, yr(bt);
              }
              var Pe = [], me = [], ze = 0;
              if (D === "deleteRange") {
                if (K.type === 4) return H({ numFailures: ze, failures: me, results: [], lastResult: void 0 });
                K.type === 3 ? Pe.push(Z = W.clear()) : Pe.push(Z = W.delete(l(K)));
              } else {
                var z = te ? z ? [L, j] : [L, null] : [j, null], he = z[0], ft = z[1];
                if (te) for (var dt = 0; dt < oe; ++dt) Pe.push(Z = ft && ft[dt] !== void 0 ? W[D](he[dt], ft[dt]) : W[D](he[dt])), Z.onerror = ve;
                else for (dt = 0; dt < oe; ++dt) Pe.push(Z = W[D](he[dt])), Z.onerror = ve;
              }
              function po(bt) {
                bt = bt.target.result, Pe.forEach(function(jn, xi) {
                  return jn.error != null && (me[xi] = jn.error);
                }), H({ numFailures: ze, failures: me, results: D === "delete" ? j : Pe.map(function(jn) {
                  return jn.result;
                }), lastResult: bt });
              }
              Z.onerror = function(bt) {
                ve(bt), po(bt);
              }, Z.onsuccess = po;
            });
          }, getMany: function(P) {
            var T = P.trans, D = P.keys;
            return new Promise(function(j, L) {
              j = Ue(j);
              for (var K, H = T.objectStore(O), Q = D.length, W = new Array(Q), z = 0, te = 0, Z = function(Pe) {
                Pe = Pe.target, W[Pe._pos] = Pe.result, ++te === z && j(W);
              }, oe = $t(L), ve = 0; ve < Q; ++ve) D[ve] != null && ((K = H.get(D[ve]))._pos = ve, K.onsuccess = Z, K.onerror = oe, ++z);
              z === 0 && j(W);
            });
          }, get: function(P) {
            var T = P.trans, D = P.key;
            return new Promise(function(j, L) {
              j = Ue(j);
              var K = T.objectStore(O).get(D);
              K.onsuccess = function(H) {
                return j(H.target.result);
              }, K.onerror = $t(L);
            });
          }, query: (w = S, function(P) {
            return new Promise(function(T, D) {
              T = Ue(T);
              var j, L, K, z = P.trans, H = P.values, Q = P.limit, Z = P.query, W = Q === 1 / 0 ? void 0 : Q, te = Z.index, Z = Z.range, z = z.objectStore(O), te = te.isPrimaryKey ? z : z.index(te.name), Z = l(Z);
              if (Q === 0) return T({ result: [] });
              w ? ((W = H ? te.getAll(Z, W) : te.getAllKeys(Z, W)).onsuccess = function(oe) {
                return T({ result: oe.target.result });
              }, W.onerror = $t(D)) : (j = 0, L = !H && "openKeyCursor" in te ? te.openKeyCursor(Z) : te.openCursor(Z), K = [], L.onsuccess = function(oe) {
                var ve = L.result;
                return ve ? (K.push(H ? ve.value : ve.primaryKey), ++j === Q ? T({ result: K }) : void ve.continue()) : T({ result: K });
              }, L.onerror = $t(D));
            });
          }), openCursor: function(P) {
            var T = P.trans, D = P.values, j = P.query, L = P.reverse, K = P.unique;
            return new Promise(function(H, Q) {
              H = Ue(H);
              var te = j.index, W = j.range, z = T.objectStore(O), z = te.isPrimaryKey ? z : z.index(te.name), te = L ? K ? "prevunique" : "prev" : K ? "nextunique" : "next", Z = !D && "openKeyCursor" in z ? z.openKeyCursor(l(W), te) : z.openCursor(l(W), te);
              Z.onerror = $t(Q), Z.onsuccess = Ue(function(oe) {
                var ve, Pe, me, ze, he = Z.result;
                he ? (he.___id = ++iu, he.done = !1, ve = he.continue.bind(he), Pe = (Pe = he.continuePrimaryKey) && Pe.bind(he), me = he.advance.bind(he), ze = function() {
                  throw new Error("Cursor not stopped");
                }, he.trans = T, he.stop = he.continue = he.continuePrimaryKey = he.advance = function() {
                  throw new Error("Cursor not started");
                }, he.fail = Ue(Q), he.next = function() {
                  var ft = this, dt = 1;
                  return this.start(function() {
                    return dt-- ? ft.continue() : ft.stop();
                  }).then(function() {
                    return ft;
                  });
                }, he.start = function(ft) {
                  function dt() {
                    if (Z.result) try {
                      ft();
                    } catch (bt) {
                      he.fail(bt);
                    }
                    else he.done = !0, he.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, he.stop();
                  }
                  var po = new Promise(function(bt, jn) {
                    bt = Ue(bt), Z.onerror = $t(jn), he.fail = jn, he.stop = function(xi) {
                      he.stop = he.continue = he.continuePrimaryKey = he.advance = ze, bt(xi);
                    };
                  });
                  return Z.onsuccess = Ue(function(bt) {
                    Z.onsuccess = dt, dt();
                  }), he.continue = ve, he.continuePrimaryKey = Pe, he.advance = me, dt(), po;
                }, H(he)) : H(null);
              }, Q);
            });
          }, count: function(P) {
            var T = P.query, D = P.trans, j = T.index, L = T.range;
            return new Promise(function(K, H) {
              var Q = D.objectStore(O), W = j.isPrimaryKey ? Q : Q.index(j.name), Q = l(L), W = Q ? W.count(Q) : W.count();
              W.onsuccess = Ue(function(z) {
                return K(z.target.result);
              }), W.onerror = $t(H);
            });
          } };
        }
        var d, m, v, E = (m = _, v = Ls((d = n).objectStoreNames), { schema: { name: d.name, tables: v.map(function(R) {
          return m.objectStore(R);
        }).map(function(R) {
          var w = R.keyPath, T = R.autoIncrement, O = p(w), P = {}, T = { name: R.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: w == null, compound: O, keyPath: w, autoIncrement: T, unique: !0, extractKey: oi(w) }, indexes: Ls(R.indexNames).map(function(D) {
            return R.index(D);
          }).map(function(K) {
            var j = K.name, L = K.unique, H = K.multiEntry, K = K.keyPath, H = { name: j, compound: p(K), keyPath: K, unique: L, multiEntry: H, extractKey: oi(K) };
            return P[br(K)] = H;
          }), getIndexByKeyPath: function(D) {
            return P[br(D)];
          } };
          return P[":id"] = T.primaryKey, w != null && (P[br(w)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < v.length && "getAll" in m.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), _ = E.schema, S = E.hasGetAll, E = _.tables.map(c), g = {};
        return E.forEach(function(R) {
          return g[R.name] = R;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(R) {
          if (!g[R]) throw new Error("Table '".concat(R, "' not found"));
          return g[R];
        }, MIN_KEY: -1 / 0, MAX_KEY: gr(r), schema: _ };
      }
      function au(n, r, s, l) {
        var c = s.IDBKeyRange;
        return s.indexedDB, { dbcore: (l = su(r, c, l), n.dbcore.reduce(function(d, m) {
          return m = m.create, i(i({}, d), m(d));
        }, l)) };
      }
      function to(n, l) {
        var s = l.db, l = au(n._middlewares, s, n._deps, l);
        n.core = l.dbcore, n.tables.forEach(function(c) {
          var d = c.name;
          n.core.schema.tables.some(function(m) {
            return m.name === d;
          }) && (c.core = n.core.table(d), n[d] instanceof n.Table && (n[d].core = c.core));
        });
      }
      function no(n, r, s, l) {
        s.forEach(function(c) {
          var d = l[c];
          r.forEach(function(m) {
            var v = function _(S, E) {
              return F(S, E) || (S = N(S)) && _(S, E);
            }(m, c);
            (!v || "value" in v && v.value === void 0) && (m === n.Transaction.prototype || m instanceof n.Transaction ? G(m, c, { get: function() {
              return this.table(c);
            }, set: function(_) {
              I(this, c, { value: _, writable: !0, configurable: !0, enumerable: !0 });
            } }) : m[c] = new n.Table(c, d));
          });
        });
      }
      function ii(n, r) {
        r.forEach(function(s) {
          for (var l in s) s[l] instanceof n.Table && delete s[l];
        });
      }
      function lu(n, r) {
        return n._cfg.version - r._cfg.version;
      }
      function uu(n, r, s, l) {
        var c = n._dbSchema;
        s.objectStoreNames.contains("$meta") && !c.$meta && (c.$meta = ri("$meta", Ms("")[0], []), n._storeNames.push("$meta"));
        var d = n._createTransaction("readwrite", n._storeNames, c);
        d.create(s), d._completion.catch(l);
        var m = d._reject.bind(d), v = ie.transless || ie;
        pn(function() {
          return ie.trans = d, ie.transless = v, r !== 0 ? (to(n, s), S = r, ((_ = d).storeNames.includes("$meta") ? _.table("$meta").get("version").then(function(E) {
            return E ?? S;
          }) : ne.resolve(S)).then(function(E) {
            return R = E, w = d, O = s, P = [], E = (g = n)._versions, T = g._dbSchema = oo(0, g.idbdb, O), (E = E.filter(function(D) {
              return D._cfg.version >= R;
            })).length !== 0 ? (E.forEach(function(D) {
              P.push(function() {
                var j = T, L = D._cfg.dbschema;
                io(g, j, O), io(g, L, O), T = g._dbSchema = L;
                var K = si(j, L);
                K.add.forEach(function(te) {
                  ai(O, te[0], te[1].primKey, te[1].indexes);
                }), K.change.forEach(function(te) {
                  if (te.recreate) throw new se.Upgrade("Not yet support for changing primary key");
                  var Z = O.objectStore(te.name);
                  te.add.forEach(function(oe) {
                    return ro(Z, oe);
                  }), te.change.forEach(function(oe) {
                    Z.deleteIndex(oe.name), ro(Z, oe);
                  }), te.del.forEach(function(oe) {
                    return Z.deleteIndex(oe);
                  });
                });
                var H = D._cfg.contentUpgrade;
                if (H && D._cfg.version > R) {
                  to(g, O), w._memoizedTables = {};
                  var Q = xe(L);
                  K.del.forEach(function(te) {
                    Q[te] = j[te];
                  }), ii(g, [g.Transaction.prototype]), no(g, [g.Transaction.prototype], f(Q), Q), w.schema = Q;
                  var W, z = jt(H);
                  return z && zn(), K = ne.follow(function() {
                    var te;
                    (W = H(w)) && z && (te = hn.bind(null, null), W.then(te, te));
                  }), W && typeof W.then == "function" ? ne.resolve(W) : K.then(function() {
                    return W;
                  });
                }
              }), P.push(function(j) {
                var L, K, H = D._cfg.dbschema;
                L = H, K = j, [].slice.call(K.db.objectStoreNames).forEach(function(Q) {
                  return L[Q] == null && K.db.deleteObjectStore(Q);
                }), ii(g, [g.Transaction.prototype]), no(g, [g.Transaction.prototype], g._storeNames, g._dbSchema), w.schema = g._dbSchema;
              }), P.push(function(j) {
                g.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(g.idbdb.version / 10) === D._cfg.version ? (g.idbdb.deleteObjectStore("$meta"), delete g._dbSchema.$meta, g._storeNames = g._storeNames.filter(function(L) {
                  return L !== "$meta";
                })) : j.objectStore("$meta").put(D._cfg.version, "version"));
              });
            }), function D() {
              return P.length ? ne.resolve(P.shift()(w.idbtrans)).then(D) : ne.resolve();
            }().then(function() {
              Ks(T, O);
            })) : ne.resolve();
            var g, R, w, O, P, T;
          }).catch(m)) : (f(c).forEach(function(E) {
            ai(s, E, c[E].primKey, c[E].indexes);
          }), to(n, s), void ne.follow(function() {
            return n.on.populate.fire(d);
          }).catch(m));
          var _, S;
        });
      }
      function cu(n, r) {
        Ks(n._dbSchema, r), r.db.version % 10 != 0 || r.objectStoreNames.contains("$meta") || r.db.createObjectStore("$meta").add(Math.ceil(r.db.version / 10 - 1), "version");
        var s = oo(0, n.idbdb, r);
        io(n, n._dbSchema, r);
        for (var l = 0, c = si(s, n._dbSchema).change; l < c.length; l++) {
          var d = function(m) {
            if (m.change.length || m.recreate) return console.warn("Unable to patch indexes of table ".concat(m.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var v = r.objectStore(m.name);
            m.add.forEach(function(_) {
              $ && console.debug("Dexie upgrade patch: Creating missing index ".concat(m.name, ".").concat(_.src)), ro(v, _);
            });
          }(c[l]);
          if (typeof d == "object") return d.value;
        }
      }
      function si(n, r) {
        var s, l = { del: [], add: [], change: [] };
        for (s in n) r[s] || l.del.push(s);
        for (s in r) {
          var c = n[s], d = r[s];
          if (c) {
            var m = { name: s, def: d, recreate: !1, del: [], add: [], change: [] };
            if ("" + (c.primKey.keyPath || "") != "" + (d.primKey.keyPath || "") || c.primKey.auto !== d.primKey.auto) m.recreate = !0, l.change.push(m);
            else {
              var v = c.idxByName, _ = d.idxByName, S = void 0;
              for (S in v) _[S] || m.del.push(S);
              for (S in _) {
                var E = v[S], g = _[S];
                E ? E.src !== g.src && m.change.push(g) : m.add.push(g);
              }
              (0 < m.del.length || 0 < m.add.length || 0 < m.change.length) && l.change.push(m);
            }
          } else l.add.push([s, d]);
        }
        return l;
      }
      function ai(n, r, s, l) {
        var c = n.db.createObjectStore(r, s.keyPath ? { keyPath: s.keyPath, autoIncrement: s.auto } : { autoIncrement: s.auto });
        return l.forEach(function(d) {
          return ro(c, d);
        }), c;
      }
      function Ks(n, r) {
        f(n).forEach(function(s) {
          r.db.objectStoreNames.contains(s) || ($ && console.debug("Dexie: Creating missing table", s), ai(r, s, n[s].primKey, n[s].indexes));
        });
      }
      function ro(n, r) {
        n.createIndex(r.name, r.keyPath, { unique: r.unique, multiEntry: r.multi });
      }
      function oo(n, r, s) {
        var l = {};
        return pe(r.objectStoreNames, 0).forEach(function(c) {
          for (var d = s.objectStore(c), m = ni(js(S = d.keyPath), S || "", !0, !1, !!d.autoIncrement, S && typeof S != "string", !0), v = [], _ = 0; _ < d.indexNames.length; ++_) {
            var E = d.index(d.indexNames[_]), S = E.keyPath, E = ni(E.name, S, !!E.unique, !!E.multiEntry, !1, S && typeof S != "string", !1);
            v.push(E);
          }
          l[c] = ri(c, m, v);
        }), l;
      }
      function io(n, r, s) {
        for (var l = s.db.objectStoreNames, c = 0; c < l.length; ++c) {
          var d = l[c], m = s.objectStore(d);
          n._hasGetAll = "getAll" in m;
          for (var v = 0; v < m.indexNames.length; ++v) {
            var _ = m.indexNames[v], S = m.index(_).keyPath, E = typeof S == "string" ? S : "[" + pe(S).join("+") + "]";
            !r[d] || (S = r[d].idxByName[E]) && (S.name = _, delete r[d].idxByName[E], r[d].idxByName[_] = S);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && u.WorkerGlobalScope && u instanceof u.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function Ms(n) {
        return n.split(",").map(function(r, s) {
          var d = r.split(":"), l = (c = d[1]) === null || c === void 0 ? void 0 : c.trim(), c = (r = d[0].trim()).replace(/([&*]|\+\+)/g, ""), d = /^\[/.test(c) ? c.match(/^\[(.*)\]$/)[1].split("+") : c;
          return ni(c, d || null, /\&/.test(r), /\*/.test(r), /\+\+/.test(r), p(d), s === 0, l);
        });
      }
      var fu = (Jn.prototype._createTableSchema = ri, Jn.prototype._parseIndexSyntax = Ms, Jn.prototype._parseStoresSpec = function(n, r) {
        var s = this;
        f(n).forEach(function(l) {
          if (n[l] !== null) {
            var c = s._parseIndexSyntax(n[l]), d = c.shift();
            if (!d) throw new se.Schema("Invalid schema for table " + l + ": " + n[l]);
            if (d.unique = !0, d.multi) throw new se.Schema("Primary key cannot be multiEntry*");
            c.forEach(function(m) {
              if (m.auto) throw new se.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!m.keyPath) throw new se.Schema("Index must have a name and cannot be an empty string");
            }), c = s._createTableSchema(l, d, c), r[l] = c;
          }
        });
      }, Jn.prototype.stores = function(s) {
        var r = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, s) : s;
        var s = r._versions, l = {}, c = {};
        return s.forEach(function(d) {
          h(l, d._cfg.storesSource), c = d._cfg.dbschema = {}, d._parseStoresSpec(l, c);
        }), r._dbSchema = c, ii(r, [r._allTables, r, r.Transaction.prototype]), no(r, [r._allTables, r, r.Transaction.prototype, this._cfg.tables], f(c), c), r._storeNames = f(c), this;
      }, Jn.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = Y(this._cfg.contentUpgrade || y, n), this;
      }, Jn);
      function Jn() {
      }
      function li(n, r) {
        var s = n._dbNamesDB;
        return s || (s = n._dbNamesDB = new Yt(Yr, { addons: [], indexedDB: n, IDBKeyRange: r })).version(1).stores({ dbnames: "name" }), s.table("dbnames");
      }
      function ui(n) {
        return n && typeof n.databases == "function";
      }
      function ci(n) {
        return pn(function() {
          return ie.letThrough = !0, n();
        });
      }
      function fi(n) {
        return !("from" in n);
      }
      var ct = function(n, r) {
        if (!this) {
          var s = new ct();
          return n && "d" in n && h(s, n), s;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? r : n } : { d: 0 });
      };
      function _r(n, r, s) {
        var l = Ce(r, s);
        if (!isNaN(l)) {
          if (0 < l) throw RangeError();
          if (fi(n)) return h(n, { from: r, to: s, d: 1 });
          var c = n.l, l = n.r;
          if (Ce(s, n.from) < 0) return c ? _r(c, r, s) : n.l = { from: r, to: s, d: 1, l: null, r: null }, $s(n);
          if (0 < Ce(r, n.to)) return l ? _r(l, r, s) : n.r = { from: r, to: s, d: 1, l: null, r: null }, $s(n);
          Ce(r, n.from) < 0 && (n.from = r, n.l = null, n.d = l ? l.d + 1 : 1), 0 < Ce(s, n.to) && (n.to = s, n.r = null, n.d = n.l ? n.l.d + 1 : 1), s = !n.r, c && !n.l && wr(n, c), l && s && wr(n, l);
        }
      }
      function wr(n, r) {
        fi(r) || function s(l, _) {
          var d = _.from, m = _.to, v = _.l, _ = _.r;
          _r(l, d, m), v && s(l, v), _ && s(l, _);
        }(n, r);
      }
      function Fs(n, r) {
        var s = so(r), l = s.next();
        if (l.done) return !1;
        for (var c = l.value, d = so(n), m = d.next(c.from), v = m.value; !l.done && !m.done; ) {
          if (Ce(v.from, c.to) <= 0 && 0 <= Ce(v.to, c.from)) return !0;
          Ce(c.from, v.from) < 0 ? c = (l = s.next(v.from)).value : v = (m = d.next(c.from)).value;
        }
        return !1;
      }
      function so(n) {
        var r = fi(n) ? null : { s: 0, n };
        return { next: function(s) {
          for (var l = 0 < arguments.length; r; ) switch (r.s) {
            case 0:
              if (r.s = 1, l) for (; r.n.l && Ce(s, r.n.from) < 0; ) r = { up: r, n: r.n.l, s: 1 };
              else for (; r.n.l; ) r = { up: r, n: r.n.l, s: 1 };
            case 1:
              if (r.s = 2, !l || Ce(s, r.n.to) <= 0) return { value: r.n, done: !1 };
            case 2:
              if (r.n.r) {
                r.s = 3, r = { up: r, n: r.n.r, s: 0 };
                continue;
              }
            case 3:
              r = r.up;
          }
          return { done: !0 };
        } };
      }
      function $s(n) {
        var r, s, l = (((r = n.r) === null || r === void 0 ? void 0 : r.d) || 0) - (((s = n.l) === null || s === void 0 ? void 0 : s.d) || 0), c = 1 < l ? "r" : l < -1 ? "l" : "";
        c && (r = c == "r" ? "l" : "r", s = i({}, n), l = n[c], n.from = l.from, n.to = l.to, n[c] = l[c], s[c] = l[r], (n[r] = s).d = Bs(s)), n.d = Bs(n);
      }
      function Bs(s) {
        var r = s.r, s = s.l;
        return (r ? s ? Math.max(r.d, s.d) : r.d : s ? s.d : 0) + 1;
      }
      function ao(n, r) {
        return f(r).forEach(function(s) {
          n[s] ? wr(n[s], r[s]) : n[s] = function l(c) {
            var d, m, v = {};
            for (d in c) C(c, d) && (m = c[d], v[d] = !m || typeof m != "object" || vt.has(m.constructor) ? m : l(m));
            return v;
          }(r[s]);
        }), n;
      }
      function di(n, r) {
        return n.all || r.all || Object.keys(n).some(function(s) {
          return r[s] && Fs(r[s], n[s]);
        });
      }
      A(ct.prototype, ((Dt = { add: function(n) {
        return wr(this, n), this;
      }, addKey: function(n) {
        return _r(this, n, n), this;
      }, addKeys: function(n) {
        var r = this;
        return n.forEach(function(s) {
          return _r(r, s, s);
        }), this;
      }, hasKey: function(n) {
        var r = so(this).next(n).value;
        return r && Ce(r.from, n) <= 0 && 0 <= Ce(r.to, n);
      } })[$e] = function() {
        return so(this);
      }, Dt));
      var kn = {}, pi = {}, hi = !1;
      function lo(n) {
        ao(pi, n), hi || (hi = !0, setTimeout(function() {
          hi = !1, mi(pi, !(pi = {}));
        }, 0));
      }
      function mi(n, r) {
        r === void 0 && (r = !1);
        var s = /* @__PURE__ */ new Set();
        if (n.all) for (var l = 0, c = Object.values(kn); l < c.length; l++) qs(m = c[l], n, s, r);
        else for (var d in n) {
          var m, v = /^idb\:\/\/(.*)\/(.*)\//.exec(d);
          v && (d = v[1], v = v[2], (m = kn["idb://".concat(d, "/").concat(v)]) && qs(m, n, s, r));
        }
        s.forEach(function(_) {
          return _();
        });
      }
      function qs(n, r, s, l) {
        for (var c = [], d = 0, m = Object.entries(n.queries.query); d < m.length; d++) {
          for (var v = m[d], _ = v[0], S = [], E = 0, g = v[1]; E < g.length; E++) {
            var R = g[E];
            di(r, R.obsSet) ? R.subscribers.forEach(function(T) {
              return s.add(T);
            }) : l && S.push(R);
          }
          l && c.push([_, S]);
        }
        if (l) for (var w = 0, O = c; w < O.length; w++) {
          var P = O[w], _ = P[0], S = P[1];
          n.queries.query[_] = S;
        }
      }
      function du(n) {
        var r = n._state, s = n._deps.indexedDB;
        if (r.isBeingOpened || n.idbdb) return r.dbReadyPromise.then(function() {
          return r.dbOpenError ? Ge(r.dbOpenError) : n;
        });
        r.isBeingOpened = !0, r.dbOpenError = null, r.openComplete = !1;
        var l = r.openCanceller, c = Math.round(10 * n.verno), d = !1;
        function m() {
          if (r.openCanceller !== l) throw new se.DatabaseClosed("db.open() was cancelled");
        }
        function v() {
          return new ne(function(R, w) {
            if (m(), !s) throw new se.MissingAPI();
            var O = n.name, P = r.autoSchema || !c ? s.open(O) : s.open(O, c);
            if (!P) throw new se.MissingAPI();
            P.onerror = $t(w), P.onblocked = Ue(n._fireOnBlocked), P.onupgradeneeded = Ue(function(T) {
              var D;
              E = P.transaction, r.autoSchema && !n._options.allowEmptyDB ? (P.onerror = yr, E.abort(), P.result.close(), (D = s.deleteDatabase(O)).onsuccess = D.onerror = Ue(function() {
                w(new se.NoSuchDatabase("Database ".concat(O, " doesnt exist")));
              })) : (E.onerror = $t(w), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, g = T < 1, n.idbdb = P.result, d && cu(n, E), uu(n, T / 10, E, w));
            }, w), P.onsuccess = Ue(function() {
              E = null;
              var T, D, j, L, K, H = n.idbdb = P.result, Q = pe(H.objectStoreNames);
              if (0 < Q.length) try {
                var W = H.transaction((L = Q).length === 1 ? L[0] : L, "readonly");
                if (r.autoSchema) D = H, j = W, (T = n).verno = D.version / 10, j = T._dbSchema = oo(0, D, j), T._storeNames = pe(D.objectStoreNames, 0), no(T, [T._allTables], f(j), j);
                else if (io(n, n._dbSchema, W), ((K = si(oo(0, (K = n).idbdb, W), K._dbSchema)).add.length || K.change.some(function(z) {
                  return z.add.length || z.change.length;
                })) && !d) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), H.close(), c = H.version + 1, d = !0, R(v());
                to(n, W);
              } catch {
              }
              Gn.push(n), H.onversionchange = Ue(function(z) {
                r.vcFired = !0, n.on("versionchange").fire(z);
              }), H.onclose = Ue(function(z) {
                n.on("close").fire(z);
              }), g && (K = n._deps, W = O, H = K.indexedDB, K = K.IDBKeyRange, ui(H) || W === Yr || li(H, K).put({ name: W }).catch(y)), R();
            }, w);
          }).catch(function(R) {
            switch (R?.name) {
              case "UnknownError":
                if (0 < r.PR1398_maxLoop) return r.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), v();
                break;
              case "VersionError":
                if (0 < c) return c = 0, v();
            }
            return ne.reject(R);
          });
        }
        var _, S = r.dbReadyResolve, E = null, g = !1;
        return ne.race([l, (typeof navigator > "u" ? ne.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(R) {
          function w() {
            return indexedDB.databases().finally(R);
          }
          _ = setInterval(w, 100), w();
        }).finally(function() {
          return clearInterval(_);
        }) : Promise.resolve()).then(v)]).then(function() {
          return m(), r.onReadyBeingFired = [], ne.resolve(ci(function() {
            return n.on.ready.fire(n.vip);
          })).then(function R() {
            if (0 < r.onReadyBeingFired.length) {
              var w = r.onReadyBeingFired.reduce(Y, y);
              return r.onReadyBeingFired = [], ne.resolve(ci(function() {
                return w(n.vip);
              })).then(R);
            }
          });
        }).finally(function() {
          r.openCanceller === l && (r.onReadyBeingFired = null, r.isBeingOpened = !1);
        }).catch(function(R) {
          r.dbOpenError = R;
          try {
            E && E.abort();
          } catch {
          }
          return l === r.openCanceller && n._close(), Ge(R);
        }).finally(function() {
          r.openComplete = !0, S();
        }).then(function() {
          var R;
          return g && (R = {}, n.tables.forEach(function(w) {
            w.schema.indexes.forEach(function(O) {
              O.name && (R["idb://".concat(n.name, "/").concat(w.name, "/").concat(O.name)] = new ct(-1 / 0, [[[]]]));
            }), R["idb://".concat(n.name, "/").concat(w.name, "/")] = R["idb://".concat(n.name, "/").concat(w.name, "/:dels")] = new ct(-1 / 0, [[[]]]);
          }), vn(vr).fire(R), mi(R, !0)), n;
        });
      }
      function yi(n) {
        function r(d) {
          return n.next(d);
        }
        var s = c(r), l = c(function(d) {
          return n.throw(d);
        });
        function c(d) {
          return function(_) {
            var v = d(_), _ = v.value;
            return v.done ? _ : _ && typeof _.then == "function" ? _.then(s, l) : p(_) ? Promise.all(_).then(s, l) : s(_);
          };
        }
        return c(r)();
      }
      function uo(n, r, s) {
        for (var l = p(n) ? n.slice() : [n], c = 0; c < s; ++c) l.push(r);
        return l;
      }
      var pu = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return i(i({}, n), { table: function(r) {
          var s = n.table(r), l = s.schema, c = {}, d = [];
          function m(g, R, w) {
            var O = br(g), P = c[O] = c[O] || [], T = g == null ? 0 : typeof g == "string" ? 1 : g.length, D = 0 < R, D = i(i({}, w), { name: D ? "".concat(O, "(virtual-from:").concat(w.name, ")") : w.name, lowLevelIndex: w, isVirtual: D, keyTail: R, keyLength: T, extractKey: oi(g), unique: !D && w.unique });
            return P.push(D), D.isPrimaryKey || d.push(D), 1 < T && m(T === 2 ? g[0] : g.slice(0, T - 1), R + 1, w), P.sort(function(j, L) {
              return j.keyTail - L.keyTail;
            }), D;
          }
          r = m(l.primaryKey.keyPath, 0, l.primaryKey), c[":id"] = [r];
          for (var v = 0, _ = l.indexes; v < _.length; v++) {
            var S = _[v];
            m(S.keyPath, 0, S);
          }
          function E(g) {
            var R, w = g.query.index;
            return w.isVirtual ? i(i({}, g), { query: { index: w.lowLevelIndex, range: (R = g.query.range, w = w.keyTail, { type: R.type === 1 ? 2 : R.type, lower: uo(R.lower, R.lowerOpen ? n.MAX_KEY : n.MIN_KEY, w), lowerOpen: !0, upper: uo(R.upper, R.upperOpen ? n.MIN_KEY : n.MAX_KEY, w), upperOpen: !0 }) } }) : g;
          }
          return i(i({}, s), { schema: i(i({}, l), { primaryKey: r, indexes: d, getIndexByKeyPath: function(g) {
            return (g = c[br(g)]) && g[0];
          } }), count: function(g) {
            return s.count(E(g));
          }, query: function(g) {
            return s.query(E(g));
          }, openCursor: function(g) {
            var R = g.query.index, w = R.keyTail, O = R.isVirtual, P = R.keyLength;
            return O ? s.openCursor(E(g)).then(function(D) {
              return D && T(D);
            }) : s.openCursor(g);
            function T(D) {
              return Object.create(D, { continue: { value: function(j) {
                j != null ? D.continue(uo(j, g.reverse ? n.MAX_KEY : n.MIN_KEY, w)) : g.unique ? D.continue(D.key.slice(0, P).concat(g.reverse ? n.MIN_KEY : n.MAX_KEY, w)) : D.continue();
              } }, continuePrimaryKey: { value: function(j, L) {
                D.continuePrimaryKey(uo(j, n.MAX_KEY, w), L);
              } }, primaryKey: { get: function() {
                return D.primaryKey;
              } }, key: { get: function() {
                var j = D.key;
                return P === 1 ? j[0] : j.slice(0, P);
              } }, value: { get: function() {
                return D.value;
              } } });
            }
          } });
        } });
      } };
      function vi(n, r, s, l) {
        return s = s || {}, l = l || "", f(n).forEach(function(c) {
          var d, m, v;
          C(r, c) ? (d = n[c], m = r[c], typeof d == "object" && typeof m == "object" && d && m ? (v = un(d)) !== un(m) ? s[l + c] = r[c] : v === "Object" ? vi(d, m, s, l + c + ".") : d !== m && (s[l + c] = r[c]) : d !== m && (s[l + c] = r[c])) : s[l + c] = void 0;
        }), f(r).forEach(function(c) {
          C(n, c) || (s[l + c] = r[c]);
        }), s;
      }
      function gi(n, r) {
        return r.type === "delete" ? r.keys : r.keys || r.values.map(n.extractKey);
      }
      var hu = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return i(i({}, n), { table: function(r) {
          var s = n.table(r), l = s.schema.primaryKey;
          return i(i({}, s), { mutate: function(c) {
            var d = ie.trans, m = d.table(r).hook, v = m.deleting, _ = m.creating, S = m.updating;
            switch (c.type) {
              case "add":
                if (_.fire === y) break;
                return d._promise("readwrite", function() {
                  return E(c);
                }, !0);
              case "put":
                if (_.fire === y && S.fire === y) break;
                return d._promise("readwrite", function() {
                  return E(c);
                }, !0);
              case "delete":
                if (v.fire === y) break;
                return d._promise("readwrite", function() {
                  return E(c);
                }, !0);
              case "deleteRange":
                if (v.fire === y) break;
                return d._promise("readwrite", function() {
                  return function g(R, w, O) {
                    return s.query({ trans: R, values: !1, query: { index: l, range: w }, limit: O }).then(function(P) {
                      var T = P.result;
                      return E({ type: "delete", keys: T, trans: R }).then(function(D) {
                        return 0 < D.numFailures ? Promise.reject(D.failures[0]) : T.length < O ? { failures: [], numFailures: 0, lastResult: void 0 } : g(R, i(i({}, w), { lower: T[T.length - 1], lowerOpen: !0 }), O);
                      });
                    });
                  }(c.trans, c.range, 1e4);
                }, !0);
            }
            return s.mutate(c);
            function E(g) {
              var R, w, O, P = ie.trans, T = g.keys || gi(l, g);
              if (!T) throw new Error("Keys missing");
              return (g = g.type === "add" || g.type === "put" ? i(i({}, g), { keys: T }) : i({}, g)).type !== "delete" && (g.values = a([], g.values)), g.keys && (g.keys = a([], g.keys)), R = s, O = T, ((w = g).type === "add" ? Promise.resolve([]) : R.getMany({ trans: w.trans, keys: O, cache: "immutable" })).then(function(D) {
                var j = T.map(function(L, K) {
                  var H, Q, W, z = D[K], te = { onerror: null, onsuccess: null };
                  return g.type === "delete" ? v.fire.call(te, L, z, P) : g.type === "add" || z === void 0 ? (H = _.fire.call(te, L, g.values[K], P), L == null && H != null && (g.keys[K] = L = H, l.outbound || De(g.values[K], l.keyPath, L))) : (H = vi(z, g.values[K]), (Q = S.fire.call(te, H, L, z, P)) && (W = g.values[K], Object.keys(Q).forEach(function(Z) {
                    C(W, Z) ? W[Z] = Q[Z] : De(W, Z, Q[Z]);
                  }))), te;
                });
                return s.mutate(g).then(function(L) {
                  for (var K = L.failures, H = L.results, Q = L.numFailures, L = L.lastResult, W = 0; W < T.length; ++W) {
                    var z = (H || T)[W], te = j[W];
                    z == null ? te.onerror && te.onerror(K[W]) : te.onsuccess && te.onsuccess(g.type === "put" && D[W] ? g.values[W] : z);
                  }
                  return { failures: K, results: H, numFailures: Q, lastResult: L };
                }).catch(function(L) {
                  return j.forEach(function(K) {
                    return K.onerror && K.onerror(L);
                  }), Promise.reject(L);
                });
              });
            }
          } });
        } });
      } };
      function Us(n, r, s) {
        try {
          if (!r || r.keys.length < n.length) return null;
          for (var l = [], c = 0, d = 0; c < r.keys.length && d < n.length; ++c) Ce(r.keys[c], n[d]) === 0 && (l.push(s ? ut(r.values[c]) : r.values[c]), ++d);
          return l.length === n.length ? l : null;
        } catch {
          return null;
        }
      }
      var mu = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(r) {
          var s = n.table(r);
          return i(i({}, s), { getMany: function(l) {
            if (!l.cache) return s.getMany(l);
            var c = Us(l.keys, l.trans._cache, l.cache === "clone");
            return c ? ne.resolve(c) : s.getMany(l).then(function(d) {
              return l.trans._cache = { keys: l.keys, values: l.cache === "clone" ? ut(d) : d }, d;
            });
          }, mutate: function(l) {
            return l.type !== "add" && (l.trans._cache = null), s.mutate(l);
          } });
        } };
      } };
      function Vs(n, r) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !r.schema.primaryKey.outbound;
      }
      function Hs(n, r) {
        switch (n) {
          case "query":
            return r.values && !r.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var yu = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var r = n.schema.name, s = new ct(n.MIN_KEY, n.MAX_KEY);
        return i(i({}, n), { transaction: function(l, c, d) {
          if (ie.subscr && c !== "readonly") throw new se.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ie.querier));
          return n.transaction(l, c, d);
        }, table: function(l) {
          var c = n.table(l), d = c.schema, m = d.primaryKey, g = d.indexes, v = m.extractKey, _ = m.outbound, S = m.autoIncrement && g.filter(function(w) {
            return w.compound && w.keyPath.includes(m.keyPath);
          }), E = i(i({}, c), { mutate: function(w) {
            function O(Z) {
              return Z = "idb://".concat(r, "/").concat(l, "/").concat(Z), L[Z] || (L[Z] = new ct());
            }
            var P, T, D, j = w.trans, L = w.mutatedParts || (w.mutatedParts = {}), K = O(""), H = O(":dels"), Q = w.type, te = w.type === "deleteRange" ? [w.range] : w.type === "delete" ? [w.keys] : w.values.length < 50 ? [gi(m, w).filter(function(Z) {
              return Z;
            }), w.values] : [], W = te[0], z = te[1], te = w.trans._cache;
            return p(W) ? (K.addKeys(W), (te = Q === "delete" || W.length === z.length ? Us(W, te) : null) || H.addKeys(W), (te || z) && (P = O, T = te, D = z, d.indexes.forEach(function(Z) {
              var oe = P(Z.name || "");
              function ve(me) {
                return me != null ? Z.extractKey(me) : null;
              }
              function Pe(me) {
                return Z.multiEntry && p(me) ? me.forEach(function(ze) {
                  return oe.addKey(ze);
                }) : oe.addKey(me);
              }
              (T || D).forEach(function(me, ft) {
                var he = T && ve(T[ft]), ft = D && ve(D[ft]);
                Ce(he, ft) !== 0 && (he != null && Pe(he), ft != null && Pe(ft));
              });
            }))) : W ? (z = { from: (z = W.lower) !== null && z !== void 0 ? z : n.MIN_KEY, to: (z = W.upper) !== null && z !== void 0 ? z : n.MAX_KEY }, H.add(z), K.add(z)) : (K.add(s), H.add(s), d.indexes.forEach(function(Z) {
              return O(Z.name).add(s);
            })), c.mutate(w).then(function(Z) {
              return !W || w.type !== "add" && w.type !== "put" || (K.addKeys(Z.results), S && S.forEach(function(oe) {
                for (var ve = w.values.map(function(he) {
                  return oe.extractKey(he);
                }), Pe = oe.keyPath.findIndex(function(he) {
                  return he === m.keyPath;
                }), me = 0, ze = Z.results.length; me < ze; ++me) ve[me][Pe] = Z.results[me];
                O(oe.name).addKeys(ve);
              })), j.mutatedParts = ao(j.mutatedParts || {}, L), Z;
            });
          } }), g = function(O) {
            var P = O.query, O = P.index, P = P.range;
            return [O, new ct((O = P.lower) !== null && O !== void 0 ? O : n.MIN_KEY, (P = P.upper) !== null && P !== void 0 ? P : n.MAX_KEY)];
          }, R = { get: function(w) {
            return [m, new ct(w.key)];
          }, getMany: function(w) {
            return [m, new ct().addKeys(w.keys)];
          }, count: g, query: g, openCursor: g };
          return f(R).forEach(function(w) {
            E[w] = function(O) {
              var P = ie.subscr, T = !!P, D = Vs(ie, c) && Hs(w, O) ? O.obsSet = {} : P;
              if (T) {
                var j = function(z) {
                  return z = "idb://".concat(r, "/").concat(l, "/").concat(z), D[z] || (D[z] = new ct());
                }, L = j(""), K = j(":dels"), P = R[w](O), T = P[0], P = P[1];
                if ((w === "query" && T.isPrimaryKey && !O.values ? K : j(T.name || "")).add(P), !T.isPrimaryKey) {
                  if (w !== "count") {
                    var H = w === "query" && _ && O.values && c.query(i(i({}, O), { values: !1 }));
                    return c[w].apply(this, arguments).then(function(z) {
                      if (w === "query") {
                        if (_ && O.values) return H.then(function(ve) {
                          return ve = ve.result, L.addKeys(ve), z;
                        });
                        var te = O.values ? z.result.map(v) : z.result;
                        (O.values ? L : K).addKeys(te);
                      } else if (w === "openCursor") {
                        var Z = z, oe = O.values;
                        return Z && Object.create(Z, { key: { get: function() {
                          return K.addKey(Z.primaryKey), Z.key;
                        } }, primaryKey: { get: function() {
                          var ve = Z.primaryKey;
                          return K.addKey(ve), ve;
                        } }, value: { get: function() {
                          return oe && L.addKey(Z.primaryKey), Z.value;
                        } } });
                      }
                      return z;
                    });
                  }
                  K.add(s);
                }
              }
              return c[w].apply(this, arguments);
            };
          }), E;
        } });
      } };
      function Ws(n, r, s) {
        if (s.numFailures === 0) return r;
        if (r.type === "deleteRange") return null;
        var l = r.keys ? r.keys.length : "values" in r && r.values ? r.values.length : 1;
        return s.numFailures === l ? null : (r = i({}, r), p(r.keys) && (r.keys = r.keys.filter(function(c, d) {
          return !(d in s.failures);
        })), "values" in r && p(r.values) && (r.values = r.values.filter(function(c, d) {
          return !(d in s.failures);
        })), r);
      }
      function bi(n, r) {
        return s = n, ((l = r).lower === void 0 || (l.lowerOpen ? 0 < Ce(s, l.lower) : 0 <= Ce(s, l.lower))) && (n = n, (r = r).upper === void 0 || (r.upperOpen ? Ce(n, r.upper) < 0 : Ce(n, r.upper) <= 0));
        var s, l;
      }
      function zs(n, r, R, l, c, d) {
        if (!R || R.length === 0) return n;
        var m = r.query.index, v = m.multiEntry, _ = r.query.range, S = l.schema.primaryKey.extractKey, E = m.extractKey, g = (m.lowLevelIndex || m).extractKey, R = R.reduce(function(w, O) {
          var P = w, T = [];
          if (O.type === "add" || O.type === "put") for (var D = new ct(), j = O.values.length - 1; 0 <= j; --j) {
            var L, K = O.values[j], H = S(K);
            D.hasKey(H) || (L = E(K), (v && p(L) ? L.some(function(Z) {
              return bi(Z, _);
            }) : bi(L, _)) && (D.addKey(H), T.push(K)));
          }
          switch (O.type) {
            case "add":
              var Q = new ct().addKeys(r.values ? w.map(function(oe) {
                return S(oe);
              }) : w), P = w.concat(r.values ? T.filter(function(oe) {
                return oe = S(oe), !Q.hasKey(oe) && (Q.addKey(oe), !0);
              }) : T.map(function(oe) {
                return S(oe);
              }).filter(function(oe) {
                return !Q.hasKey(oe) && (Q.addKey(oe), !0);
              }));
              break;
            case "put":
              var W = new ct().addKeys(O.values.map(function(oe) {
                return S(oe);
              }));
              P = w.filter(function(oe) {
                return !W.hasKey(r.values ? S(oe) : oe);
              }).concat(r.values ? T : T.map(function(oe) {
                return S(oe);
              }));
              break;
            case "delete":
              var z = new ct().addKeys(O.keys);
              P = w.filter(function(oe) {
                return !z.hasKey(r.values ? S(oe) : oe);
              });
              break;
            case "deleteRange":
              var te = O.range;
              P = w.filter(function(oe) {
                return !bi(S(oe), te);
              });
          }
          return P;
        }, n);
        return R === n ? n : (R.sort(function(w, O) {
          return Ce(g(w), g(O)) || Ce(S(w), S(O));
        }), r.limit && r.limit < 1 / 0 && (R.length > r.limit ? R.length = r.limit : n.length === r.limit && R.length < r.limit && (c.dirty = !0)), d ? Object.freeze(R) : R);
      }
      function Gs(n, r) {
        return Ce(n.lower, r.lower) === 0 && Ce(n.upper, r.upper) === 0 && !!n.lowerOpen == !!r.lowerOpen && !!n.upperOpen == !!r.upperOpen;
      }
      function vu(n, r) {
        return function(s, l, c, d) {
          if (s === void 0) return l !== void 0 ? -1 : 0;
          if (l === void 0) return 1;
          if ((l = Ce(s, l)) === 0) {
            if (c && d) return 0;
            if (c) return 1;
            if (d) return -1;
          }
          return l;
        }(n.lower, r.lower, n.lowerOpen, r.lowerOpen) <= 0 && 0 <= function(s, l, c, d) {
          if (s === void 0) return l !== void 0 ? 1 : 0;
          if (l === void 0) return -1;
          if ((l = Ce(s, l)) === 0) {
            if (c && d) return 0;
            if (c) return -1;
            if (d) return 1;
          }
          return l;
        }(n.upper, r.upper, n.upperOpen, r.upperOpen);
      }
      function gu(n, r, s, l) {
        n.subscribers.add(s), l.addEventListener("abort", function() {
          var c, d;
          n.subscribers.delete(s), n.subscribers.size === 0 && (c = n, d = r, setTimeout(function() {
            c.subscribers.size === 0 && Ee(d, c);
          }, 3e3));
        });
      }
      var bu = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var r = n.schema.name;
        return i(i({}, n), { transaction: function(s, l, c) {
          var d, m, v = n.transaction(s, l, c);
          return l === "readwrite" && (m = (d = new AbortController()).signal, c = function(_) {
            return function() {
              if (d.abort(), l === "readwrite") {
                for (var S = /* @__PURE__ */ new Set(), E = 0, g = s; E < g.length; E++) {
                  var R = g[E], w = kn["idb://".concat(r, "/").concat(R)];
                  if (w) {
                    var O = n.table(R), P = w.optimisticOps.filter(function(oe) {
                      return oe.trans === v;
                    });
                    if (v._explicit && _ && v.mutatedParts) for (var T = 0, D = Object.values(w.queries.query); T < D.length; T++) for (var j = 0, L = (Q = D[T]).slice(); j < L.length; j++) di((W = L[j]).obsSet, v.mutatedParts) && (Ee(Q, W), W.subscribers.forEach(function(oe) {
                      return S.add(oe);
                    }));
                    else if (0 < P.length) {
                      w.optimisticOps = w.optimisticOps.filter(function(oe) {
                        return oe.trans !== v;
                      });
                      for (var K = 0, H = Object.values(w.queries.query); K < H.length; K++) for (var Q, W, z, te = 0, Z = (Q = H[K]).slice(); te < Z.length; te++) (W = Z[te]).res != null && v.mutatedParts && (_ && !W.dirty ? (z = Object.isFrozen(W.res), z = zs(W.res, W.req, P, O, W, z), W.dirty ? (Ee(Q, W), W.subscribers.forEach(function(oe) {
                        return S.add(oe);
                      })) : z !== W.res && (W.res = z, W.promise = ne.resolve({ result: z }))) : (W.dirty && Ee(Q, W), W.subscribers.forEach(function(oe) {
                        return S.add(oe);
                      })));
                    }
                  }
                }
                S.forEach(function(oe) {
                  return oe();
                });
              }
            };
          }, v.addEventListener("abort", c(!1), { signal: m }), v.addEventListener("error", c(!1), { signal: m }), v.addEventListener("complete", c(!0), { signal: m })), v;
        }, table: function(s) {
          var l = n.table(s), c = l.schema.primaryKey;
          return i(i({}, l), { mutate: function(d) {
            var m = ie.trans;
            if (c.outbound || m.db._options.cache === "disabled" || m.explicit || m.idbtrans.mode !== "readwrite") return l.mutate(d);
            var v = kn["idb://".concat(r, "/").concat(s)];
            return v ? (m = l.mutate(d), d.type !== "add" && d.type !== "put" || !(50 <= d.values.length || gi(c, d).some(function(_) {
              return _ == null;
            })) ? (v.optimisticOps.push(d), d.mutatedParts && lo(d.mutatedParts), m.then(function(_) {
              0 < _.numFailures && (Ee(v.optimisticOps, d), (_ = Ws(0, d, _)) && v.optimisticOps.push(_), d.mutatedParts && lo(d.mutatedParts));
            }), m.catch(function() {
              Ee(v.optimisticOps, d), d.mutatedParts && lo(d.mutatedParts);
            })) : m.then(function(_) {
              var S = Ws(0, i(i({}, d), { values: d.values.map(function(E, g) {
                var R;
                return _.failures[g] ? E : (E = (R = c.keyPath) !== null && R !== void 0 && R.includes(".") ? ut(E) : i({}, E), De(E, c.keyPath, _.results[g]), E);
              }) }), _);
              v.optimisticOps.push(S), queueMicrotask(function() {
                return d.mutatedParts && lo(d.mutatedParts);
              });
            }), m) : l.mutate(d);
          }, query: function(d) {
            if (!Vs(ie, l) || !Hs("query", d)) return l.query(d);
            var m = ((S = ie.trans) === null || S === void 0 ? void 0 : S.db._options.cache) === "immutable", g = ie, v = g.requery, _ = g.signal, S = function(O, P, T, D) {
              var j = kn["idb://".concat(O, "/").concat(P)];
              if (!j) return [];
              if (!(P = j.queries[T])) return [null, !1, j, null];
              var L = P[(D.query ? D.query.index.name : null) || ""];
              if (!L) return [null, !1, j, null];
              switch (T) {
                case "query":
                  var K = L.find(function(H) {
                    return H.req.limit === D.limit && H.req.values === D.values && Gs(H.req.query.range, D.query.range);
                  });
                  return K ? [K, !0, j, L] : [L.find(function(H) {
                    return ("limit" in H.req ? H.req.limit : 1 / 0) >= D.limit && (!D.values || H.req.values) && vu(H.req.query.range, D.query.range);
                  }), !1, j, L];
                case "count":
                  return K = L.find(function(H) {
                    return Gs(H.req.query.range, D.query.range);
                  }), [K, !!K, j, L];
              }
            }(r, s, "query", d), E = S[0], g = S[1], R = S[2], w = S[3];
            return E && g ? E.obsSet = d.obsSet : (g = l.query(d).then(function(O) {
              var P = O.result;
              if (E && (E.res = P), m) {
                for (var T = 0, D = P.length; T < D; ++T) Object.freeze(P[T]);
                Object.freeze(P);
              } else O.result = ut(P);
              return O;
            }).catch(function(O) {
              return w && E && Ee(w, E), Promise.reject(O);
            }), E = { obsSet: d.obsSet, promise: g, subscribers: /* @__PURE__ */ new Set(), type: "query", req: d, dirty: !1 }, w ? w.push(E) : (w = [E], (R = R || (kn["idb://".concat(r, "/").concat(s)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[d.query.index.name || ""] = w)), gu(E, w, v, _), E.promise.then(function(O) {
              return { result: zs(O.result, d, R?.optimisticOps, l, E, m) };
            });
          } });
        } });
      } };
      function co(n, r) {
        return new Proxy(n, { get: function(s, l, c) {
          return l === "db" ? r : Reflect.get(s, l, c);
        } });
      }
      var Yt = (Ye.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new se.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new se.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var r = this._versions, s = r.filter(function(l) {
          return l._cfg.version === n;
        })[0];
        return s || (s = new this.Version(n), r.push(s), r.sort(lu), s.stores({}), this._state.autoSchema = !1, s);
      }, Ye.prototype._whenReady = function(n) {
        var r = this;
        return this.idbdb && (this._state.openComplete || ie.letThrough || this._vip) ? n() : new ne(function(s, l) {
          if (r._state.openComplete) return l(new se.DatabaseClosed(r._state.dbOpenError));
          if (!r._state.isBeingOpened) {
            if (!r._state.autoOpen) return void l(new se.DatabaseClosed());
            r.open().catch(y);
          }
          r._state.dbReadyPromise.then(s, l);
        }).then(n);
      }, Ye.prototype.use = function(n) {
        var r = n.stack, s = n.create, l = n.level, c = n.name;
        return c && this.unuse({ stack: r, name: c }), n = this._middlewares[r] || (this._middlewares[r] = []), n.push({ stack: r, create: s, level: l ?? 10, name: c }), n.sort(function(d, m) {
          return d.level - m.level;
        }), this;
      }, Ye.prototype.unuse = function(n) {
        var r = n.stack, s = n.name, l = n.create;
        return r && this._middlewares[r] && (this._middlewares[r] = this._middlewares[r].filter(function(c) {
          return l ? c.create !== l : !!s && c.name !== s;
        })), this;
      }, Ye.prototype.open = function() {
        var n = this;
        return An(We, function() {
          return du(n);
        });
      }, Ye.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, r = Gn.indexOf(this);
        if (0 <= r && Gn.splice(r, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ne(function(s) {
          n.dbReadyResolve = s;
        }), n.openCanceller = new ne(function(s, l) {
          n.cancelOpen = l;
        }));
      }, Ye.prototype.close = function(s) {
        var r = (s === void 0 ? { disableAutoOpen: !0 } : s).disableAutoOpen, s = this._state;
        r ? (s.isBeingOpened && s.cancelOpen(new se.DatabaseClosed()), this._close(), s.autoOpen = !1, s.dbOpenError = new se.DatabaseClosed()) : (this._close(), s.autoOpen = this._options.autoOpen || s.isBeingOpened, s.openComplete = !1, s.dbOpenError = null);
      }, Ye.prototype.delete = function(n) {
        var r = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var s = 0 < arguments.length && typeof arguments[0] != "object", l = this._state;
        return new ne(function(c, d) {
          function m() {
            r.close(n);
            var v = r._deps.indexedDB.deleteDatabase(r.name);
            v.onsuccess = Ue(function() {
              var _, S, E;
              _ = r._deps, S = r.name, E = _.indexedDB, _ = _.IDBKeyRange, ui(E) || S === Yr || li(E, _).delete(S).catch(y), c();
            }), v.onerror = $t(d), v.onblocked = r._fireOnBlocked;
          }
          if (s) throw new se.InvalidArgument("Invalid closeOptions argument to db.delete()");
          l.isBeingOpened ? l.dbReadyPromise.then(m) : m();
        });
      }, Ye.prototype.backendDB = function() {
        return this.idbdb;
      }, Ye.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Ye.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, Ye.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Ye.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Ye.prototype, "tables", { get: function() {
        var n = this;
        return f(this._allTables).map(function(r) {
          return n._allTables[r];
        });
      }, enumerable: !1, configurable: !0 }), Ye.prototype.transaction = function() {
        var n = (function(r, s, l) {
          var c = arguments.length;
          if (c < 2) throw new se.InvalidArgument("Too few arguments");
          for (var d = new Array(c - 1); --c; ) d[c - 1] = arguments[c];
          return l = d.pop(), [r, Ve(d), l];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, Ye.prototype._transaction = function(n, r, s) {
        var l = this, c = ie.trans;
        c && c.db === this && n.indexOf("!") === -1 || (c = null);
        var d, m, v = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (m = r.map(function(S) {
            if (S = S instanceof l.Table ? S.name : S, typeof S != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return S;
          }), n == "r" || n === Jo) d = Jo;
          else {
            if (n != "rw" && n != Xo) throw new se.InvalidArgument("Invalid transaction mode: " + n);
            d = Xo;
          }
          if (c) {
            if (c.mode === Jo && d === Xo) {
              if (!v) throw new se.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              c = null;
            }
            c && m.forEach(function(S) {
              if (c && c.storeNames.indexOf(S) === -1) {
                if (!v) throw new se.SubTransaction("Table " + S + " not included in parent transaction.");
                c = null;
              }
            }), v && c && !c.active && (c = null);
          }
        } catch (S) {
          return c ? c._promise(null, function(E, g) {
            g(S);
          }) : Ge(S);
        }
        var _ = (function S(E, g, R, w, O) {
          return ne.resolve().then(function() {
            var P = ie.transless || ie, T = E._createTransaction(g, R, E._dbSchema, w);
            if (T.explicit = !0, P = { trans: T, transless: P }, w) T.idbtrans = w.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, E._state.PR1398_maxLoop = 3;
            } catch (L) {
              return L.name === cn.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                return S(E, g, R, null, O);
              })) : Ge(L);
            }
            var D, j = jt(O);
            return j && zn(), P = ne.follow(function() {
              var L;
              (D = O.call(T, T)) && (j ? (L = hn.bind(null, null), D.then(L, L)) : typeof D.next == "function" && typeof D.throw == "function" && (D = yi(D)));
            }, P), (D && typeof D.then == "function" ? ne.resolve(D).then(function(L) {
              return T.active ? L : Ge(new se.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : P.then(function() {
              return D;
            })).then(function(L) {
              return w && T._resolve(), T._completion.then(function() {
                return L;
              });
            }).catch(function(L) {
              return T._reject(L), Ge(L);
            });
          });
        }).bind(null, this, d, m, c, s);
        return c ? c._promise(d, _, "lock") : ie.trans ? An(ie.transless, function() {
          return l._whenReady(_);
        }) : this._whenReady(_);
      }, Ye.prototype.table = function(n) {
        if (!C(this._allTables, n)) throw new se.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, Ye);
      function Ye(n, r) {
        var s = this;
        this._middlewares = {}, this.verno = 0;
        var l = Ye.dependencies;
        this._options = r = i({ addons: Ye.addons, autoOpen: !0, indexedDB: l.indexedDB, IDBKeyRange: l.IDBKeyRange, cache: "cloned" }, r), this._deps = { indexedDB: r.indexedDB, IDBKeyRange: r.IDBKeyRange }, l = r.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var c, d, m, v, _, S = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: y, dbReadyPromise: null, cancelOpen: y, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: r.autoOpen };
        S.dbReadyPromise = new ne(function(g) {
          S.dbReadyResolve = g;
        }), S.openCanceller = new ne(function(g, R) {
          S.cancelOpen = R;
        }), this._state = S, this.name = n, this.on = pr(this, "populate", "blocked", "versionchange", "close", { ready: [Y, y] }), this.once = function(g, R) {
          var w = function() {
            for (var O = [], P = 0; P < arguments.length; P++) O[P] = arguments[P];
            s.on(g).unsubscribe(w), R.apply(s, O);
          };
          return s.on(g, w);
        }, this.on.ready.subscribe = Se(this.on.ready.subscribe, function(g) {
          return function(R, w) {
            Ye.vip(function() {
              var O, P = s._state;
              P.openComplete ? (P.dbOpenError || ne.resolve().then(R), w && g(R)) : P.onReadyBeingFired ? (P.onReadyBeingFired.push(R), w && g(R)) : (g(R), O = s, w || g(function T() {
                O.on.ready.unsubscribe(R), O.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (c = this, hr(tu.prototype, function(D, T) {
          this.db = c;
          var w = Cs, O = null;
          if (T) try {
            w = T();
          } catch (j) {
            O = j;
          }
          var P = D._ctx, T = P.table, D = T.hook.reading.fire;
          this._ctx = { table: T, index: P.index, isPrimKey: !P.index || T.schema.primKey.keyPath && P.index === T.schema.primKey.name, range: w, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: O, or: P.or, valueMapper: D !== x ? D : null };
        })), this.Table = (d = this, hr(Ts.prototype, function(g, R, w) {
          this.db = d, this._tx = w, this.name = g, this.schema = R, this.hook = d._allTables[g] ? d._allTables[g].hook : pr(null, { creating: [B, y], reading: [M, x], updating: [ee, y], deleting: [V, y] });
        })), this.Transaction = (m = this, hr(ou.prototype, function(g, R, w, O, P) {
          var T = this;
          g !== "readonly" && R.forEach(function(D) {
            D = (D = w[D]) === null || D === void 0 ? void 0 : D.yProps, D && (R = R.concat(D.map(function(j) {
              return j.updatesTable;
            })));
          }), this.db = m, this.mode = g, this.storeNames = R, this.schema = w, this.chromeTransactionDurability = O, this.idbtrans = null, this.on = pr(this, "complete", "error", "abort"), this.parent = P || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ne(function(D, j) {
            T._resolve = D, T._reject = j;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(D) {
            var j = T.active;
            return T.active = !1, T.on.error.fire(D), T.parent ? T.parent._reject(D) : j && T.idbtrans && T.idbtrans.abort(), Ge(D);
          });
        })), this.Version = (v = this, hr(fu.prototype, function(g) {
          this.db = v, this._cfg = { version: g, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (_ = this, hr(Is.prototype, function(g, R, w) {
          if (this.db = _, this._ctx = { table: g, index: R === ":id" ? null : R, or: w }, this._cmp = this._ascending = Ce, this._descending = function(O, P) {
            return Ce(P, O);
          }, this._max = function(O, P) {
            return 0 < Ce(O, P) ? O : P;
          }, this._min = function(O, P) {
            return Ce(O, P) < 0 ? O : P;
          }, this._IDBKeyRange = _._deps.IDBKeyRange, !this._IDBKeyRange) throw new se.MissingAPI();
        })), this.on("versionchange", function(g) {
          0 < g.newVersion ? console.warn("Another connection wants to upgrade database '".concat(s.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(s.name, "'. Closing db now to resume the delete request.")), s.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(g) {
          !g.newVersion || g.newVersion < g.oldVersion ? console.warn("Dexie.delete('".concat(s.name, "') was blocked")) : console.warn("Upgrade '".concat(s.name, "' blocked by other connection holding version ").concat(g.oldVersion / 10));
        }), this._maxKey = gr(r.IDBKeyRange), this._createTransaction = function(g, R, w, O) {
          return new s.Transaction(g, R, w, s._options.chromeTransactionDurability, O);
        }, this._fireOnBlocked = function(g) {
          s.on("blocked").fire(g), Gn.filter(function(R) {
            return R.name === s.name && R !== s && !R._state.vcFired;
          }).map(function(R) {
            return R.on("versionchange").fire(g);
          });
        }, this.use(mu), this.use(bu), this.use(yu), this.use(pu), this.use(hu);
        var E = new Proxy(this, { get: function(g, R, w) {
          if (R === "_vip") return !0;
          if (R === "table") return function(P) {
            return co(s.table(P), E);
          };
          var O = Reflect.get(g, R, w);
          return O instanceof Ts ? co(O, E) : R === "tables" ? O.map(function(P) {
            return co(P, E);
          }) : R === "_createTransaction" ? function() {
            return co(O.apply(this, arguments), E);
          } : O;
        } });
        this.vip = E, l.forEach(function(g) {
          return g(s);
        });
      }
      var fo, Dt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", _u = (_i.prototype.subscribe = function(n, r, s) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: r, complete: s });
      }, _i.prototype[Dt] = function() {
        return this;
      }, _i);
      function _i(n) {
        this._subscribe = n;
      }
      try {
        fo = { indexedDB: u.indexedDB || u.mozIndexedDB || u.webkitIndexedDB || u.msIndexedDB, IDBKeyRange: u.IDBKeyRange || u.webkitIDBKeyRange };
      } catch {
        fo = { indexedDB: null, IDBKeyRange: null };
      }
      function Ys(n) {
        var r, s = !1, l = new _u(function(c) {
          var d = jt(n), m, v = !1, _ = {}, S = {}, E = { get closed() {
            return v;
          }, unsubscribe: function() {
            v || (v = !0, m && m.abort(), g && vn.storagemutated.unsubscribe(w));
          } };
          c.start && c.start(E);
          var g = !1, R = function() {
            return Qo(O);
          }, w = function(P) {
            ao(_, P), di(S, _) && R();
          }, O = function() {
            var P, T, D;
            !v && fo.indexedDB && (_ = {}, P = {}, m && m.abort(), m = new AbortController(), D = function(j) {
              var L = Hn();
              try {
                d && zn();
                var K = pn(n, j);
                return K = d ? K.finally(hn) : K;
              } finally {
                L && Wn();
              }
            }(T = { subscr: P, signal: m.signal, requery: R, querier: n, trans: null }), Promise.resolve(D).then(function(j) {
              s = !0, r = j, v || T.signal.aborted || (_ = {}, function(L) {
                for (var K in L) if (C(L, K)) return;
                return 1;
              }(S = P) || g || (vn(vr, w), g = !0), Qo(function() {
                return !v && c.next && c.next(j);
              }));
            }, function(j) {
              s = !1, ["DatabaseClosedError", "AbortError"].includes(j?.name) || v || Qo(function() {
                v || c.error && c.error(j);
              });
            }));
          };
          return setTimeout(R, 0), E;
        });
        return l.hasValue = function() {
          return s;
        }, l.getValue = function() {
          return r;
        }, l;
      }
      var In = Yt;
      function wi(n) {
        var r = gn;
        try {
          gn = !0, vn.storagemutated.fire(n), mi(n, !0);
        } finally {
          gn = r;
        }
      }
      A(In, i(i({}, dr), { delete: function(n) {
        return new In(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new In(n, { addons: [] }).open().then(function(r) {
          return r.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return r = In.dependencies, s = r.indexedDB, r = r.IDBKeyRange, (ui(s) ? Promise.resolve(s.databases()).then(function(l) {
            return l.map(function(c) {
              return c.name;
            }).filter(function(c) {
              return c !== Yr;
            });
          }) : li(s, r).toCollection().primaryKeys()).then(n);
        } catch {
          return Ge(new se.MissingAPI());
        }
        var r, s;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return ie.trans ? An(ie.transless, n) : n();
      }, vip: ci, async: function(n) {
        return function() {
          try {
            var r = yi(n.apply(this, arguments));
            return r && typeof r.then == "function" ? r : ne.resolve(r);
          } catch (s) {
            return Ge(s);
          }
        };
      }, spawn: function(n, r, s) {
        try {
          var l = yi(n.apply(s, r || []));
          return l && typeof l.then == "function" ? l : ne.resolve(l);
        } catch (c) {
          return Ge(c);
        }
      }, currentTransaction: { get: function() {
        return ie.trans || null;
      } }, waitFor: function(n, r) {
        return r = ne.resolve(typeof n == "function" ? In.ignoreTransaction(n) : n).timeout(r || 6e4), ie.trans ? ie.trans.waitFor(r) : r;
      }, Promise: ne, debug: { get: function() {
        return $;
      }, set: function(n) {
        ue(n);
      } }, derive: re, extend: h, props: A, override: Se, Events: pr, on: vn, liveQuery: Ys, extendObservabilitySet: ao, getByKeyPath: Ke, setByKeyPath: De, delByKeyPath: function(n, r) {
        typeof r == "string" ? De(n, r, void 0) : "length" in r && [].map.call(r, function(s) {
          De(n, s, void 0);
        });
      }, shallowClone: xe, deepClone: ut, getObjectDiff: vi, cmp: Ce, asap: _e, minKey: -1 / 0, addons: [], connections: Gn, errnames: cn, dependencies: fo, cache: kn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, r, s) {
        return n + r / Math.pow(10, 2 * s);
      }) })), In.maxKey = gr(In.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (vn(vr, function(n) {
        gn || (n = new CustomEvent(ti, { detail: n }), gn = !0, dispatchEvent(n), gn = !1);
      }), addEventListener(ti, function(n) {
        n = n.detail, gn || wi(n);
      }));
      var Xn, gn = !1, Qs = function() {
      };
      return typeof BroadcastChannel < "u" && ((Qs = function() {
        (Xn = new BroadcastChannel(ti)).onmessage = function(n) {
          return n.data && wi(n.data);
        };
      })(), typeof Xn.unref == "function" && Xn.unref(), vn(vr, function(n) {
        gn || Xn.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!Yt.disableBfCache && n.persisted) {
          $ && console.debug("Dexie: handling persisted pagehide"), Xn?.close();
          for (var r = 0, s = Gn; r < s.length; r++) s[r].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !Yt.disableBfCache && n.persisted && ($ && console.debug("Dexie: handling persisted pageshow"), Qs(), wi({ all: new ct(-1 / 0, [[]]) }));
      })), ne.rejectionMapper = function(n, r) {
        return !n || n instanceof zt || n instanceof TypeError || n instanceof SyntaxError || !n.name || !fn[n.name] ? n : (r = new fn[n.name](r || n.message, n), "stack" in n && G(r, "stack", { get: function() {
          return this.inner.stack;
        } }), r);
      }, ue($), i(Yt, Object.freeze({ __proto__: null, Dexie: Yt, liveQuery: Ys, Entity: Os, cmp: Ce, PropModification: mr, replacePrefix: function(n, r) {
        return new mr({ replacePrefix: [n, r] });
      }, add: function(n) {
        return new mr({ add: n });
      }, remove: function(n) {
        return new mr({ remove: n });
      }, default: Yt, RangeSet: ct, mergeRanges: wr, rangesOverlap: Fs }), { default: Yt }), Yt;
    });
  }(_o)), _o.exports;
}
var Zf = Xf();
const Gi = /* @__PURE__ */ Qf(Zf), Ia = Symbol.for("Dexie"), Ao = globalThis[Ia] || (globalThis[Ia] = Gi);
if (Gi.semVer !== Ao.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Gi.semVer} and ${Ao.semVer}`);
const {
  liveQuery: Zp,
  mergeRanges: eh,
  rangesOverlap: th,
  RangeSet: nh,
  cmp: rh,
  Entity: oh,
  PropModification: ih,
  replacePrefix: sh,
  add: ah,
  remove: lh,
  DexieYProvider: uh
} = Ao;
var st = /* @__PURE__ */ ((e) => (e.GOOSE = "GOOSE", e.SMV = "SMV", e.REPORT = "Report", e.INTERNAL = "Internal", e.WIRED = "Wired", e.CONTROL = "Control", e))(st || {});
const Ro = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Internal: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: []
};
function Wl(e) {
  return {
    addRecord: t,
    findChildRecordsByTagName: i,
    ensureRelationship: o,
    findParentRecordsWithinDepthAndGivenTagName: a,
    db: e
  };
  async function t(u) {
    const f = {
      ...u,
      id: crypto.randomUUID()
    };
    try {
      const p = await e.table(f.tagName).add(f), h = await e.table(f.tagName).get(p);
      if (!h) {
        const N = { msg: "could not find added record", table: f.tagName, addedId: p };
        throw console.error(N), new Error(JSON.stringify(N));
      }
      return h;
    } catch (p) {
      const h = {
        msg: "could not add record",
        db: e.name,
        table: f.tagName,
        recordToAdd: f,
        err: p
      };
      throw console.error(h), new Error(JSON.stringify(h));
    }
  }
  async function o(u, f) {
    const p = u.children?.some(
      (N) => N.id === f.id && N.tagName === f.tagName
    ), h = f.parent?.id === u.id && f.parent?.tagName === u.tagName;
    p || (u.children || (u.children = []), u.children.push({
      id: f.id,
      tagName: f.tagName
    }), await e.table(u.tagName).update(u.id, u)), h || (f.parent = {
      id: u.id,
      tagName: u.tagName
    }, await e.table(f.tagName).update(f.id, f));
  }
  async function i(u, f) {
    return !u.children || u.children.length === 0 ? [] : await Promise.all(
      u.children.filter((h) => h.tagName === f).map(async (h) => {
        const N = h.tagName, b = h.id;
        return await e.table(N).get({ id: b });
      })
    );
  }
  async function a(u, f, p = []) {
    const h = [];
    let N = u;
    for (let b = 0; b < f; b++) {
      if (!N.parent)
        return h;
      const C = await e.table(N.parent.tagName).get(N.parent.id);
      if (!C) {
        const A = {
          msg: "Parent record not found",
          table: N.parent.tagName,
          id: N.parent.id
        };
        throw console.error(A), new Error(JSON.stringify(A));
      }
      (p.length == 0 || p.length > 0 && p.includes(C.tagName)) && h.push(C), N = C;
    }
    return h;
  }
}
function ed(e, t) {
  return e.attributes?.find((o) => o.name === t);
}
function Oe(e, t) {
  return e?.attributes?.find((o) => o.name === t)?.value;
}
function td(e) {
  return {
    findAllEnrichedLNodes: t,
    findAllLNodeTypes: o,
    enrichWithDataObjectSpecifications: u
  };
  async function t() {
    const p = await f();
    return p.length ? await u(p) : [];
  }
  async function o() {
    const p = await e.table("LNodeType").toArray(), h = [];
    for (const N of p)
      h.push({
        id: N.id,
        typeId: Oe(N, "id") ?? "",
        lnClass: Oe(N, "lnClass") ?? "",
        dataObjects: await i(N)
      });
    return h;
  }
  async function i(p) {
    if (!p.children) return [];
    const h = [];
    for (const N of p.children) {
      if (N.tagName !== "DO") continue;
      const b = await e.table("DO").get(N.id);
      b && h.push({
        id: b.id,
        name: Oe(b, "name") ?? "",
        type: Oe(b, "type") ?? "",
        dataAttributes: await a(b),
        lnodeTypeId: p.id
      });
    }
    return h;
  }
  async function a(p) {
    const h = Oe(p, "type");
    if (!h) return [];
    const N = (await e.table("DOType").toArray()).find(
      (C) => C.attributes?.find((A) => A.name === "id" && A.value === h)
    );
    if (!N || !N.children) return [];
    const b = [];
    for (const C of N.children) {
      if (C.tagName !== "DA") continue;
      const A = await e.table("DA").get(C.id);
      A && b.push({
        id: A.id,
        name: Oe(A, "name") ?? "",
        type: Oe(A, "type") ?? "",
        bType: Oe(A, "bType") ?? "",
        fc: Oe(A, "fc") ?? "",
        dataObjectId: p.id
      });
    }
    return b;
  }
  async function u(p) {
    const h = await e.table("Private").toArray(), N = await e.table("DOS").toArray(), b = await e.table("DAS").toArray(), C = await e.table("SubscriberLNode").toArray();
    return Promise.all(
      p.map(async (A) => {
        const I = h.find(
          (re) => re.parent?.id === A.id && re.parent?.tagName === "LNode" && Oe(re, "type") === "eIEC61850-6-100"
        );
        if (!I || !I.children)
          return { ...A, dataObjectSpecifications: [] };
        const G = [];
        for (const re of I.children) {
          if (re.tagName !== "DOS") continue;
          const F = N.find((pe) => pe.id === re.id);
          if (!F) continue;
          const U = [];
          if (F.children)
            for (const pe of F.children) {
              if (pe.tagName !== "DAS") continue;
              const Se = b.find((_e) => _e.id === pe.id);
              if (!Se) continue;
              let le;
              if (Se.children) {
                const _e = Se.children.find((Ke) => Ke.tagName === "SubscriberLNode");
                if (_e) {
                  const Ke = C.find((De) => De.id === _e.id);
                  Ke && (le = {
                    id: Ke.id,
                    inputName: Oe(Ke, "inputName") ?? "",
                    service: zl(Ke, "service"),
                    pLN: Oe(Ke, "pLN") ?? ""
                  });
                }
              }
              U.push({
                id: Se.id,
                name: Oe(Se, "name") ?? "",
                desc: Oe(Se, "desc") ?? "",
                dataObjectSpecificationId: F.id,
                subscriberLNode: le
              });
            }
          G.push({
            id: F.id,
            name: Oe(F, "name") ?? "",
            desc: Oe(F, "desc") ?? "",
            dataAttributeSpecifications: U,
            lNodeId: A.id
          });
        }
        return { ...A, dataObjectSpecifications: G };
      })
    );
  }
  async function f() {
    return (await e.table("LNode").toArray()).map((h) => ({
      id: h.id,
      uuid: Oe(h, "uuid") ?? "",
      iedName: Oe(h, "iedName") ?? "",
      prefix: Oe(h, "prefix") ?? "",
      lnClass: Oe(h, "lnClass") ?? "",
      lnInst: Oe(h, "lnInst") ?? "",
      lnType: Oe(h, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function zl(e, t) {
  const o = e?.attributes?.find((a) => a.name === t)?.value;
  if (!o) return;
  switch (o.toUpperCase()) {
    case "GOOSE":
      return st.GOOSE;
    case "SMV":
      return st.SMV;
    case "REPORT":
      return st.REPORT;
    case "INTERNAL":
      return st.INTERNAL;
    case "WIRED":
      return st.WIRED;
    case "CONTROL":
      return st.CONTROL;
    default:
      return;
  }
}
async function Ho(e) {
  try {
    const t = new Ao(e);
    return await t.open(), t;
  } catch (t) {
    throw console.error("Error opening database:", t), t;
  }
}
function nd(e) {
  const t = Wl(e);
  return {
    findAllExistingConnections: o,
    findAllExistingControlledConnections: i
  };
  async function o() {
    const a = await e.table("SourceRef").toArray();
    if (!a.length) return [];
    const u = [];
    for (const f of a) {
      if (!f.attributes) continue;
      const p = Oe(f, "sourceLNodeUuid"), h = await e.table("LNode").toArray().then(
        (C) => C.find(
          (A) => A.attributes?.some(
            (I) => I.name === "uuid" && I.value === p
          )
        )?.id
      ) || null, N = await t.findParentRecordsWithinDepthAndGivenTagName(
        f,
        3,
        ["LNode"]
      );
      if (N.length != 1) {
        const C = {
          msg: "LNode record not found for SourceRef id",
          id: f.id
        };
        throw console.error(C), new Error(JSON.stringify(C));
      }
      const b = {
        id: f.id,
        sourceLNodeId: h,
        destinationLNodeId: N[0].id,
        sourceDataObject: Oe(f, "sourceDoName") || "",
        sourceDataAttribute: Oe(f, "sourceDaName") || "",
        dataflowType: zl(f, "service"),
        inputInstance: Oe(f, "inputInst") || "",
        input: Oe(f, "input") || "",
        preferredLNode: Oe(f, "pLN") || "",
        preferredDataObject: Oe(f, "pDO") || "",
        preferredDataAttribute: Oe(f, "pDA") || "",
        processResource: Oe(f, "resourceName") || ""
      };
      u.push(b);
    }
    return u;
  }
  async function i() {
    const a = await e.table("ControlRef").toArray();
    if (!a.length) return [];
    const u = [];
    for (const f of a) {
      if (!f.attributes) continue;
      const p = Oe(f, "controlledLNodeUuid"), h = Oe(f, "controlledDoName"), N = await e.table("LNode").toArray().then(
        (A) => A.find(
          (I) => I.attributes?.some(
            (G) => G.name === "uuid" && G.value === p
          )
        )?.id
      ) || null, b = await t.findParentRecordsWithinDepthAndGivenTagName(
        f,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (b.length != 1) {
        const A = {
          msg: "LNode record not found for ControlRef id",
          id: f.id
        };
        throw console.error(A), new Error(JSON.stringify(A));
      }
      const C = {
        controllerLNodeId: b[0].id,
        controlledLNodeId: N,
        controlledDataObject: h || "",
        dataflowType: st.CONTROL,
        outputInstance: Oe(f, "outputInst") || "",
        outputName: Oe(f, "output") || ""
      };
      u.push(C);
    }
    return u;
  }
}
function ur(e) {
  return `${e.prefix} ${e.lnClass} ${e.lnInst}`;
}
const rd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, od = { class: "col-start-1 col-span-1 self-center justify-self-end" }, id = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, sd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, ad = ["data-testid"], ld = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, ud = { class: "col-start-5 col-span-1 self-center justify-self-start" }, cd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, fd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, dd = /* @__PURE__ */ Mt({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(e) {
    const t = e, o = Ot(() => [...t.connections].sort((i, a) => i.dataflowType < a.dataflowType ? -1 : i.dataflowType > a.dataflowType ? 1 : 0));
    return (i, a) => (de(!0), be(Le, null, Tt(o.value, (u, f) => (de(), be("div", rd, [
      k("div", od, [
        k("span", id, Ie(u.sourceDataObject), 1),
        k("span", sd, Ie(u.sourceDataAttribute), 1)
      ]),
      a[0] || (a[0] = k("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      k("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-line-${f}`
      }, null, 8, ad),
      a[1] || (a[1] = k("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        k("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      k("div", ld, Ie(u.dataflowType), 1),
      a[2] || (a[2] = k("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      k("div", ud, [
        k("span", cd, Ie(u.input), 1),
        k("span", fd, Ie(u.inputInstance), 1)
      ])
    ]))), 256));
  }
});
var Do = /* @__PURE__ */ ((e) => (e.Connection = "connection", e.Placeholder = "placeholder", e))(Do || {});
const Gl = /* @__PURE__ */ Gf("dataflow/sidebar", () => {
  const e = Qe(null);
  function t(o, i) {
    e.value = {
      type: o,
      element: i
    };
  }
  return {
    // state
    activeElement: e,
    // actions
    setActiveElement: t
  };
}), pd = ["onClick"], hd = ["data-testid"], md = {
  height: "12",
  width: "8",
  class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
  xmlns: "http://www.w3.org/2000/svg"
}, yd = ["onClick"], vd = { class: "col-start-5 col-span-1 self-center justify-self-start" }, gd = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, bd = /* @__PURE__ */ Mt({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(e) {
    const t = Gl();
    function o(a) {
      t.setActiveElement(Do.Placeholder, a);
    }
    function i(a) {
      return t.activeElement?.type === Do.Placeholder && t.activeElement?.element?.id === a.id;
    }
    return (a, u) => (de(!0), be(Le, null, Tt(a.destinationPlaceHolderPorts, (f, p) => (de(), be("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px] cursor-pointer",
      key: `destination-placeholder-port-${p}`
    }, [
      k("div", {
        class: "col-start-3 col-span-1 relative flex items-center row-start-1",
        onClick: (h) => o(f)
      }, [
        k("div", {
          class: kr(["h-[2px] bg-(--color-ocean-gray-100) absolute left-[80%] w-[20%]", {
            "bg-(--color-primary)": i(f)
          }]),
          "data-testid": `placeholder-line-${p}`
        }, null, 10, hd)
      ], 8, pd),
      (de(), be("svg", md, [
        k("polygon", {
          points: "0,0 8,6 0,12",
          style: Lo({
            fill: i(f) ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ])),
      k("div", {
        onClick: (h) => o(f),
        class: kr(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]", {
          "bg-(--color-primary)": i(f)
        }])
      }, null, 10, yd),
      k("div", vd, [
        k("span", gd, Ie(f.input), 1)
      ])
    ]))), 128));
  }
});
function vs(e) {
  const t = Wl(e);
  return {
    createControlledConnection: i,
    createConnection: o,
    createDestinationPlaceholder: a
  };
  async function o(u, f, p) {
    const h = await ja(e, t, p);
    await wd(t, f, h, u);
  }
  async function i(u, f, p) {
    const h = await _d(e, t, f), N = Sd(
      u,
      p
    ), b = await xd(
      t,
      N,
      h.namespace
    );
    await t.ensureRelationship(h, b);
    const C = await gs(e, t, p), A = {
      name: u.controlledSignal,
      desc: ""
    }, I = await Od(
      t,
      A,
      h.namespace
      //TODO: update with SDK integration. Private has no namespace, so we get it from here.
    );
    await t.ensureRelationship(C[0], I);
  }
  async function a(u, f) {
    const p = await ja(e, t, f), h = await wo(
      t,
      Cd(u),
      p.namespace
    );
    await t.ensureRelationship(p, h);
  }
}
async function ja(e, t, o) {
  const i = await gs(e, t, o), a = await t.findChildRecordsByTagName(
    i[0],
    "LNodeInputs"
  );
  if (a.length != 1) {
    const u = {
      msg: `LNodeInputs element not found or more than one element found in LNode with uuid ${o.uuid}`
    };
    throw console.error(u), new Error(JSON.stringify(u));
  }
  return a[0];
}
async function _d(e, t, o) {
  const i = await gs(e, t, o), a = await t.findChildRecordsByTagName(
    i[0],
    "LNodeOutputs"
  );
  if (a.length != 1) {
    const u = {
      msg: `LNodeOutputs element not found or more than one element found in LNode with uuid ${o.uuid}`
    };
    throw console.error(u), new Error(JSON.stringify(u));
  }
  return a[0];
}
async function gs(e, t, o) {
  const i = await e.table("LNode").get({ id: o.id });
  if (!i || !i.children || i.children.length == 0) {
    const f = {
      msg: `LNode element with uuid ${o.uuid} not found or empty`
    };
    throw console.error(f), new Error(JSON.stringify(f));
  }
  const a = await t.findChildRecordsByTagName(i, "Private");
  if (!a.filter((f) => ed(f, "type")?.value === "eIEC61850-6-100").at(0)) {
    const f = {
      msg: `Private element of type 'eIEC61850-6-100' not found in LNode with uuid ${o.uuid}`
    };
    throw console.error(f), new Error(JSON.stringify(f));
  }
  return a;
}
async function wd(e, t, o, i) {
  const a = await wo(
    e,
    Ii(i, t),
    o.namespace
  );
  if (await e.ensureRelationship(o, a), i.includeQuality) {
    let u = structuredClone(Ae(i));
    u.attribute = "q";
    const f = await wo(
      e,
      Ii(u, t),
      o.namespace
    );
    await e.ensureRelationship(o, f);
  }
  if (i.includeTimestamp) {
    let u = structuredClone(Ae(i));
    u.attribute = "t";
    const f = await wo(
      e,
      Ii(u, t),
      o.namespace
    );
    await e.ensureRelationship(o, f);
  }
}
async function wo(e, t, o) {
  const i = {
    tagName: "SourceRef",
    namespace: o,
    attributes: [
      {
        name: "pLN",
        value: t.pLN
      },
      {
        name: "pDO",
        value: t.pDO
      },
      {
        name: "pDA",
        value: t.pDA
      },
      {
        name: "input",
        value: t.inputName
      },
      {
        name: "inputInst",
        value: t.inputInstance
      },
      {
        name: "service",
        value: t.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: t.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: t.sourceDoName
      },
      {
        name: "sourceDaName",
        value: t.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: t.resourceName
      },
      {
        name: "source",
        value: t.source
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(i);
}
async function xd(e, t, o) {
  const i = {
    tagName: "ControlRef",
    namespace: o,
    attributes: [
      {
        name: "pDO",
        value: t.pDO
      },
      {
        name: "pLN",
        value: t.pLN
      },
      {
        name: "controlled",
        value: t.controlled
      },
      {
        name: "output",
        value: t.output
      },
      {
        name: "outputInst",
        value: t.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: t.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: t.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(i);
}
function Ii(e, t) {
  return {
    dataflowType: e.type,
    inputName: e.inputName,
    inputInstance: e.inputInstance,
    sourceLNodeUuid: t.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    source: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: e.signal,
    sourceDaName: e.attribute,
    pLN: t.lnClass,
    pDO: e.signal,
    pDA: e.attribute
  };
}
function Sd(e, t) {
  return {
    pDO: "",
    pLN: "",
    controlled: "",
    //TODO: see "path"-rule (Standart: 6.2.4 ControlRef)
    output: e.outputName,
    outputInst: e.outputInstance,
    controlledLNodeUuid: t.uuid,
    controlledDoName: e.controlledSignal
  };
}
function Cd(e) {
  return {
    dataflowType: e.dataflowType,
    inputName: e.inputName,
    inputInstance: "",
    sourceLNodeUuid: "",
    resourceName: e.processResource,
    source: "",
    sourceDoName: "",
    sourceDaName: "",
    pLN: e.preferredLNode,
    pDO: e.preferredDataObject,
    pDA: e.preferredDataAttribute
  };
}
async function Od(e, t, o) {
  const i = {
    tagName: "DOS",
    namespace: o,
    attributes: [
      {
        name: "name",
        value: t.name
      },
      {
        name: "desc",
        value: t.desc
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(i);
}
const Nd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Ed = ["open"], Td = { class: "modal-box" }, Pd = { class: "grid grid-cols-2 gap-4 mt-4" }, Ad = { class: "grid grid-cols-2 gap-4 mt-4" }, Rd = ["value", "disabled"], Dd = { class: "grid grid-cols-2 gap-4 mt-4" }, kd = ["value"], Id = { class: "grid grid-cols-2 gap-4 mt-4" }, jd = ["value"], Ld = { class: "grid grid-cols-2 gap-4 mt-4" }, Kd = ["value"], Md = { class: "grid grid-cols-2 gap-4 mt-4" }, Fd = /* @__PURE__ */ Mt({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["destinationPlaceholderCreated"],
  setup(e, { emit: t }) {
    const o = e, i = t, a = Qe(
      h()
    ), u = Qe(!1), f = Ot(() => {
      const re = o.lnodeTypes.find(
        (F) => F.lnClass === a.value.preferredLNode
      );
      return re ? a.value.dataflowType ? re.dataObjects.filter(
        (F) => F.dataAttributes.some(
          (U) => Ro[a.value.dataflowType].includes(U.fc)
        )
      ).map((F) => F.name) : re.dataObjects.map((F) => F.name) : [];
    }), p = Ot(() => {
      const re = o.lnodeTypes.find(
        (U) => U.lnClass === a.value.preferredLNode
      );
      if (!re) return [];
      const F = re.dataObjects.find(
        (U) => U.name === a.value.preferredDataObject
      );
      return F ? a.value.dataflowType ? F.dataAttributes.filter(
        (U) => Ro[a.value.dataflowType].includes(U.fc)
      ).map((U) => U.name) : F.dataAttributes.map((U) => U.name) : [];
    });
    function h() {
      return {
        dataflowType: null,
        inputName: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    function N() {
      u.value = !0;
    }
    function b() {
      I(), u.value = !1;
    }
    async function C() {
      try {
        if (!A(a.value))
          return;
        const re = localStorage.getItem("currentActiveFileDatabaseName");
        if (!re)
          throw new Error("no active file");
        const F = await Ho(re);
        await vs(F).createDestinationPlaceholder(
          a.value,
          o.destinationLNode
        ), F.close(), i("destinationPlaceholderCreated"), b();
      } catch (re) {
        console.error("Error creating destination placeholder port:", re), alert(`Error creating placeholder: ${re instanceof Error ? re.message : "Unknown error"}`);
      }
    }
    function A(re) {
      return re.inputName ? !0 : (alert("Please enter an input name."), !1);
    }
    function I() {
      a.value = h();
    }
    function G(re) {
      for (const F of re)
        a.value[F] = "";
    }
    return (re, F) => (de(), be("div", Nd, [
      k("button", {
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center",
        onClick: N,
        "aria-label": "Add destination placeholder"
      }, F[9] || (F[9] = [
        k("svg", {
          width: "16px",
          height: "16px",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          k("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          k("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      k("dialog", {
        class: "modal",
        open: u.value
      }, [
        k("div", Td, [
          F[21] || (F[21] = k("h3", { class: "text-lg font-bold" }, "Create Placeholder - Receive data from", -1)),
          k("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: b,
            "aria-label": "Close destination placeholder creation"
          }, F[10] || (F[10] = [
            k("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              k("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          k("div", Pd, [
            F[11] || (F[11] = k("label", {
              for: "input-name-input",
              class: "col-start-1 self-center"
            }, "Input", -1)),
            ot(k("input", {
              id: "input-name-input",
              type: "text",
              placeholder: "Input Name",
              class: "input col-start-2",
              "onUpdate:modelValue": F[0] || (F[0] = (U) => a.value.inputName = U)
            }, null, 512), [
              [ar, a.value.inputName]
            ])
          ]),
          k("div", Ad, [
            F[13] || (F[13] = k("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            ot(k("select", {
              id: "dataflow-type-select",
              class: "select col-start-2",
              "onUpdate:modelValue": F[1] || (F[1] = (U) => a.value.dataflowType = U),
              onChange: F[2] || (F[2] = (U) => G(["preferredDataObject"]))
            }, [
              (de(!0), be(Le, null, Tt(Object.values(He(st)), (U) => (de(), be("option", {
                key: U,
                value: U,
                disabled: U === He(st).CONTROL
              }, Ie(U), 9, Rd))), 128)),
              F[12] || (F[12] = k("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [xn, a.value.dataflowType]
            ])
          ]),
          k("div", Dd, [
            F[15] || (F[15] = k("label", {
              for: "preferred-lnode-select",
              class: "col-start-1 self-center"
            }, "Preferred LNode", -1)),
            ot(k("select", {
              id: "preferred-lnode-select",
              class: "select col-start-2",
              "onUpdate:modelValue": F[3] || (F[3] = (U) => a.value.preferredLNode = U),
              onChange: F[4] || (F[4] = (U) => G(["preferredDataObject"]))
            }, [
              (de(!0), be(Le, null, Tt(re.lnodeTypes, (U) => (de(), be("option", {
                key: U.lnClass,
                value: U.lnClass
              }, Ie(U.lnClass), 9, kd))), 128)),
              F[14] || (F[14] = k("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 544), [
              [xn, a.value.preferredLNode]
            ])
          ]),
          k("div", Id, [
            F[17] || (F[17] = k("label", {
              for: "data-object-select",
              class: "col-start-1 self-center"
            }, "Preferred Data Object", -1)),
            ot(k("select", {
              id: "data-object-select",
              class: "select col-start-2",
              "onUpdate:modelValue": F[5] || (F[5] = (U) => a.value.preferredDataObject = U),
              onChange: F[6] || (F[6] = (U) => G(["preferredDataAttribute"]))
            }, [
              (de(!0), be(Le, null, Tt(f.value, (U) => (de(), be("option", {
                key: U,
                value: U
              }, Ie(U), 9, jd))), 128)),
              F[16] || (F[16] = k("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 544), [
              [xn, a.value.preferredDataObject]
            ])
          ]),
          k("div", Ld, [
            F[19] || (F[19] = k("label", {
              for: "data-attribute-select",
              class: "col-start-1 self-center"
            }, "Preferred Data Attribute", -1)),
            ot(k("select", {
              id: "data-attribute-select",
              class: "select col-start-2",
              "onUpdate:modelValue": F[7] || (F[7] = (U) => a.value.preferredDataAttribute = U)
            }, [
              (de(!0), be(Le, null, Tt(p.value, (U) => (de(), be("option", {
                key: U,
                value: U
              }, Ie(U), 9, Kd))), 128)),
              F[18] || (F[18] = k("option", {
                key: "empty",
                value: ""
              }, "-", -1))
            ], 512), [
              [xn, a.value.preferredDataAttribute]
            ])
          ]),
          k("div", Md, [
            F[20] || (F[20] = k("label", {
              for: "process-resource-input",
              class: "col-start-1 self-center"
            }, "Process Resource", -1)),
            ot(k("input", {
              id: "process-resource-input",
              type: "text",
              placeholder: "Process Resource",
              class: "input col-start-2",
              "onUpdate:modelValue": F[8] || (F[8] = (U) => a.value.processResource = U)
            }, null, 512), [
              [ar, a.value.processResource]
            ])
          ]),
          k("div", { class: "modal-action" }, [
            k("button", {
              class: "btn bg-(--color-primary) border-none text-white",
              onClick: C
            }, " Save ")
          ])
        ])
      ], 8, Ed)
    ]));
  }
}), $d = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Bd = { class: "col-start-1 col-span-1 self-center justify-self-end" }, qd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Ud = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Vd = ["data-testid"], Hd = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Wd = { class: "col-start-5 col-span-1 self-center justify-self-start" }, zd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Gd = /* @__PURE__ */ Mt({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(e) {
    return (t, o) => (de(!0), be(Le, null, Tt(t.controlledConnections, (i, a) => (de(), be("div", $d, [
      k("div", Bd, [
        k("span", qd, Ie(i.outputName), 1),
        k("span", Ud, Ie(i.outputInstance), 1)
      ]),
      o[0] || (o[0] = k("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      k("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-controlled-connection-line-${a}`
      }, null, 8, Vd),
      o[1] || (o[1] = k("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        k("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      k("div", Hd, Ie(i.dataflowType), 1),
      o[2] || (o[2] = k("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      k("div", Wd, [
        k("span", zd, Ie(i.controlledDataObject), 1)
      ])
    ]))), 256));
  }
}), Yd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, Qd = ["value"], Jd = ["value"], Xd = ["value"], Zd = ["value"], ep = { class: "col-span-full row-start-2" }, tp = /* @__PURE__ */ Mt({
  __name: "dataflow-visualisation",
  props: {
    lnodes: {},
    connections: {},
    lnodeTypes: {},
    controlledConnections: {}
  },
  emits: ["sourceLNodeChange", "destinationLNodeChange", "destinationPlaceholderCreated"],
  setup(e, { emit: t }) {
    const o = t, i = e;
    rn(
      () => i.lnodes,
      () => {
        a.value = void 0, u.value = void 0;
      }
    );
    const a = Qe(), u = Qe(), f = Qe(), p = Qe(), h = Ot(
      () => i.lnodes.filter((F) => F.id !== u.value)
    ), N = Ot(
      () => i.lnodes.filter((F) => F.id !== a.value)
    ), b = Ot(() => !a.value || !u.value ? [] : i.connections.filter(
      (F) => F.sourceLNodeId === a.value && F.destinationLNodeId === u.value
    )), C = Ot(() => !a.value || !u.value ? [] : i.controlledConnections.filter(
      (F) => F.controllerLNodeId === a.value && F.controlledLNodeId === u.value
    )), A = Ot(() => u.value ? i.connections.filter(
      (F) => F.destinationLNodeId === u.value && !F.sourceLNodeId
    ) : []);
    function I(F) {
      return i.lnodes.find((U) => U.id === F) ?? void 0;
    }
    function G(F) {
      a.value = F, f.value = I(F), o("sourceLNodeChange", F);
    }
    function re(F) {
      u.value = F, p.value = I(F), o("destinationLNodeChange", F);
    }
    return (F, U) => (de(), be("div", Yd, [
      U[6] || (U[6] = k("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      k("select", {
        value: a.value ?? "",
        onChange: U[0] || (U[0] = (pe) => G(pe.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        U[3] || (U[3] = Kl(" > ")),
        U[4] || (U[4] = k("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (de(!0), be(Le, null, Tt(h.value, (pe) => (de(), be("option", {
          key: pe.id,
          value: pe.id
        }, Ie(He(ur)(pe)), 9, Jd))), 128))
      ], 40, Qd),
      U[7] || (U[7] = k("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      k("select", {
        value: u.value ?? "",
        onChange: U[1] || (U[1] = (pe) => re(pe.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        U[5] || (U[5] = k("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (de(!0), be(Le, null, Tt(N.value, (pe) => (de(), be("option", {
          key: pe.id,
          value: pe.id
        }, Ie(He(ur)(pe)), 9, Zd))), 128))
      ], 40, Xd),
      k("div", ep, [
        b.value.length > 0 ? (de(), tn(dd, {
          key: 0,
          connections: b.value
        }, null, 8, ["connections"])) : nn("", !0),
        C.value.length > 0 ? (de(), tn(Gd, {
          key: 1,
          controlledConnections: C.value
        }, null, 8, ["controlledConnections"])) : nn("", !0),
        A.value.length > 0 ? (de(), tn(bd, {
          key: 2,
          destinationPlaceHolderPorts: A.value
        }, null, 8, ["destinationPlaceHolderPorts"])) : nn("", !0)
      ]),
      p.value ? (de(), tn(Fd, {
        key: 0,
        destinationLNode: p.value,
        class: "col-span-full row-start-3",
        lnodeTypes: F.lnodeTypes,
        onDestinationPlaceholderCreated: U[2] || (U[2] = (pe) => o("destinationPlaceholderCreated"))
      }, null, 8, ["destinationLNode", "lnodeTypes"])) : nn("", !0)
    ]));
  }
}), np = { class: "grid grid-cols-2 gap-4 mt-4" }, rp = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, op = ["value"], ip = { class: "grid grid-cols-2 gap-4 mt-4" }, sp = ["value"], ap = { class: "grid grid-cols-2 gap-4 mt-4" }, lp = ["value"], up = { class: "grid grid-cols-2 gap-4 mt-4" }, cp = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, fp = ["value"], dp = { class: "grid grid-cols-2 gap-4 mt-4" }, pp = { class: "grid grid-cols-2 gap-4 mt-4" }, hp = { class: "mt-4" }, mp = { class: "mt-4" }, yp = /* @__PURE__ */ Mt({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const o = e, i = t, a = Qe(p());
    Rl(
      () => a.value.inputName = a.value.signal
    ), rn(
      () => a.value.inputName,
      () => {
        a.value.inputInstance = "1";
      }
    ), rn(
      () => o.dataflowType,
      (A) => {
        switch (C(), a.value.type = A, A) {
          case st.GOOSE:
          case st.SMV:
            a.value.includeQuality = !0, a.value.includeTimestamp = !1;
            break;
          case st.REPORT:
            a.value.includeQuality = !0, a.value.includeTimestamp = !0;
            break;
          default:
            a.value.includeQuality = !1, a.value.includeTimestamp = !1;
        }
      }
    );
    const u = Ot(() => !o.dataflowType || !o.sourceLNode ? [] : o.lnodeTypes.find((A) => A.typeId === o.sourceLNode.lnType)?.dataObjects.filter(
      (A) => A.dataAttributes.some(
        (I) => Ro[o.dataflowType]?.includes(I.fc)
      )
    ).map((A) => A.name) || []), f = Ot(() => !o.dataflowType || !o.sourceLNode ? [] : o.lnodeTypes.find((A) => A.typeId === o.sourceLNode.lnType)?.dataObjects.find((A) => A.name === a.value.signal)?.dataAttributes.filter(
      (A) => Ro[o.dataflowType]?.includes(A.fc)
    ).filter((A) => A.name !== "t" && A.name !== "q").map((A) => A.name) || []);
    function p() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function h(A) {
      for (const I of A)
        a.value[I] = "";
    }
    async function N() {
      try {
        if (!b(a.value))
          return;
        const A = localStorage.getItem("currentActiveFileDatabaseName");
        if (!A)
          throw new Error("no active file");
        const I = await Ho(A);
        await vs(I).createConnection(
          a.value,
          o.sourceLNode,
          o.destinationLNode
        ), I.close(), i("connectionCreated"), C();
      } catch (A) {
        console.error("Error creating dataflow:", A), alert(`Error creating dataflow: ${A instanceof Error ? A.message : "Unknown error"}`);
      }
    }
    function b(A) {
      return A.type ? A.signal ? A.attribute ? A.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function C() {
      a.value = p();
    }
    return (A, I) => (de(), be(Le, null, [
      I[17] || (I[17] = k("hr", { class: "solid mt-4" }, null, -1)),
      k("div", np, [
        I[7] || (I[7] = k("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Source", -1)),
        k("select", rp, [
          k("option", {
            value: o.sourceLNode.id
          }, Ie(He(ur)(A.sourceLNode)), 9, op)
        ])
      ]),
      k("div", ip, [
        I[9] || (I[9] = k("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Signal (DO)", -1)),
        ot(k("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": I[0] || (I[0] = (G) => a.value.signal = G),
          onChange: I[1] || (I[1] = (G) => h(["attribute"]))
        }, [
          (de(!0), be(Le, null, Tt(u.value, (G) => (de(), be("option", {
            key: G,
            value: G
          }, Ie(G), 9, sp))), 128)),
          I[8] || (I[8] = k("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 544), [
          [xn, a.value.signal]
        ])
      ]),
      k("div", ap, [
        I[11] || (I[11] = k("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Attribute (DA)", -1)),
        ot(k("select", {
          id: "data-attribute-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": I[2] || (I[2] = (G) => a.value.attribute = G)
        }, [
          (de(!0), be(Le, null, Tt(f.value, (G) => (de(), be("option", {
            key: G,
            value: G
          }, Ie(G), 9, lp))), 128)),
          I[10] || (I[10] = k("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [xn, a.value.attribute]
        ])
      ]),
      I[18] || (I[18] = k("hr", { class: "solid mt-4" }, null, -1)),
      k("div", up, [
        I[12] || (I[12] = k("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Destination", -1)),
        k("select", cp, [
          k("option", {
            value: o.destinationLNode.id
          }, Ie(He(ur)(A.destinationLNode)), 9, fp)
        ])
      ]),
      k("div", dp, [
        I[13] || (I[13] = k("label", {
          for: "input-name-input",
          class: "col-start-1 self-center"
        }, "Input Name", -1)),
        ot(k("input", {
          id: "input-name-input",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": I[3] || (I[3] = (G) => a.value.inputName = G)
        }, null, 512), [
          [ar, a.value.inputName]
        ])
      ]),
      k("div", pp, [
        I[14] || (I[14] = k("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        ot(k("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": I[4] || (I[4] = (G) => a.value.inputInstance = G)
        }, null, 512), [
          [ar, a.value.inputInstance]
        ])
      ]),
      I[19] || (I[19] = k("hr", { class: "solid mt-4" }, null, -1)),
      k("div", hp, [
        ot(k("input", {
          type: "checkbox",
          "onUpdate:modelValue": I[5] || (I[5] = (G) => a.value.includeQuality = G),
          class: "checkbox mr-2",
          id: "checkbox-include-quality"
        }, null, 512), [
          [Na, a.value.includeQuality]
        ]),
        I[15] || (I[15] = k("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
      ]),
      k("div", mp, [
        ot(k("input", {
          type: "checkbox",
          "onUpdate:modelValue": I[6] || (I[6] = (G) => a.value.includeTimestamp = G),
          class: "checkbox mr-2",
          id: "checkbox-include-timestamp"
        }, null, 512), [
          [Na, a.value.includeTimestamp]
        ]),
        I[16] || (I[16] = k("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
      ]),
      k("div", { class: "modal-action" }, [
        k("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: N,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), vp = { class: "grid grid-cols-2 gap-4 mt-4" }, gp = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, bp = ["value"], _p = { class: "grid grid-cols-2 gap-4 mt-4" }, wp = ["value"], xp = { class: "grid grid-cols-2 gap-4 mt-4" }, Sp = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Cp = ["value"], Op = { class: "grid grid-cols-2 gap-4 mt-4" }, Np = { class: "grid grid-cols-2 gap-4 mt-4" }, Ep = /* @__PURE__ */ Mt({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const o = e, i = t, a = Qe(
      f()
    );
    Rl(
      () => a.value.outputName = a.value.controlledSignal
    ), rn(
      () => a.value.outputName,
      () => {
        a.value.outputInstance = "1";
      }
    );
    const u = Ot(() => o.destinationLNode ? o.lnodeTypes.find((C) => C.typeId === o.destinationLNode.lnType)?.dataObjects.map((C) => C.name) || [] : []);
    function f() {
      return {
        type: st.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function p() {
      try {
        if (!h(a.value))
          return;
        const b = localStorage.getItem("currentActiveFileDatabaseName");
        if (!b)
          throw new Error("no active file");
        const C = await Ho(b);
        await vs(C).createControlledConnection(
          a.value,
          o.sourceLNode,
          o.destinationLNode
        ), C.close(), i("connectionCreated"), N();
      } catch (b) {
        console.error("Error creating controlled dataflow:", b), alert(`Error creating controlled dataflow: ${b instanceof Error ? b.message : "Unknown error"}`);
      }
    }
    function h(b) {
      return b.type ? b.outputName ? b.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function N() {
      a.value = f();
    }
    return (b, C) => (de(), be(Le, null, [
      C[9] || (C[9] = k("hr", { class: "solid mt-4" }, null, -1)),
      k("div", vp, [
        C[3] || (C[3] = k("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        k("select", gp, [
          k("option", {
            value: o.destinationLNode.id
          }, Ie(He(ur)(b.destinationLNode)), 9, bp)
        ])
      ]),
      k("div", _p, [
        C[5] || (C[5] = k("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        ot(k("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": C[0] || (C[0] = (A) => a.value.controlledSignal = A)
        }, [
          (de(!0), be(Le, null, Tt(u.value, (A) => (de(), be("option", {
            key: A,
            value: A
          }, Ie(A), 9, wp))), 128)),
          C[4] || (C[4] = k("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [xn, a.value.controlledSignal]
        ])
      ]),
      C[10] || (C[10] = k("hr", { class: "solid mt-4" }, null, -1)),
      k("div", xp, [
        C[6] || (C[6] = k("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        k("select", Sp, [
          k("option", {
            value: o.sourceLNode.id
          }, Ie(He(ur)(b.sourceLNode)), 9, Cp)
        ])
      ]),
      k("div", Op, [
        C[7] || (C[7] = k("label", {
          for: "output-name-input",
          class: "col-start-1 self-center"
        }, "Controller Output Name", -1)),
        ot(k("input", {
          id: "output-name-input",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": C[1] || (C[1] = (A) => a.value.outputName = A)
        }, null, 512), [
          [ar, a.value.outputName]
        ])
      ]),
      k("div", Np, [
        C[8] || (C[8] = k("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Ouput Instance", -1)),
        ot(k("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": C[2] || (C[2] = (A) => a.value.outputInstance = A)
        }, null, 512), [
          [ar, a.value.outputInstance]
        ])
      ]),
      C[11] || (C[11] = k("hr", { class: "solid mt-4" }, null, -1)),
      k("div", { class: "modal-action" }, [
        k("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: p,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), Tp = ["disabled"], Pp = ["open"], Ap = { class: "modal-box" }, Rp = { class: "grid grid-cols-2 gap-4 mt-4" }, Dp = ["value", "disabled"], kp = /* @__PURE__ */ Mt({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const o = e, i = t, a = Qe(!1), u = Qe(null), f = Ot(
      () => o.sourceLNode?.lnClass === "IHMI" || o.sourceLNode?.lnClass === "ITCI"
    );
    function p(C) {
      const A = C.target.value;
      u.value = A;
    }
    function h() {
      i("connectionCreated"), b();
    }
    function N() {
      a.value = !0;
    }
    function b() {
      a.value = !1, u.value = null;
    }
    return (C, A) => (de(), be(Le, null, [
      k("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: N,
        disabled: !o.sourceLNode || !o.destinationLNode,
        "aria-label": "Add connection"
      }, " + ", 8, Tp),
      o.sourceLNode && o.destinationLNode ? (de(), be("dialog", {
        key: 0,
        class: "modal",
        open: a.value
      }, [
        k("div", Ap, [
          A[4] || (A[4] = k("h3", { class: "text-lg font-bold" }, "Create Connection", -1)),
          k("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: b,
            "aria-label": "Close dataflow creation",
            "data-testId": "close-dataflow-creation"
          }, A[1] || (A[1] = [
            k("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              k("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          k("div", Rp, [
            A[3] || (A[3] = k("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            ot(k("select", {
              id: "dataflow-type-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": A[0] || (A[0] = (I) => u.value = I),
              onChange: p
            }, [
              (de(!0), be(Le, null, Tt(Object.values(He(st)), (I) => (de(), be("option", {
                key: I,
                value: I,
                disabled: I === He(st).CONTROL && !f.value
              }, Ie(I), 9, Dp))), 128)),
              A[2] || (A[2] = k("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [xn, u.value]
            ])
          ]),
          u.value !== He(st).CONTROL ? (de(), tn(yp, {
            key: 0,
            sourceLNode: o.sourceLNode,
            destinationLNode: o.destinationLNode,
            lnodeTypes: o.lnodeTypes,
            dataflowType: u.value,
            onConnectionCreated: h
          }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes", "dataflowType"])) : (de(), tn(Ep, {
            key: 1,
            sourceLNode: o.sourceLNode,
            destinationLNode: o.destinationLNode,
            lnodeTypes: o.lnodeTypes,
            dataflowType: u.value,
            onConnectionCreated: h
          }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes", "dataflowType"]))
        ])
      ], 8, Pp)) : nn("", !0)
    ], 64));
  }
}), Ip = { class: "flex flex-col items-center justify-center w-full" }, jp = /* @__PURE__ */ Mt({
  __name: "dataflow-view",
  props: {
    sdks: {}
  },
  setup(e) {
    const t = e, o = Qe(), i = Qe(), a = Qe([]), u = Qe([]), f = Qe([]), p = Qe([]);
    rn(
      () => t.sdks,
      () => {
        h(), N();
      },
      { immediate: !0 }
    );
    async function h() {
      t.sdks && (a.value = await t.sdks.lnodeSDK.findAllEnrichedLNodes(), u.value = await t.sdks.lnodeSDK.findAllLNodeTypes());
    }
    async function N() {
      t.sdks && (f.value = await t.sdks.connectionSDK.findAllExistingConnections(), p.value = await t.sdks.connectionSDK.findAllExistingControlledConnections());
    }
    function b(I) {
      o.value = A(I);
    }
    function C(I) {
      i.value = A(I);
    }
    function A(I) {
      return a.value.find((G) => G.id === I) ?? void 0;
    }
    return (I, G) => (de(), be("div", Ip, [
      xt(tp, {
        connections: f.value,
        controlledConnections: p.value,
        lnodes: a.value,
        lnodeTypes: u.value,
        onSourceLNodeChange: b,
        onDestinationLNodeChange: C,
        onDestinationPlaceholderCreated: N
      }, null, 8, ["connections", "controlledConnections", "lnodes", "lnodeTypes"]),
      xt(kp, {
        sourceLNode: o.value,
        destinationLNode: i.value,
        lnodeTypes: u.value,
        onConnectionCreated: N
      }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes"])
    ]));
  }
}), Yl = (e, t) => {
  const o = e.__vccOpts || e;
  for (const [i, a] of t)
    o[i] = a;
  return o;
}, Lp = {}, Kp = { class: "layout" }, Mp = { class: "main" }, Fp = { class: "sidebar" };
function $p(e, t) {
  return de(), be("div", Kp, [
    k("div", Mp, [
      na(e.$slots, "main", {}, void 0)
    ]),
    k("div", Fp, [
      na(e.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const Bp = /* @__PURE__ */ Yl(Lp, [["render", $p], ["__scopeId", "data-v-86088f9f"]]), qp = {
  name: "sidebar",
  class: "root"
}, Up = { class: "tabs tabs-box" }, Vp = { key: 0 }, Hp = { key: 0 }, Wp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, zp = { key: 1 }, Gp = /* @__PURE__ */ Mt({
  __name: "sidebar",
  setup(e) {
    const t = Qe("details"), o = Gl();
    return (i, a) => (de(), be("div", qp, [
      k("div", Up, [
        ot(k("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": a[0] || (a[0] = (u) => t.value = u),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [Ta, t.value]
        ]),
        ot(k("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": a[1] || (a[1] = (u) => t.value = u),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [Ta, t.value]
        ])
      ]),
      k("div", null, [
        t.value === "details" ? (de(), be("div", Vp, [
          He(o).activeElement?.type === He(Do).Placeholder ? (de(), be("div", Hp, [
            a[2] || (a[2] = k("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
            He(o).activeElement.element.dataflowType ? (de(), be("span", Wp, Ie(He(o).activeElement.element.dataflowType), 1)) : nn("", !0),
            k("p", null, "Input: " + Ie(He(o).activeElement.element.input), 1),
            k("p", null, "Preferred LNode: " + Ie(He(o).activeElement.element.preferredLNode || "-"), 1),
            k("p", null, "Preferred DO: " + Ie(He(o).activeElement.element.preferredDataObject || "-"), 1),
            k("p", null, "Preferred DA: " + Ie(He(o).activeElement.element.preferredDataAttribute || "-"), 1),
            k("p", null, "Process Resource: " + Ie(He(o).activeElement.element.processResource || "-"), 1)
          ])) : nn("", !0)
        ])) : nn("", !0),
        t.value === "advanced" ? (de(), be("div", zp)) : nn("", !0)
      ])
    ]));
  }
}), Yp = /* @__PURE__ */ Yl(Gp, [["__scopeId", "data-v-d560451c"]]), Qp = ["id"], Jp = { class: "p-10" }, Xp = /* @__PURE__ */ Mt({
  __name: "app",
  props: {
    api: {}
  },
  setup(e) {
    const t = "dataflow";
    let o = Qe();
    yl(() => {
      window.addEventListener("storage", i), a();
    }), fs(() => {
      window.removeEventListener("storage", i);
    });
    async function i(f) {
      if (f.key !== "currentActiveFileDatabaseName")
        return;
      const p = f.newValue;
      if (!p)
        throw new Error("incorrect active file name: " + p);
      await u(p);
    }
    async function a() {
      const f = localStorage.getItem("currentActiveFileDatabaseName");
      f && await u(f);
    }
    async function u(f) {
      o.value && o.value.db.close();
      const p = await Ho(f);
      if (!p) throw new Error("database is not initialized.");
      o.value = {
        db: p,
        lnodeSDK: td(p),
        connectionSDK: nd(p)
      };
    }
    return (f, p) => (de(), be("article", {
      id: He(t),
      style: { height: "100%" }
    }, [
      xt(Bp, null, {
        main: Fi(() => [
          k("div", Jp, [
            xt(jp, { sdks: He(o) }, null, 8, ["sdks"])
          ])
        ]),
        sidebar: Fi(() => [
          xt(Yp)
        ]),
        _: 1
      })
    ], 8, Qp));
  }
});
function ch(e, t) {
  if (!document.getElementById(e)) {
    console.error({ msg: "could not found root element", rootId: e });
    return;
  }
  const i = Ff(Xp, { api: t });
  return i.use(qf()), i.mount(`#${e}`), i.unmount;
}
export {
  ch as default
};
