(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.pointer-events-none{pointer-events:none}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-\\[1\\.5rem\\]{top:1.5rem}.right-\\[1\\.5rem\\]{right:1.5rem}.-z-1{z-index:-1}.z-1{z-index:1}.z-10{z-index:10}.-order-1{order:-1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-2{margin-left:calc(var(--spacing)*2)}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.inline-flex{display:inline-flex}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.min-h-\\[450px\\]{min-height:450px}.w-\\[20px\\]{width:20px}.w-full{width:100%}.max-w-max{max-width:max-content}.cursor-pointer{cursor:pointer}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-1{grid-template-rows:repeat(1,minmax(0,1fr))}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Zi(e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const r of e.split(",")) t[r] = 1;
  return (r) => r in t;
}
const Ke = {}, ir = [], Yt = () => {
}, $u = () => !1, jo = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // uppercase letter
(e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), es = (e) => e.startsWith("onUpdate:"), _t = Object.assign, ts = (e, t) => {
  const r = e.indexOf(t);
  r > -1 && e.splice(r, 1);
}, Ku = Object.prototype.hasOwnProperty, Me = (e, t) => Ku.call(e, t), he = Array.isArray, sr = (e) => Fr(e) === "[object Map]", fr = (e) => Fr(e) === "[object Set]", na = (e) => Fr(e) === "[object Date]", _e = (e) => typeof e == "function", Ze = (e) => typeof e == "string", Bt = (e) => typeof e == "symbol", Be = (e) => e !== null && typeof e == "object", Ha = (e) => (Be(e) || _e(e)) && _e(e.then) && _e(e.catch), Wa = Object.prototype.toString, Fr = (e) => Wa.call(e), Fu = (e) => Fr(e).slice(8, -1), za = (e) => Fr(e) === "[object Object]", ns = (e) => Ze(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Nr = /* @__PURE__ */ Zi(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Mo = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (r) => t[r] || (t[r] = e(r));
}, Bu = /-(\w)/g, Nn = Mo(
  (e) => e.replace(Bu, (t, r) => r ? r.toUpperCase() : "")
), qu = /\B([A-Z])/g, Hn = Mo(
  (e) => e.replace(qu, "-$1").toLowerCase()
), Ga = Mo((e) => e.charAt(0).toUpperCase() + e.slice(1)), Ni = Mo(
  (e) => e ? `on${Ga(e)}` : ""
), On = (e, t) => !Object.is(e, t), _o = (e, ...t) => {
  for (let r = 0; r < e.length; r++)
    e[r](...t);
}, $i = (e, t, r, i = !1) => {
  Object.defineProperty(e, t, {
    configurable: !0,
    enumerable: !1,
    writable: i,
    value: r
  });
}, No = (e) => {
  const t = parseFloat(e);
  return isNaN(t) ? e : t;
};
let ra;
const $o = () => ra || (ra = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function rs(e) {
  if (he(e)) {
    const t = {};
    for (let r = 0; r < e.length; r++) {
      const i = e[r], s = Ze(i) ? Wu(i) : rs(i);
      if (s)
        for (const u in s)
          t[u] = s[u];
    }
    return t;
  } else if (Ze(e) || Be(e))
    return e;
}
const Uu = /;(?![^(]*\))/g, Vu = /:([^]+)/, Hu = /\/\*[^]*?\*\//g;
function Wu(e) {
  const t = {};
  return e.replace(Hu, "").split(Uu).forEach((r) => {
    if (r) {
      const i = r.split(Vu);
      i.length > 1 && (t[i[0].trim()] = i[1].trim());
    }
  }), t;
}
function Un(e) {
  let t = "";
  if (Ze(e))
    t = e;
  else if (he(e))
    for (let r = 0; r < e.length; r++) {
      const i = Un(e[r]);
      i && (t += i + " ");
    }
  else if (Be(e))
    for (const r in e)
      e[r] && (t += r + " ");
  return t.trim();
}
const zu = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Gu = /* @__PURE__ */ Zi(zu);
function Ya(e) {
  return !!e || e === "";
}
function Yu(e, t) {
  if (e.length !== t.length) return !1;
  let r = !0;
  for (let i = 0; r && i < e.length; i++)
    r = Vn(e[i], t[i]);
  return r;
}
function Vn(e, t) {
  if (e === t) return !0;
  let r = na(e), i = na(t);
  if (r || i)
    return r && i ? e.getTime() === t.getTime() : !1;
  if (r = Bt(e), i = Bt(t), r || i)
    return e === t;
  if (r = he(e), i = he(t), r || i)
    return r && i ? Yu(e, t) : !1;
  if (r = Be(e), i = Be(t), r || i) {
    if (!r || !i)
      return !1;
    const s = Object.keys(e).length, u = Object.keys(t).length;
    if (s !== u)
      return !1;
    for (const c in e) {
      const d = e.hasOwnProperty(c), h = t.hasOwnProperty(c);
      if (d && !h || !d && h || !Vn(e[c], t[c]))
        return !1;
    }
  }
  return String(e) === String(t);
}
function os(e, t) {
  return e.findIndex((r) => Vn(r, t));
}
const Qa = (e) => !!(e && e.__v_isRef === !0), we = (e) => Ze(e) ? e : e == null ? "" : he(e) || Be(e) && (e.toString === Wa || !_e(e.toString)) ? Qa(e) ? we(e.value) : JSON.stringify(e, Ja, 2) : String(e), Ja = (e, t) => Qa(t) ? Ja(e, t.value) : sr(t) ? {
  [`Map(${t.size})`]: [...t.entries()].reduce(
    (r, [i, s], u) => (r[Ti(i, u) + " =>"] = s, r),
    {}
  )
} : fr(t) ? {
  [`Set(${t.size})`]: [...t.values()].map((r) => Ti(r))
} : Bt(t) ? Ti(t) : Be(t) && !he(t) && !za(t) ? String(t) : t, Ti = (e, t = "") => {
  var r;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Bt(e) ? `Symbol(${(r = e.description) != null ? r : t})` : e
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let vt;
class Xa {
  constructor(t = !1) {
    this.detached = t, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = vt, !t && vt && (this.index = (vt.scopes || (vt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let t, r;
      if (this.scopes)
        for (t = 0, r = this.scopes.length; t < r; t++)
          this.scopes[t].pause();
      for (t = 0, r = this.effects.length; t < r; t++)
        this.effects[t].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let t, r;
      if (this.scopes)
        for (t = 0, r = this.scopes.length; t < r; t++)
          this.scopes[t].resume();
      for (t = 0, r = this.effects.length; t < r; t++)
        this.effects[t].resume();
    }
  }
  run(t) {
    if (this._active) {
      const r = vt;
      try {
        return vt = this, t();
      } finally {
        vt = r;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = vt, vt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (vt = this.prevScope, this.prevScope = void 0);
  }
  stop(t) {
    if (this._active) {
      this._active = !1;
      let r, i;
      for (r = 0, i = this.effects.length; r < i; r++)
        this.effects[r].stop();
      for (this.effects.length = 0, r = 0, i = this.cleanups.length; r < i; r++)
        this.cleanups[r]();
      if (this.cleanups.length = 0, this.scopes) {
        for (r = 0, i = this.scopes.length; r < i; r++)
          this.scopes[r].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !t) {
        const s = this.parent.scopes.pop();
        s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Za(e) {
  return new Xa(e);
}
function el() {
  return vt;
}
function Qu(e, t = !1) {
  vt && vt.cleanups.push(e);
}
let Fe;
const Ei = /* @__PURE__ */ new WeakSet();
class tl {
  constructor(t) {
    this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, vt && vt.active && vt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ei.has(this) && (Ei.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || rl(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, oa(this), ol(this);
    const t = Fe, r = Ft;
    Fe = this, Ft = !0;
    try {
      return this.fn();
    } finally {
      il(this), Fe = t, Ft = r, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let t = this.deps; t; t = t.nextDep)
        as(t);
      this.deps = this.depsTail = void 0, oa(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ei.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Ki(this) && this.run();
  }
  get dirty() {
    return Ki(this);
  }
}
let nl = 0, Tr, Er;
function rl(e, t = !1) {
  if (e.flags |= 8, t) {
    e.next = Er, Er = e;
    return;
  }
  e.next = Tr, Tr = e;
}
function is() {
  nl++;
}
function ss() {
  if (--nl > 0)
    return;
  if (Er) {
    let t = Er;
    for (Er = void 0; t; ) {
      const r = t.next;
      t.next = void 0, t.flags &= -9, t = r;
    }
  }
  let e;
  for (; Tr; ) {
    let t = Tr;
    for (Tr = void 0; t; ) {
      const r = t.next;
      if (t.next = void 0, t.flags &= -9, t.flags & 1)
        try {
          t.trigger();
        } catch (i) {
          e || (e = i);
        }
      t = r;
    }
  }
  if (e) throw e;
}
function ol(e) {
  for (let t = e.deps; t; t = t.nextDep)
    t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t;
}
function il(e) {
  let t, r = e.depsTail, i = r;
  for (; i; ) {
    const s = i.prevDep;
    i.version === -1 ? (i === r && (r = s), as(i), Ju(i)) : t = i, i.dep.activeLink = i.prevActiveLink, i.prevActiveLink = void 0, i = s;
  }
  e.deps = t, e.depsTail = r;
}
function Ki(e) {
  for (let t = e.deps; t; t = t.nextDep)
    if (t.dep.version !== t.version || t.dep.computed && (sl(t.dep.computed) || t.dep.version !== t.version))
      return !0;
  return !!e._dirty;
}
function sl(e) {
  if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Lr) || (e.globalVersion = Lr, !e.isSSR && e.flags & 128 && (!e.deps && !e._dirty || !Ki(e))))
    return;
  e.flags |= 2;
  const t = e.dep, r = Fe, i = Ft;
  Fe = e, Ft = !0;
  try {
    ol(e);
    const s = e.fn(e._value);
    (t.version === 0 || On(s, e._value)) && (e.flags |= 128, e._value = s, t.version++);
  } catch (s) {
    throw t.version++, s;
  } finally {
    Fe = r, Ft = i, il(e), e.flags &= -3;
  }
}
function as(e, t = !1) {
  const { dep: r, prevSub: i, nextSub: s } = e;
  if (i && (i.nextSub = s, e.prevSub = void 0), s && (s.prevSub = i, e.nextSub = void 0), r.subs === e && (r.subs = i, !i && r.computed)) {
    r.computed.flags &= -5;
    for (let u = r.computed.deps; u; u = u.nextDep)
      as(u, !0);
  }
  !t && !--r.sc && r.map && r.map.delete(r.key);
}
function Ju(e) {
  const { prevDep: t, nextDep: r } = e;
  t && (t.nextDep = r, e.prevDep = void 0), r && (r.prevDep = t, e.nextDep = void 0);
}
let Ft = !0;
const al = [];
function ln() {
  al.push(Ft), Ft = !1;
}
function un() {
  const e = al.pop();
  Ft = e === void 0 ? !0 : e;
}
function oa(e) {
  const { cleanup: t } = e;
  if (e.cleanup = void 0, t) {
    const r = Fe;
    Fe = void 0;
    try {
      t();
    } finally {
      Fe = r;
    }
  }
}
let Lr = 0;
class Xu {
  constructor(t, r) {
    this.sub = t, this.dep = r, this.version = r.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ls {
  // TODO isolatedDeclarations "__v_skip"
  constructor(t) {
    this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(t) {
    if (!Fe || !Ft || Fe === this.computed)
      return;
    let r = this.activeLink;
    if (r === void 0 || r.sub !== Fe)
      r = this.activeLink = new Xu(Fe, this), Fe.deps ? (r.prevDep = Fe.depsTail, Fe.depsTail.nextDep = r, Fe.depsTail = r) : Fe.deps = Fe.depsTail = r, ll(r);
    else if (r.version === -1 && (r.version = this.version, r.nextDep)) {
      const i = r.nextDep;
      i.prevDep = r.prevDep, r.prevDep && (r.prevDep.nextDep = i), r.prevDep = Fe.depsTail, r.nextDep = void 0, Fe.depsTail.nextDep = r, Fe.depsTail = r, Fe.deps === r && (Fe.deps = i);
    }
    return r;
  }
  trigger(t) {
    this.version++, Lr++, this.notify(t);
  }
  notify(t) {
    is();
    try {
      for (let r = this.subs; r; r = r.prevSub)
        r.sub.notify() && r.sub.dep.notify();
    } finally {
      ss();
    }
  }
}
function ll(e) {
  if (e.dep.sc++, e.sub.flags & 4) {
    const t = e.dep.computed;
    if (t && !e.dep.subs) {
      t.flags |= 20;
      for (let i = t.deps; i; i = i.nextDep)
        ll(i);
    }
    const r = e.dep.subs;
    r !== e && (e.prevSub = r, r && (r.nextSub = e)), e.dep.subs = e;
  }
}
const To = /* @__PURE__ */ new WeakMap(), Bn = Symbol(
  ""
), Fi = Symbol(
  ""
), jr = Symbol(
  ""
);
function bt(e, t, r) {
  if (Ft && Fe) {
    let i = To.get(e);
    i || To.set(e, i = /* @__PURE__ */ new Map());
    let s = i.get(r);
    s || (i.set(r, s = new ls()), s.map = i, s.key = r), s.track();
  }
}
function nn(e, t, r, i, s, u) {
  const c = To.get(e);
  if (!c) {
    Lr++;
    return;
  }
  const d = (h) => {
    h && h.trigger();
  };
  if (is(), t === "clear")
    c.forEach(d);
  else {
    const h = he(e), C = h && ns(r);
    if (h && r === "length") {
      const y = Number(i);
      c.forEach((b, x) => {
        (x === "length" || x === jr || !Bt(x) && x >= y) && d(b);
      });
    } else
      switch ((r !== void 0 || c.has(void 0)) && d(c.get(r)), C && d(c.get(jr)), t) {
        case "add":
          h ? C && d(c.get("length")) : (d(c.get(Bn)), sr(e) && d(c.get(Fi)));
          break;
        case "delete":
          h || (d(c.get(Bn)), sr(e) && d(c.get(Fi)));
          break;
        case "set":
          sr(e) && d(c.get(Bn));
          break;
      }
  }
  ss();
}
function Zu(e, t) {
  const r = To.get(e);
  return r && r.get(t);
}
function nr(e) {
  const t = Ae(e);
  return t === e ? t : (bt(t, "iterate", jr), It(e) ? t : t.map(ct));
}
function Ko(e) {
  return bt(e = Ae(e), "iterate", jr), e;
}
const ec = {
  __proto__: null,
  [Symbol.iterator]() {
    return Ai(this, Symbol.iterator, ct);
  },
  concat(...e) {
    return nr(this).concat(
      ...e.map((t) => he(t) ? nr(t) : t)
    );
  },
  entries() {
    return Ai(this, "entries", (e) => (e[1] = ct(e[1]), e));
  },
  every(e, t) {
    return en(this, "every", e, t, void 0, arguments);
  },
  filter(e, t) {
    return en(this, "filter", e, t, (r) => r.map(ct), arguments);
  },
  find(e, t) {
    return en(this, "find", e, t, ct, arguments);
  },
  findIndex(e, t) {
    return en(this, "findIndex", e, t, void 0, arguments);
  },
  findLast(e, t) {
    return en(this, "findLast", e, t, ct, arguments);
  },
  findLastIndex(e, t) {
    return en(this, "findLastIndex", e, t, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(e, t) {
    return en(this, "forEach", e, t, void 0, arguments);
  },
  includes(...e) {
    return Pi(this, "includes", e);
  },
  indexOf(...e) {
    return Pi(this, "indexOf", e);
  },
  join(e) {
    return nr(this).join(e);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...e) {
    return Pi(this, "lastIndexOf", e);
  },
  map(e, t) {
    return en(this, "map", e, t, void 0, arguments);
  },
  pop() {
    return Cr(this, "pop");
  },
  push(...e) {
    return Cr(this, "push", e);
  },
  reduce(e, ...t) {
    return ia(this, "reduce", e, t);
  },
  reduceRight(e, ...t) {
    return ia(this, "reduceRight", e, t);
  },
  shift() {
    return Cr(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(e, t) {
    return en(this, "some", e, t, void 0, arguments);
  },
  splice(...e) {
    return Cr(this, "splice", e);
  },
  toReversed() {
    return nr(this).toReversed();
  },
  toSorted(e) {
    return nr(this).toSorted(e);
  },
  toSpliced(...e) {
    return nr(this).toSpliced(...e);
  },
  unshift(...e) {
    return Cr(this, "unshift", e);
  },
  values() {
    return Ai(this, "values", ct);
  }
};
function Ai(e, t, r) {
  const i = Ko(e), s = i[t]();
  return i !== e && !It(e) && (s._next = s.next, s.next = () => {
    const u = s._next();
    return u.value && (u.value = r(u.value)), u;
  }), s;
}
const tc = Array.prototype;
function en(e, t, r, i, s, u) {
  const c = Ko(e), d = c !== e && !It(e), h = c[t];
  if (h !== tc[t]) {
    const b = h.apply(e, u);
    return d ? ct(b) : b;
  }
  let C = r;
  c !== e && (d ? C = function(b, x) {
    return r.call(this, ct(b), x, e);
  } : r.length > 2 && (C = function(b, x) {
    return r.call(this, b, x, e);
  }));
  const y = h.call(c, C, i);
  return d && s ? s(y) : y;
}
function ia(e, t, r, i) {
  const s = Ko(e);
  let u = r;
  return s !== e && (It(e) ? r.length > 3 && (u = function(c, d, h) {
    return r.call(this, c, d, h, e);
  }) : u = function(c, d, h) {
    return r.call(this, c, ct(d), h, e);
  }), s[t](u, ...i);
}
function Pi(e, t, r) {
  const i = Ae(e);
  bt(i, "iterate", jr);
  const s = i[t](...r);
  return (s === -1 || s === !1) && fs(r[0]) ? (r[0] = Ae(r[0]), i[t](...r)) : s;
}
function Cr(e, t, r = []) {
  ln(), is();
  const i = Ae(e)[t].apply(e, r);
  return ss(), un(), i;
}
const nc = /* @__PURE__ */ Zi("__proto__,__v_isRef,__isVue"), ul = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((e) => e !== "arguments" && e !== "caller").map((e) => Symbol[e]).filter(Bt)
);
function rc(e) {
  Bt(e) || (e = String(e));
  const t = Ae(this);
  return bt(t, "has", e), t.hasOwnProperty(e);
}
class cl {
  constructor(t = !1, r = !1) {
    this._isReadonly = t, this._isShallow = r;
  }
  get(t, r, i) {
    if (r === "__v_skip") return t.__v_skip;
    const s = this._isReadonly, u = this._isShallow;
    if (r === "__v_isReactive")
      return !s;
    if (r === "__v_isReadonly")
      return s;
    if (r === "__v_isShallow")
      return u;
    if (r === "__v_raw")
      return i === (s ? u ? pc : hl : u ? pl : dl).get(t) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(t) === Object.getPrototypeOf(i) ? t : void 0;
    const c = he(t);
    if (!s) {
      let h;
      if (c && (h = ec[r]))
        return h;
      if (r === "hasOwnProperty")
        return rc;
    }
    const d = Reflect.get(
      t,
      r,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      ze(t) ? t : i
    );
    return (Bt(r) ? ul.has(r) : nc(r)) || (s || bt(t, "get", r), u) ? d : ze(d) ? c && ns(r) ? d : d.value : Be(d) ? s ? ml(d) : Fo(d) : d;
  }
}
class fl extends cl {
  constructor(t = !1) {
    super(!1, t);
  }
  set(t, r, i, s) {
    let u = t[r];
    if (!this._isShallow) {
      const h = Tn(u);
      if (!It(i) && !Tn(i) && (u = Ae(u), i = Ae(i)), !he(t) && ze(u) && !ze(i))
        return h ? !1 : (u.value = i, !0);
    }
    const c = he(t) && ns(r) ? Number(r) < t.length : Me(t, r), d = Reflect.set(
      t,
      r,
      i,
      ze(t) ? t : s
    );
    return t === Ae(s) && (c ? On(i, u) && nn(t, "set", r, i) : nn(t, "add", r, i)), d;
  }
  deleteProperty(t, r) {
    const i = Me(t, r);
    t[r];
    const s = Reflect.deleteProperty(t, r);
    return s && i && nn(t, "delete", r, void 0), s;
  }
  has(t, r) {
    const i = Reflect.has(t, r);
    return (!Bt(r) || !ul.has(r)) && bt(t, "has", r), i;
  }
  ownKeys(t) {
    return bt(
      t,
      "iterate",
      he(t) ? "length" : Bn
    ), Reflect.ownKeys(t);
  }
}
class oc extends cl {
  constructor(t = !1) {
    super(!0, t);
  }
  set(t, r) {
    return !0;
  }
  deleteProperty(t, r) {
    return !0;
  }
}
const ic = /* @__PURE__ */ new fl(), sc = /* @__PURE__ */ new oc(), ac = /* @__PURE__ */ new fl(!0);
const Bi = (e) => e, yo = (e) => Reflect.getPrototypeOf(e);
function lc(e, t, r) {
  return function(...i) {
    const s = this.__v_raw, u = Ae(s), c = sr(u), d = e === "entries" || e === Symbol.iterator && c, h = e === "keys" && c, C = s[e](...i), y = r ? Bi : t ? Eo : ct;
    return !t && bt(
      u,
      "iterate",
      h ? Fi : Bn
    ), {
      // iterator protocol
      next() {
        const { value: b, done: x } = C.next();
        return x ? { value: b, done: x } : {
          value: d ? [y(b[0]), y(b[1])] : y(b),
          done: x
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function go(e) {
  return function(...t) {
    return e === "delete" ? !1 : e === "clear" ? void 0 : this;
  };
}
function uc(e, t) {
  const r = {
    get(s) {
      const u = this.__v_raw, c = Ae(u), d = Ae(s);
      e || (On(s, d) && bt(c, "get", s), bt(c, "get", d));
      const { has: h } = yo(c), C = t ? Bi : e ? Eo : ct;
      if (h.call(c, s))
        return C(u.get(s));
      if (h.call(c, d))
        return C(u.get(d));
      u !== c && u.get(s);
    },
    get size() {
      const s = this.__v_raw;
      return !e && bt(Ae(s), "iterate", Bn), Reflect.get(s, "size", s);
    },
    has(s) {
      const u = this.__v_raw, c = Ae(u), d = Ae(s);
      return e || (On(s, d) && bt(c, "has", s), bt(c, "has", d)), s === d ? u.has(s) : u.has(s) || u.has(d);
    },
    forEach(s, u) {
      const c = this, d = c.__v_raw, h = Ae(d), C = t ? Bi : e ? Eo : ct;
      return !e && bt(h, "iterate", Bn), d.forEach((y, b) => s.call(u, C(y), C(b), c));
    }
  };
  return _t(
    r,
    e ? {
      add: go("add"),
      set: go("set"),
      delete: go("delete"),
      clear: go("clear")
    } : {
      add(s) {
        !t && !It(s) && !Tn(s) && (s = Ae(s));
        const u = Ae(this);
        return yo(u).has.call(u, s) || (u.add(s), nn(u, "add", s, s)), this;
      },
      set(s, u) {
        !t && !It(u) && !Tn(u) && (u = Ae(u));
        const c = Ae(this), { has: d, get: h } = yo(c);
        let C = d.call(c, s);
        C || (s = Ae(s), C = d.call(c, s));
        const y = h.call(c, s);
        return c.set(s, u), C ? On(u, y) && nn(c, "set", s, u) : nn(c, "add", s, u), this;
      },
      delete(s) {
        const u = Ae(this), { has: c, get: d } = yo(u);
        let h = c.call(u, s);
        h || (s = Ae(s), h = c.call(u, s)), d && d.call(u, s);
        const C = u.delete(s);
        return h && nn(u, "delete", s, void 0), C;
      },
      clear() {
        const s = Ae(this), u = s.size !== 0, c = s.clear();
        return u && nn(
          s,
          "clear",
          void 0,
          void 0
        ), c;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((s) => {
    r[s] = lc(s, e, t);
  }), r;
}
function us(e, t) {
  const r = uc(e, t);
  return (i, s, u) => s === "__v_isReactive" ? !e : s === "__v_isReadonly" ? e : s === "__v_raw" ? i : Reflect.get(
    Me(r, s) && s in i ? r : i,
    s,
    u
  );
}
const cc = {
  get: /* @__PURE__ */ us(!1, !1)
}, fc = {
  get: /* @__PURE__ */ us(!1, !0)
}, dc = {
  get: /* @__PURE__ */ us(!0, !1)
};
const dl = /* @__PURE__ */ new WeakMap(), pl = /* @__PURE__ */ new WeakMap(), hl = /* @__PURE__ */ new WeakMap(), pc = /* @__PURE__ */ new WeakMap();
function hc(e) {
  switch (e) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function mc(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : hc(Fu(e));
}
function Fo(e) {
  return Tn(e) ? e : cs(
    e,
    !1,
    ic,
    cc,
    dl
  );
}
function yc(e) {
  return cs(
    e,
    !1,
    ac,
    fc,
    pl
  );
}
function ml(e) {
  return cs(
    e,
    !0,
    sc,
    dc,
    hl
  );
}
function cs(e, t, r, i, s) {
  if (!Be(e) || e.__v_raw && !(t && e.__v_isReactive))
    return e;
  const u = mc(e);
  if (u === 0)
    return e;
  const c = s.get(e);
  if (c)
    return c;
  const d = new Proxy(
    e,
    u === 2 ? i : r
  );
  return s.set(e, d), d;
}
function sn(e) {
  return Tn(e) ? sn(e.__v_raw) : !!(e && e.__v_isReactive);
}
function Tn(e) {
  return !!(e && e.__v_isReadonly);
}
function It(e) {
  return !!(e && e.__v_isShallow);
}
function fs(e) {
  return e ? !!e.__v_raw : !1;
}
function Ae(e) {
  const t = e && e.__v_raw;
  return t ? Ae(t) : e;
}
function ds(e) {
  return !Me(e, "__v_skip") && Object.isExtensible(e) && $i(e, "__v_skip", !0), e;
}
const ct = (e) => Be(e) ? Fo(e) : e, Eo = (e) => Be(e) ? ml(e) : e;
function ze(e) {
  return e ? e.__v_isRef === !0 : !1;
}
function Qe(e) {
  return yl(e, !1);
}
function gc(e) {
  return yl(e, !0);
}
function yl(e, t) {
  return ze(e) ? e : new vc(e, t);
}
class vc {
  constructor(t, r) {
    this.dep = new ls(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = r ? t : Ae(t), this._value = r ? t : ct(t), this.__v_isShallow = r;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(t) {
    const r = this._rawValue, i = this.__v_isShallow || It(t) || Tn(t);
    t = i ? t : Ae(t), On(t, r) && (this._rawValue = t, this._value = i ? t : ct(t), this.dep.trigger());
  }
}
function We(e) {
  return ze(e) ? e.value : e;
}
const bc = {
  get: (e, t, r) => t === "__v_raw" ? e : We(Reflect.get(e, t, r)),
  set: (e, t, r, i) => {
    const s = e[t];
    return ze(s) && !ze(r) ? (s.value = r, !0) : Reflect.set(e, t, r, i);
  }
};
function gl(e) {
  return sn(e) ? e : new Proxy(e, bc);
}
function _c(e) {
  const t = he(e) ? new Array(e.length) : {};
  for (const r in e)
    t[r] = vl(e, r);
  return t;
}
class wc {
  constructor(t, r, i) {
    this._object = t, this._key = r, this._defaultValue = i, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const t = this._object[this._key];
    return this._value = t === void 0 ? this._defaultValue : t;
  }
  set value(t) {
    this._object[this._key] = t;
  }
  get dep() {
    return Zu(Ae(this._object), this._key);
  }
}
class xc {
  constructor(t) {
    this._getter = t, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Cc(e, t, r) {
  return ze(e) ? e : _e(e) ? new xc(e) : Be(e) && arguments.length > 1 ? vl(e, t, r) : Qe(e);
}
function vl(e, t, r) {
  const i = e[t];
  return ze(i) ? i : new wc(e, t, r);
}
class Sc {
  constructor(t, r, i) {
    this.fn = t, this.setter = r, this._value = void 0, this.dep = new ls(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Lr - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !r, this.isSSR = i;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Fe !== this)
      return rl(this, !0), !0;
  }
  get value() {
    const t = this.dep.track();
    return sl(this), t && (t.version = this.dep.version), this._value;
  }
  set value(t) {
    this.setter && this.setter(t);
  }
}
function Oc(e, t, r = !1) {
  let i, s;
  return _e(e) ? i = e : (i = e.get, s = e.set), new Sc(i, s, r);
}
const vo = {}, Ao = /* @__PURE__ */ new WeakMap();
let Fn;
function Nc(e, t = !1, r = Fn) {
  if (r) {
    let i = Ao.get(r);
    i || Ao.set(r, i = []), i.push(e);
  }
}
function Tc(e, t, r = Ke) {
  const { immediate: i, deep: s, once: u, scheduler: c, augmentJob: d, call: h } = r, C = (ae) => s ? ae : It(ae) || s === !1 || s === 0 ? rn(ae, 1) : rn(ae);
  let y, b, x, w, L = !1, re = !1;
  if (ze(e) ? (b = () => e.value, L = It(e)) : sn(e) ? (b = () => C(e), L = !0) : he(e) ? (re = !0, L = e.some((ae) => sn(ae) || It(ae)), b = () => e.map((ae) => {
    if (ze(ae))
      return ae.value;
    if (sn(ae))
      return C(ae);
    if (_e(ae))
      return h ? h(ae, 2) : ae();
  })) : _e(e) ? t ? b = h ? () => h(e, 2) : e : b = () => {
    if (x) {
      ln();
      try {
        x();
      } finally {
        un();
      }
    }
    const ae = Fn;
    Fn = y;
    try {
      return h ? h(e, 3, [w]) : e(w);
    } finally {
      Fn = ae;
    }
  } : b = Yt, t && s) {
    const ae = b, be = s === !0 ? 1 / 0 : s;
    b = () => rn(ae(), be);
  }
  const Le = el(), ne = () => {
    y.stop(), Le && Le.active && ts(Le.effects, y);
  };
  if (u && t) {
    const ae = t;
    t = (...be) => {
      ae(...be), ne();
    };
  }
  let se = re ? new Array(e.length).fill(vo) : vo;
  const de = (ae) => {
    if (!(!(y.flags & 1) || !y.dirty && !ae))
      if (t) {
        const be = y.run();
        if (s || L || (re ? be.some((Ne, Se) => On(Ne, se[Se])) : On(be, se))) {
          x && x();
          const Ne = Fn;
          Fn = y;
          try {
            const Se = [
              be,
              // pass undefined as the old value when it's changed for the first time
              se === vo ? void 0 : re && se[0] === vo ? [] : se,
              w
            ];
            se = be, h ? h(t, 3, Se) : (
              // @ts-expect-error
              t(...Se)
            );
          } finally {
            Fn = Ne;
          }
        }
      } else
        y.run();
  };
  return d && d(de), y = new tl(b), y.scheduler = c ? () => c(de, !1) : de, w = (ae) => Nc(ae, !1, y), x = y.onStop = () => {
    const ae = Ao.get(y);
    if (ae) {
      if (h)
        h(ae, 4);
      else
        for (const be of ae) be();
      Ao.delete(y);
    }
  }, t ? i ? de(!0) : se = y.run() : c ? c(de.bind(null, !0), !0) : y.run(), ne.pause = y.pause.bind(y), ne.resume = y.resume.bind(y), ne.stop = ne, ne;
}
function rn(e, t = 1 / 0, r) {
  if (t <= 0 || !Be(e) || e.__v_skip || (r = r || /* @__PURE__ */ new Set(), r.has(e)))
    return e;
  if (r.add(e), t--, ze(e))
    rn(e.value, t, r);
  else if (he(e))
    for (let i = 0; i < e.length; i++)
      rn(e[i], t, r);
  else if (fr(e) || sr(e))
    e.forEach((i) => {
      rn(i, t, r);
    });
  else if (za(e)) {
    for (const i in e)
      rn(e[i], t, r);
    for (const i of Object.getOwnPropertySymbols(e))
      Object.prototype.propertyIsEnumerable.call(e, i) && rn(e[i], t, r);
  }
  return e;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Br(e, t, r, i) {
  try {
    return i ? e(...i) : e();
  } catch (s) {
    Bo(s, t, r);
  }
}
function Qt(e, t, r, i) {
  if (_e(e)) {
    const s = Br(e, t, r, i);
    return s && Ha(s) && s.catch((u) => {
      Bo(u, t, r);
    }), s;
  }
  if (he(e)) {
    const s = [];
    for (let u = 0; u < e.length; u++)
      s.push(Qt(e[u], t, r, i));
    return s;
  }
}
function Bo(e, t, r, i = !0) {
  const s = t ? t.vnode : null, { errorHandler: u, throwUnhandledErrorInProduction: c } = t && t.appContext.config || Ke;
  if (t) {
    let d = t.parent;
    const h = t.proxy, C = `https://vuejs.org/error-reference/#runtime-${r}`;
    for (; d; ) {
      const y = d.ec;
      if (y) {
        for (let b = 0; b < y.length; b++)
          if (y[b](e, h, C) === !1)
            return;
      }
      d = d.parent;
    }
    if (u) {
      ln(), Br(u, null, 10, [
        e,
        h,
        C
      ]), un();
      return;
    }
  }
  Ec(e, r, s, i, c);
}
function Ec(e, t, r, i = !0, s = !1) {
  if (s)
    throw e;
  console.error(e);
}
const Nt = [];
let Wt = -1;
const ar = [];
let Cn = null, or = 0;
const bl = /* @__PURE__ */ Promise.resolve();
let Po = null;
function ps(e) {
  const t = Po || bl;
  return e ? t.then(this ? e.bind(this) : e) : t;
}
function Ac(e) {
  let t = Wt + 1, r = Nt.length;
  for (; t < r; ) {
    const i = t + r >>> 1, s = Nt[i], u = Mr(s);
    u < e || u === e && s.flags & 2 ? t = i + 1 : r = i;
  }
  return t;
}
function hs(e) {
  if (!(e.flags & 1)) {
    const t = Mr(e), r = Nt[Nt.length - 1];
    !r || // fast path when the job id is larger than the tail
    !(e.flags & 2) && t >= Mr(r) ? Nt.push(e) : Nt.splice(Ac(t), 0, e), e.flags |= 1, _l();
  }
}
function _l() {
  Po || (Po = bl.then(xl));
}
function Pc(e) {
  he(e) ? ar.push(...e) : Cn && e.id === -1 ? Cn.splice(or + 1, 0, e) : e.flags & 1 || (ar.push(e), e.flags |= 1), _l();
}
function sa(e, t, r = Wt + 1) {
  for (; r < Nt.length; r++) {
    const i = Nt[r];
    if (i && i.flags & 2) {
      if (e && i.id !== e.uid)
        continue;
      Nt.splice(r, 1), r--, i.flags & 4 && (i.flags &= -2), i(), i.flags & 4 || (i.flags &= -2);
    }
  }
}
function wl(e) {
  if (ar.length) {
    const t = [...new Set(ar)].sort(
      (r, i) => Mr(r) - Mr(i)
    );
    if (ar.length = 0, Cn) {
      Cn.push(...t);
      return;
    }
    for (Cn = t, or = 0; or < Cn.length; or++) {
      const r = Cn[or];
      r.flags & 4 && (r.flags &= -2), r.flags & 8 || r(), r.flags &= -2;
    }
    Cn = null, or = 0;
  }
}
const Mr = (e) => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id;
function xl(e) {
  try {
    for (Wt = 0; Wt < Nt.length; Wt++) {
      const t = Nt[Wt];
      t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Br(
        t,
        t.i,
        t.i ? 15 : 14
      ), t.flags & 4 || (t.flags &= -2));
    }
  } finally {
    for (; Wt < Nt.length; Wt++) {
      const t = Nt[Wt];
      t && (t.flags &= -2);
    }
    Wt = -1, Nt.length = 0, wl(), Po = null, (Nt.length || ar.length) && xl();
  }
}
let ut = null, Cl = null;
function Ro(e) {
  const t = ut;
  return ut = e, Cl = e && e.type.__scopeId || null, t;
}
function qi(e, t = ut, r) {
  if (!t || e._n)
    return e;
  const i = (...s) => {
    i._d && ba(-1);
    const u = Ro(t);
    let c;
    try {
      c = e(...s);
    } finally {
      Ro(u), i._d && ba(1);
    }
    return c;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function He(e, t) {
  if (ut === null)
    return e;
  const r = Ho(ut), i = e.dirs || (e.dirs = []);
  for (let s = 0; s < t.length; s++) {
    let [u, c, d, h = Ke] = t[s];
    u && (_e(u) && (u = {
      mounted: u,
      updated: u
    }), u.deep && rn(c), i.push({
      dir: u,
      instance: r,
      value: c,
      oldValue: void 0,
      arg: d,
      modifiers: h
    }));
  }
  return e;
}
function $n(e, t, r, i) {
  const s = e.dirs, u = t && t.dirs;
  for (let c = 0; c < s.length; c++) {
    const d = s[c];
    u && (d.oldValue = u[c].value);
    let h = d.dir[i];
    h && (ln(), Qt(h, r, 8, [
      e.el,
      d,
      e,
      t
    ]), un());
  }
}
const Sl = Symbol("_vte"), Rc = (e) => e.__isTeleport, Ar = (e) => e && (e.disabled || e.disabled === ""), aa = (e) => e && (e.defer || e.defer === ""), la = (e) => typeof SVGElement < "u" && e instanceof SVGElement, ua = (e) => typeof MathMLElement == "function" && e instanceof MathMLElement, Ui = (e, t) => {
  const r = e && e.to;
  return Ze(r) ? t ? t(r) : null : r;
}, Ol = {
  name: "Teleport",
  __isTeleport: !0,
  process(e, t, r, i, s, u, c, d, h, C) {
    const {
      mc: y,
      pc: b,
      pbc: x,
      o: { insert: w, querySelector: L, createText: re, createComment: Le }
    } = C, ne = Ar(t.props);
    let { shapeFlag: se, children: de, dynamicChildren: ae } = t;
    if (e == null) {
      const be = t.el = re(""), Ne = t.anchor = re("");
      w(be, r, i), w(Ne, r, i);
      const Se = (me, $e) => {
        se & 16 && (s && s.isCE && (s.ce._teleportTarget = me), y(
          de,
          me,
          $e,
          s,
          u,
          c,
          d,
          h
        ));
      }, ye = () => {
        const me = t.target = Ui(t.props, L), $e = Tl(me, t, re, w);
        me && (c !== "svg" && la(me) ? c = "svg" : c !== "mathml" && ua(me) && (c = "mathml"), ne || (Se(me, $e), wo(t, !1)));
      };
      ne && (Se(r, Ne), wo(t, !0)), aa(t.props) ? (t.el.__isMounted = !1, Ot(() => {
        ye(), delete t.el.__isMounted;
      }, u)) : ye();
    } else {
      if (aa(t.props) && e.el.__isMounted === !1) {
        Ot(() => {
          Ol.process(
            e,
            t,
            r,
            i,
            s,
            u,
            c,
            d,
            h,
            C
          );
        }, u);
        return;
      }
      t.el = e.el, t.targetStart = e.targetStart;
      const be = t.anchor = e.anchor, Ne = t.target = e.target, Se = t.targetAnchor = e.targetAnchor, ye = Ar(e.props), me = ye ? r : Ne, $e = ye ? be : Se;
      if (c === "svg" || la(Ne) ? c = "svg" : (c === "mathml" || ua(Ne)) && (c = "mathml"), ae ? (x(
        e.dynamicChildren,
        ae,
        me,
        s,
        u,
        c,
        d
      ), bs(e, t, !0)) : h || b(
        e,
        t,
        me,
        $e,
        s,
        u,
        c,
        d,
        !1
      ), ne)
        ye ? t.props && e.props && t.props.to !== e.props.to && (t.props.to = e.props.to) : bo(
          t,
          r,
          be,
          C,
          1
        );
      else if ((t.props && t.props.to) !== (e.props && e.props.to)) {
        const rt = t.target = Ui(
          t.props,
          L
        );
        rt && bo(
          t,
          rt,
          null,
          C,
          0
        );
      } else ye && bo(
        t,
        Ne,
        Se,
        C,
        1
      );
      wo(t, ne);
    }
  },
  remove(e, t, r, { um: i, o: { remove: s } }, u) {
    const {
      shapeFlag: c,
      children: d,
      anchor: h,
      targetStart: C,
      targetAnchor: y,
      target: b,
      props: x
    } = e;
    if (b && (s(C), s(y)), u && s(h), c & 16) {
      const w = u || !Ar(x);
      for (let L = 0; L < d.length; L++) {
        const re = d[L];
        i(
          re,
          t,
          r,
          w,
          !!re.dynamicChildren
        );
      }
    }
  },
  move: bo,
  hydrate: Dc
};
function bo(e, t, r, { o: { insert: i }, m: s }, u = 2) {
  u === 0 && i(e.targetAnchor, t, r);
  const { el: c, anchor: d, shapeFlag: h, children: C, props: y } = e, b = u === 2;
  if (b && i(c, t, r), (!b || Ar(y)) && h & 16)
    for (let x = 0; x < C.length; x++)
      s(
        C[x],
        t,
        r,
        2
      );
  b && i(d, t, r);
}
function Dc(e, t, r, i, s, u, {
  o: { nextSibling: c, parentNode: d, querySelector: h, insert: C, createText: y }
}, b) {
  const x = t.target = Ui(
    t.props,
    h
  );
  if (x) {
    const w = Ar(t.props), L = x._lpa || x.firstChild;
    if (t.shapeFlag & 16)
      if (w)
        t.anchor = b(
          c(e),
          t,
          d(e),
          r,
          i,
          s,
          u
        ), t.targetStart = L, t.targetAnchor = L && c(L);
      else {
        t.anchor = c(e);
        let re = L;
        for (; re; ) {
          if (re && re.nodeType === 8) {
            if (re.data === "teleport start anchor")
              t.targetStart = re;
            else if (re.data === "teleport anchor") {
              t.targetAnchor = re, x._lpa = t.targetAnchor && c(t.targetAnchor);
              break;
            }
          }
          re = c(re);
        }
        t.targetAnchor || Tl(x, t, y, C), b(
          L && c(L),
          t,
          x,
          r,
          i,
          s,
          u
        );
      }
    wo(t, w);
  }
  return t.anchor && c(t.anchor);
}
const Nl = Ol;
function wo(e, t) {
  const r = e.ctx;
  if (r && r.ut) {
    let i, s;
    for (t ? (i = e.el, s = e.anchor) : (i = e.targetStart, s = e.targetAnchor); i && i !== s; )
      i.nodeType === 1 && i.setAttribute("data-v-owner", r.uid), i = i.nextSibling;
    r.ut();
  }
}
function Tl(e, t, r, i) {
  const s = t.targetStart = r(""), u = t.targetAnchor = r("");
  return s[Sl] = u, e && (i(s, e), i(u, e)), u;
}
function ms(e, t) {
  e.shapeFlag & 6 && e.component ? (e.transition = t, ms(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function wt(e, t) {
  return _e(e) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    _t({ name: e.name }, t, { setup: e })
  ) : e;
}
function El(e) {
  e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0];
}
function Al(e) {
  const t = Af(), r = gc(null);
  if (t) {
    const s = t.refs === Ke ? t.refs = {} : t.refs;
    Object.defineProperty(s, e, {
      enumerable: !0,
      get: () => r.value,
      set: (u) => r.value = u
    });
  }
  return r;
}
function Pr(e, t, r, i, s = !1) {
  if (he(e)) {
    e.forEach(
      (L, re) => Pr(
        L,
        t && (he(t) ? t[re] : t),
        r,
        i,
        s
      )
    );
    return;
  }
  if (lr(i) && !s) {
    i.shapeFlag & 512 && i.type.__asyncResolved && i.component.subTree.component && Pr(e, t, r, i.component.subTree);
    return;
  }
  const u = i.shapeFlag & 4 ? Ho(i.component) : i.el, c = s ? null : u, { i: d, r: h } = e, C = t && t.r, y = d.refs === Ke ? d.refs = {} : d.refs, b = d.setupState, x = Ae(b), w = b === Ke ? () => !1 : (L) => Me(x, L);
  if (C != null && C !== h && (Ze(C) ? (y[C] = null, w(C) && (b[C] = null)) : ze(C) && (C.value = null)), _e(h))
    Br(h, d, 12, [c, y]);
  else {
    const L = Ze(h), re = ze(h);
    if (L || re) {
      const Le = () => {
        if (e.f) {
          const ne = L ? w(h) ? b[h] : y[h] : h.value;
          s ? he(ne) && ts(ne, u) : he(ne) ? ne.includes(u) || ne.push(u) : L ? (y[h] = [u], w(h) && (b[h] = y[h])) : (h.value = [u], e.k && (y[e.k] = h.value));
        } else L ? (y[h] = c, w(h) && (b[h] = c)) : re && (h.value = c, e.k && (y[e.k] = c));
      };
      c ? (Le.id = -1, Ot(Le, r)) : Le();
    }
  }
}
$o().requestIdleCallback;
$o().cancelIdleCallback;
const lr = (e) => !!e.type.__asyncLoader, Pl = (e) => e.type.__isKeepAlive;
function kc(e, t) {
  Rl(e, "a", t);
}
function Ic(e, t) {
  Rl(e, "da", t);
}
function Rl(e, t, r = ft) {
  const i = e.__wdc || (e.__wdc = () => {
    let s = r;
    for (; s; ) {
      if (s.isDeactivated)
        return;
      s = s.parent;
    }
    return e();
  });
  if (qo(t, i, r), r) {
    let s = r.parent;
    for (; s && s.parent; )
      Pl(s.parent.vnode) && Lc(i, t, r, s), s = s.parent;
  }
}
function Lc(e, t, r, i) {
  const s = qo(
    t,
    e,
    i,
    !0
    /* prepend */
  );
  ys(() => {
    ts(i[t], s);
  }, r);
}
function qo(e, t, r = ft, i = !1) {
  if (r) {
    const s = r[e] || (r[e] = []), u = t.__weh || (t.__weh = (...c) => {
      ln();
      const d = qr(r), h = Qt(t, r, e, c);
      return d(), un(), h;
    });
    return i ? s.unshift(u) : s.push(u), u;
  }
}
const fn = (e) => (t, r = ft) => {
  (!Kr || e === "sp") && qo(e, (...i) => t(...i), r);
}, jc = fn("bm"), Dl = fn("m"), Mc = fn(
  "bu"
), $c = fn("u"), Kc = fn(
  "bum"
), ys = fn("um"), Fc = fn(
  "sp"
), Bc = fn("rtg"), qc = fn("rtc");
function Uc(e, t = ft) {
  qo("ec", e, t);
}
const Vc = Symbol.for("v-ndc");
function dt(e, t, r, i) {
  let s;
  const u = r, c = he(e);
  if (c || Ze(e)) {
    const d = c && sn(e);
    let h = !1, C = !1;
    d && (h = !It(e), C = Tn(e), e = Ko(e)), s = new Array(e.length);
    for (let y = 0, b = e.length; y < b; y++)
      s[y] = t(
        h ? C ? Eo(ct(e[y])) : ct(e[y]) : e[y],
        y,
        void 0,
        u
      );
  } else if (typeof e == "number") {
    s = new Array(e);
    for (let d = 0; d < e; d++)
      s[d] = t(d + 1, d, void 0, u);
  } else if (Be(e))
    if (e[Symbol.iterator])
      s = Array.from(
        e,
        (d, h) => t(d, h, void 0, u)
      );
    else {
      const d = Object.keys(e);
      s = new Array(d.length);
      for (let h = 0, C = d.length; h < C; h++) {
        const y = d[h];
        s[h] = t(e[y], y, h, u);
      }
    }
  else
    s = [];
  return s;
}
function ca(e, t, r = {}, i, s) {
  if (ut.ce || ut.parent && lr(ut.parent) && ut.parent.ce)
    return t !== "default" && (r.name = t), ie(), Mt(
      Ie,
      null,
      [tt("slot", r, i)],
      64
    );
  let u = e[t];
  u && u._c && (u._d = !1), ie();
  const c = u && kl(u(r)), d = r.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  c && c.key, h = Mt(
    Ie,
    {
      key: (d && !Bt(d) ? d : `_${t}`) + // #7256 force differentiate fallback content from actual content
      (!c && i ? "_fb" : "")
    },
    c || [],
    c && e._ === 1 ? 64 : -2
  );
  return u && u._c && (u._d = !0), h;
}
function kl(e) {
  return e.some((t) => ws(t) ? !(t.type === cn || t.type === Ie && !kl(t.children)) : !0) ? e : null;
}
const Vi = (e) => e ? Zl(e) ? Ho(e) : Vi(e.parent) : null, Rr = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ _t(/* @__PURE__ */ Object.create(null), {
    $: (e) => e,
    $el: (e) => e.vnode.el,
    $data: (e) => e.data,
    $props: (e) => e.props,
    $attrs: (e) => e.attrs,
    $slots: (e) => e.slots,
    $refs: (e) => e.refs,
    $parent: (e) => Vi(e.parent),
    $root: (e) => Vi(e.root),
    $host: (e) => e.ce,
    $emit: (e) => e.emit,
    $options: (e) => Ll(e),
    $forceUpdate: (e) => e.f || (e.f = () => {
      hs(e.update);
    }),
    $nextTick: (e) => e.n || (e.n = ps.bind(e.proxy)),
    $watch: (e) => hf.bind(e)
  })
), Ri = (e, t) => e !== Ke && !e.__isScriptSetup && Me(e, t), Hc = {
  get({ _: e }, t) {
    if (t === "__v_skip")
      return !0;
    const { ctx: r, setupState: i, data: s, props: u, accessCache: c, type: d, appContext: h } = e;
    let C;
    if (t[0] !== "$") {
      const w = c[t];
      if (w !== void 0)
        switch (w) {
          case 1:
            return i[t];
          case 2:
            return s[t];
          case 4:
            return r[t];
          case 3:
            return u[t];
        }
      else {
        if (Ri(i, t))
          return c[t] = 1, i[t];
        if (s !== Ke && Me(s, t))
          return c[t] = 2, s[t];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (C = e.propsOptions[0]) && Me(C, t)
        )
          return c[t] = 3, u[t];
        if (r !== Ke && Me(r, t))
          return c[t] = 4, r[t];
        Hi && (c[t] = 0);
      }
    }
    const y = Rr[t];
    let b, x;
    if (y)
      return t === "$attrs" && bt(e.attrs, "get", ""), y(e);
    if (
      // css module (injected by vue-loader)
      (b = d.__cssModules) && (b = b[t])
    )
      return b;
    if (r !== Ke && Me(r, t))
      return c[t] = 4, r[t];
    if (
      // global properties
      x = h.config.globalProperties, Me(x, t)
    )
      return x[t];
  },
  set({ _: e }, t, r) {
    const { data: i, setupState: s, ctx: u } = e;
    return Ri(s, t) ? (s[t] = r, !0) : i !== Ke && Me(i, t) ? (i[t] = r, !0) : Me(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (u[t] = r, !0);
  },
  has({
    _: { data: e, setupState: t, accessCache: r, ctx: i, appContext: s, propsOptions: u }
  }, c) {
    let d;
    return !!r[c] || e !== Ke && Me(e, c) || Ri(t, c) || (d = u[0]) && Me(d, c) || Me(i, c) || Me(Rr, c) || Me(s.config.globalProperties, c);
  },
  defineProperty(e, t, r) {
    return r.get != null ? e._.accessCache[t] = 0 : Me(r, "value") && this.set(e, t, r.value, null), Reflect.defineProperty(e, t, r);
  }
};
function fa(e) {
  return he(e) ? e.reduce(
    (t, r) => (t[r] = null, t),
    {}
  ) : e;
}
let Hi = !0;
function Wc(e) {
  const t = Ll(e), r = e.proxy, i = e.ctx;
  Hi = !1, t.beforeCreate && da(t.beforeCreate, e, "bc");
  const {
    // state
    data: s,
    computed: u,
    methods: c,
    watch: d,
    provide: h,
    inject: C,
    // lifecycle
    created: y,
    beforeMount: b,
    mounted: x,
    beforeUpdate: w,
    updated: L,
    activated: re,
    deactivated: Le,
    beforeDestroy: ne,
    beforeUnmount: se,
    destroyed: de,
    unmounted: ae,
    render: be,
    renderTracked: Ne,
    renderTriggered: Se,
    errorCaptured: ye,
    serverPrefetch: me,
    // public API
    expose: $e,
    inheritAttrs: rt,
    // assets
    components: pt,
    directives: ht,
    filters: Pn
  } = t;
  if (C && zc(C, i, null), c)
    for (const Oe in c) {
      const Pe = c[Oe];
      _e(Pe) && (i[Oe] = Pe.bind(r));
    }
  if (s) {
    const Oe = s.call(r, r);
    Be(Oe) && (e.data = Fo(Oe));
  }
  if (Hi = !0, u)
    for (const Oe in u) {
      const Pe = u[Oe], Tt = _e(Pe) ? Pe.bind(r, r) : _e(Pe.get) ? Pe.get.bind(r, r) : Yt, Et = !_e(Pe) && _e(Pe.set) ? Pe.set.bind(r) : Yt, jt = lt({
        get: Tt,
        set: Et
      });
      Object.defineProperty(i, Oe, {
        enumerable: !0,
        configurable: !0,
        get: () => jt.value,
        set: (Rt) => jt.value = Rt
      });
    }
  if (d)
    for (const Oe in d)
      Il(d[Oe], i, r, Oe);
  if (h) {
    const Oe = _e(h) ? h.call(r) : h;
    Reflect.ownKeys(Oe).forEach((Pe) => {
      Zc(Pe, Oe[Pe]);
    });
  }
  y && da(y, e, "c");
  function qe(Oe, Pe) {
    he(Pe) ? Pe.forEach((Tt) => Oe(Tt.bind(r))) : Pe && Oe(Pe.bind(r));
  }
  if (qe(jc, b), qe(Dl, x), qe(Mc, w), qe($c, L), qe(kc, re), qe(Ic, Le), qe(Uc, ye), qe(qc, Ne), qe(Bc, Se), qe(Kc, se), qe(ys, ae), qe(Fc, me), he($e))
    if ($e.length) {
      const Oe = e.exposed || (e.exposed = {});
      $e.forEach((Pe) => {
        Object.defineProperty(Oe, Pe, {
          get: () => r[Pe],
          set: (Tt) => r[Pe] = Tt
        });
      });
    } else e.exposed || (e.exposed = {});
  be && e.render === Yt && (e.render = be), rt != null && (e.inheritAttrs = rt), pt && (e.components = pt), ht && (e.directives = ht), me && El(e);
}
function zc(e, t, r = Yt) {
  he(e) && (e = Wi(e));
  for (const i in e) {
    const s = e[i];
    let u;
    Be(s) ? "default" in s ? u = Dr(
      s.from || i,
      s.default,
      !0
    ) : u = Dr(s.from || i) : u = Dr(s), ze(u) ? Object.defineProperty(t, i, {
      enumerable: !0,
      configurable: !0,
      get: () => u.value,
      set: (c) => u.value = c
    }) : t[i] = u;
  }
}
function da(e, t, r) {
  Qt(
    he(e) ? e.map((i) => i.bind(t.proxy)) : e.bind(t.proxy),
    t,
    r
  );
}
function Il(e, t, r, i) {
  let s = i.includes(".") ? zl(r, i) : () => r[i];
  if (Ze(e)) {
    const u = t[e];
    _e(u) && an(s, u);
  } else if (_e(e))
    an(s, e.bind(r));
  else if (Be(e))
    if (he(e))
      e.forEach((u) => Il(u, t, r, i));
    else {
      const u = _e(e.handler) ? e.handler.bind(r) : t[e.handler];
      _e(u) && an(s, u, e);
    }
}
function Ll(e) {
  const t = e.type, { mixins: r, extends: i } = t, {
    mixins: s,
    optionsCache: u,
    config: { optionMergeStrategies: c }
  } = e.appContext, d = u.get(t);
  let h;
  return d ? h = d : !s.length && !r && !i ? h = t : (h = {}, s.length && s.forEach(
    (C) => Do(h, C, c, !0)
  ), Do(h, t, c)), Be(t) && u.set(t, h), h;
}
function Do(e, t, r, i = !1) {
  const { mixins: s, extends: u } = t;
  u && Do(e, u, r, !0), s && s.forEach(
    (c) => Do(e, c, r, !0)
  );
  for (const c in t)
    if (!(i && c === "expose")) {
      const d = Gc[c] || r && r[c];
      e[c] = d ? d(e[c], t[c]) : t[c];
    }
  return e;
}
const Gc = {
  data: pa,
  props: ha,
  emits: ha,
  // objects
  methods: Or,
  computed: Or,
  // lifecycle
  beforeCreate: St,
  created: St,
  beforeMount: St,
  mounted: St,
  beforeUpdate: St,
  updated: St,
  beforeDestroy: St,
  beforeUnmount: St,
  destroyed: St,
  unmounted: St,
  activated: St,
  deactivated: St,
  errorCaptured: St,
  serverPrefetch: St,
  // assets
  components: Or,
  directives: Or,
  // watch
  watch: Qc,
  // provide / inject
  provide: pa,
  inject: Yc
};
function pa(e, t) {
  return t ? e ? function() {
    return _t(
      _e(e) ? e.call(this, this) : e,
      _e(t) ? t.call(this, this) : t
    );
  } : t : e;
}
function Yc(e, t) {
  return Or(Wi(e), Wi(t));
}
function Wi(e) {
  if (he(e)) {
    const t = {};
    for (let r = 0; r < e.length; r++)
      t[e[r]] = e[r];
    return t;
  }
  return e;
}
function St(e, t) {
  return e ? [...new Set([].concat(e, t))] : t;
}
function Or(e, t) {
  return e ? _t(/* @__PURE__ */ Object.create(null), e, t) : t;
}
function ha(e, t) {
  return e ? he(e) && he(t) ? [.../* @__PURE__ */ new Set([...e, ...t])] : _t(
    /* @__PURE__ */ Object.create(null),
    fa(e),
    fa(t ?? {})
  ) : t;
}
function Qc(e, t) {
  if (!e) return t;
  if (!t) return e;
  const r = _t(/* @__PURE__ */ Object.create(null), e);
  for (const i in t)
    r[i] = St(e[i], t[i]);
  return r;
}
function jl() {
  return {
    app: null,
    config: {
      isNativeTag: $u,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Jc = 0;
function Xc(e, t) {
  return function(i, s = null) {
    _e(i) || (i = _t({}, i)), s != null && !Be(s) && (s = null);
    const u = jl(), c = /* @__PURE__ */ new WeakSet(), d = [];
    let h = !1;
    const C = u.app = {
      _uid: Jc++,
      _component: i,
      _props: s,
      _container: null,
      _context: u,
      _instance: null,
      version: Lf,
      get config() {
        return u.config;
      },
      set config(y) {
      },
      use(y, ...b) {
        return c.has(y) || (y && _e(y.install) ? (c.add(y), y.install(C, ...b)) : _e(y) && (c.add(y), y(C, ...b))), C;
      },
      mixin(y) {
        return u.mixins.includes(y) || u.mixins.push(y), C;
      },
      component(y, b) {
        return b ? (u.components[y] = b, C) : u.components[y];
      },
      directive(y, b) {
        return b ? (u.directives[y] = b, C) : u.directives[y];
      },
      mount(y, b, x) {
        if (!h) {
          const w = C._ceVNode || tt(i, s);
          return w.appContext = u, x === !0 ? x = "svg" : x === !1 && (x = void 0), e(w, y, x), h = !0, C._container = y, y.__vue_app__ = C, Ho(w.component);
        }
      },
      onUnmount(y) {
        d.push(y);
      },
      unmount() {
        h && (Qt(
          d,
          C._instance,
          16
        ), e(null, C._container), delete C._container.__vue_app__);
      },
      provide(y, b) {
        return u.provides[y] = b, C;
      },
      runWithContext(y) {
        const b = qn;
        qn = C;
        try {
          return y();
        } finally {
          qn = b;
        }
      }
    };
    return C;
  };
}
let qn = null;
function Zc(e, t) {
  if (ft) {
    let r = ft.provides;
    const i = ft.parent && ft.parent.provides;
    i === r && (r = ft.provides = Object.create(i)), r[e] = t;
  }
}
function Dr(e, t, r = !1) {
  const i = ft || ut;
  if (i || qn) {
    let s = qn ? qn._context.provides : i ? i.parent == null || i.ce ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : void 0;
    if (s && e in s)
      return s[e];
    if (arguments.length > 1)
      return r && _e(t) ? t.call(i && i.proxy) : t;
  }
}
function ef() {
  return !!(ft || ut || qn);
}
const Ml = {}, $l = () => Object.create(Ml), Kl = (e) => Object.getPrototypeOf(e) === Ml;
function tf(e, t, r, i = !1) {
  const s = {}, u = $l();
  e.propsDefaults = /* @__PURE__ */ Object.create(null), Fl(e, t, s, u);
  for (const c in e.propsOptions[0])
    c in s || (s[c] = void 0);
  r ? e.props = i ? s : yc(s) : e.type.props ? e.props = s : e.props = u, e.attrs = u;
}
function nf(e, t, r, i) {
  const {
    props: s,
    attrs: u,
    vnode: { patchFlag: c }
  } = e, d = Ae(s), [h] = e.propsOptions;
  let C = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || c > 0) && !(c & 16)
  ) {
    if (c & 8) {
      const y = e.vnode.dynamicProps;
      for (let b = 0; b < y.length; b++) {
        let x = y[b];
        if (Uo(e.emitsOptions, x))
          continue;
        const w = t[x];
        if (h)
          if (Me(u, x))
            w !== u[x] && (u[x] = w, C = !0);
          else {
            const L = Nn(x);
            s[L] = zi(
              h,
              d,
              L,
              w,
              e,
              !1
            );
          }
        else
          w !== u[x] && (u[x] = w, C = !0);
      }
    }
  } else {
    Fl(e, t, s, u) && (C = !0);
    let y;
    for (const b in d)
      (!t || // for camelCase
      !Me(t, b) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((y = Hn(b)) === b || !Me(t, y))) && (h ? r && // for camelCase
      (r[b] !== void 0 || // for kebab-case
      r[y] !== void 0) && (s[b] = zi(
        h,
        d,
        b,
        void 0,
        e,
        !0
      )) : delete s[b]);
    if (u !== d)
      for (const b in u)
        (!t || !Me(t, b)) && (delete u[b], C = !0);
  }
  C && nn(e.attrs, "set", "");
}
function Fl(e, t, r, i) {
  const [s, u] = e.propsOptions;
  let c = !1, d;
  if (t)
    for (let h in t) {
      if (Nr(h))
        continue;
      const C = t[h];
      let y;
      s && Me(s, y = Nn(h)) ? !u || !u.includes(y) ? r[y] = C : (d || (d = {}))[y] = C : Uo(e.emitsOptions, h) || (!(h in i) || C !== i[h]) && (i[h] = C, c = !0);
    }
  if (u) {
    const h = Ae(r), C = d || Ke;
    for (let y = 0; y < u.length; y++) {
      const b = u[y];
      r[b] = zi(
        s,
        h,
        b,
        C[b],
        e,
        !Me(C, b)
      );
    }
  }
  return c;
}
function zi(e, t, r, i, s, u) {
  const c = e[r];
  if (c != null) {
    const d = Me(c, "default");
    if (d && i === void 0) {
      const h = c.default;
      if (c.type !== Function && !c.skipFactory && _e(h)) {
        const { propsDefaults: C } = s;
        if (r in C)
          i = C[r];
        else {
          const y = qr(s);
          i = C[r] = h.call(
            null,
            t
          ), y();
        }
      } else
        i = h;
      s.ce && s.ce._setProp(r, i);
    }
    c[
      0
      /* shouldCast */
    ] && (u && !d ? i = !1 : c[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === Hn(r)) && (i = !0));
  }
  return i;
}
const rf = /* @__PURE__ */ new WeakMap();
function Bl(e, t, r = !1) {
  const i = r ? rf : t.propsCache, s = i.get(e);
  if (s)
    return s;
  const u = e.props, c = {}, d = [];
  let h = !1;
  if (!_e(e)) {
    const y = (b) => {
      h = !0;
      const [x, w] = Bl(b, t, !0);
      _t(c, x), w && d.push(...w);
    };
    !r && t.mixins.length && t.mixins.forEach(y), e.extends && y(e.extends), e.mixins && e.mixins.forEach(y);
  }
  if (!u && !h)
    return Be(e) && i.set(e, ir), ir;
  if (he(u))
    for (let y = 0; y < u.length; y++) {
      const b = Nn(u[y]);
      ma(b) && (c[b] = Ke);
    }
  else if (u)
    for (const y in u) {
      const b = Nn(y);
      if (ma(b)) {
        const x = u[y], w = c[b] = he(x) || _e(x) ? { type: x } : _t({}, x), L = w.type;
        let re = !1, Le = !0;
        if (he(L))
          for (let ne = 0; ne < L.length; ++ne) {
            const se = L[ne], de = _e(se) && se.name;
            if (de === "Boolean") {
              re = !0;
              break;
            } else de === "String" && (Le = !1);
          }
        else
          re = _e(L) && L.name === "Boolean";
        w[
          0
          /* shouldCast */
        ] = re, w[
          1
          /* shouldCastTrue */
        ] = Le, (re || Me(w, "default")) && d.push(b);
      }
    }
  const C = [c, d];
  return Be(e) && i.set(e, C), C;
}
function ma(e) {
  return e[0] !== "$" && !Nr(e);
}
const gs = (e) => e[0] === "_" || e === "$stable", vs = (e) => he(e) ? e.map(zt) : [zt(e)], of = (e, t, r) => {
  if (t._n)
    return t;
  const i = qi((...s) => vs(t(...s)), r);
  return i._c = !1, i;
}, ql = (e, t, r) => {
  const i = e._ctx;
  for (const s in e) {
    if (gs(s)) continue;
    const u = e[s];
    if (_e(u))
      t[s] = of(s, u, i);
    else if (u != null) {
      const c = vs(u);
      t[s] = () => c;
    }
  }
}, Ul = (e, t) => {
  const r = vs(t);
  e.slots.default = () => r;
}, Vl = (e, t, r) => {
  for (const i in t)
    (r || !gs(i)) && (e[i] = t[i]);
}, sf = (e, t, r) => {
  const i = e.slots = $l();
  if (e.vnode.shapeFlag & 32) {
    const s = t.__;
    s && $i(i, "__", s, !0);
    const u = t._;
    u ? (Vl(i, t, r), r && $i(i, "_", u, !0)) : ql(t, i);
  } else t && Ul(e, t);
}, af = (e, t, r) => {
  const { vnode: i, slots: s } = e;
  let u = !0, c = Ke;
  if (i.shapeFlag & 32) {
    const d = t._;
    d ? r && d === 1 ? u = !1 : Vl(s, t, r) : (u = !t.$stable, ql(t, s)), c = t;
  } else t && (Ul(e, t), c = { default: 1 });
  if (u)
    for (const d in s)
      !gs(d) && c[d] == null && delete s[d];
}, Ot = wf;
function lf(e) {
  return uf(e);
}
function uf(e, t) {
  const r = $o();
  r.__VUE__ = !0;
  const {
    insert: i,
    remove: s,
    patchProp: u,
    createElement: c,
    createText: d,
    createComment: h,
    setText: C,
    setElementText: y,
    parentNode: b,
    nextSibling: x,
    setScopeId: w = Yt,
    insertStaticContent: L
  } = e, re = (g, T, K, q = null, B = null, U = null, X = void 0, Y = null, z = !!T.dynamicChildren) => {
    if (g === T)
      return;
    g && !Sr(g, T) && (q = pn(g), Rt(g, B, U, !0), g = null), T.patchFlag === -2 && (z = !1, T.dynamicChildren = null);
    const { type: F, ref: ce, shapeFlag: Q } = T;
    switch (F) {
      case Vo:
        Le(g, T, K, q);
        break;
      case cn:
        ne(g, T, K, q);
        break;
      case ki:
        g == null && se(T, K, q, X);
        break;
      case Ie:
        pt(
          g,
          T,
          K,
          q,
          B,
          U,
          X,
          Y,
          z
        );
        break;
      default:
        Q & 1 ? be(
          g,
          T,
          K,
          q,
          B,
          U,
          X,
          Y,
          z
        ) : Q & 6 ? ht(
          g,
          T,
          K,
          q,
          B,
          U,
          X,
          Y,
          z
        ) : (Q & 64 || Q & 128) && F.process(
          g,
          T,
          K,
          q,
          B,
          U,
          X,
          Y,
          z,
          hn
        );
    }
    ce != null && B ? Pr(ce, g && g.ref, U, T || g, !T) : ce == null && g && g.ref != null && Pr(g.ref, null, U, g, !0);
  }, Le = (g, T, K, q) => {
    if (g == null)
      i(
        T.el = d(T.children),
        K,
        q
      );
    else {
      const B = T.el = g.el;
      T.children !== g.children && C(B, T.children);
    }
  }, ne = (g, T, K, q) => {
    g == null ? i(
      T.el = h(T.children || ""),
      K,
      q
    ) : T.el = g.el;
  }, se = (g, T, K, q) => {
    [g.el, g.anchor] = L(
      g.children,
      T,
      K,
      q,
      g.el,
      g.anchor
    );
  }, de = ({ el: g, anchor: T }, K, q) => {
    let B;
    for (; g && g !== T; )
      B = x(g), i(g, K, q), g = B;
    i(T, K, q);
  }, ae = ({ el: g, anchor: T }) => {
    let K;
    for (; g && g !== T; )
      K = x(g), s(g), g = K;
    s(T);
  }, be = (g, T, K, q, B, U, X, Y, z) => {
    T.type === "svg" ? X = "svg" : T.type === "math" && (X = "mathml"), g == null ? Ne(
      T,
      K,
      q,
      B,
      U,
      X,
      Y,
      z
    ) : me(
      g,
      T,
      B,
      U,
      X,
      Y,
      z
    );
  }, Ne = (g, T, K, q, B, U, X, Y) => {
    let z, F;
    const { props: ce, shapeFlag: Q, transition: ue, dirs: pe } = g;
    if (z = g.el = c(
      g.type,
      U,
      ce && ce.is,
      ce
    ), Q & 8 ? y(z, g.children) : Q & 16 && ye(
      g.children,
      z,
      null,
      q,
      B,
      Di(g, U),
      X,
      Y
    ), pe && $n(g, null, q, "created"), Se(z, g, g.scopeId, X, q), ce) {
      for (const Re in ce)
        Re !== "value" && !Nr(Re) && u(z, Re, null, ce[Re], U, q);
      "value" in ce && u(z, "value", null, ce.value, U), (F = ce.onVnodeBeforeMount) && Ht(F, q, g);
    }
    pe && $n(g, null, q, "beforeMount");
    const xe = cf(B, ue);
    xe && ue.beforeEnter(z), i(z, T, K), ((F = ce && ce.onVnodeMounted) || xe || pe) && Ot(() => {
      F && Ht(F, q, g), xe && ue.enter(z), pe && $n(g, null, q, "mounted");
    }, B);
  }, Se = (g, T, K, q, B) => {
    if (K && w(g, K), q)
      for (let U = 0; U < q.length; U++)
        w(g, q[U]);
    if (B) {
      let U = B.subTree;
      if (T === U || Yl(U.type) && (U.ssContent === T || U.ssFallback === T)) {
        const X = B.vnode;
        Se(
          g,
          X,
          X.scopeId,
          X.slotScopeIds,
          B.parent
        );
      }
    }
  }, ye = (g, T, K, q, B, U, X, Y, z = 0) => {
    for (let F = z; F < g.length; F++) {
      const ce = g[F] = Y ? Sn(g[F]) : zt(g[F]);
      re(
        null,
        ce,
        T,
        K,
        q,
        B,
        U,
        X,
        Y
      );
    }
  }, me = (g, T, K, q, B, U, X) => {
    const Y = T.el = g.el;
    let { patchFlag: z, dynamicChildren: F, dirs: ce } = T;
    z |= g.patchFlag & 16;
    const Q = g.props || Ke, ue = T.props || Ke;
    let pe;
    if (K && Kn(K, !1), (pe = ue.onVnodeBeforeUpdate) && Ht(pe, K, T, g), ce && $n(T, g, K, "beforeUpdate"), K && Kn(K, !0), (Q.innerHTML && ue.innerHTML == null || Q.textContent && ue.textContent == null) && y(Y, ""), F ? $e(
      g.dynamicChildren,
      F,
      Y,
      K,
      q,
      Di(T, B),
      U
    ) : X || Pe(
      g,
      T,
      Y,
      null,
      K,
      q,
      Di(T, B),
      U,
      !1
    ), z > 0) {
      if (z & 16)
        rt(Y, Q, ue, K, B);
      else if (z & 2 && Q.class !== ue.class && u(Y, "class", null, ue.class, B), z & 4 && u(Y, "style", Q.style, ue.style, B), z & 8) {
        const xe = T.dynamicProps;
        for (let Re = 0; Re < xe.length; Re++) {
          const ke = xe[Re], et = Q[ke], ot = ue[ke];
          (ot !== et || ke === "value") && u(Y, ke, et, ot, B, K);
        }
      }
      z & 1 && g.children !== T.children && y(Y, T.children);
    } else !X && F == null && rt(Y, Q, ue, K, B);
    ((pe = ue.onVnodeUpdated) || ce) && Ot(() => {
      pe && Ht(pe, K, T, g), ce && $n(T, g, K, "updated");
    }, q);
  }, $e = (g, T, K, q, B, U, X) => {
    for (let Y = 0; Y < T.length; Y++) {
      const z = g[Y], F = T[Y], ce = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        z.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (z.type === Ie || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Sr(z, F) || // - In the case of a component, it could contain anything.
        z.shapeFlag & 198) ? b(z.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          K
        )
      );
      re(
        z,
        F,
        ce,
        null,
        q,
        B,
        U,
        X,
        !0
      );
    }
  }, rt = (g, T, K, q, B) => {
    if (T !== K) {
      if (T !== Ke)
        for (const U in T)
          !Nr(U) && !(U in K) && u(
            g,
            U,
            T[U],
            null,
            B,
            q
          );
      for (const U in K) {
        if (Nr(U)) continue;
        const X = K[U], Y = T[U];
        X !== Y && U !== "value" && u(g, U, Y, X, B, q);
      }
      "value" in K && u(g, "value", T.value, K.value, B);
    }
  }, pt = (g, T, K, q, B, U, X, Y, z) => {
    const F = T.el = g ? g.el : d(""), ce = T.anchor = g ? g.anchor : d("");
    let { patchFlag: Q, dynamicChildren: ue, slotScopeIds: pe } = T;
    pe && (Y = Y ? Y.concat(pe) : pe), g == null ? (i(F, K, q), i(ce, K, q), ye(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      T.children || [],
      K,
      ce,
      B,
      U,
      X,
      Y,
      z
    )) : Q > 0 && Q & 64 && ue && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    g.dynamicChildren ? ($e(
      g.dynamicChildren,
      ue,
      K,
      B,
      U,
      X,
      Y
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (T.key != null || B && T === B.subTree) && bs(
      g,
      T,
      !0
      /* shallow */
    )) : Pe(
      g,
      T,
      K,
      ce,
      B,
      U,
      X,
      Y,
      z
    );
  }, ht = (g, T, K, q, B, U, X, Y, z) => {
    T.slotScopeIds = Y, g == null ? T.shapeFlag & 512 ? B.ctx.activate(
      T,
      K,
      q,
      X,
      z
    ) : Pn(
      T,
      K,
      q,
      B,
      U,
      X,
      z
    ) : dn(g, T, z);
  }, Pn = (g, T, K, q, B, U, X) => {
    const Y = g.component = Ef(
      g,
      q,
      B
    );
    if (Pl(g) && (Y.ctx.renderer = hn), Pf(Y, !1, X), Y.asyncDep) {
      if (B && B.registerDep(Y, qe, X), !g.el) {
        const z = Y.subTree = tt(cn);
        ne(null, z, T, K);
      }
    } else
      qe(
        Y,
        g,
        T,
        K,
        B,
        U,
        X
      );
  }, dn = (g, T, K) => {
    const q = T.component = g.component;
    if (bf(g, T, K))
      if (q.asyncDep && !q.asyncResolved) {
        Oe(q, T, K);
        return;
      } else
        q.next = T, q.update();
    else
      T.el = g.el, q.vnode = T;
  }, qe = (g, T, K, q, B, U, X) => {
    const Y = () => {
      if (g.isMounted) {
        let { next: Q, bu: ue, u: pe, parent: xe, vnode: Re } = g;
        {
          const it = Hl(g);
          if (it) {
            Q && (Q.el = Re.el, Oe(g, Q, X)), it.asyncDep.then(() => {
              g.isUnmounted || Y();
            });
            return;
          }
        }
        let ke = Q, et;
        Kn(g, !1), Q ? (Q.el = Re.el, Oe(g, Q, X)) : Q = Re, ue && _o(ue), (et = Q.props && Q.props.onVnodeBeforeUpdate) && Ht(et, xe, Q, Re), Kn(g, !0);
        const ot = ga(g), xt = g.subTree;
        g.subTree = ot, re(
          xt,
          ot,
          // parent may have changed if it's in a teleport
          b(xt.el),
          // anchor may have changed if it's in a fragment
          pn(xt),
          g,
          B,
          U
        ), Q.el = ot.el, ke === null && _f(g, ot.el), pe && Ot(pe, B), (et = Q.props && Q.props.onVnodeUpdated) && Ot(
          () => Ht(et, xe, Q, Re),
          B
        );
      } else {
        let Q;
        const { el: ue, props: pe } = T, { bm: xe, m: Re, parent: ke, root: et, type: ot } = g, xt = lr(T);
        Kn(g, !1), xe && _o(xe), !xt && (Q = pe && pe.onVnodeBeforeMount) && Ht(Q, ke, T), Kn(g, !0);
        {
          et.ce && // @ts-expect-error _def is private
          et.ce._def.shadowRoot !== !1 && et.ce._injectChildStyle(ot);
          const it = g.subTree = ga(g);
          re(
            null,
            it,
            K,
            q,
            g,
            B,
            U
          ), T.el = it.el;
        }
        if (Re && Ot(Re, B), !xt && (Q = pe && pe.onVnodeMounted)) {
          const it = T;
          Ot(
            () => Ht(Q, ke, it),
            B
          );
        }
        (T.shapeFlag & 256 || ke && lr(ke.vnode) && ke.vnode.shapeFlag & 256) && g.a && Ot(g.a, B), g.isMounted = !0, T = K = q = null;
      }
    };
    g.scope.on();
    const z = g.effect = new tl(Y);
    g.scope.off();
    const F = g.update = z.run.bind(z), ce = g.job = z.runIfDirty.bind(z);
    ce.i = g, ce.id = g.uid, z.scheduler = () => hs(ce), Kn(g, !0), F();
  }, Oe = (g, T, K) => {
    T.component = g;
    const q = g.vnode.props;
    g.vnode = T, g.next = null, nf(g, T.props, q, K), af(g, T.children, K), ln(), sa(g), un();
  }, Pe = (g, T, K, q, B, U, X, Y, z = !1) => {
    const F = g && g.children, ce = g ? g.shapeFlag : 0, Q = T.children, { patchFlag: ue, shapeFlag: pe } = T;
    if (ue > 0) {
      if (ue & 128) {
        Et(
          F,
          Q,
          K,
          q,
          B,
          U,
          X,
          Y,
          z
        );
        return;
      } else if (ue & 256) {
        Tt(
          F,
          Q,
          K,
          q,
          B,
          U,
          X,
          Y,
          z
        );
        return;
      }
    }
    pe & 8 ? (ce & 16 && Dt(F, B, U), Q !== F && y(K, Q)) : ce & 16 ? pe & 16 ? Et(
      F,
      Q,
      K,
      q,
      B,
      U,
      X,
      Y,
      z
    ) : Dt(F, B, U, !0) : (ce & 8 && y(K, ""), pe & 16 && ye(
      Q,
      K,
      q,
      B,
      U,
      X,
      Y,
      z
    ));
  }, Tt = (g, T, K, q, B, U, X, Y, z) => {
    g = g || ir, T = T || ir;
    const F = g.length, ce = T.length, Q = Math.min(F, ce);
    let ue;
    for (ue = 0; ue < Q; ue++) {
      const pe = T[ue] = z ? Sn(T[ue]) : zt(T[ue]);
      re(
        g[ue],
        pe,
        K,
        null,
        B,
        U,
        X,
        Y,
        z
      );
    }
    F > ce ? Dt(
      g,
      B,
      U,
      !0,
      !1,
      Q
    ) : ye(
      T,
      K,
      q,
      B,
      U,
      X,
      Y,
      z,
      Q
    );
  }, Et = (g, T, K, q, B, U, X, Y, z) => {
    let F = 0;
    const ce = T.length;
    let Q = g.length - 1, ue = ce - 1;
    for (; F <= Q && F <= ue; ) {
      const pe = g[F], xe = T[F] = z ? Sn(T[F]) : zt(T[F]);
      if (Sr(pe, xe))
        re(
          pe,
          xe,
          K,
          null,
          B,
          U,
          X,
          Y,
          z
        );
      else
        break;
      F++;
    }
    for (; F <= Q && F <= ue; ) {
      const pe = g[Q], xe = T[ue] = z ? Sn(T[ue]) : zt(T[ue]);
      if (Sr(pe, xe))
        re(
          pe,
          xe,
          K,
          null,
          B,
          U,
          X,
          Y,
          z
        );
      else
        break;
      Q--, ue--;
    }
    if (F > Q) {
      if (F <= ue) {
        const pe = ue + 1, xe = pe < ce ? T[pe].el : q;
        for (; F <= ue; )
          re(
            null,
            T[F] = z ? Sn(T[F]) : zt(T[F]),
            K,
            xe,
            B,
            U,
            X,
            Y,
            z
          ), F++;
      }
    } else if (F > ue)
      for (; F <= Q; )
        Rt(g[F], B, U, !0), F++;
    else {
      const pe = F, xe = F, Re = /* @__PURE__ */ new Map();
      for (F = xe; F <= ue; F++) {
        const Ge = T[F] = z ? Sn(T[F]) : zt(T[F]);
        Ge.key != null && Re.set(Ge.key, F);
      }
      let ke, et = 0;
      const ot = ue - xe + 1;
      let xt = !1, it = 0;
      const qt = new Array(ot);
      for (F = 0; F < ot; F++) qt[F] = 0;
      for (F = pe; F <= Q; F++) {
        const Ge = g[F];
        if (et >= ot) {
          Rt(Ge, B, U, !0);
          continue;
        }
        let oe;
        if (Ge.key != null)
          oe = Re.get(Ge.key);
        else
          for (ke = xe; ke <= ue; ke++)
            if (qt[ke - xe] === 0 && Sr(Ge, T[ke])) {
              oe = ke;
              break;
            }
        oe === void 0 ? Rt(Ge, B, U, !0) : (qt[oe - xe] = F + 1, oe >= it ? it = oe : xt = !0, re(
          Ge,
          T[oe],
          K,
          null,
          B,
          U,
          X,
          Y,
          z
        ), et++);
      }
      const zn = xt ? ff(qt) : ir;
      for (ke = zn.length - 1, F = ot - 1; F >= 0; F--) {
        const Ge = xe + F, oe = T[Ge], mn = Ge + 1 < ce ? T[Ge + 1].el : q;
        qt[F] === 0 ? re(
          null,
          oe,
          K,
          mn,
          B,
          U,
          X,
          Y,
          z
        ) : xt && (ke < 0 || F !== zn[ke] ? jt(oe, K, mn, 2) : ke--);
      }
    }
  }, jt = (g, T, K, q, B = null) => {
    const { el: U, type: X, transition: Y, children: z, shapeFlag: F } = g;
    if (F & 6) {
      jt(g.component.subTree, T, K, q);
      return;
    }
    if (F & 128) {
      g.suspense.move(T, K, q);
      return;
    }
    if (F & 64) {
      X.move(g, T, K, hn);
      return;
    }
    if (X === Ie) {
      i(U, T, K);
      for (let Q = 0; Q < z.length; Q++)
        jt(z[Q], T, K, q);
      i(g.anchor, T, K);
      return;
    }
    if (X === ki) {
      de(g, T, K);
      return;
    }
    if (q !== 2 && F & 1 && Y)
      if (q === 0)
        Y.beforeEnter(U), i(U, T, K), Ot(() => Y.enter(U), B);
      else {
        const { leave: Q, delayLeave: ue, afterLeave: pe } = Y, xe = () => {
          g.ctx.isUnmounted ? s(U) : i(U, T, K);
        }, Re = () => {
          Q(U, () => {
            xe(), pe && pe();
          });
        };
        ue ? ue(U, xe, Re) : Re();
      }
    else
      i(U, T, K);
  }, Rt = (g, T, K, q = !1, B = !1) => {
    const {
      type: U,
      props: X,
      ref: Y,
      children: z,
      dynamicChildren: F,
      shapeFlag: ce,
      patchFlag: Q,
      dirs: ue,
      cacheIndex: pe
    } = g;
    if (Q === -2 && (B = !1), Y != null && (ln(), Pr(Y, null, K, g, !0), un()), pe != null && (T.renderCache[pe] = void 0), ce & 256) {
      T.ctx.deactivate(g);
      return;
    }
    const xe = ce & 1 && ue, Re = !lr(g);
    let ke;
    if (Re && (ke = X && X.onVnodeBeforeUnmount) && Ht(ke, T, g), ce & 6)
      Wn(g.component, K, q);
    else {
      if (ce & 128) {
        g.suspense.unmount(K, q);
        return;
      }
      xe && $n(g, null, T, "beforeUnmount"), ce & 64 ? g.type.remove(
        g,
        T,
        K,
        hn,
        q
      ) : F && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !F.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (U !== Ie || Q > 0 && Q & 64) ? Dt(
        F,
        T,
        K,
        !1,
        !0
      ) : (U === Ie && Q & 384 || !B && ce & 16) && Dt(z, T, K), q && Jt(g);
    }
    (Re && (ke = X && X.onVnodeUnmounted) || xe) && Ot(() => {
      ke && Ht(ke, T, g), xe && $n(g, null, T, "unmounted");
    }, K);
  }, Jt = (g) => {
    const { type: T, el: K, anchor: q, transition: B } = g;
    if (T === Ie) {
      Vr(K, q);
      return;
    }
    if (T === ki) {
      ae(g);
      return;
    }
    const U = () => {
      s(K), B && !B.persisted && B.afterLeave && B.afterLeave();
    };
    if (g.shapeFlag & 1 && B && !B.persisted) {
      const { leave: X, delayLeave: Y } = B, z = () => X(K, U);
      Y ? Y(g.el, U, z) : z();
    } else
      U();
  }, Vr = (g, T) => {
    let K;
    for (; g !== T; )
      K = x(g), s(g), g = K;
    s(T);
  }, Wn = (g, T, K) => {
    const {
      bum: q,
      scope: B,
      job: U,
      subTree: X,
      um: Y,
      m: z,
      a: F,
      parent: ce,
      slots: { __: Q }
    } = g;
    ya(z), ya(F), q && _o(q), ce && he(Q) && Q.forEach((ue) => {
      ce.renderCache[ue] = void 0;
    }), B.stop(), U && (U.flags |= 8, Rt(X, g, T, K)), Y && Ot(Y, T), Ot(() => {
      g.isUnmounted = !0;
    }, T), T && T.pendingBranch && !T.isUnmounted && g.asyncDep && !g.asyncResolved && g.suspenseId === T.pendingId && (T.deps--, T.deps === 0 && T.resolve());
  }, Dt = (g, T, K, q = !1, B = !1, U = 0) => {
    for (let X = U; X < g.length; X++)
      Rt(g[X], T, K, q, B);
  }, pn = (g) => {
    if (g.shapeFlag & 6)
      return pn(g.component.subTree);
    if (g.shapeFlag & 128)
      return g.suspense.next();
    const T = x(g.anchor || g.el), K = T && T[Sl];
    return K ? x(K) : T;
  };
  let dr = !1;
  const le = (g, T, K) => {
    g == null ? T._vnode && Rt(T._vnode, null, null, !0) : re(
      T._vnode || null,
      g,
      T,
      null,
      null,
      null,
      K
    ), T._vnode = g, dr || (dr = !0, sa(), wl(), dr = !1);
  }, hn = {
    p: re,
    um: Rt,
    m: jt,
    r: Jt,
    mt: Pn,
    mc: ye,
    pc: Pe,
    pbc: $e,
    n: pn,
    o: e
  };
  return {
    render: le,
    hydrate: void 0,
    createApp: Xc(le)
  };
}
function Di({ type: e, props: t }, r) {
  return r === "svg" && e === "foreignObject" || r === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : r;
}
function Kn({ effect: e, job: t }, r) {
  r ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5);
}
function cf(e, t) {
  return (!e || e && !e.pendingBranch) && t && !t.persisted;
}
function bs(e, t, r = !1) {
  const i = e.children, s = t.children;
  if (he(i) && he(s))
    for (let u = 0; u < i.length; u++) {
      const c = i[u];
      let d = s[u];
      d.shapeFlag & 1 && !d.dynamicChildren && ((d.patchFlag <= 0 || d.patchFlag === 32) && (d = s[u] = Sn(s[u]), d.el = c.el), !r && d.patchFlag !== -2 && bs(c, d)), d.type === Vo && (d.el = c.el), d.type === cn && !d.el && (d.el = c.el);
    }
}
function ff(e) {
  const t = e.slice(), r = [0];
  let i, s, u, c, d;
  const h = e.length;
  for (i = 0; i < h; i++) {
    const C = e[i];
    if (C !== 0) {
      if (s = r[r.length - 1], e[s] < C) {
        t[i] = s, r.push(i);
        continue;
      }
      for (u = 0, c = r.length - 1; u < c; )
        d = u + c >> 1, e[r[d]] < C ? u = d + 1 : c = d;
      C < e[r[u]] && (u > 0 && (t[i] = r[u - 1]), r[u] = i);
    }
  }
  for (u = r.length, c = r[u - 1]; u-- > 0; )
    r[u] = c, c = t[c];
  return r;
}
function Hl(e) {
  const t = e.subTree.component;
  if (t)
    return t.asyncDep && !t.asyncResolved ? t : Hl(t);
}
function ya(e) {
  if (e)
    for (let t = 0; t < e.length; t++)
      e[t].flags |= 8;
}
const df = Symbol.for("v-scx"), pf = () => Dr(df);
function Wl(e, t) {
  return _s(e, null, t);
}
function an(e, t, r) {
  return _s(e, t, r);
}
function _s(e, t, r = Ke) {
  const { immediate: i, deep: s, flush: u, once: c } = r, d = _t({}, r), h = t && i || !t && u !== "post";
  let C;
  if (Kr) {
    if (u === "sync") {
      const w = pf();
      C = w.__watcherHandles || (w.__watcherHandles = []);
    } else if (!h) {
      const w = () => {
      };
      return w.stop = Yt, w.resume = Yt, w.pause = Yt, w;
    }
  }
  const y = ft;
  d.call = (w, L, re) => Qt(w, y, L, re);
  let b = !1;
  u === "post" ? d.scheduler = (w) => {
    Ot(w, y && y.suspense);
  } : u !== "sync" && (b = !0, d.scheduler = (w, L) => {
    L ? w() : hs(w);
  }), d.augmentJob = (w) => {
    t && (w.flags |= 4), b && (w.flags |= 2, y && (w.id = y.uid, w.i = y));
  };
  const x = Tc(e, t, d);
  return Kr && (C ? C.push(x) : h && x()), x;
}
function hf(e, t, r) {
  const i = this.proxy, s = Ze(e) ? e.includes(".") ? zl(i, e) : () => i[e] : e.bind(i, i);
  let u;
  _e(t) ? u = t : (u = t.handler, r = t);
  const c = qr(this), d = _s(s, u.bind(i), r);
  return c(), d;
}
function zl(e, t) {
  const r = t.split(".");
  return () => {
    let i = e;
    for (let s = 0; s < r.length && i; s++)
      i = i[r[s]];
    return i;
  };
}
const mf = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${Nn(t)}Modifiers`] || e[`${Hn(t)}Modifiers`];
function yf(e, t, ...r) {
  if (e.isUnmounted) return;
  const i = e.vnode.props || Ke;
  let s = r;
  const u = t.startsWith("update:"), c = u && mf(i, t.slice(7));
  c && (c.trim && (s = r.map((y) => Ze(y) ? y.trim() : y)), c.number && (s = r.map(No)));
  let d, h = i[d = Ni(t)] || // also try camelCase event handler (#2249)
  i[d = Ni(Nn(t))];
  !h && u && (h = i[d = Ni(Hn(t))]), h && Qt(
    h,
    e,
    6,
    s
  );
  const C = i[d + "Once"];
  if (C) {
    if (!e.emitted)
      e.emitted = {};
    else if (e.emitted[d])
      return;
    e.emitted[d] = !0, Qt(
      C,
      e,
      6,
      s
    );
  }
}
function Gl(e, t, r = !1) {
  const i = t.emitsCache, s = i.get(e);
  if (s !== void 0)
    return s;
  const u = e.emits;
  let c = {}, d = !1;
  if (!_e(e)) {
    const h = (C) => {
      const y = Gl(C, t, !0);
      y && (d = !0, _t(c, y));
    };
    !r && t.mixins.length && t.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h);
  }
  return !u && !d ? (Be(e) && i.set(e, null), null) : (he(u) ? u.forEach((h) => c[h] = null) : _t(c, u), Be(e) && i.set(e, c), c);
}
function Uo(e, t) {
  return !e || !jo(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), Me(e, t[0].toLowerCase() + t.slice(1)) || Me(e, Hn(t)) || Me(e, t));
}
function ga(e) {
  const {
    type: t,
    vnode: r,
    proxy: i,
    withProxy: s,
    propsOptions: [u],
    slots: c,
    attrs: d,
    emit: h,
    render: C,
    renderCache: y,
    props: b,
    data: x,
    setupState: w,
    ctx: L,
    inheritAttrs: re
  } = e, Le = Ro(e);
  let ne, se;
  try {
    if (r.shapeFlag & 4) {
      const ae = s || i, be = ae;
      ne = zt(
        C.call(
          be,
          ae,
          y,
          b,
          w,
          x,
          L
        )
      ), se = d;
    } else {
      const ae = t;
      ne = zt(
        ae.length > 1 ? ae(
          b,
          { attrs: d, slots: c, emit: h }
        ) : ae(
          b,
          null
        )
      ), se = t.props ? d : gf(d);
    }
  } catch (ae) {
    kr.length = 0, Bo(ae, e, 1), ne = tt(cn);
  }
  let de = ne;
  if (se && re !== !1) {
    const ae = Object.keys(se), { shapeFlag: be } = de;
    ae.length && be & 7 && (u && ae.some(es) && (se = vf(
      se,
      u
    )), de = ur(de, se, !1, !0));
  }
  return r.dirs && (de = ur(de, null, !1, !0), de.dirs = de.dirs ? de.dirs.concat(r.dirs) : r.dirs), r.transition && ms(de, r.transition), ne = de, Ro(Le), ne;
}
const gf = (e) => {
  let t;
  for (const r in e)
    (r === "class" || r === "style" || jo(r)) && ((t || (t = {}))[r] = e[r]);
  return t;
}, vf = (e, t) => {
  const r = {};
  for (const i in e)
    (!es(i) || !(i.slice(9) in t)) && (r[i] = e[i]);
  return r;
};
function bf(e, t, r) {
  const { props: i, children: s, component: u } = e, { props: c, children: d, patchFlag: h } = t, C = u.emitsOptions;
  if (t.dirs || t.transition)
    return !0;
  if (r && h >= 0) {
    if (h & 1024)
      return !0;
    if (h & 16)
      return i ? va(i, c, C) : !!c;
    if (h & 8) {
      const y = t.dynamicProps;
      for (let b = 0; b < y.length; b++) {
        const x = y[b];
        if (c[x] !== i[x] && !Uo(C, x))
          return !0;
      }
    }
  } else
    return (s || d) && (!d || !d.$stable) ? !0 : i === c ? !1 : i ? c ? va(i, c, C) : !0 : !!c;
  return !1;
}
function va(e, t, r) {
  const i = Object.keys(t);
  if (i.length !== Object.keys(e).length)
    return !0;
  for (let s = 0; s < i.length; s++) {
    const u = i[s];
    if (t[u] !== e[u] && !Uo(r, u))
      return !0;
  }
  return !1;
}
function _f({ vnode: e, parent: t }, r) {
  for (; t; ) {
    const i = t.subTree;
    if (i.suspense && i.suspense.activeBranch === e && (i.el = e.el), i === e)
      (e = t.vnode).el = r, t = t.parent;
    else
      break;
  }
}
const Yl = (e) => e.__isSuspense;
function wf(e, t) {
  t && t.pendingBranch ? he(e) ? t.effects.push(...e) : t.effects.push(e) : Pc(e);
}
const Ie = Symbol.for("v-fgt"), Vo = Symbol.for("v-txt"), cn = Symbol.for("v-cmt"), ki = Symbol.for("v-stc"), kr = [];
let Pt = null;
function ie(e = !1) {
  kr.push(Pt = e ? null : []);
}
function xf() {
  kr.pop(), Pt = kr[kr.length - 1] || null;
}
let $r = 1;
function ba(e, t = !1) {
  $r += e, e < 0 && Pt && t && (Pt.hasOnce = !0);
}
function Ql(e) {
  return e.dynamicChildren = $r > 0 ? Pt || ir : null, xf(), $r > 0 && Pt && Pt.push(e), e;
}
function fe(e, t, r, i, s, u) {
  return Ql(
    O(
      e,
      t,
      r,
      i,
      s,
      u,
      !0
    )
  );
}
function Mt(e, t, r, i, s) {
  return Ql(
    tt(
      e,
      t,
      r,
      i,
      s,
      !0
    )
  );
}
function ws(e) {
  return e ? e.__v_isVNode === !0 : !1;
}
function Sr(e, t) {
  return e.type === t.type && e.key === t.key;
}
const Jl = ({ key: e }) => e ?? null, xo = ({
  ref: e,
  ref_key: t,
  ref_for: r
}) => (typeof e == "number" && (e = "" + e), e != null ? Ze(e) || ze(e) || _e(e) ? { i: ut, r: e, k: t, f: !!r } : e : null);
function O(e, t = null, r = null, i = 0, s = null, u = e === Ie ? 0 : 1, c = !1, d = !1) {
  const h = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e,
    props: t,
    key: t && Jl(t),
    ref: t && xo(t),
    scopeId: Cl,
    slotScopeIds: null,
    children: r,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: u,
    patchFlag: i,
    dynamicProps: s,
    dynamicChildren: null,
    appContext: null,
    ctx: ut
  };
  return d ? (xs(h, r), u & 128 && e.normalize(h)) : r && (h.shapeFlag |= Ze(r) ? 8 : 16), $r > 0 && // avoid a block node from tracking itself
  !c && // has current parent block
  Pt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (h.patchFlag > 0 || u & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  h.patchFlag !== 32 && Pt.push(h), h;
}
const tt = Cf;
function Cf(e, t = null, r = null, i = 0, s = null, u = !1) {
  if ((!e || e === Vc) && (e = cn), ws(e)) {
    const d = ur(
      e,
      t,
      !0
      /* mergeRef: true */
    );
    return r && xs(d, r), $r > 0 && !u && Pt && (d.shapeFlag & 6 ? Pt[Pt.indexOf(e)] = d : Pt.push(d)), d.patchFlag = -2, d;
  }
  if (If(e) && (e = e.__vccOpts), t) {
    t = Sf(t);
    let { class: d, style: h } = t;
    d && !Ze(d) && (t.class = Un(d)), Be(h) && (fs(h) && !he(h) && (h = _t({}, h)), t.style = rs(h));
  }
  const c = Ze(e) ? 1 : Yl(e) ? 128 : Rc(e) ? 64 : Be(e) ? 4 : _e(e) ? 2 : 0;
  return O(
    e,
    t,
    r,
    i,
    s,
    c,
    u,
    !0
  );
}
function Sf(e) {
  return e ? fs(e) || Kl(e) ? _t({}, e) : e : null;
}
function ur(e, t, r = !1, i = !1) {
  const { props: s, ref: u, patchFlag: c, children: d, transition: h } = e, C = t ? Of(s || {}, t) : s, y = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: C,
    key: C && Jl(C),
    ref: t && t.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      r && u ? he(u) ? u.concat(xo(t)) : [u, xo(t)] : xo(t)
    ) : u,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: d,
    target: e.target,
    targetStart: e.targetStart,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: t && e.type !== Ie ? c === -1 ? 16 : c | 16 : c,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: h,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && ur(e.ssContent),
    ssFallback: e.ssFallback && ur(e.ssFallback),
    el: e.el,
    anchor: e.anchor,
    ctx: e.ctx,
    ce: e.ce
  };
  return h && i && ms(
    y,
    h.clone(y)
  ), y;
}
function Xl(e = " ", t = 0) {
  return tt(Vo, null, e, t);
}
function $t(e = "", t = !1) {
  return t ? (ie(), Mt(cn, null, e)) : tt(cn, null, e);
}
function zt(e) {
  return e == null || typeof e == "boolean" ? tt(cn) : he(e) ? tt(
    Ie,
    null,
    // #3666, avoid reference pollution when reusing vnode
    e.slice()
  ) : ws(e) ? Sn(e) : tt(Vo, null, String(e));
}
function Sn(e) {
  return e.el === null && e.patchFlag !== -1 || e.memo ? e : ur(e);
}
function xs(e, t) {
  let r = 0;
  const { shapeFlag: i } = e;
  if (t == null)
    t = null;
  else if (he(t))
    r = 16;
  else if (typeof t == "object")
    if (i & 65) {
      const s = t.default;
      s && (s._c && (s._d = !1), xs(e, s()), s._c && (s._d = !0));
      return;
    } else {
      r = 32;
      const s = t._;
      !s && !Kl(t) ? t._ctx = ut : s === 3 && ut && (ut.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024));
    }
  else _e(t) ? (t = { default: t, _ctx: ut }, r = 32) : (t = String(t), i & 64 ? (r = 16, t = [Xl(t)]) : r = 8);
  e.children = t, e.shapeFlag |= r;
}
function Of(...e) {
  const t = {};
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    for (const s in i)
      if (s === "class")
        t.class !== i.class && (t.class = Un([t.class, i.class]));
      else if (s === "style")
        t.style = rs([t.style, i.style]);
      else if (jo(s)) {
        const u = t[s], c = i[s];
        c && u !== c && !(he(u) && u.includes(c)) && (t[s] = u ? [].concat(u, c) : c);
      } else s !== "" && (t[s] = i[s]);
  }
  return t;
}
function Ht(e, t, r, i = null) {
  Qt(e, t, 7, [
    r,
    i
  ]);
}
const Nf = jl();
let Tf = 0;
function Ef(e, t, r) {
  const i = e.type, s = (t ? t.appContext : e.appContext) || Nf, u = {
    uid: Tf++,
    vnode: e,
    type: i,
    parent: t,
    appContext: s,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Xa(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: t ? t.provides : Object.create(s.provides),
    ids: t ? t.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Bl(i, s),
    emitsOptions: Gl(i, s),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Ke,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: Ke,
    data: Ke,
    props: Ke,
    attrs: Ke,
    slots: Ke,
    refs: Ke,
    setupState: Ke,
    setupContext: null,
    // suspense related
    suspense: r,
    suspenseId: r ? r.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return u.ctx = { _: u }, u.root = t ? t.root : u, u.emit = yf.bind(null, u), e.ce && e.ce(u), u;
}
let ft = null;
const Af = () => ft || ut;
let ko, Gi;
{
  const e = $o(), t = (r, i) => {
    let s;
    return (s = e[r]) || (s = e[r] = []), s.push(i), (u) => {
      s.length > 1 ? s.forEach((c) => c(u)) : s[0](u);
    };
  };
  ko = t(
    "__VUE_INSTANCE_SETTERS__",
    (r) => ft = r
  ), Gi = t(
    "__VUE_SSR_SETTERS__",
    (r) => Kr = r
  );
}
const qr = (e) => {
  const t = ft;
  return ko(e), e.scope.on(), () => {
    e.scope.off(), ko(t);
  };
}, _a = () => {
  ft && ft.scope.off(), ko(null);
};
function Zl(e) {
  return e.vnode.shapeFlag & 4;
}
let Kr = !1;
function Pf(e, t = !1, r = !1) {
  t && Gi(t);
  const { props: i, children: s } = e.vnode, u = Zl(e);
  tf(e, i, u, t), sf(e, s, r || t);
  const c = u ? Rf(e, t) : void 0;
  return t && Gi(!1), c;
}
function Rf(e, t) {
  const r = e.type;
  e.accessCache = /* @__PURE__ */ Object.create(null), e.proxy = new Proxy(e.ctx, Hc);
  const { setup: i } = r;
  if (i) {
    ln();
    const s = e.setupContext = i.length > 1 ? kf(e) : null, u = qr(e), c = Br(
      i,
      e,
      0,
      [
        e.props,
        s
      ]
    ), d = Ha(c);
    if (un(), u(), (d || e.sp) && !lr(e) && El(e), d) {
      if (c.then(_a, _a), t)
        return c.then((h) => {
          wa(e, h);
        }).catch((h) => {
          Bo(h, e, 0);
        });
      e.asyncDep = c;
    } else
      wa(e, c);
  } else
    eu(e);
}
function wa(e, t, r) {
  _e(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Be(t) && (e.setupState = gl(t)), eu(e);
}
function eu(e, t, r) {
  const i = e.type;
  e.render || (e.render = i.render || Yt);
  {
    const s = qr(e);
    ln();
    try {
      Wc(e);
    } finally {
      un(), s();
    }
  }
}
const Df = {
  get(e, t) {
    return bt(e, "get", ""), e[t];
  }
};
function kf(e) {
  const t = (r) => {
    e.exposed = r || {};
  };
  return {
    attrs: new Proxy(e.attrs, Df),
    slots: e.slots,
    emit: e.emit,
    expose: t
  };
}
function Ho(e) {
  return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(gl(ds(e.exposed)), {
    get(t, r) {
      if (r in t)
        return t[r];
      if (r in Rr)
        return Rr[r](e);
    },
    has(t, r) {
      return r in t || r in Rr;
    }
  })) : e.proxy;
}
function If(e) {
  return _e(e) && "__vccOpts" in e;
}
const lt = (e, t) => Oc(e, t, Kr), Lf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Yi;
const xa = typeof window < "u" && window.trustedTypes;
if (xa)
  try {
    Yi = /* @__PURE__ */ xa.createPolicy("vue", {
      createHTML: (e) => e
    });
  } catch {
  }
const tu = Yi ? (e) => Yi.createHTML(e) : (e) => e, jf = "http://www.w3.org/2000/svg", Mf = "http://www.w3.org/1998/Math/MathML", tn = typeof document < "u" ? document : null, Ca = tn && /* @__PURE__ */ tn.createElement("template"), $f = {
  insert: (e, t, r) => {
    t.insertBefore(e, r || null);
  },
  remove: (e) => {
    const t = e.parentNode;
    t && t.removeChild(e);
  },
  createElement: (e, t, r, i) => {
    const s = t === "svg" ? tn.createElementNS(jf, e) : t === "mathml" ? tn.createElementNS(Mf, e) : r ? tn.createElement(e, { is: r }) : tn.createElement(e);
    return e === "select" && i && i.multiple != null && s.setAttribute("multiple", i.multiple), s;
  },
  createText: (e) => tn.createTextNode(e),
  createComment: (e) => tn.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t;
  },
  setElementText: (e, t) => {
    e.textContent = t;
  },
  parentNode: (e) => e.parentNode,
  nextSibling: (e) => e.nextSibling,
  querySelector: (e) => tn.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(e, t, r, i, s, u) {
    const c = r ? r.previousSibling : t.lastChild;
    if (s && (s === u || s.nextSibling))
      for (; t.insertBefore(s.cloneNode(!0), r), !(s === u || !(s = s.nextSibling)); )
        ;
    else {
      Ca.innerHTML = tu(
        i === "svg" ? `<svg>${e}</svg>` : i === "mathml" ? `<math>${e}</math>` : e
      );
      const d = Ca.content;
      if (i === "svg" || i === "mathml") {
        const h = d.firstChild;
        for (; h.firstChild; )
          d.appendChild(h.firstChild);
        d.removeChild(h);
      }
      t.insertBefore(d, r);
    }
    return [
      // first
      c ? c.nextSibling : t.firstChild,
      // last
      r ? r.previousSibling : t.lastChild
    ];
  }
}, Kf = Symbol("_vtc");
function Ff(e, t, r) {
  const i = e[Kf];
  i && (t = (t ? [t, ...i] : [...i]).join(" ")), t == null ? e.removeAttribute("class") : r ? e.setAttribute("class", t) : e.className = t;
}
const Sa = Symbol("_vod"), Bf = Symbol("_vsh"), qf = Symbol(""), Uf = /(^|;)\s*display\s*:/;
function Vf(e, t, r) {
  const i = e.style, s = Ze(r);
  let u = !1;
  if (r && !s) {
    if (t)
      if (Ze(t))
        for (const c of t.split(";")) {
          const d = c.slice(0, c.indexOf(":")).trim();
          r[d] == null && Co(i, d, "");
        }
      else
        for (const c in t)
          r[c] == null && Co(i, c, "");
    for (const c in r)
      c === "display" && (u = !0), Co(i, c, r[c]);
  } else if (s) {
    if (t !== r) {
      const c = i[qf];
      c && (r += ";" + c), i.cssText = r, u = Uf.test(r);
    }
  } else t && e.removeAttribute("style");
  Sa in e && (e[Sa] = u ? i.display : "", e[Bf] && (i.display = "none"));
}
const Oa = /\s*!important$/;
function Co(e, t, r) {
  if (he(r))
    r.forEach((i) => Co(e, t, i));
  else if (r == null && (r = ""), t.startsWith("--"))
    e.setProperty(t, r);
  else {
    const i = Hf(e, t);
    Oa.test(r) ? e.setProperty(
      Hn(i),
      r.replace(Oa, ""),
      "important"
    ) : e[i] = r;
  }
}
const Na = ["Webkit", "Moz", "ms"], Ii = {};
function Hf(e, t) {
  const r = Ii[t];
  if (r)
    return r;
  let i = Nn(t);
  if (i !== "filter" && i in e)
    return Ii[t] = i;
  i = Ga(i);
  for (let s = 0; s < Na.length; s++) {
    const u = Na[s] + i;
    if (u in e)
      return Ii[t] = u;
  }
  return t;
}
const Ta = "http://www.w3.org/1999/xlink";
function Ea(e, t, r, i, s, u = Gu(t)) {
  i && t.startsWith("xlink:") ? r == null ? e.removeAttributeNS(Ta, t.slice(6, t.length)) : e.setAttributeNS(Ta, t, r) : r == null || u && !Ya(r) ? e.removeAttribute(t) : e.setAttribute(
    t,
    u ? "" : Bt(r) ? String(r) : r
  );
}
function Aa(e, t, r, i, s) {
  if (t === "innerHTML" || t === "textContent") {
    r != null && (e[t] = t === "innerHTML" ? tu(r) : r);
    return;
  }
  const u = e.tagName;
  if (t === "value" && u !== "PROGRESS" && // custom elements may use _value internally
  !u.includes("-")) {
    const d = u === "OPTION" ? e.getAttribute("value") || "" : e.value, h = r == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      e.type === "checkbox" ? "on" : ""
    ) : String(r);
    (d !== h || !("_value" in e)) && (e.value = h), r == null && e.removeAttribute(t), e._value = r;
    return;
  }
  let c = !1;
  if (r === "" || r == null) {
    const d = typeof e[t];
    d === "boolean" ? r = Ya(r) : r == null && d === "string" ? (r = "", c = !0) : d === "number" && (r = 0, c = !0);
  }
  try {
    e[t] = r;
  } catch {
  }
  c && e.removeAttribute(s || t);
}
function on(e, t, r, i) {
  e.addEventListener(t, r, i);
}
function Wf(e, t, r, i) {
  e.removeEventListener(t, r, i);
}
const Pa = Symbol("_vei");
function zf(e, t, r, i, s = null) {
  const u = e[Pa] || (e[Pa] = {}), c = u[t];
  if (i && c)
    c.value = i;
  else {
    const [d, h] = Gf(t);
    if (i) {
      const C = u[t] = Jf(
        i,
        s
      );
      on(e, d, C, h);
    } else c && (Wf(e, d, c, h), u[t] = void 0);
  }
}
const Ra = /(?:Once|Passive|Capture)$/;
function Gf(e) {
  let t;
  if (Ra.test(e)) {
    t = {};
    let i;
    for (; i = e.match(Ra); )
      e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0;
  }
  return [e[2] === ":" ? e.slice(3) : Hn(e.slice(2)), t];
}
let Li = 0;
const Yf = /* @__PURE__ */ Promise.resolve(), Qf = () => Li || (Yf.then(() => Li = 0), Li = Date.now());
function Jf(e, t) {
  const r = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= r.attached)
      return;
    Qt(
      Xf(i, r.value),
      t,
      5,
      [i]
    );
  };
  return r.value = e, r.attached = Qf(), r;
}
function Xf(e, t) {
  if (he(t)) {
    const r = e.stopImmediatePropagation;
    return e.stopImmediatePropagation = () => {
      r.call(e), e._stopped = !0;
    }, t.map(
      (i) => (s) => !s._stopped && i && i(s)
    );
  } else
    return t;
}
const Da = (e) => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && // lowercase letter
e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, Zf = (e, t, r, i, s, u) => {
  const c = s === "svg";
  t === "class" ? Ff(e, i, c) : t === "style" ? Vf(e, r, i) : jo(t) ? es(t) || zf(e, t, r, i, u) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : ed(e, t, i, c)) ? (Aa(e, t, i), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && Ea(e, t, i, c, u, t !== "value")) : /* #11081 force set props for possible async custom element */ e._isVueCE && (/[A-Z]/.test(t) || !Ze(i)) ? Aa(e, Nn(t), i, u, t) : (t === "true-value" ? e._trueValue = i : t === "false-value" && (e._falseValue = i), Ea(e, t, i, c));
};
function ed(e, t, r, i) {
  if (i)
    return !!(t === "innerHTML" || t === "textContent" || t in e && Da(t) && _e(r));
  if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "autocorrect" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA")
    return !1;
  if (t === "width" || t === "height") {
    const s = e.tagName;
    if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE")
      return !1;
  }
  return Da(t) && Ze(r) ? !1 : t in e;
}
const En = (e) => {
  const t = e.props["onUpdate:modelValue"] || !1;
  return he(t) ? (r) => _o(t, r) : t;
};
function td(e) {
  e.target.composing = !0;
}
function ka(e) {
  const t = e.target;
  t.composing && (t.composing = !1, t.dispatchEvent(new Event("input")));
}
const Lt = Symbol("_assign"), An = {
  created(e, { modifiers: { lazy: t, trim: r, number: i } }, s) {
    e[Lt] = En(s);
    const u = i || s.props && s.props.type === "number";
    on(e, t ? "change" : "input", (c) => {
      if (c.target.composing) return;
      let d = e.value;
      r && (d = d.trim()), u && (d = No(d)), e[Lt](d);
    }), r && on(e, "change", () => {
      e.value = e.value.trim();
    }), t || (on(e, "compositionstart", td), on(e, "compositionend", ka), on(e, "change", ka));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(e, { value: t }) {
    e.value = t ?? "";
  },
  beforeUpdate(e, { value: t, oldValue: r, modifiers: { lazy: i, trim: s, number: u } }, c) {
    if (e[Lt] = En(c), e.composing) return;
    const d = (u || e.type === "number") && !/^0\d/.test(e.value) ? No(e.value) : e.value, h = t ?? "";
    d !== h && (document.activeElement === e && e.type !== "range" && (i && t === r || s && e.value.trim() === h) || (e.value = h));
  }
}, Ia = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(e, t, r) {
    e[Lt] = En(r), on(e, "change", () => {
      const i = e._modelValue, s = cr(e), u = e.checked, c = e[Lt];
      if (he(i)) {
        const d = os(i, s), h = d !== -1;
        if (u && !h)
          c(i.concat(s));
        else if (!u && h) {
          const C = [...i];
          C.splice(d, 1), c(C);
        }
      } else if (fr(i)) {
        const d = new Set(i);
        u ? d.add(s) : d.delete(s), c(d);
      } else
        c(nu(e, u));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: La,
  beforeUpdate(e, t, r) {
    e[Lt] = En(r), La(e, t, r);
  }
};
function La(e, { value: t, oldValue: r }, i) {
  e._modelValue = t;
  let s;
  if (he(t))
    s = os(t, i.props.value) > -1;
  else if (fr(t))
    s = t.has(i.props.value);
  else {
    if (t === r) return;
    s = Vn(t, nu(e, !0));
  }
  e.checked !== s && (e.checked = s);
}
const ja = {
  created(e, { value: t }, r) {
    e.checked = Vn(t, r.props.value), e[Lt] = En(r), on(e, "change", () => {
      e[Lt](cr(e));
    });
  },
  beforeUpdate(e, { value: t, oldValue: r }, i) {
    e[Lt] = En(i), t !== r && (e.checked = Vn(t, i.props.value));
  }
}, Kt = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(e, { value: t, modifiers: { number: r } }, i) {
    const s = fr(t);
    on(e, "change", () => {
      const u = Array.prototype.filter.call(e.options, (c) => c.selected).map(
        (c) => r ? No(cr(c)) : cr(c)
      );
      e[Lt](
        e.multiple ? s ? new Set(u) : u : u[0]
      ), e._assigning = !0, ps(() => {
        e._assigning = !1;
      });
    }), e[Lt] = En(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(e, { value: t }) {
    Ma(e, t);
  },
  beforeUpdate(e, t, r) {
    e[Lt] = En(r);
  },
  updated(e, { value: t }) {
    e._assigning || Ma(e, t);
  }
};
function Ma(e, t) {
  const r = e.multiple, i = he(t);
  if (!(r && !i && !fr(t))) {
    for (let s = 0, u = e.options.length; s < u; s++) {
      const c = e.options[s], d = cr(c);
      if (r)
        if (i) {
          const h = typeof d;
          h === "string" || h === "number" ? c.selected = t.some((C) => String(C) === String(d)) : c.selected = os(t, d) > -1;
        } else
          c.selected = t.has(d);
      else if (Vn(cr(c), t)) {
        e.selectedIndex !== s && (e.selectedIndex = s);
        return;
      }
    }
    !r && e.selectedIndex !== -1 && (e.selectedIndex = -1);
  }
}
function cr(e) {
  return "_value" in e ? e._value : e.value;
}
function nu(e, t) {
  const r = t ? "_trueValue" : "_falseValue";
  return r in e ? e[r] : t;
}
const nd = /* @__PURE__ */ _t({ patchProp: Zf }, $f);
let $a;
function rd() {
  return $a || ($a = lf(nd));
}
const od = (...e) => {
  const t = rd().createApp(...e), { mount: r } = t;
  return t.mount = (i) => {
    const s = sd(i);
    if (!s) return;
    const u = t._component;
    !_e(u) && !u.render && !u.template && (u.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
    const c = r(s, !1, id(s));
    return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), c;
  }, t;
};
function id(e) {
  if (e instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && e instanceof MathMLElement)
    return "mathml";
}
function sd(e) {
  return Ze(e) ? document.querySelector(e) : e;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let ru;
const Wo = (e) => ru = e, ou = (
  /* istanbul ignore next */
  Symbol()
);
function Qi(e) {
  return e && typeof e == "object" && Object.prototype.toString.call(e) === "[object Object]" && typeof e.toJSON != "function";
}
var Ir;
(function(e) {
  e.direct = "direct", e.patchObject = "patch object", e.patchFunction = "patch function";
})(Ir || (Ir = {}));
function ad() {
  const e = Za(!0), t = e.run(() => Qe({}));
  let r = [], i = [];
  const s = ds({
    install(u) {
      Wo(s), s._a = u, u.provide(ou, s), u.config.globalProperties.$pinia = s, i.forEach((c) => r.push(c)), i = [];
    },
    use(u) {
      return this._a ? r.push(u) : i.push(u), this;
    },
    _p: r,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: e,
    _s: /* @__PURE__ */ new Map(),
    state: t
  });
  return s;
}
const iu = () => {
};
function Ka(e, t, r, i = iu) {
  e.push(t);
  const s = () => {
    const u = e.indexOf(t);
    u > -1 && (e.splice(u, 1), i());
  };
  return !r && el() && Qu(s), s;
}
function rr(e, ...t) {
  e.slice().forEach((r) => {
    r(...t);
  });
}
const ld = (e) => e(), Fa = Symbol(), ji = Symbol();
function Ji(e, t) {
  e instanceof Map && t instanceof Map ? t.forEach((r, i) => e.set(i, r)) : e instanceof Set && t instanceof Set && t.forEach(e.add, e);
  for (const r in t) {
    if (!t.hasOwnProperty(r))
      continue;
    const i = t[r], s = e[r];
    Qi(s) && Qi(i) && e.hasOwnProperty(r) && !ze(i) && !sn(i) ? e[r] = Ji(s, i) : e[r] = i;
  }
  return e;
}
const ud = (
  /* istanbul ignore next */
  Symbol()
);
function cd(e) {
  return !Qi(e) || !Object.prototype.hasOwnProperty.call(e, ud);
}
const { assign: xn } = Object;
function fd(e) {
  return !!(ze(e) && e.effect);
}
function dd(e, t, r, i) {
  const { state: s, actions: u, getters: c } = t, d = r.state.value[e];
  let h;
  function C() {
    d || (r.state.value[e] = s ? s() : {});
    const y = _c(r.state.value[e]);
    return xn(y, u, Object.keys(c || {}).reduce((b, x) => (b[x] = ds(lt(() => {
      Wo(r);
      const w = r._s.get(e);
      return c[x].call(w, w);
    })), b), {}));
  }
  return h = su(e, C, t, r, i, !0), h;
}
function su(e, t, r = {}, i, s, u) {
  let c;
  const d = xn({ actions: {} }, r), h = { deep: !0 };
  let C, y, b = [], x = [], w;
  const L = i.state.value[e];
  !u && !L && (i.state.value[e] = {}), Qe({});
  let re;
  function Le(ye) {
    let me;
    C = y = !1, typeof ye == "function" ? (ye(i.state.value[e]), me = {
      type: Ir.patchFunction,
      storeId: e,
      events: w
    }) : (Ji(i.state.value[e], ye), me = {
      type: Ir.patchObject,
      payload: ye,
      storeId: e,
      events: w
    });
    const $e = re = Symbol();
    ps().then(() => {
      re === $e && (C = !0);
    }), y = !0, rr(b, me, i.state.value[e]);
  }
  const ne = u ? function() {
    const { state: me } = r, $e = me ? me() : {};
    this.$patch((rt) => {
      xn(rt, $e);
    });
  } : (
    /* istanbul ignore next */
    iu
  );
  function se() {
    c.stop(), b = [], x = [], i._s.delete(e);
  }
  const de = (ye, me = "") => {
    if (Fa in ye)
      return ye[ji] = me, ye;
    const $e = function() {
      Wo(i);
      const rt = Array.from(arguments), pt = [], ht = [];
      function Pn(Oe) {
        pt.push(Oe);
      }
      function dn(Oe) {
        ht.push(Oe);
      }
      rr(x, {
        args: rt,
        name: $e[ji],
        store: be,
        after: Pn,
        onError: dn
      });
      let qe;
      try {
        qe = ye.apply(this && this.$id === e ? this : be, rt);
      } catch (Oe) {
        throw rr(ht, Oe), Oe;
      }
      return qe instanceof Promise ? qe.then((Oe) => (rr(pt, Oe), Oe)).catch((Oe) => (rr(ht, Oe), Promise.reject(Oe))) : (rr(pt, qe), qe);
    };
    return $e[Fa] = !0, $e[ji] = me, $e;
  }, ae = {
    _p: i,
    // _s: scope,
    $id: e,
    $onAction: Ka.bind(null, x),
    $patch: Le,
    $reset: ne,
    $subscribe(ye, me = {}) {
      const $e = Ka(b, ye, me.detached, () => rt()), rt = c.run(() => an(() => i.state.value[e], (pt) => {
        (me.flush === "sync" ? y : C) && ye({
          storeId: e,
          type: Ir.direct,
          events: w
        }, pt);
      }, xn({}, h, me)));
      return $e;
    },
    $dispose: se
  }, be = Fo(ae);
  i._s.set(e, be);
  const Se = (i._a && i._a.runWithContext || ld)(() => i._e.run(() => (c = Za()).run(() => t({ action: de }))));
  for (const ye in Se) {
    const me = Se[ye];
    if (ze(me) && !fd(me) || sn(me))
      u || (L && cd(me) && (ze(me) ? me.value = L[ye] : Ji(me, L[ye])), i.state.value[e][ye] = me);
    else if (typeof me == "function") {
      const $e = de(me, ye);
      Se[ye] = $e, d.actions[ye] = me;
    }
  }
  return xn(be, Se), xn(Ae(be), Se), Object.defineProperty(be, "$state", {
    get: () => i.state.value[e],
    set: (ye) => {
      Le((me) => {
        xn(me, ye);
      });
    }
  }), i._p.forEach((ye) => {
    xn(be, c.run(() => ye({
      store: be,
      app: i._a,
      pinia: i,
      options: d
    })));
  }), L && u && r.hydrate && r.hydrate(be.$state, L), C = !0, y = !0, be;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function pd(e, t, r) {
  let i;
  const s = typeof t == "function";
  i = s ? r : t;
  function u(c, d) {
    const h = ef();
    return c = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    c || (h ? Dr(ou, null) : null), c && Wo(c), c = ru, c._s.has(e) || (s ? su(e, t, i, c) : dd(e, i, c)), c._s.get(e);
  }
  return u.$id = e, u;
}
function au(e) {
  const t = Ae(e), r = {};
  for (const i in t) {
    const s = t[i];
    s.effect ? r[i] = // ...
    lt({
      get: () => e[i],
      set(u) {
        e[i] = u;
      }
    }) : (ze(s) || sn(s)) && (r[i] = // ---
    Cc(e, i));
  }
  return r;
}
var hd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function md(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var So = { exports: {} }, yd = So.exports, Ba;
function gd() {
  return Ba || (Ba = 1, function(e, t) {
    (function(r, i) {
      e.exports = i();
    })(yd, function() {
      var r = function(n, o) {
        return (r = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(a, l) {
          a.__proto__ = l;
        } || function(a, l) {
          for (var f in l) Object.prototype.hasOwnProperty.call(l, f) && (a[f] = l[f]);
        })(n, o);
      }, i = function() {
        return (i = Object.assign || function(n) {
          for (var o, a = 1, l = arguments.length; a < l; a++) for (var f in o = arguments[a]) Object.prototype.hasOwnProperty.call(o, f) && (n[f] = o[f]);
          return n;
        }).apply(this, arguments);
      };
      function s(n, o, a) {
        for (var l, f = 0, p = o.length; f < p; f++) !l && f in o || ((l = l || Array.prototype.slice.call(o, 0, f))[f] = o[f]);
        return n.concat(l || Array.prototype.slice.call(o));
      }
      var u = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : hd, c = Object.keys, d = Array.isArray;
      function h(n, o) {
        return typeof o != "object" || c(o).forEach(function(a) {
          n[a] = o[a];
        }), n;
      }
      typeof Promise > "u" || u.Promise || (u.Promise = Promise);
      var C = Object.getPrototypeOf, y = {}.hasOwnProperty;
      function b(n, o) {
        return y.call(n, o);
      }
      function x(n, o) {
        typeof o == "function" && (o = o(C(n))), (typeof Reflect > "u" ? c : Reflect.ownKeys)(o).forEach(function(a) {
          L(n, a, o[a]);
        });
      }
      var w = Object.defineProperty;
      function L(n, o, a, l) {
        w(n, o, h(a && b(a, "get") && typeof a.get == "function" ? { get: a.get, set: a.set, configurable: !0 } : { value: a, configurable: !0, writable: !0 }, l));
      }
      function re(n) {
        return { from: function(o) {
          return n.prototype = Object.create(o.prototype), L(n.prototype, "constructor", n), { extend: x.bind(null, n.prototype) };
        } };
      }
      var Le = Object.getOwnPropertyDescriptor, ne = [].slice;
      function se(n, o, a) {
        return ne.call(n, o, a);
      }
      function de(n, o) {
        return o(n);
      }
      function ae(n) {
        if (!n) throw new Error("Assertion Failed");
      }
      function be(n) {
        u.setImmediate ? setImmediate(n) : setTimeout(n, 0);
      }
      function Ne(n, o) {
        if (typeof o == "string" && b(n, o)) return n[o];
        if (!o) return n;
        if (typeof o != "string") {
          for (var a = [], l = 0, f = o.length; l < f; ++l) {
            var p = Ne(n, o[l]);
            a.push(p);
          }
          return a;
        }
        var m = o.indexOf(".");
        if (m !== -1) {
          var v = n[o.substr(0, m)];
          return v == null ? void 0 : Ne(v, o.substr(m + 1));
        }
      }
      function Se(n, o, a) {
        if (n && o !== void 0 && !("isFrozen" in Object && Object.isFrozen(n))) if (typeof o != "string" && "length" in o) {
          ae(typeof a != "string" && "length" in a);
          for (var l = 0, f = o.length; l < f; ++l) Se(n, o[l], a[l]);
        } else {
          var p, m, v = o.indexOf(".");
          v !== -1 ? (p = o.substr(0, v), (m = o.substr(v + 1)) === "" ? a === void 0 ? d(n) && !isNaN(parseInt(p)) ? n.splice(p, 1) : delete n[p] : n[p] = a : Se(v = !(v = n[p]) || !b(n, p) ? n[p] = {} : v, m, a)) : a === void 0 ? d(n) && !isNaN(parseInt(o)) ? n.splice(o, 1) : delete n[o] : n[o] = a;
        }
      }
      function ye(n) {
        var o, a = {};
        for (o in n) b(n, o) && (a[o] = n[o]);
        return a;
      }
      var me = [].concat;
      function $e(n) {
        return me.apply([], n);
      }
      var xe = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat($e([8, 16, 32, 64].map(function(n) {
        return ["Int", "Uint", "Float"].map(function(o) {
          return o + n + "Array";
        });
      }))).filter(function(n) {
        return u[n];
      }), rt = new Set(xe.map(function(n) {
        return u[n];
      })), pt = null;
      function ht(n) {
        return pt = /* @__PURE__ */ new WeakMap(), n = function o(a) {
          if (!a || typeof a != "object") return a;
          var l = pt.get(a);
          if (l) return l;
          if (d(a)) {
            l = [], pt.set(a, l);
            for (var f = 0, p = a.length; f < p; ++f) l.push(o(a[f]));
          } else if (rt.has(a.constructor)) l = a;
          else {
            var m, v = C(a);
            for (m in l = v === Object.prototype ? {} : Object.create(v), pt.set(a, l), a) b(a, m) && (l[m] = o(a[m]));
          }
          return l;
        }(n), pt = null, n;
      }
      var Pn = {}.toString;
      function dn(n) {
        return Pn.call(n).slice(8, -1);
      }
      var qe = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Oe = typeof qe == "symbol" ? function(n) {
        var o;
        return n != null && (o = n[qe]) && o.apply(n);
      } : function() {
        return null;
      };
      function Pe(n, o) {
        return o = n.indexOf(o), 0 <= o && n.splice(o, 1), 0 <= o;
      }
      var Tt = {};
      function Et(n) {
        var o, a, l, f;
        if (arguments.length === 1) {
          if (d(n)) return n.slice();
          if (this === Tt && typeof n == "string") return [n];
          if (f = Oe(n)) {
            for (a = []; !(l = f.next()).done; ) a.push(l.value);
            return a;
          }
          if (n == null) return [n];
          if (typeof (o = n.length) != "number") return [n];
          for (a = new Array(o); o--; ) a[o] = n[o];
          return a;
        }
        for (o = arguments.length, a = new Array(o); o--; ) a[o] = arguments[o];
        return a;
      }
      var jt = typeof Symbol < "u" ? function(n) {
        return n[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], kt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(pe), Rt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Jt(n, o) {
        this.name = n, this.message = o;
      }
      function Vr(n, o) {
        return n + ". Errors: " + Object.keys(o).map(function(a) {
          return o[a].toString();
        }).filter(function(a, l, f) {
          return f.indexOf(a) === l;
        }).join(`
`);
      }
      function Wn(n, o, a, l) {
        this.failures = o, this.failedKeys = l, this.successCount = a, this.message = Vr(n, o);
      }
      function Dt(n, o) {
        this.name = "BulkError", this.failures = Object.keys(o).map(function(a) {
          return o[a];
        }), this.failuresByPos = o, this.message = Vr(n, this.failures);
      }
      re(Jt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), re(Wn).from(Jt), re(Dt).from(Jt);
      var pn = kt.reduce(function(n, o) {
        return n[o] = o + "Error", n;
      }, {}), dr = Jt, le = kt.reduce(function(n, o) {
        var a = o + "Error";
        function l(f, p) {
          this.name = a, f ? typeof f == "string" ? (this.message = "".concat(f).concat(p ? `
 ` + p : ""), this.inner = p || null) : typeof f == "object" && (this.message = "".concat(f.name, " ").concat(f.message), this.inner = f) : (this.message = Rt[o] || a, this.inner = null);
        }
        return re(l).from(dr), n[o] = l, n;
      }, {});
      le.Syntax = SyntaxError, le.Type = TypeError, le.Range = RangeError;
      var hn = pe.reduce(function(n, o) {
        return n[o + "Error"] = le[o], n;
      }, {}), pr = kt.reduce(function(n, o) {
        return ["Syntax", "Type", "Range"].indexOf(o) === -1 && (n[o + "Error"] = le[o]), n;
      }, {});
      function g() {
      }
      function T(n) {
        return n;
      }
      function K(n, o) {
        return n == null || n === T ? o : function(a) {
          return o(n(a));
        };
      }
      function q(n, o) {
        return function() {
          n.apply(this, arguments), o.apply(this, arguments);
        };
      }
      function B(n, o) {
        return n === g ? o : function() {
          var a = n.apply(this, arguments);
          a !== void 0 && (arguments[0] = a);
          var l = this.onsuccess, f = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var p = o.apply(this, arguments);
          return l && (this.onsuccess = this.onsuccess ? q(l, this.onsuccess) : l), f && (this.onerror = this.onerror ? q(f, this.onerror) : f), p !== void 0 ? p : a;
        };
      }
      function U(n, o) {
        return n === g ? o : function() {
          n.apply(this, arguments);
          var a = this.onsuccess, l = this.onerror;
          this.onsuccess = this.onerror = null, o.apply(this, arguments), a && (this.onsuccess = this.onsuccess ? q(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? q(l, this.onerror) : l);
        };
      }
      function X(n, o) {
        return n === g ? o : function(a) {
          var l = n.apply(this, arguments);
          h(a, l);
          var f = this.onsuccess, p = this.onerror;
          return this.onsuccess = null, this.onerror = null, a = o.apply(this, arguments), f && (this.onsuccess = this.onsuccess ? q(f, this.onsuccess) : f), p && (this.onerror = this.onerror ? q(p, this.onerror) : p), l === void 0 ? a === void 0 ? void 0 : a : h(l, a);
        };
      }
      function Y(n, o) {
        return n === g ? o : function() {
          return o.apply(this, arguments) !== !1 && n.apply(this, arguments);
        };
      }
      function z(n, o) {
        return n === g ? o : function() {
          var a = n.apply(this, arguments);
          if (a && typeof a.then == "function") {
            for (var l = this, f = arguments.length, p = new Array(f); f--; ) p[f] = arguments[f];
            return a.then(function() {
              return o.apply(l, p);
            });
          }
          return o.apply(this, arguments);
        };
      }
      pr.ModifyError = Wn, pr.DexieError = Jt, pr.BulkError = Dt;
      var F = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function ce(n) {
        F = n;
      }
      var Q = {}, ue = 100, xe = typeof Promise > "u" ? [] : function() {
        var n = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [n, C(n), n];
        var o = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [o, C(o), n];
      }(), pe = xe[0], kt = xe[1], xe = xe[2], kt = kt && kt.then, Re = pe && pe.constructor, ke = !!xe, et = function(n, o) {
        mn.push([n, o]), xt && (queueMicrotask(hu), xt = !1);
      }, ot = !0, xt = !0, it = [], qt = [], zn = T, Ge = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: g, pgp: !1, env: {}, finalize: g }, oe = Ge, mn = [], Rn = 0, Hr = [];
      function ee(n) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var o = this._PSD = oe;
        if (typeof n != "function") {
          if (n !== Q) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Qo(this, this._value));
        }
        this._state = null, this._value = null, ++o.ref, function a(l, f) {
          try {
            f(function(p) {
              if (l._state === null) {
                if (p === l) throw new TypeError("A promise cannot be resolved with itself.");
                var m = l._lib && Gn();
                p && typeof p.then == "function" ? a(l, function(v, S) {
                  p instanceof ee ? p._then(v, S) : p.then(v, S);
                }) : (l._state = !0, l._value = p, Os(l)), m && Yn();
              }
            }, Qo.bind(null, l));
          } catch (p) {
            Qo(l, p);
          }
        }(this, n);
      }
      var Yo = { get: function() {
        var n = oe, o = Yr;
        function a(l, f) {
          var p = this, m = !n.global && (n !== oe || o !== Yr), v = m && !gn(), S = new ee(function(E, P) {
            Jo(p, new Ss(Ts(l, n, m, v), Ts(f, n, m, v), E, P, n));
          });
          return this._consoleTask && (S._consoleTask = this._consoleTask), S;
        }
        return a.prototype = Q, a;
      }, set: function(n) {
        L(this, "then", n && n.prototype === Q ? Yo : { get: function() {
          return n;
        }, set: Yo.set });
      } };
      function Ss(n, o, a, l, f) {
        this.onFulfilled = typeof n == "function" ? n : null, this.onRejected = typeof o == "function" ? o : null, this.resolve = a, this.reject = l, this.psd = f;
      }
      function Qo(n, o) {
        var a, l;
        qt.push(o), n._state === null && (a = n._lib && Gn(), o = zn(o), n._state = !1, n._value = o, l = n, it.some(function(f) {
          return f._value === l._value;
        }) || it.push(l), Os(n), a && Yn());
      }
      function Os(n) {
        var o = n._listeners;
        n._listeners = [];
        for (var a = 0, l = o.length; a < l; ++a) Jo(n, o[a]);
        var f = n._PSD;
        --f.ref || f.finalize(), Rn === 0 && (++Rn, et(function() {
          --Rn == 0 && Xo();
        }, []));
      }
      function Jo(n, o) {
        if (n._state !== null) {
          var a = n._state ? o.onFulfilled : o.onRejected;
          if (a === null) return (n._state ? o.resolve : o.reject)(n._value);
          ++o.psd.ref, ++Rn, et(pu, [a, n, o]);
        } else n._listeners.push(o);
      }
      function pu(n, o, a) {
        try {
          var l, f = o._value;
          !o._state && qt.length && (qt = []), l = F && o._consoleTask ? o._consoleTask.run(function() {
            return n(f);
          }) : n(f), o._state || qt.indexOf(f) !== -1 || function(p) {
            for (var m = it.length; m; ) if (it[--m]._value === p._value) return it.splice(m, 1);
          }(o), a.resolve(l);
        } catch (p) {
          a.reject(p);
        } finally {
          --Rn == 0 && Xo(), --a.psd.ref || a.psd.finalize();
        }
      }
      function hu() {
        Dn(Ge, function() {
          Gn() && Yn();
        });
      }
      function Gn() {
        var n = ot;
        return xt = ot = !1, n;
      }
      function Yn() {
        var n, o, a;
        do
          for (; 0 < mn.length; ) for (n = mn, mn = [], a = n.length, o = 0; o < a; ++o) {
            var l = n[o];
            l[0].apply(null, l[1]);
          }
        while (0 < mn.length);
        xt = ot = !0;
      }
      function Xo() {
        var n = it;
        it = [], n.forEach(function(l) {
          l._PSD.onunhandled.call(null, l._value, l);
        });
        for (var o = Hr.slice(0), a = o.length; a; ) o[--a]();
      }
      function Wr(n) {
        return new ee(Q, !1, n);
      }
      function Ve(n, o) {
        var a = oe;
        return function() {
          var l = Gn(), f = oe;
          try {
            return vn(a, !0), n.apply(this, arguments);
          } catch (p) {
            o && o(p);
          } finally {
            vn(f, !1), l && Yn();
          }
        };
      }
      x(ee.prototype, { then: Yo, _then: function(n, o) {
        Jo(this, new Ss(null, null, n, o, oe));
      }, catch: function(n) {
        if (arguments.length === 1) return this.then(null, n);
        var o = n, a = arguments[1];
        return typeof o == "function" ? this.then(null, function(l) {
          return (l instanceof o ? a : Wr)(l);
        }) : this.then(null, function(l) {
          return (l && l.name === o ? a : Wr)(l);
        });
      }, finally: function(n) {
        return this.then(function(o) {
          return ee.resolve(n()).then(function() {
            return o;
          });
        }, function(o) {
          return ee.resolve(n()).then(function() {
            return Wr(o);
          });
        });
      }, timeout: function(n, o) {
        var a = this;
        return n < 1 / 0 ? new ee(function(l, f) {
          var p = setTimeout(function() {
            return f(new le.Timeout(o));
          }, n);
          a.then(l, f).finally(clearTimeout.bind(null, p));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && L(ee.prototype, Symbol.toStringTag, "Dexie.Promise"), Ge.env = Ns(), x(ee, { all: function() {
        var n = Et.apply(null, arguments).map(Qr);
        return new ee(function(o, a) {
          n.length === 0 && o([]);
          var l = n.length;
          n.forEach(function(f, p) {
            return ee.resolve(f).then(function(m) {
              n[p] = m, --l || o(n);
            }, a);
          });
        });
      }, resolve: function(n) {
        return n instanceof ee ? n : n && typeof n.then == "function" ? new ee(function(o, a) {
          n.then(o, a);
        }) : new ee(Q, !0, n);
      }, reject: Wr, race: function() {
        var n = Et.apply(null, arguments).map(Qr);
        return new ee(function(o, a) {
          n.map(function(l) {
            return ee.resolve(l).then(o, a);
          });
        });
      }, PSD: { get: function() {
        return oe;
      }, set: function(n) {
        return oe = n;
      } }, totalEchoes: { get: function() {
        return Yr;
      } }, newPSD: yn, usePSD: Dn, scheduler: { get: function() {
        return et;
      }, set: function(n) {
        et = n;
      } }, rejectionMapper: { get: function() {
        return zn;
      }, set: function(n) {
        zn = n;
      } }, follow: function(n, o) {
        return new ee(function(a, l) {
          return yn(function(f, p) {
            var m = oe;
            m.unhandleds = [], m.onunhandled = p, m.finalize = q(function() {
              var v, S = this;
              v = function() {
                S.unhandleds.length === 0 ? f() : p(S.unhandleds[0]);
              }, Hr.push(function E() {
                v(), Hr.splice(Hr.indexOf(E), 1);
              }), ++Rn, et(function() {
                --Rn == 0 && Xo();
              }, []);
            }, m.finalize), n();
          }, o, a, l);
        });
      } }), Re && (Re.allSettled && L(ee, "allSettled", function() {
        var n = Et.apply(null, arguments).map(Qr);
        return new ee(function(o) {
          n.length === 0 && o([]);
          var a = n.length, l = new Array(a);
          n.forEach(function(f, p) {
            return ee.resolve(f).then(function(m) {
              return l[p] = { status: "fulfilled", value: m };
            }, function(m) {
              return l[p] = { status: "rejected", reason: m };
            }).then(function() {
              return --a || o(l);
            });
          });
        });
      }), Re.any && typeof AggregateError < "u" && L(ee, "any", function() {
        var n = Et.apply(null, arguments).map(Qr);
        return new ee(function(o, a) {
          n.length === 0 && a(new AggregateError([]));
          var l = n.length, f = new Array(l);
          n.forEach(function(p, m) {
            return ee.resolve(p).then(function(v) {
              return o(v);
            }, function(v) {
              f[m] = v, --l || a(new AggregateError(f));
            });
          });
        });
      }), Re.withResolvers && (ee.withResolvers = Re.withResolvers));
      var st = { awaits: 0, echoes: 0, id: 0 }, mu = 0, zr = [], Gr = 0, Yr = 0, yu = 0;
      function yn(n, o, a, l) {
        var f = oe, p = Object.create(f);
        return p.parent = f, p.ref = 0, p.global = !1, p.id = ++yu, Ge.env, p.env = ke ? { Promise: ee, PromiseProp: { value: ee, configurable: !0, writable: !0 }, all: ee.all, race: ee.race, allSettled: ee.allSettled, any: ee.any, resolve: ee.resolve, reject: ee.reject } : {}, o && h(p, o), ++f.ref, p.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, l = Dn(p, n, a, l), p.ref === 0 && p.finalize(), l;
      }
      function Qn() {
        return st.id || (st.id = ++mu), ++st.awaits, st.echoes += ue, st.id;
      }
      function gn() {
        return !!st.awaits && (--st.awaits == 0 && (st.id = 0), st.echoes = st.awaits * ue, !0);
      }
      function Qr(n) {
        return st.echoes && n && n.constructor === Re ? (Qn(), n.then(function(o) {
          return gn(), o;
        }, function(o) {
          return gn(), Je(o);
        })) : n;
      }
      function gu() {
        var n = zr[zr.length - 1];
        zr.pop(), vn(n, !1);
      }
      function vn(n, o) {
        var a, l = oe;
        (o ? !st.echoes || Gr++ && n === oe : !Gr || --Gr && n === oe) || queueMicrotask(o ? (function(f) {
          ++Yr, st.echoes && --st.echoes != 0 || (st.echoes = st.awaits = st.id = 0), zr.push(oe), vn(f, !0);
        }).bind(null, n) : gu), n !== oe && (oe = n, l === Ge && (Ge.env = Ns()), ke && (a = Ge.env.Promise, o = n.env, (l.global || n.global) && (Object.defineProperty(u, "Promise", o.PromiseProp), a.all = o.all, a.race = o.race, a.resolve = o.resolve, a.reject = o.reject, o.allSettled && (a.allSettled = o.allSettled), o.any && (a.any = o.any))));
      }
      function Ns() {
        var n = u.Promise;
        return ke ? { Promise: n, PromiseProp: Object.getOwnPropertyDescriptor(u, "Promise"), all: n.all, race: n.race, allSettled: n.allSettled, any: n.any, resolve: n.resolve, reject: n.reject } : {};
      }
      function Dn(n, o, a, l, f) {
        var p = oe;
        try {
          return vn(n, !0), o(a, l, f);
        } finally {
          vn(p, !1);
        }
      }
      function Ts(n, o, a, l) {
        return typeof n != "function" ? n : function() {
          var f = oe;
          a && Qn(), vn(o, !0);
          try {
            return n.apply(this, arguments);
          } finally {
            vn(f, !1), l && queueMicrotask(gn);
          }
        };
      }
      function Zo(n) {
        Promise === Re && st.echoes === 0 ? Gr === 0 ? n() : enqueueNativeMicroTask(n) : setTimeout(n, 0);
      }
      ("" + kt).indexOf("[native code]") === -1 && (Qn = gn = g);
      var Je = ee.reject, kn = "￿", Xt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Es = "String expected.", Jn = [], Jr = "__dbnames", ei = "readonly", ti = "readwrite";
      function In(n, o) {
        return n ? o ? function() {
          return n.apply(this, arguments) && o.apply(this, arguments);
        } : n : o;
      }
      var As = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Xr(n) {
        return typeof n != "string" || /\./.test(n) ? function(o) {
          return o;
        } : function(o) {
          return o[n] === void 0 && n in o && delete (o = ht(o))[n], o;
        };
      }
      function Ps() {
        throw le.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Te(n, o) {
        try {
          var a = Rs(n), l = Rs(o);
          if (a !== l) return a === "Array" ? 1 : l === "Array" ? -1 : a === "binary" ? 1 : l === "binary" ? -1 : a === "string" ? 1 : l === "string" ? -1 : a === "Date" ? 1 : l !== "Date" ? NaN : -1;
          switch (a) {
            case "number":
            case "Date":
            case "string":
              return o < n ? 1 : n < o ? -1 : 0;
            case "binary":
              return function(f, p) {
                for (var m = f.length, v = p.length, S = m < v ? m : v, E = 0; E < S; ++E) if (f[E] !== p[E]) return f[E] < p[E] ? -1 : 1;
                return m === v ? 0 : m < v ? -1 : 1;
              }(Ds(n), Ds(o));
            case "Array":
              return function(f, p) {
                for (var m = f.length, v = p.length, S = m < v ? m : v, E = 0; E < S; ++E) {
                  var P = Te(f[E], p[E]);
                  if (P !== 0) return P;
                }
                return m === v ? 0 : m < v ? -1 : 1;
              }(n, o);
          }
        } catch {
        }
        return NaN;
      }
      function Rs(n) {
        var o = typeof n;
        return o != "object" ? o : ArrayBuffer.isView(n) ? "binary" : (n = dn(n), n === "ArrayBuffer" ? "binary" : n);
      }
      function Ds(n) {
        return n instanceof Uint8Array ? n : ArrayBuffer.isView(n) ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);
      }
      function Zr(n, o, a) {
        var l = n.schema.yProps;
        return l ? (o && 0 < a.numFailures && (o = o.filter(function(f, p) {
          return !a.failures[p];
        })), Promise.all(l.map(function(f) {
          return f = f.updatesTable, o ? n.db.table(f).where("k").anyOf(o).delete() : n.db.table(f).clear();
        })).then(function() {
          return a;
        })) : a;
      }
      var ks = (Ue.prototype._trans = function(n, o, a) {
        var l = this._tx || oe.trans, f = this.name, p = F && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(n === "readonly" ? "read" : "write", " ").concat(this.name));
        function m(E, P, _) {
          if (!_.schema[f]) throw new le.NotFound("Table " + f + " not part of transaction");
          return o(_.idbtrans, _);
        }
        var v = Gn();
        try {
          var S = l && l.db._novip === this.db._novip ? l === oe.trans ? l._promise(n, m, a) : yn(function() {
            return l._promise(n, m, a);
          }, { trans: l, transless: oe.transless || oe }) : function E(P, _, k, N) {
            if (P.idbdb && (P._state.openComplete || oe.letThrough || P._vip)) {
              var A = P._createTransaction(_, k, P._dbSchema);
              try {
                A.create(), P._state.PR1398_maxLoop = 3;
              } catch (D) {
                return D.name === pn.InvalidState && P.isOpen() && 0 < --P._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), P.close({ disableAutoOpen: !1 }), P.open().then(function() {
                  return E(P, _, k, N);
                })) : Je(D);
              }
              return A._promise(_, function(D, R) {
                return yn(function() {
                  return oe.trans = A, N(D, R, A);
                });
              }).then(function(D) {
                if (_ === "readwrite") try {
                  A.idbtrans.commit();
                } catch {
                }
                return _ === "readonly" ? D : A._completion.then(function() {
                  return D;
                });
              });
            }
            if (P._state.openComplete) return Je(new le.DatabaseClosed(P._state.dbOpenError));
            if (!P._state.isBeingOpened) {
              if (!P._state.autoOpen) return Je(new le.DatabaseClosed());
              P.open().catch(g);
            }
            return P._state.dbReadyPromise.then(function() {
              return E(P, _, k, N);
            });
          }(this.db, n, [this.name], m);
          return p && (S._consoleTask = p, S = S.catch(function(E) {
            return console.trace(E), Je(E);
          })), S;
        } finally {
          v && Yn();
        }
      }, Ue.prototype.get = function(n, o) {
        var a = this;
        return n && n.constructor === Object ? this.where(n).first(o) : n == null ? Je(new le.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(l) {
          return a.core.get({ trans: l, key: n }).then(function(f) {
            return a.hook.reading.fire(f);
          });
        }).then(o);
      }, Ue.prototype.where = function(n) {
        if (typeof n == "string") return new this.db.WhereClause(this, n);
        if (d(n)) return new this.db.WhereClause(this, "[".concat(n.join("+"), "]"));
        var o = c(n);
        if (o.length === 1) return this.where(o[0]).equals(n[o[0]]);
        var a = this.schema.indexes.concat(this.schema.primKey).filter(function(v) {
          if (v.compound && o.every(function(E) {
            return 0 <= v.keyPath.indexOf(E);
          })) {
            for (var S = 0; S < o.length; ++S) if (o.indexOf(v.keyPath[S]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(v, S) {
          return v.keyPath.length - S.keyPath.length;
        })[0];
        if (a && this.db._maxKey !== kn) {
          var p = a.keyPath.slice(0, o.length);
          return this.where(p).equals(p.map(function(S) {
            return n[S];
          }));
        }
        !a && F && console.warn("The query ".concat(JSON.stringify(n), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(o.join("+"), "]"));
        var l = this.schema.idxByName;
        function f(v, S) {
          return Te(v, S) === 0;
        }
        var m = o.reduce(function(_, S) {
          var E = _[0], P = _[1], _ = l[S], k = n[S];
          return [E || _, E || !_ ? In(P, _ && _.multi ? function(N) {
            return N = Ne(N, S), d(N) && N.some(function(A) {
              return f(k, A);
            });
          } : function(N) {
            return f(k, Ne(N, S));
          }) : P];
        }, [null, null]), p = m[0], m = m[1];
        return p ? this.where(p.name).equals(n[p.keyPath]).filter(m) : a ? this.filter(m) : this.where(o).equals("");
      }, Ue.prototype.filter = function(n) {
        return this.toCollection().and(n);
      }, Ue.prototype.count = function(n) {
        return this.toCollection().count(n);
      }, Ue.prototype.offset = function(n) {
        return this.toCollection().offset(n);
      }, Ue.prototype.limit = function(n) {
        return this.toCollection().limit(n);
      }, Ue.prototype.each = function(n) {
        return this.toCollection().each(n);
      }, Ue.prototype.toArray = function(n) {
        return this.toCollection().toArray(n);
      }, Ue.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ue.prototype.orderBy = function(n) {
        return new this.db.Collection(new this.db.WhereClause(this, d(n) ? "[".concat(n.join("+"), "]") : n));
      }, Ue.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ue.prototype.mapToClass = function(n) {
        var o, a = this.db, l = this.name;
        function f() {
          return o !== null && o.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = n).prototype instanceof Ps && (function(S, E) {
          if (typeof E != "function" && E !== null) throw new TypeError("Class extends value " + String(E) + " is not a constructor or null");
          function P() {
            this.constructor = S;
          }
          r(S, E), S.prototype = E === null ? Object.create(E) : (P.prototype = E.prototype, new P());
        }(f, o = n), Object.defineProperty(f.prototype, "db", { get: function() {
          return a;
        }, enumerable: !1, configurable: !0 }), f.prototype.table = function() {
          return l;
        }, n = f);
        for (var p = /* @__PURE__ */ new Set(), m = n.prototype; m; m = C(m)) Object.getOwnPropertyNames(m).forEach(function(S) {
          return p.add(S);
        });
        function v(S) {
          if (!S) return S;
          var E, P = Object.create(n.prototype);
          for (E in S) if (!p.has(E)) try {
            P[E] = S[E];
          } catch {
          }
          return P;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = v, this.hook("reading", v), n;
      }, Ue.prototype.defineClass = function() {
        return this.mapToClass(function(n) {
          h(this, n);
        });
      }, Ue.prototype.add = function(n, o) {
        var a = this, l = this.schema.primKey, f = l.auto, p = l.keyPath, m = n;
        return p && f && (m = Xr(p)(n)), this._trans("readwrite", function(v) {
          return a.core.mutate({ trans: v, type: "add", keys: o != null ? [o] : null, values: [m] });
        }).then(function(v) {
          return v.numFailures ? ee.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (p) try {
            Se(n, p, v);
          } catch {
          }
          return v;
        });
      }, Ue.prototype.update = function(n, o) {
        return typeof n != "object" || d(n) ? this.where(":id").equals(n).modify(o) : (n = Ne(n, this.schema.primKey.keyPath), n === void 0 ? Je(new le.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(n).modify(o));
      }, Ue.prototype.put = function(n, o) {
        var a = this, l = this.schema.primKey, f = l.auto, p = l.keyPath, m = n;
        return p && f && (m = Xr(p)(n)), this._trans("readwrite", function(v) {
          return a.core.mutate({ trans: v, type: "put", values: [m], keys: o != null ? [o] : null });
        }).then(function(v) {
          return v.numFailures ? ee.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (p) try {
            Se(n, p, v);
          } catch {
          }
          return v;
        });
      }, Ue.prototype.delete = function(n) {
        var o = this;
        return this._trans("readwrite", function(a) {
          return o.core.mutate({ trans: a, type: "delete", keys: [n] }).then(function(l) {
            return Zr(o, [n], l);
          }).then(function(l) {
            return l.numFailures ? ee.reject(l.failures[0]) : void 0;
          });
        });
      }, Ue.prototype.clear = function() {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "deleteRange", range: As }).then(function(a) {
            return Zr(n, null, a);
          });
        }).then(function(o) {
          return o.numFailures ? ee.reject(o.failures[0]) : void 0;
        });
      }, Ue.prototype.bulkGet = function(n) {
        var o = this;
        return this._trans("readonly", function(a) {
          return o.core.getMany({ keys: n, trans: a }).then(function(l) {
            return l.map(function(f) {
              return o.hook.reading.fire(f);
            });
          });
        });
      }, Ue.prototype.bulkAdd = function(n, o, a) {
        var l = this, f = Array.isArray(o) ? o : void 0, p = (a = a || (f ? void 0 : o)) ? a.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var E = l.schema.primKey, v = E.auto, E = E.keyPath;
          if (E && f) throw new le.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (f && f.length !== n.length) throw new le.InvalidArgument("Arguments objects and keys must have the same length");
          var S = n.length, E = E && v ? n.map(Xr(E)) : n;
          return l.core.mutate({ trans: m, type: "add", keys: f, values: E, wantResults: p }).then(function(A) {
            var _ = A.numFailures, k = A.results, N = A.lastResult, A = A.failures;
            if (_ === 0) return p ? k : N;
            throw new Dt("".concat(l.name, ".bulkAdd(): ").concat(_, " of ").concat(S, " operations failed"), A);
          });
        });
      }, Ue.prototype.bulkPut = function(n, o, a) {
        var l = this, f = Array.isArray(o) ? o : void 0, p = (a = a || (f ? void 0 : o)) ? a.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var E = l.schema.primKey, v = E.auto, E = E.keyPath;
          if (E && f) throw new le.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (f && f.length !== n.length) throw new le.InvalidArgument("Arguments objects and keys must have the same length");
          var S = n.length, E = E && v ? n.map(Xr(E)) : n;
          return l.core.mutate({ trans: m, type: "put", keys: f, values: E, wantResults: p }).then(function(A) {
            var _ = A.numFailures, k = A.results, N = A.lastResult, A = A.failures;
            if (_ === 0) return p ? k : N;
            throw new Dt("".concat(l.name, ".bulkPut(): ").concat(_, " of ").concat(S, " operations failed"), A);
          });
        });
      }, Ue.prototype.bulkUpdate = function(n) {
        var o = this, a = this.core, l = n.map(function(m) {
          return m.key;
        }), f = n.map(function(m) {
          return m.changes;
        }), p = [];
        return this._trans("readwrite", function(m) {
          return a.getMany({ trans: m, keys: l, cache: "clone" }).then(function(v) {
            var S = [], E = [];
            n.forEach(function(_, k) {
              var N = _.key, A = _.changes, D = v[k];
              if (D) {
                for (var R = 0, I = Object.keys(A); R < I.length; R++) {
                  var j = I[R], M = A[j];
                  if (j === o.schema.primKey.keyPath) {
                    if (Te(M, N) !== 0) throw new le.Constraint("Cannot update primary key in bulkUpdate()");
                  } else Se(D, j, M);
                }
                p.push(k), S.push(N), E.push(D);
              }
            });
            var P = S.length;
            return a.mutate({ trans: m, type: "put", keys: S, values: E, updates: { keys: l, changeSpecs: f } }).then(function(_) {
              var k = _.numFailures, N = _.failures;
              if (k === 0) return P;
              for (var A = 0, D = Object.keys(N); A < D.length; A++) {
                var R, I = D[A], j = p[Number(I)];
                j != null && (R = N[I], delete N[I], N[j] = R);
              }
              throw new Dt("".concat(o.name, ".bulkUpdate(): ").concat(k, " of ").concat(P, " operations failed"), N);
            });
          });
        });
      }, Ue.prototype.bulkDelete = function(n) {
        var o = this, a = n.length;
        return this._trans("readwrite", function(l) {
          return o.core.mutate({ trans: l, type: "delete", keys: n }).then(function(f) {
            return Zr(o, n, f);
          });
        }).then(function(m) {
          var f = m.numFailures, p = m.lastResult, m = m.failures;
          if (f === 0) return p;
          throw new Dt("".concat(o.name, ".bulkDelete(): ").concat(f, " of ").concat(a, " operations failed"), m);
        });
      }, Ue);
      function Ue() {
      }
      function hr(n) {
        function o(m, v) {
          if (v) {
            for (var S = arguments.length, E = new Array(S - 1); --S; ) E[S - 1] = arguments[S];
            return a[m].subscribe.apply(null, E), n;
          }
          if (typeof m == "string") return a[m];
        }
        var a = {};
        o.addEventType = p;
        for (var l = 1, f = arguments.length; l < f; ++l) p(arguments[l]);
        return o;
        function p(m, v, S) {
          if (typeof m != "object") {
            var E;
            v = v || Y;
            var P = { subscribers: [], fire: S = S || g, subscribe: function(_) {
              P.subscribers.indexOf(_) === -1 && (P.subscribers.push(_), P.fire = v(P.fire, _));
            }, unsubscribe: function(_) {
              P.subscribers = P.subscribers.filter(function(k) {
                return k !== _;
              }), P.fire = P.subscribers.reduce(v, S);
            } };
            return a[m] = o[m] = P;
          }
          c(E = m).forEach(function(_) {
            var k = E[_];
            if (d(k)) p(_, E[_][0], E[_][1]);
            else {
              if (k !== "asap") throw new le.InvalidArgument("Invalid event config");
              var N = p(_, T, function() {
                for (var A = arguments.length, D = new Array(A); A--; ) D[A] = arguments[A];
                N.subscribers.forEach(function(R) {
                  be(function() {
                    R.apply(null, D);
                  });
                });
              });
            }
          });
        }
      }
      function mr(n, o) {
        return re(o).from({ prototype: n }), o;
      }
      function Xn(n, o) {
        return !(n.filter || n.algorithm || n.or) && (o ? n.justLimit : !n.replayFilter);
      }
      function ni(n, o) {
        n.filter = In(n.filter, o);
      }
      function ri(n, o, a) {
        var l = n.replayFilter;
        n.replayFilter = l ? function() {
          return In(l(), o());
        } : o, n.justLimit = a && !l;
      }
      function eo(n, o) {
        if (n.isPrimKey) return o.primaryKey;
        var a = o.getIndexByKeyPath(n.index);
        if (!a) throw new le.Schema("KeyPath " + n.index + " on object store " + o.name + " is not indexed");
        return a;
      }
      function Is(n, o, a) {
        var l = eo(n, o.schema);
        return o.openCursor({ trans: a, values: !n.keysOnly, reverse: n.dir === "prev", unique: !!n.unique, query: { index: l, range: n.range } });
      }
      function to(n, o, a, l) {
        var f = n.replayFilter ? In(n.filter, n.replayFilter()) : n.filter;
        if (n.or) {
          var p = {}, m = function(v, S, E) {
            var P, _;
            f && !f(S, E, function(k) {
              return S.stop(k);
            }, function(k) {
              return S.fail(k);
            }) || ((_ = "" + (P = S.primaryKey)) == "[object ArrayBuffer]" && (_ = "" + new Uint8Array(P)), b(p, _) || (p[_] = !0, o(v, S, E)));
          };
          return Promise.all([n.or._iterate(m, a), Ls(Is(n, l, a), n.algorithm, m, !n.keysOnly && n.valueMapper)]);
        }
        return Ls(Is(n, l, a), In(n.algorithm, f), o, !n.keysOnly && n.valueMapper);
      }
      function Ls(n, o, a, l) {
        var f = Ve(l ? function(p, m, v) {
          return a(l(p), m, v);
        } : a);
        return n.then(function(p) {
          if (p) return p.start(function() {
            var m = function() {
              return p.continue();
            };
            o && !o(p, function(v) {
              return m = v;
            }, function(v) {
              p.stop(v), m = g;
            }, function(v) {
              p.fail(v), m = g;
            }) || f(p.value, p, function(v) {
              return m = v;
            }), m();
          });
        });
      }
      var yr = (js.prototype.execute = function(n) {
        var o = this["@@propmod"];
        if (o.add !== void 0) {
          var a = o.add;
          if (d(a)) return s(s([], d(n) ? n : [], !0), a).sort();
          if (typeof a == "number") return (Number(n) || 0) + a;
          if (typeof a == "bigint") try {
            return BigInt(n) + a;
          } catch {
            return BigInt(0) + a;
          }
          throw new TypeError("Invalid term ".concat(a));
        }
        if (o.remove !== void 0) {
          var l = o.remove;
          if (d(l)) return d(n) ? n.filter(function(f) {
            return !l.includes(f);
          }).sort() : [];
          if (typeof l == "number") return Number(n) - l;
          if (typeof l == "bigint") try {
            return BigInt(n) - l;
          } catch {
            return BigInt(0) - l;
          }
          throw new TypeError("Invalid subtrahend ".concat(l));
        }
        return a = (a = o.replacePrefix) === null || a === void 0 ? void 0 : a[0], a && typeof n == "string" && n.startsWith(a) ? o.replacePrefix[1] + n.substring(a.length) : n;
      }, js);
      function js(n) {
        this["@@propmod"] = n;
      }
      var vu = (je.prototype._read = function(n, o) {
        var a = this._ctx;
        return a.error ? a.table._trans(null, Je.bind(null, a.error)) : a.table._trans("readonly", n).then(o);
      }, je.prototype._write = function(n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, Je.bind(null, o.error)) : o.table._trans("readwrite", n, "locked");
      }, je.prototype._addAlgorithm = function(n) {
        var o = this._ctx;
        o.algorithm = In(o.algorithm, n);
      }, je.prototype._iterate = function(n, o) {
        return to(this._ctx, n, o, this._ctx.table.core);
      }, je.prototype.clone = function(n) {
        var o = Object.create(this.constructor.prototype), a = Object.create(this._ctx);
        return n && h(a, n), o._ctx = a, o;
      }, je.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, je.prototype.each = function(n) {
        var o = this._ctx;
        return this._read(function(a) {
          return to(o, n, a, o.table.core);
        });
      }, je.prototype.count = function(n) {
        var o = this;
        return this._read(function(a) {
          var l = o._ctx, f = l.table.core;
          if (Xn(l, !0)) return f.count({ trans: a, query: { index: eo(l, f.schema), range: l.range } }).then(function(m) {
            return Math.min(m, l.limit);
          });
          var p = 0;
          return to(l, function() {
            return ++p, !1;
          }, a, f).then(function() {
            return p;
          });
        }).then(n);
      }, je.prototype.sortBy = function(n, o) {
        var a = n.split(".").reverse(), l = a[0], f = a.length - 1;
        function p(S, E) {
          return E ? p(S[a[E]], E - 1) : S[l];
        }
        var m = this._ctx.dir === "next" ? 1 : -1;
        function v(S, E) {
          return Te(p(S, f), p(E, f)) * m;
        }
        return this.toArray(function(S) {
          return S.sort(v);
        }).then(o);
      }, je.prototype.toArray = function(n) {
        var o = this;
        return this._read(function(a) {
          var l = o._ctx;
          if (l.dir === "next" && Xn(l, !0) && 0 < l.limit) {
            var f = l.valueMapper, p = eo(l, l.table.core.schema);
            return l.table.core.query({ trans: a, limit: l.limit, values: !0, query: { index: p, range: l.range } }).then(function(v) {
              return v = v.result, f ? v.map(f) : v;
            });
          }
          var m = [];
          return to(l, function(v) {
            return m.push(v);
          }, a, l.table.core).then(function() {
            return m;
          });
        }, n);
      }, je.prototype.offset = function(n) {
        var o = this._ctx;
        return n <= 0 || (o.offset += n, Xn(o) ? ri(o, function() {
          var a = n;
          return function(l, f) {
            return a === 0 || (a === 1 ? --a : f(function() {
              l.advance(a), a = 0;
            }), !1);
          };
        }) : ri(o, function() {
          var a = n;
          return function() {
            return --a < 0;
          };
        })), this;
      }, je.prototype.limit = function(n) {
        return this._ctx.limit = Math.min(this._ctx.limit, n), ri(this._ctx, function() {
          var o = n;
          return function(a, l, f) {
            return --o <= 0 && l(f), 0 <= o;
          };
        }, !0), this;
      }, je.prototype.until = function(n, o) {
        return ni(this._ctx, function(a, l, f) {
          return !n(a.value) || (l(f), o);
        }), this;
      }, je.prototype.first = function(n) {
        return this.limit(1).toArray(function(o) {
          return o[0];
        }).then(n);
      }, je.prototype.last = function(n) {
        return this.reverse().first(n);
      }, je.prototype.filter = function(n) {
        var o;
        return ni(this._ctx, function(a) {
          return n(a.value);
        }), (o = this._ctx).isMatch = In(o.isMatch, n), this;
      }, je.prototype.and = function(n) {
        return this.filter(n);
      }, je.prototype.or = function(n) {
        return new this.db.WhereClause(this._ctx.table, n, this);
      }, je.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, je.prototype.desc = function() {
        return this.reverse();
      }, je.prototype.eachKey = function(n) {
        var o = this._ctx;
        return o.keysOnly = !o.isMatch, this.each(function(a, l) {
          n(l.key, l);
        });
      }, je.prototype.eachUniqueKey = function(n) {
        return this._ctx.unique = "unique", this.eachKey(n);
      }, je.prototype.eachPrimaryKey = function(n) {
        var o = this._ctx;
        return o.keysOnly = !o.isMatch, this.each(function(a, l) {
          n(l.primaryKey, l);
        });
      }, je.prototype.keys = function(n) {
        var o = this._ctx;
        o.keysOnly = !o.isMatch;
        var a = [];
        return this.each(function(l, f) {
          a.push(f.key);
        }).then(function() {
          return a;
        }).then(n);
      }, je.prototype.primaryKeys = function(n) {
        var o = this._ctx;
        if (o.dir === "next" && Xn(o, !0) && 0 < o.limit) return this._read(function(l) {
          var f = eo(o, o.table.core.schema);
          return o.table.core.query({ trans: l, values: !1, limit: o.limit, query: { index: f, range: o.range } });
        }).then(function(l) {
          return l.result;
        }).then(n);
        o.keysOnly = !o.isMatch;
        var a = [];
        return this.each(function(l, f) {
          a.push(f.primaryKey);
        }).then(function() {
          return a;
        }).then(n);
      }, je.prototype.uniqueKeys = function(n) {
        return this._ctx.unique = "unique", this.keys(n);
      }, je.prototype.firstKey = function(n) {
        return this.limit(1).keys(function(o) {
          return o[0];
        }).then(n);
      }, je.prototype.lastKey = function(n) {
        return this.reverse().firstKey(n);
      }, je.prototype.distinct = function() {
        var n = this._ctx, n = n.index && n.table.schema.idxByName[n.index];
        if (!n || !n.multi) return this;
        var o = {};
        return ni(this._ctx, function(f) {
          var l = f.primaryKey.toString(), f = b(o, l);
          return o[l] = !0, !f;
        }), this;
      }, je.prototype.modify = function(n) {
        var o = this, a = this._ctx;
        return this._write(function(l) {
          var f, p, m;
          m = typeof n == "function" ? n : (f = c(n), p = f.length, function(I) {
            for (var j = !1, M = 0; M < p; ++M) {
              var $ = f[M], V = n[$], G = Ne(I, $);
              V instanceof yr ? (Se(I, $, V.execute(G)), j = !0) : G !== V && (Se(I, $, V), j = !0);
            }
            return j;
          });
          var v = a.table.core, _ = v.schema.primaryKey, S = _.outbound, E = _.extractKey, P = 200, _ = o.db._options.modifyChunkSize;
          _ && (P = typeof _ == "object" ? _[v.name] || _["*"] || 200 : _);
          function k(I, $) {
            var M = $.failures, $ = $.numFailures;
            A += I - $;
            for (var V = 0, G = c(M); V < G.length; V++) {
              var H = G[V];
              N.push(M[H]);
            }
          }
          var N = [], A = 0, D = [], R = n === Ms;
          return o.clone().primaryKeys().then(function(I) {
            function j($) {
              var V = Math.min(P, I.length - $), G = I.slice($, $ + V);
              return (R ? Promise.resolve([]) : v.getMany({ trans: l, keys: G, cache: "immutable" })).then(function(H) {
                var W = [], Z = [], J = S ? [] : null, te = R ? G : [];
                if (!R) for (var Ce = 0; Ce < V; ++Ce) {
                  var De = H[Ce], ve = { value: ht(De), primKey: I[$ + Ce] };
                  m.call(ve, ve.value, ve) !== !1 && (ve.value == null ? te.push(I[$ + Ce]) : S || Te(E(De), E(ve.value)) === 0 ? (Z.push(ve.value), S && J.push(I[$ + Ce])) : (te.push(I[$ + Ce]), W.push(ve.value)));
                }
                return Promise.resolve(0 < W.length && v.mutate({ trans: l, type: "add", values: W }).then(function(Ye) {
                  for (var ge in Ye.failures) te.splice(parseInt(ge), 1);
                  k(W.length, Ye);
                })).then(function() {
                  return (0 < Z.length || M && typeof n == "object") && v.mutate({ trans: l, type: "put", keys: J, values: Z, criteria: M, changeSpec: typeof n != "function" && n, isAdditionalChunk: 0 < $ }).then(function(Ye) {
                    return k(Z.length, Ye);
                  });
                }).then(function() {
                  return (0 < te.length || M && R) && v.mutate({ trans: l, type: "delete", keys: te, criteria: M, isAdditionalChunk: 0 < $ }).then(function(Ye) {
                    return Zr(a.table, te, Ye);
                  }).then(function(Ye) {
                    return k(te.length, Ye);
                  });
                }).then(function() {
                  return I.length > $ + V && j($ + P);
                });
              });
            }
            var M = Xn(a) && a.limit === 1 / 0 && (typeof n != "function" || R) && { index: a.index, range: a.range };
            return j(0).then(function() {
              if (0 < N.length) throw new Wn("Error modifying one or more objects", N, A, D);
              return I.length;
            });
          });
        });
      }, je.prototype.delete = function() {
        var n = this._ctx, o = n.range;
        return !Xn(n) || n.table.schema.yProps || !n.isPrimKey && o.type !== 3 ? this.modify(Ms) : this._write(function(a) {
          var l = n.table.core.schema.primaryKey, f = o;
          return n.table.core.count({ trans: a, query: { index: l, range: f } }).then(function(p) {
            return n.table.core.mutate({ trans: a, type: "deleteRange", range: f }).then(function(S) {
              var v = S.failures, S = S.numFailures;
              if (S) throw new Wn("Could not delete some values", Object.keys(v).map(function(E) {
                return v[E];
              }), p - S);
              return p - S;
            });
          });
        });
      }, je);
      function je() {
      }
      var Ms = function(n, o) {
        return o.value = null;
      };
      function bu(n, o) {
        return n < o ? -1 : n === o ? 0 : 1;
      }
      function _u(n, o) {
        return o < n ? -1 : n === o ? 0 : 1;
      }
      function At(n, o, a) {
        return n = n instanceof Ks ? new n.Collection(n) : n, n._ctx.error = new (a || TypeError)(o), n;
      }
      function Zn(n) {
        return new n.Collection(n, function() {
          return $s("");
        }).limit(0);
      }
      function no(n, o, a, l) {
        var f, p, m, v, S, E, P, _ = a.length;
        if (!a.every(function(A) {
          return typeof A == "string";
        })) return At(n, Es);
        function k(A) {
          f = A === "next" ? function(R) {
            return R.toUpperCase();
          } : function(R) {
            return R.toLowerCase();
          }, p = A === "next" ? function(R) {
            return R.toLowerCase();
          } : function(R) {
            return R.toUpperCase();
          }, m = A === "next" ? bu : _u;
          var D = a.map(function(R) {
            return { lower: p(R), upper: f(R) };
          }).sort(function(R, I) {
            return m(R.lower, I.lower);
          });
          v = D.map(function(R) {
            return R.upper;
          }), S = D.map(function(R) {
            return R.lower;
          }), P = (E = A) === "next" ? "" : l;
        }
        k("next"), n = new n.Collection(n, function() {
          return bn(v[0], S[_ - 1] + l);
        }), n._ondirectionchange = function(A) {
          k(A);
        };
        var N = 0;
        return n._addAlgorithm(function(A, D, R) {
          var I = A.key;
          if (typeof I != "string") return !1;
          var j = p(I);
          if (o(j, S, N)) return !0;
          for (var M = null, $ = N; $ < _; ++$) {
            var V = function(G, H, W, Z, J, te) {
              for (var Ce = Math.min(G.length, Z.length), De = -1, ve = 0; ve < Ce; ++ve) {
                var Ye = H[ve];
                if (Ye !== Z[ve]) return J(G[ve], W[ve]) < 0 ? G.substr(0, ve) + W[ve] + W.substr(ve + 1) : J(G[ve], Z[ve]) < 0 ? G.substr(0, ve) + Z[ve] + W.substr(ve + 1) : 0 <= De ? G.substr(0, De) + H[De] + W.substr(De + 1) : null;
                J(G[ve], Ye) < 0 && (De = ve);
              }
              return Ce < Z.length && te === "next" ? G + W.substr(G.length) : Ce < G.length && te === "prev" ? G.substr(0, W.length) : De < 0 ? null : G.substr(0, De) + Z[De] + W.substr(De + 1);
            }(I, j, v[$], S[$], m, E);
            V === null && M === null ? N = $ + 1 : (M === null || 0 < m(M, V)) && (M = V);
          }
          return D(M !== null ? function() {
            A.continue(M + P);
          } : R), !1;
        }), n;
      }
      function bn(n, o, a, l) {
        return { type: 2, lower: n, upper: o, lowerOpen: a, upperOpen: l };
      }
      function $s(n) {
        return { type: 1, lower: n, upper: n };
      }
      var Ks = (Object.defineProperty(at.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), at.prototype.between = function(n, o, a, l) {
        a = a !== !1, l = l === !0;
        try {
          return 0 < this._cmp(n, o) || this._cmp(n, o) === 0 && (a || l) && (!a || !l) ? Zn(this) : new this.Collection(this, function() {
            return bn(n, o, !a, !l);
          });
        } catch {
          return At(this, Xt);
        }
      }, at.prototype.equals = function(n) {
        return n == null ? At(this, Xt) : new this.Collection(this, function() {
          return $s(n);
        });
      }, at.prototype.above = function(n) {
        return n == null ? At(this, Xt) : new this.Collection(this, function() {
          return bn(n, void 0, !0);
        });
      }, at.prototype.aboveOrEqual = function(n) {
        return n == null ? At(this, Xt) : new this.Collection(this, function() {
          return bn(n, void 0, !1);
        });
      }, at.prototype.below = function(n) {
        return n == null ? At(this, Xt) : new this.Collection(this, function() {
          return bn(void 0, n, !1, !0);
        });
      }, at.prototype.belowOrEqual = function(n) {
        return n == null ? At(this, Xt) : new this.Collection(this, function() {
          return bn(void 0, n);
        });
      }, at.prototype.startsWith = function(n) {
        return typeof n != "string" ? At(this, Es) : this.between(n, n + kn, !0, !0);
      }, at.prototype.startsWithIgnoreCase = function(n) {
        return n === "" ? this.startsWith(n) : no(this, function(o, a) {
          return o.indexOf(a[0]) === 0;
        }, [n], kn);
      }, at.prototype.equalsIgnoreCase = function(n) {
        return no(this, function(o, a) {
          return o === a[0];
        }, [n], "");
      }, at.prototype.anyOfIgnoreCase = function() {
        var n = Et.apply(Tt, arguments);
        return n.length === 0 ? Zn(this) : no(this, function(o, a) {
          return a.indexOf(o) !== -1;
        }, n, "");
      }, at.prototype.startsWithAnyOfIgnoreCase = function() {
        var n = Et.apply(Tt, arguments);
        return n.length === 0 ? Zn(this) : no(this, function(o, a) {
          return a.some(function(l) {
            return o.indexOf(l) === 0;
          });
        }, n, kn);
      }, at.prototype.anyOf = function() {
        var n = this, o = Et.apply(Tt, arguments), a = this._cmp;
        try {
          o.sort(a);
        } catch {
          return At(this, Xt);
        }
        if (o.length === 0) return Zn(this);
        var l = new this.Collection(this, function() {
          return bn(o[0], o[o.length - 1]);
        });
        l._ondirectionchange = function(p) {
          a = p === "next" ? n._ascending : n._descending, o.sort(a);
        };
        var f = 0;
        return l._addAlgorithm(function(p, m, v) {
          for (var S = p.key; 0 < a(S, o[f]); ) if (++f === o.length) return m(v), !1;
          return a(S, o[f]) === 0 || (m(function() {
            p.continue(o[f]);
          }), !1);
        }), l;
      }, at.prototype.notEqual = function(n) {
        return this.inAnyRange([[-1 / 0, n], [n, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, at.prototype.noneOf = function() {
        var n = Et.apply(Tt, arguments);
        if (n.length === 0) return new this.Collection(this);
        try {
          n.sort(this._ascending);
        } catch {
          return At(this, Xt);
        }
        var o = n.reduce(function(a, l) {
          return a ? a.concat([[a[a.length - 1][1], l]]) : [[-1 / 0, l]];
        }, null);
        return o.push([n[n.length - 1], this.db._maxKey]), this.inAnyRange(o, { includeLowers: !1, includeUppers: !1 });
      }, at.prototype.inAnyRange = function(I, o) {
        var a = this, l = this._cmp, f = this._ascending, p = this._descending, m = this._min, v = this._max;
        if (I.length === 0) return Zn(this);
        if (!I.every(function(j) {
          return j[0] !== void 0 && j[1] !== void 0 && f(j[0], j[1]) <= 0;
        })) return At(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", le.InvalidArgument);
        var S = !o || o.includeLowers !== !1, E = o && o.includeUppers === !0, P, _ = f;
        function k(j, M) {
          return _(j[0], M[0]);
        }
        try {
          (P = I.reduce(function(j, M) {
            for (var $ = 0, V = j.length; $ < V; ++$) {
              var G = j[$];
              if (l(M[0], G[1]) < 0 && 0 < l(M[1], G[0])) {
                G[0] = m(G[0], M[0]), G[1] = v(G[1], M[1]);
                break;
              }
            }
            return $ === V && j.push(M), j;
          }, [])).sort(k);
        } catch {
          return At(this, Xt);
        }
        var N = 0, A = E ? function(j) {
          return 0 < f(j, P[N][1]);
        } : function(j) {
          return 0 <= f(j, P[N][1]);
        }, D = S ? function(j) {
          return 0 < p(j, P[N][0]);
        } : function(j) {
          return 0 <= p(j, P[N][0]);
        }, R = A, I = new this.Collection(this, function() {
          return bn(P[0][0], P[P.length - 1][1], !S, !E);
        });
        return I._ondirectionchange = function(j) {
          _ = j === "next" ? (R = A, f) : (R = D, p), P.sort(k);
        }, I._addAlgorithm(function(j, M, $) {
          for (var V, G = j.key; R(G); ) if (++N === P.length) return M($), !1;
          return !A(V = G) && !D(V) || (a._cmp(G, P[N][1]) === 0 || a._cmp(G, P[N][0]) === 0 || M(function() {
            _ === f ? j.continue(P[N][0]) : j.continue(P[N][1]);
          }), !1);
        }), I;
      }, at.prototype.startsWithAnyOf = function() {
        var n = Et.apply(Tt, arguments);
        return n.every(function(o) {
          return typeof o == "string";
        }) ? n.length === 0 ? Zn(this) : this.inAnyRange(n.map(function(o) {
          return [o, o + kn];
        })) : At(this, "startsWithAnyOf() only works with strings");
      }, at);
      function at() {
      }
      function Ut(n) {
        return Ve(function(o) {
          return gr(o), n(o.target.error), !1;
        });
      }
      function gr(n) {
        n.stopPropagation && n.stopPropagation(), n.preventDefault && n.preventDefault();
      }
      var vr = "storagemutated", oi = "x-storagemutated-1", _n = hr(null, vr), wu = (Vt.prototype._lock = function() {
        return ae(!oe.global), ++this._reculock, this._reculock !== 1 || oe.global || (oe.lockOwnerFor = this), this;
      }, Vt.prototype._unlock = function() {
        if (ae(!oe.global), --this._reculock == 0) for (oe.global || (oe.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var n = this._blockedFuncs.shift();
          try {
            Dn(n[1], n[0]);
          } catch {
          }
        }
        return this;
      }, Vt.prototype._locked = function() {
        return this._reculock && oe.lockOwnerFor !== this;
      }, Vt.prototype.create = function(n) {
        var o = this;
        if (!this.mode) return this;
        var a = this.db.idbdb, l = this.db._state.dbOpenError;
        if (ae(!this.idbtrans), !n && !a) switch (l && l.name) {
          case "DatabaseClosedError":
            throw new le.DatabaseClosed(l);
          case "MissingAPIError":
            throw new le.MissingAPI(l.message, l);
          default:
            throw new le.OpenFailed(l);
        }
        if (!this.active) throw new le.TransactionInactive();
        return ae(this._completion._state === null), (n = this.idbtrans = n || (this.db.core || a).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ve(function(f) {
          gr(f), o._reject(n.error);
        }), n.onabort = Ve(function(f) {
          gr(f), o.active && o._reject(new le.Abort(n.error)), o.active = !1, o.on("abort").fire(f);
        }), n.oncomplete = Ve(function() {
          o.active = !1, o._resolve(), "mutatedParts" in n && _n.storagemutated.fire(n.mutatedParts);
        }), this;
      }, Vt.prototype._promise = function(n, o, a) {
        var l = this;
        if (n === "readwrite" && this.mode !== "readwrite") return Je(new le.ReadOnly("Transaction is readonly"));
        if (!this.active) return Je(new le.TransactionInactive());
        if (this._locked()) return new ee(function(p, m) {
          l._blockedFuncs.push([function() {
            l._promise(n, o, a).then(p, m);
          }, oe]);
        });
        if (a) return yn(function() {
          var p = new ee(function(m, v) {
            l._lock();
            var S = o(m, v, l);
            S && S.then && S.then(m, v);
          });
          return p.finally(function() {
            return l._unlock();
          }), p._lib = !0, p;
        });
        var f = new ee(function(p, m) {
          var v = o(p, m, l);
          v && v.then && v.then(p, m);
        });
        return f._lib = !0, f;
      }, Vt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Vt.prototype.waitFor = function(n) {
        var o, a = this._root(), l = ee.resolve(n);
        a._waitingFor ? a._waitingFor = a._waitingFor.then(function() {
          return l;
        }) : (a._waitingFor = l, a._waitingQueue = [], o = a.idbtrans.objectStore(a.storeNames[0]), function p() {
          for (++a._spinCount; a._waitingQueue.length; ) a._waitingQueue.shift()();
          a._waitingFor && (o.get(-1 / 0).onsuccess = p);
        }());
        var f = a._waitingFor;
        return new ee(function(p, m) {
          l.then(function(v) {
            return a._waitingQueue.push(Ve(p.bind(null, v)));
          }, function(v) {
            return a._waitingQueue.push(Ve(m.bind(null, v)));
          }).finally(function() {
            a._waitingFor === f && (a._waitingFor = null);
          });
        });
      }, Vt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new le.Abort()));
      }, Vt.prototype.table = function(n) {
        var o = this._memoizedTables || (this._memoizedTables = {});
        if (b(o, n)) return o[n];
        var a = this.schema[n];
        if (!a) throw new le.NotFound("Table " + n + " not part of transaction");
        return a = new this.db.Table(n, a, this), a.core = this.db.core.table(n), o[n] = a;
      }, Vt);
      function Vt() {
      }
      function ii(n, o, a, l, f, p, m, v) {
        return { name: n, keyPath: o, unique: a, multi: l, auto: f, compound: p, src: (a && !m ? "&" : "") + (l ? "*" : "") + (f ? "++" : "") + Fs(o), type: v };
      }
      function Fs(n) {
        return typeof n == "string" ? n : n ? "[" + [].join.call(n, "+") + "]" : "";
      }
      function si(n, o, a) {
        return { name: n, primKey: o, indexes: a, mappedClass: null, idxByName: (l = function(f) {
          return [f.name, f];
        }, a.reduce(function(f, p, m) {
          return m = l(p, m), m && (f[m[0]] = m[1]), f;
        }, {})) };
        var l;
      }
      var br = function(n) {
        try {
          return n.only([[]]), br = function() {
            return [[]];
          }, [[]];
        } catch {
          return br = function() {
            return kn;
          }, kn;
        }
      };
      function ai(n) {
        return n == null ? function() {
        } : typeof n == "string" ? (o = n).split(".").length === 1 ? function(a) {
          return a[o];
        } : function(a) {
          return Ne(a, o);
        } : function(a) {
          return Ne(a, n);
        };
        var o;
      }
      function Bs(n) {
        return [].slice.call(n);
      }
      var xu = 0;
      function _r(n) {
        return n == null ? ":id" : typeof n == "string" ? n : "[".concat(n.join("+"), "]");
      }
      function Cu(n, o, S) {
        function l(R) {
          if (R.type === 3) return null;
          if (R.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var N = R.lower, A = R.upper, D = R.lowerOpen, R = R.upperOpen;
          return N === void 0 ? A === void 0 ? null : o.upperBound(A, !!R) : A === void 0 ? o.lowerBound(N, !!D) : o.bound(N, A, !!D, !!R);
        }
        function f(k) {
          var N, A = k.name;
          return { name: A, schema: k, mutate: function(D) {
            var R = D.trans, I = D.type, j = D.keys, M = D.values, $ = D.range;
            return new Promise(function(V, G) {
              V = Ve(V);
              var H = R.objectStore(A), W = H.keyPath == null, Z = I === "put" || I === "add";
              if (!Z && I !== "delete" && I !== "deleteRange") throw new Error("Invalid operation type: " + I);
              var J, te = (j || M || { length: 1 }).length;
              if (j && M && j.length !== M.length) throw new Error("Given keys array must have same length as given values array.");
              if (te === 0) return V({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Ce(Ct) {
                ++Ye, gr(Ct);
              }
              var De = [], ve = [], Ye = 0;
              if (I === "deleteRange") {
                if ($.type === 4) return V({ numFailures: Ye, failures: ve, results: [], lastResult: void 0 });
                $.type === 3 ? De.push(J = H.clear()) : De.push(J = H.delete(l($)));
              } else {
                var W = Z ? W ? [M, j] : [M, null] : [j, null], ge = W[0], yt = W[1];
                if (Z) for (var gt = 0; gt < te; ++gt) De.push(J = yt && yt[gt] !== void 0 ? H[I](ge[gt], yt[gt]) : H[I](ge[gt])), J.onerror = Ce;
                else for (gt = 0; gt < te; ++gt) De.push(J = H[I](ge[gt])), J.onerror = Ce;
              }
              function mo(Ct) {
                Ct = Ct.target.result, De.forEach(function(Mn, Oi) {
                  return Mn.error != null && (ve[Oi] = Mn.error);
                }), V({ numFailures: Ye, failures: ve, results: I === "delete" ? j : De.map(function(Mn) {
                  return Mn.result;
                }), lastResult: Ct });
              }
              J.onerror = function(Ct) {
                Ce(Ct), mo(Ct);
              }, J.onsuccess = mo;
            });
          }, getMany: function(D) {
            var R = D.trans, I = D.keys;
            return new Promise(function(j, M) {
              j = Ve(j);
              for (var $, V = R.objectStore(A), G = I.length, H = new Array(G), W = 0, Z = 0, J = function(De) {
                De = De.target, H[De._pos] = De.result, ++Z === W && j(H);
              }, te = Ut(M), Ce = 0; Ce < G; ++Ce) I[Ce] != null && (($ = V.get(I[Ce]))._pos = Ce, $.onsuccess = J, $.onerror = te, ++W);
              W === 0 && j(H);
            });
          }, get: function(D) {
            var R = D.trans, I = D.key;
            return new Promise(function(j, M) {
              j = Ve(j);
              var $ = R.objectStore(A).get(I);
              $.onsuccess = function(V) {
                return j(V.target.result);
              }, $.onerror = Ut(M);
            });
          }, query: (N = E, function(D) {
            return new Promise(function(R, I) {
              R = Ve(R);
              var j, M, $, W = D.trans, V = D.values, G = D.limit, J = D.query, H = G === 1 / 0 ? void 0 : G, Z = J.index, J = J.range, W = W.objectStore(A), Z = Z.isPrimaryKey ? W : W.index(Z.name), J = l(J);
              if (G === 0) return R({ result: [] });
              N ? ((H = V ? Z.getAll(J, H) : Z.getAllKeys(J, H)).onsuccess = function(te) {
                return R({ result: te.target.result });
              }, H.onerror = Ut(I)) : (j = 0, M = !V && "openKeyCursor" in Z ? Z.openKeyCursor(J) : Z.openCursor(J), $ = [], M.onsuccess = function(te) {
                var Ce = M.result;
                return Ce ? ($.push(V ? Ce.value : Ce.primaryKey), ++j === G ? R({ result: $ }) : void Ce.continue()) : R({ result: $ });
              }, M.onerror = Ut(I));
            });
          }), openCursor: function(D) {
            var R = D.trans, I = D.values, j = D.query, M = D.reverse, $ = D.unique;
            return new Promise(function(V, G) {
              V = Ve(V);
              var Z = j.index, H = j.range, W = R.objectStore(A), W = Z.isPrimaryKey ? W : W.index(Z.name), Z = M ? $ ? "prevunique" : "prev" : $ ? "nextunique" : "next", J = !I && "openKeyCursor" in W ? W.openKeyCursor(l(H), Z) : W.openCursor(l(H), Z);
              J.onerror = Ut(G), J.onsuccess = Ve(function(te) {
                var Ce, De, ve, Ye, ge = J.result;
                ge ? (ge.___id = ++xu, ge.done = !1, Ce = ge.continue.bind(ge), De = (De = ge.continuePrimaryKey) && De.bind(ge), ve = ge.advance.bind(ge), Ye = function() {
                  throw new Error("Cursor not stopped");
                }, ge.trans = R, ge.stop = ge.continue = ge.continuePrimaryKey = ge.advance = function() {
                  throw new Error("Cursor not started");
                }, ge.fail = Ve(G), ge.next = function() {
                  var yt = this, gt = 1;
                  return this.start(function() {
                    return gt-- ? yt.continue() : yt.stop();
                  }).then(function() {
                    return yt;
                  });
                }, ge.start = function(yt) {
                  function gt() {
                    if (J.result) try {
                      yt();
                    } catch (Ct) {
                      ge.fail(Ct);
                    }
                    else ge.done = !0, ge.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ge.stop();
                  }
                  var mo = new Promise(function(Ct, Mn) {
                    Ct = Ve(Ct), J.onerror = Ut(Mn), ge.fail = Mn, ge.stop = function(Oi) {
                      ge.stop = ge.continue = ge.continuePrimaryKey = ge.advance = Ye, Ct(Oi);
                    };
                  });
                  return J.onsuccess = Ve(function(Ct) {
                    J.onsuccess = gt, gt();
                  }), ge.continue = Ce, ge.continuePrimaryKey = De, ge.advance = ve, gt(), mo;
                }, V(ge)) : V(null);
              }, G);
            });
          }, count: function(D) {
            var R = D.query, I = D.trans, j = R.index, M = R.range;
            return new Promise(function($, V) {
              var G = I.objectStore(A), H = j.isPrimaryKey ? G : G.index(j.name), G = l(M), H = G ? H.count(G) : H.count();
              H.onsuccess = Ve(function(W) {
                return $(W.target.result);
              }), H.onerror = Ut(V);
            });
          } };
        }
        var p, m, v, P = (m = S, v = Bs((p = n).objectStoreNames), { schema: { name: p.name, tables: v.map(function(k) {
          return m.objectStore(k);
        }).map(function(k) {
          var N = k.keyPath, R = k.autoIncrement, A = d(N), D = {}, R = { name: k.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: N == null, compound: A, keyPath: N, autoIncrement: R, unique: !0, extractKey: ai(N) }, indexes: Bs(k.indexNames).map(function(I) {
            return k.index(I);
          }).map(function($) {
            var j = $.name, M = $.unique, V = $.multiEntry, $ = $.keyPath, V = { name: j, compound: d($), keyPath: $, unique: M, multiEntry: V, extractKey: ai($) };
            return D[_r($)] = V;
          }), getIndexByKeyPath: function(I) {
            return D[_r(I)];
          } };
          return D[":id"] = R.primaryKey, N != null && (D[_r(N)] = R.primaryKey), R;
        }) }, hasGetAll: 0 < v.length && "getAll" in m.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), S = P.schema, E = P.hasGetAll, P = S.tables.map(f), _ = {};
        return P.forEach(function(k) {
          return _[k.name] = k;
        }), { stack: "dbcore", transaction: n.transaction.bind(n), table: function(k) {
          if (!_[k]) throw new Error("Table '".concat(k, "' not found"));
          return _[k];
        }, MIN_KEY: -1 / 0, MAX_KEY: br(o), schema: S };
      }
      function Su(n, o, a, l) {
        var f = a.IDBKeyRange;
        return a.indexedDB, { dbcore: (l = Cu(o, f, l), n.dbcore.reduce(function(p, m) {
          return m = m.create, i(i({}, p), m(p));
        }, l)) };
      }
      function ro(n, l) {
        var a = l.db, l = Su(n._middlewares, a, n._deps, l);
        n.core = l.dbcore, n.tables.forEach(function(f) {
          var p = f.name;
          n.core.schema.tables.some(function(m) {
            return m.name === p;
          }) && (f.core = n.core.table(p), n[p] instanceof n.Table && (n[p].core = f.core));
        });
      }
      function oo(n, o, a, l) {
        a.forEach(function(f) {
          var p = l[f];
          o.forEach(function(m) {
            var v = function S(E, P) {
              return Le(E, P) || (E = C(E)) && S(E, P);
            }(m, f);
            (!v || "value" in v && v.value === void 0) && (m === n.Transaction.prototype || m instanceof n.Transaction ? L(m, f, { get: function() {
              return this.table(f);
            }, set: function(S) {
              w(this, f, { value: S, writable: !0, configurable: !0, enumerable: !0 });
            } }) : m[f] = new n.Table(f, p));
          });
        });
      }
      function li(n, o) {
        o.forEach(function(a) {
          for (var l in a) a[l] instanceof n.Table && delete a[l];
        });
      }
      function Ou(n, o) {
        return n._cfg.version - o._cfg.version;
      }
      function Nu(n, o, a, l) {
        var f = n._dbSchema;
        a.objectStoreNames.contains("$meta") && !f.$meta && (f.$meta = si("$meta", Us("")[0], []), n._storeNames.push("$meta"));
        var p = n._createTransaction("readwrite", n._storeNames, f);
        p.create(a), p._completion.catch(l);
        var m = p._reject.bind(p), v = oe.transless || oe;
        yn(function() {
          return oe.trans = p, oe.transless = v, o !== 0 ? (ro(n, a), E = o, ((S = p).storeNames.includes("$meta") ? S.table("$meta").get("version").then(function(P) {
            return P ?? E;
          }) : ee.resolve(E)).then(function(P) {
            return k = P, N = p, A = a, D = [], P = (_ = n)._versions, R = _._dbSchema = so(0, _.idbdb, A), (P = P.filter(function(I) {
              return I._cfg.version >= k;
            })).length !== 0 ? (P.forEach(function(I) {
              D.push(function() {
                var j = R, M = I._cfg.dbschema;
                ao(_, j, A), ao(_, M, A), R = _._dbSchema = M;
                var $ = ui(j, M);
                $.add.forEach(function(Z) {
                  ci(A, Z[0], Z[1].primKey, Z[1].indexes);
                }), $.change.forEach(function(Z) {
                  if (Z.recreate) throw new le.Upgrade("Not yet support for changing primary key");
                  var J = A.objectStore(Z.name);
                  Z.add.forEach(function(te) {
                    return io(J, te);
                  }), Z.change.forEach(function(te) {
                    J.deleteIndex(te.name), io(J, te);
                  }), Z.del.forEach(function(te) {
                    return J.deleteIndex(te);
                  });
                });
                var V = I._cfg.contentUpgrade;
                if (V && I._cfg.version > k) {
                  ro(_, A), N._memoizedTables = {};
                  var G = ye(M);
                  $.del.forEach(function(Z) {
                    G[Z] = j[Z];
                  }), li(_, [_.Transaction.prototype]), oo(_, [_.Transaction.prototype], c(G), G), N.schema = G;
                  var H, W = jt(V);
                  return W && Qn(), $ = ee.follow(function() {
                    var Z;
                    (H = V(N)) && W && (Z = gn.bind(null, null), H.then(Z, Z));
                  }), H && typeof H.then == "function" ? ee.resolve(H) : $.then(function() {
                    return H;
                  });
                }
              }), D.push(function(j) {
                var M, $, V = I._cfg.dbschema;
                M = V, $ = j, [].slice.call($.db.objectStoreNames).forEach(function(G) {
                  return M[G] == null && $.db.deleteObjectStore(G);
                }), li(_, [_.Transaction.prototype]), oo(_, [_.Transaction.prototype], _._storeNames, _._dbSchema), N.schema = _._dbSchema;
              }), D.push(function(j) {
                _.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(_.idbdb.version / 10) === I._cfg.version ? (_.idbdb.deleteObjectStore("$meta"), delete _._dbSchema.$meta, _._storeNames = _._storeNames.filter(function(M) {
                  return M !== "$meta";
                })) : j.objectStore("$meta").put(I._cfg.version, "version"));
              });
            }), function I() {
              return D.length ? ee.resolve(D.shift()(N.idbtrans)).then(I) : ee.resolve();
            }().then(function() {
              qs(R, A);
            })) : ee.resolve();
            var _, k, N, A, D, R;
          }).catch(m)) : (c(f).forEach(function(P) {
            ci(a, P, f[P].primKey, f[P].indexes);
          }), ro(n, a), void ee.follow(function() {
            return n.on.populate.fire(p);
          }).catch(m));
          var S, E;
        });
      }
      function Tu(n, o) {
        qs(n._dbSchema, o), o.db.version % 10 != 0 || o.objectStoreNames.contains("$meta") || o.db.createObjectStore("$meta").add(Math.ceil(o.db.version / 10 - 1), "version");
        var a = so(0, n.idbdb, o);
        ao(n, n._dbSchema, o);
        for (var l = 0, f = ui(a, n._dbSchema).change; l < f.length; l++) {
          var p = function(m) {
            if (m.change.length || m.recreate) return console.warn("Unable to patch indexes of table ".concat(m.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var v = o.objectStore(m.name);
            m.add.forEach(function(S) {
              F && console.debug("Dexie upgrade patch: Creating missing index ".concat(m.name, ".").concat(S.src)), io(v, S);
            });
          }(f[l]);
          if (typeof p == "object") return p.value;
        }
      }
      function ui(n, o) {
        var a, l = { del: [], add: [], change: [] };
        for (a in n) o[a] || l.del.push(a);
        for (a in o) {
          var f = n[a], p = o[a];
          if (f) {
            var m = { name: a, def: p, recreate: !1, del: [], add: [], change: [] };
            if ("" + (f.primKey.keyPath || "") != "" + (p.primKey.keyPath || "") || f.primKey.auto !== p.primKey.auto) m.recreate = !0, l.change.push(m);
            else {
              var v = f.idxByName, S = p.idxByName, E = void 0;
              for (E in v) S[E] || m.del.push(E);
              for (E in S) {
                var P = v[E], _ = S[E];
                P ? P.src !== _.src && m.change.push(_) : m.add.push(_);
              }
              (0 < m.del.length || 0 < m.add.length || 0 < m.change.length) && l.change.push(m);
            }
          } else l.add.push([a, p]);
        }
        return l;
      }
      function ci(n, o, a, l) {
        var f = n.db.createObjectStore(o, a.keyPath ? { keyPath: a.keyPath, autoIncrement: a.auto } : { autoIncrement: a.auto });
        return l.forEach(function(p) {
          return io(f, p);
        }), f;
      }
      function qs(n, o) {
        c(n).forEach(function(a) {
          o.db.objectStoreNames.contains(a) || (F && console.debug("Dexie: Creating missing table", a), ci(o, a, n[a].primKey, n[a].indexes));
        });
      }
      function io(n, o) {
        n.createIndex(o.name, o.keyPath, { unique: o.unique, multiEntry: o.multi });
      }
      function so(n, o, a) {
        var l = {};
        return se(o.objectStoreNames, 0).forEach(function(f) {
          for (var p = a.objectStore(f), m = ii(Fs(E = p.keyPath), E || "", !0, !1, !!p.autoIncrement, E && typeof E != "string", !0), v = [], S = 0; S < p.indexNames.length; ++S) {
            var P = p.index(p.indexNames[S]), E = P.keyPath, P = ii(P.name, E, !!P.unique, !!P.multiEntry, !1, E && typeof E != "string", !1);
            v.push(P);
          }
          l[f] = si(f, m, v);
        }), l;
      }
      function ao(n, o, a) {
        for (var l = a.db.objectStoreNames, f = 0; f < l.length; ++f) {
          var p = l[f], m = a.objectStore(p);
          n._hasGetAll = "getAll" in m;
          for (var v = 0; v < m.indexNames.length; ++v) {
            var S = m.indexNames[v], E = m.index(S).keyPath, P = typeof E == "string" ? E : "[" + se(E).join("+") + "]";
            !o[p] || (E = o[p].idxByName[P]) && (E.name = S, delete o[p].idxByName[P], o[p].idxByName[S] = E);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && u.WorkerGlobalScope && u instanceof u.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (n._hasGetAll = !1);
      }
      function Us(n) {
        return n.split(",").map(function(o, a) {
          var p = o.split(":"), l = (f = p[1]) === null || f === void 0 ? void 0 : f.trim(), f = (o = p[0].trim()).replace(/([&*]|\+\+)/g, ""), p = /^\[/.test(f) ? f.match(/^\[(.*)\]$/)[1].split("+") : f;
          return ii(f, p || null, /\&/.test(o), /\*/.test(o), /\+\+/.test(o), d(p), a === 0, l);
        });
      }
      var Eu = (er.prototype._createTableSchema = si, er.prototype._parseIndexSyntax = Us, er.prototype._parseStoresSpec = function(n, o) {
        var a = this;
        c(n).forEach(function(l) {
          if (n[l] !== null) {
            var f = a._parseIndexSyntax(n[l]), p = f.shift();
            if (!p) throw new le.Schema("Invalid schema for table " + l + ": " + n[l]);
            if (p.unique = !0, p.multi) throw new le.Schema("Primary key cannot be multiEntry*");
            f.forEach(function(m) {
              if (m.auto) throw new le.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!m.keyPath) throw new le.Schema("Index must have a name and cannot be an empty string");
            }), f = a._createTableSchema(l, p, f), o[l] = f;
          }
        });
      }, er.prototype.stores = function(a) {
        var o = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? h(this._cfg.storesSource, a) : a;
        var a = o._versions, l = {}, f = {};
        return a.forEach(function(p) {
          h(l, p._cfg.storesSource), f = p._cfg.dbschema = {}, p._parseStoresSpec(l, f);
        }), o._dbSchema = f, li(o, [o._allTables, o, o.Transaction.prototype]), oo(o, [o._allTables, o, o.Transaction.prototype, this._cfg.tables], c(f), f), o._storeNames = c(f), this;
      }, er.prototype.upgrade = function(n) {
        return this._cfg.contentUpgrade = z(this._cfg.contentUpgrade || g, n), this;
      }, er);
      function er() {
      }
      function fi(n, o) {
        var a = n._dbNamesDB;
        return a || (a = n._dbNamesDB = new Zt(Jr, { addons: [], indexedDB: n, IDBKeyRange: o })).version(1).stores({ dbnames: "name" }), a.table("dbnames");
      }
      function di(n) {
        return n && typeof n.databases == "function";
      }
      function pi(n) {
        return yn(function() {
          return oe.letThrough = !0, n();
        });
      }
      function hi(n) {
        return !("from" in n);
      }
      var mt = function(n, o) {
        if (!this) {
          var a = new mt();
          return n && "d" in n && h(a, n), a;
        }
        h(this, arguments.length ? { d: 1, from: n, to: 1 < arguments.length ? o : n } : { d: 0 });
      };
      function wr(n, o, a) {
        var l = Te(o, a);
        if (!isNaN(l)) {
          if (0 < l) throw RangeError();
          if (hi(n)) return h(n, { from: o, to: a, d: 1 });
          var f = n.l, l = n.r;
          if (Te(a, n.from) < 0) return f ? wr(f, o, a) : n.l = { from: o, to: a, d: 1, l: null, r: null }, Hs(n);
          if (0 < Te(o, n.to)) return l ? wr(l, o, a) : n.r = { from: o, to: a, d: 1, l: null, r: null }, Hs(n);
          Te(o, n.from) < 0 && (n.from = o, n.l = null, n.d = l ? l.d + 1 : 1), 0 < Te(a, n.to) && (n.to = a, n.r = null, n.d = n.l ? n.l.d + 1 : 1), a = !n.r, f && !n.l && xr(n, f), l && a && xr(n, l);
        }
      }
      function xr(n, o) {
        hi(o) || function a(l, S) {
          var p = S.from, m = S.to, v = S.l, S = S.r;
          wr(l, p, m), v && a(l, v), S && a(l, S);
        }(n, o);
      }
      function Vs(n, o) {
        var a = lo(o), l = a.next();
        if (l.done) return !1;
        for (var f = l.value, p = lo(n), m = p.next(f.from), v = m.value; !l.done && !m.done; ) {
          if (Te(v.from, f.to) <= 0 && 0 <= Te(v.to, f.from)) return !0;
          Te(f.from, v.from) < 0 ? f = (l = a.next(v.from)).value : v = (m = p.next(f.from)).value;
        }
        return !1;
      }
      function lo(n) {
        var o = hi(n) ? null : { s: 0, n };
        return { next: function(a) {
          for (var l = 0 < arguments.length; o; ) switch (o.s) {
            case 0:
              if (o.s = 1, l) for (; o.n.l && Te(a, o.n.from) < 0; ) o = { up: o, n: o.n.l, s: 1 };
              else for (; o.n.l; ) o = { up: o, n: o.n.l, s: 1 };
            case 1:
              if (o.s = 2, !l || Te(a, o.n.to) <= 0) return { value: o.n, done: !1 };
            case 2:
              if (o.n.r) {
                o.s = 3, o = { up: o, n: o.n.r, s: 0 };
                continue;
              }
            case 3:
              o = o.up;
          }
          return { done: !0 };
        } };
      }
      function Hs(n) {
        var o, a, l = (((o = n.r) === null || o === void 0 ? void 0 : o.d) || 0) - (((a = n.l) === null || a === void 0 ? void 0 : a.d) || 0), f = 1 < l ? "r" : l < -1 ? "l" : "";
        f && (o = f == "r" ? "l" : "r", a = i({}, n), l = n[f], n.from = l.from, n.to = l.to, n[f] = l[f], a[f] = l[o], (n[o] = a).d = Ws(a)), n.d = Ws(n);
      }
      function Ws(a) {
        var o = a.r, a = a.l;
        return (o ? a ? Math.max(o.d, a.d) : o.d : a ? a.d : 0) + 1;
      }
      function uo(n, o) {
        return c(o).forEach(function(a) {
          n[a] ? xr(n[a], o[a]) : n[a] = function l(f) {
            var p, m, v = {};
            for (p in f) b(f, p) && (m = f[p], v[p] = !m || typeof m != "object" || rt.has(m.constructor) ? m : l(m));
            return v;
          }(o[a]);
        }), n;
      }
      function mi(n, o) {
        return n.all || o.all || Object.keys(n).some(function(a) {
          return o[a] && Vs(o[a], n[a]);
        });
      }
      x(mt.prototype, ((kt = { add: function(n) {
        return xr(this, n), this;
      }, addKey: function(n) {
        return wr(this, n, n), this;
      }, addKeys: function(n) {
        var o = this;
        return n.forEach(function(a) {
          return wr(o, a, a);
        }), this;
      }, hasKey: function(n) {
        var o = lo(this).next(n).value;
        return o && Te(o.from, n) <= 0 && 0 <= Te(o.to, n);
      } })[qe] = function() {
        return lo(this);
      }, kt));
      var Ln = {}, yi = {}, gi = !1;
      function co(n) {
        uo(yi, n), gi || (gi = !0, setTimeout(function() {
          gi = !1, vi(yi, !(yi = {}));
        }, 0));
      }
      function vi(n, o) {
        o === void 0 && (o = !1);
        var a = /* @__PURE__ */ new Set();
        if (n.all) for (var l = 0, f = Object.values(Ln); l < f.length; l++) zs(m = f[l], n, a, o);
        else for (var p in n) {
          var m, v = /^idb\:\/\/(.*)\/(.*)\//.exec(p);
          v && (p = v[1], v = v[2], (m = Ln["idb://".concat(p, "/").concat(v)]) && zs(m, n, a, o));
        }
        a.forEach(function(S) {
          return S();
        });
      }
      function zs(n, o, a, l) {
        for (var f = [], p = 0, m = Object.entries(n.queries.query); p < m.length; p++) {
          for (var v = m[p], S = v[0], E = [], P = 0, _ = v[1]; P < _.length; P++) {
            var k = _[P];
            mi(o, k.obsSet) ? k.subscribers.forEach(function(R) {
              return a.add(R);
            }) : l && E.push(k);
          }
          l && f.push([S, E]);
        }
        if (l) for (var N = 0, A = f; N < A.length; N++) {
          var D = A[N], S = D[0], E = D[1];
          n.queries.query[S] = E;
        }
      }
      function Au(n) {
        var o = n._state, a = n._deps.indexedDB;
        if (o.isBeingOpened || n.idbdb) return o.dbReadyPromise.then(function() {
          return o.dbOpenError ? Je(o.dbOpenError) : n;
        });
        o.isBeingOpened = !0, o.dbOpenError = null, o.openComplete = !1;
        var l = o.openCanceller, f = Math.round(10 * n.verno), p = !1;
        function m() {
          if (o.openCanceller !== l) throw new le.DatabaseClosed("db.open() was cancelled");
        }
        function v() {
          return new ee(function(k, N) {
            if (m(), !a) throw new le.MissingAPI();
            var A = n.name, D = o.autoSchema || !f ? a.open(A) : a.open(A, f);
            if (!D) throw new le.MissingAPI();
            D.onerror = Ut(N), D.onblocked = Ve(n._fireOnBlocked), D.onupgradeneeded = Ve(function(R) {
              var I;
              P = D.transaction, o.autoSchema && !n._options.allowEmptyDB ? (D.onerror = gr, P.abort(), D.result.close(), (I = a.deleteDatabase(A)).onsuccess = I.onerror = Ve(function() {
                N(new le.NoSuchDatabase("Database ".concat(A, " doesnt exist")));
              })) : (P.onerror = Ut(N), R = R.oldVersion > Math.pow(2, 62) ? 0 : R.oldVersion, _ = R < 1, n.idbdb = D.result, p && Tu(n, P), Nu(n, R / 10, P, N));
            }, N), D.onsuccess = Ve(function() {
              P = null;
              var R, I, j, M, $, V = n.idbdb = D.result, G = se(V.objectStoreNames);
              if (0 < G.length) try {
                var H = V.transaction((M = G).length === 1 ? M[0] : M, "readonly");
                if (o.autoSchema) I = V, j = H, (R = n).verno = I.version / 10, j = R._dbSchema = so(0, I, j), R._storeNames = se(I.objectStoreNames, 0), oo(R, [R._allTables], c(j), j);
                else if (ao(n, n._dbSchema, H), (($ = ui(so(0, ($ = n).idbdb, H), $._dbSchema)).add.length || $.change.some(function(W) {
                  return W.add.length || W.change.length;
                })) && !p) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), V.close(), f = V.version + 1, p = !0, k(v());
                ro(n, H);
              } catch {
              }
              Jn.push(n), V.onversionchange = Ve(function(W) {
                o.vcFired = !0, n.on("versionchange").fire(W);
              }), V.onclose = Ve(function(W) {
                n.on("close").fire(W);
              }), _ && ($ = n._deps, H = A, V = $.indexedDB, $ = $.IDBKeyRange, di(V) || H === Jr || fi(V, $).put({ name: H }).catch(g)), k();
            }, N);
          }).catch(function(k) {
            switch (k?.name) {
              case "UnknownError":
                if (0 < o.PR1398_maxLoop) return o.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), v();
                break;
              case "VersionError":
                if (0 < f) return f = 0, v();
            }
            return ee.reject(k);
          });
        }
        var S, E = o.dbReadyResolve, P = null, _ = !1;
        return ee.race([l, (typeof navigator > "u" ? ee.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(k) {
          function N() {
            return indexedDB.databases().finally(k);
          }
          S = setInterval(N, 100), N();
        }).finally(function() {
          return clearInterval(S);
        }) : Promise.resolve()).then(v)]).then(function() {
          return m(), o.onReadyBeingFired = [], ee.resolve(pi(function() {
            return n.on.ready.fire(n.vip);
          })).then(function k() {
            if (0 < o.onReadyBeingFired.length) {
              var N = o.onReadyBeingFired.reduce(z, g);
              return o.onReadyBeingFired = [], ee.resolve(pi(function() {
                return N(n.vip);
              })).then(k);
            }
          });
        }).finally(function() {
          o.openCanceller === l && (o.onReadyBeingFired = null, o.isBeingOpened = !1);
        }).catch(function(k) {
          o.dbOpenError = k;
          try {
            P && P.abort();
          } catch {
          }
          return l === o.openCanceller && n._close(), Je(k);
        }).finally(function() {
          o.openComplete = !0, E();
        }).then(function() {
          var k;
          return _ && (k = {}, n.tables.forEach(function(N) {
            N.schema.indexes.forEach(function(A) {
              A.name && (k["idb://".concat(n.name, "/").concat(N.name, "/").concat(A.name)] = new mt(-1 / 0, [[[]]]));
            }), k["idb://".concat(n.name, "/").concat(N.name, "/")] = k["idb://".concat(n.name, "/").concat(N.name, "/:dels")] = new mt(-1 / 0, [[[]]]);
          }), _n(vr).fire(k), vi(k, !0)), n;
        });
      }
      function bi(n) {
        function o(p) {
          return n.next(p);
        }
        var a = f(o), l = f(function(p) {
          return n.throw(p);
        });
        function f(p) {
          return function(S) {
            var v = p(S), S = v.value;
            return v.done ? S : S && typeof S.then == "function" ? S.then(a, l) : d(S) ? Promise.all(S).then(a, l) : a(S);
          };
        }
        return f(o)();
      }
      function fo(n, o, a) {
        for (var l = d(n) ? n.slice() : [n], f = 0; f < a; ++f) l.push(o);
        return l;
      }
      var Pu = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(n) {
        return i(i({}, n), { table: function(o) {
          var a = n.table(o), l = a.schema, f = {}, p = [];
          function m(_, k, N) {
            var A = _r(_), D = f[A] = f[A] || [], R = _ == null ? 0 : typeof _ == "string" ? 1 : _.length, I = 0 < k, I = i(i({}, N), { name: I ? "".concat(A, "(virtual-from:").concat(N.name, ")") : N.name, lowLevelIndex: N, isVirtual: I, keyTail: k, keyLength: R, extractKey: ai(_), unique: !I && N.unique });
            return D.push(I), I.isPrimaryKey || p.push(I), 1 < R && m(R === 2 ? _[0] : _.slice(0, R - 1), k + 1, N), D.sort(function(j, M) {
              return j.keyTail - M.keyTail;
            }), I;
          }
          o = m(l.primaryKey.keyPath, 0, l.primaryKey), f[":id"] = [o];
          for (var v = 0, S = l.indexes; v < S.length; v++) {
            var E = S[v];
            m(E.keyPath, 0, E);
          }
          function P(_) {
            var k, N = _.query.index;
            return N.isVirtual ? i(i({}, _), { query: { index: N.lowLevelIndex, range: (k = _.query.range, N = N.keyTail, { type: k.type === 1 ? 2 : k.type, lower: fo(k.lower, k.lowerOpen ? n.MAX_KEY : n.MIN_KEY, N), lowerOpen: !0, upper: fo(k.upper, k.upperOpen ? n.MIN_KEY : n.MAX_KEY, N), upperOpen: !0 }) } }) : _;
          }
          return i(i({}, a), { schema: i(i({}, l), { primaryKey: o, indexes: p, getIndexByKeyPath: function(_) {
            return (_ = f[_r(_)]) && _[0];
          } }), count: function(_) {
            return a.count(P(_));
          }, query: function(_) {
            return a.query(P(_));
          }, openCursor: function(_) {
            var k = _.query.index, N = k.keyTail, A = k.isVirtual, D = k.keyLength;
            return A ? a.openCursor(P(_)).then(function(I) {
              return I && R(I);
            }) : a.openCursor(_);
            function R(I) {
              return Object.create(I, { continue: { value: function(j) {
                j != null ? I.continue(fo(j, _.reverse ? n.MAX_KEY : n.MIN_KEY, N)) : _.unique ? I.continue(I.key.slice(0, D).concat(_.reverse ? n.MIN_KEY : n.MAX_KEY, N)) : I.continue();
              } }, continuePrimaryKey: { value: function(j, M) {
                I.continuePrimaryKey(fo(j, n.MAX_KEY, N), M);
              } }, primaryKey: { get: function() {
                return I.primaryKey;
              } }, key: { get: function() {
                var j = I.key;
                return D === 1 ? j[0] : j.slice(0, D);
              } }, value: { get: function() {
                return I.value;
              } } });
            }
          } });
        } });
      } };
      function _i(n, o, a, l) {
        return a = a || {}, l = l || "", c(n).forEach(function(f) {
          var p, m, v;
          b(o, f) ? (p = n[f], m = o[f], typeof p == "object" && typeof m == "object" && p && m ? (v = dn(p)) !== dn(m) ? a[l + f] = o[f] : v === "Object" ? _i(p, m, a, l + f + ".") : p !== m && (a[l + f] = o[f]) : p !== m && (a[l + f] = o[f])) : a[l + f] = void 0;
        }), c(o).forEach(function(f) {
          b(n, f) || (a[l + f] = o[f]);
        }), a;
      }
      function wi(n, o) {
        return o.type === "delete" ? o.keys : o.keys || o.values.map(n.extractKey);
      }
      var Ru = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(n) {
        return i(i({}, n), { table: function(o) {
          var a = n.table(o), l = a.schema.primaryKey;
          return i(i({}, a), { mutate: function(f) {
            var p = oe.trans, m = p.table(o).hook, v = m.deleting, S = m.creating, E = m.updating;
            switch (f.type) {
              case "add":
                if (S.fire === g) break;
                return p._promise("readwrite", function() {
                  return P(f);
                }, !0);
              case "put":
                if (S.fire === g && E.fire === g) break;
                return p._promise("readwrite", function() {
                  return P(f);
                }, !0);
              case "delete":
                if (v.fire === g) break;
                return p._promise("readwrite", function() {
                  return P(f);
                }, !0);
              case "deleteRange":
                if (v.fire === g) break;
                return p._promise("readwrite", function() {
                  return function _(k, N, A) {
                    return a.query({ trans: k, values: !1, query: { index: l, range: N }, limit: A }).then(function(D) {
                      var R = D.result;
                      return P({ type: "delete", keys: R, trans: k }).then(function(I) {
                        return 0 < I.numFailures ? Promise.reject(I.failures[0]) : R.length < A ? { failures: [], numFailures: 0, lastResult: void 0 } : _(k, i(i({}, N), { lower: R[R.length - 1], lowerOpen: !0 }), A);
                      });
                    });
                  }(f.trans, f.range, 1e4);
                }, !0);
            }
            return a.mutate(f);
            function P(_) {
              var k, N, A, D = oe.trans, R = _.keys || wi(l, _);
              if (!R) throw new Error("Keys missing");
              return (_ = _.type === "add" || _.type === "put" ? i(i({}, _), { keys: R }) : i({}, _)).type !== "delete" && (_.values = s([], _.values)), _.keys && (_.keys = s([], _.keys)), k = a, A = R, ((N = _).type === "add" ? Promise.resolve([]) : k.getMany({ trans: N.trans, keys: A, cache: "immutable" })).then(function(I) {
                var j = R.map(function(M, $) {
                  var V, G, H, W = I[$], Z = { onerror: null, onsuccess: null };
                  return _.type === "delete" ? v.fire.call(Z, M, W, D) : _.type === "add" || W === void 0 ? (V = S.fire.call(Z, M, _.values[$], D), M == null && V != null && (_.keys[$] = M = V, l.outbound || Se(_.values[$], l.keyPath, M))) : (V = _i(W, _.values[$]), (G = E.fire.call(Z, V, M, W, D)) && (H = _.values[$], Object.keys(G).forEach(function(J) {
                    b(H, J) ? H[J] = G[J] : Se(H, J, G[J]);
                  }))), Z;
                });
                return a.mutate(_).then(function(M) {
                  for (var $ = M.failures, V = M.results, G = M.numFailures, M = M.lastResult, H = 0; H < R.length; ++H) {
                    var W = (V || R)[H], Z = j[H];
                    W == null ? Z.onerror && Z.onerror($[H]) : Z.onsuccess && Z.onsuccess(_.type === "put" && I[H] ? _.values[H] : W);
                  }
                  return { failures: $, results: V, numFailures: G, lastResult: M };
                }).catch(function(M) {
                  return j.forEach(function($) {
                    return $.onerror && $.onerror(M);
                  }), Promise.reject(M);
                });
              });
            }
          } });
        } });
      } };
      function Gs(n, o, a) {
        try {
          if (!o || o.keys.length < n.length) return null;
          for (var l = [], f = 0, p = 0; f < o.keys.length && p < n.length; ++f) Te(o.keys[f], n[p]) === 0 && (l.push(a ? ht(o.values[f]) : o.values[f]), ++p);
          return l.length === n.length ? l : null;
        } catch {
          return null;
        }
      }
      var Du = { stack: "dbcore", level: -1, create: function(n) {
        return { table: function(o) {
          var a = n.table(o);
          return i(i({}, a), { getMany: function(l) {
            if (!l.cache) return a.getMany(l);
            var f = Gs(l.keys, l.trans._cache, l.cache === "clone");
            return f ? ee.resolve(f) : a.getMany(l).then(function(p) {
              return l.trans._cache = { keys: l.keys, values: l.cache === "clone" ? ht(p) : p }, p;
            });
          }, mutate: function(l) {
            return l.type !== "add" && (l.trans._cache = null), a.mutate(l);
          } });
        } };
      } };
      function Ys(n, o) {
        return n.trans.mode === "readonly" && !!n.subscr && !n.trans.explicit && n.trans.db._options.cache !== "disabled" && !o.schema.primaryKey.outbound;
      }
      function Qs(n, o) {
        switch (n) {
          case "query":
            return o.values && !o.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var ku = { stack: "dbcore", level: 0, name: "Observability", create: function(n) {
        var o = n.schema.name, a = new mt(n.MIN_KEY, n.MAX_KEY);
        return i(i({}, n), { transaction: function(l, f, p) {
          if (oe.subscr && f !== "readonly") throw new le.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(oe.querier));
          return n.transaction(l, f, p);
        }, table: function(l) {
          var f = n.table(l), p = f.schema, m = p.primaryKey, _ = p.indexes, v = m.extractKey, S = m.outbound, E = m.autoIncrement && _.filter(function(N) {
            return N.compound && N.keyPath.includes(m.keyPath);
          }), P = i(i({}, f), { mutate: function(N) {
            function A(J) {
              return J = "idb://".concat(o, "/").concat(l, "/").concat(J), M[J] || (M[J] = new mt());
            }
            var D, R, I, j = N.trans, M = N.mutatedParts || (N.mutatedParts = {}), $ = A(""), V = A(":dels"), G = N.type, Z = N.type === "deleteRange" ? [N.range] : N.type === "delete" ? [N.keys] : N.values.length < 50 ? [wi(m, N).filter(function(J) {
              return J;
            }), N.values] : [], H = Z[0], W = Z[1], Z = N.trans._cache;
            return d(H) ? ($.addKeys(H), (Z = G === "delete" || H.length === W.length ? Gs(H, Z) : null) || V.addKeys(H), (Z || W) && (D = A, R = Z, I = W, p.indexes.forEach(function(J) {
              var te = D(J.name || "");
              function Ce(ve) {
                return ve != null ? J.extractKey(ve) : null;
              }
              function De(ve) {
                return J.multiEntry && d(ve) ? ve.forEach(function(Ye) {
                  return te.addKey(Ye);
                }) : te.addKey(ve);
              }
              (R || I).forEach(function(ve, yt) {
                var ge = R && Ce(R[yt]), yt = I && Ce(I[yt]);
                Te(ge, yt) !== 0 && (ge != null && De(ge), yt != null && De(yt));
              });
            }))) : H ? (W = { from: (W = H.lower) !== null && W !== void 0 ? W : n.MIN_KEY, to: (W = H.upper) !== null && W !== void 0 ? W : n.MAX_KEY }, V.add(W), $.add(W)) : ($.add(a), V.add(a), p.indexes.forEach(function(J) {
              return A(J.name).add(a);
            })), f.mutate(N).then(function(J) {
              return !H || N.type !== "add" && N.type !== "put" || ($.addKeys(J.results), E && E.forEach(function(te) {
                for (var Ce = N.values.map(function(ge) {
                  return te.extractKey(ge);
                }), De = te.keyPath.findIndex(function(ge) {
                  return ge === m.keyPath;
                }), ve = 0, Ye = J.results.length; ve < Ye; ++ve) Ce[ve][De] = J.results[ve];
                A(te.name).addKeys(Ce);
              })), j.mutatedParts = uo(j.mutatedParts || {}, M), J;
            });
          } }), _ = function(A) {
            var D = A.query, A = D.index, D = D.range;
            return [A, new mt((A = D.lower) !== null && A !== void 0 ? A : n.MIN_KEY, (D = D.upper) !== null && D !== void 0 ? D : n.MAX_KEY)];
          }, k = { get: function(N) {
            return [m, new mt(N.key)];
          }, getMany: function(N) {
            return [m, new mt().addKeys(N.keys)];
          }, count: _, query: _, openCursor: _ };
          return c(k).forEach(function(N) {
            P[N] = function(A) {
              var D = oe.subscr, R = !!D, I = Ys(oe, f) && Qs(N, A) ? A.obsSet = {} : D;
              if (R) {
                var j = function(W) {
                  return W = "idb://".concat(o, "/").concat(l, "/").concat(W), I[W] || (I[W] = new mt());
                }, M = j(""), $ = j(":dels"), D = k[N](A), R = D[0], D = D[1];
                if ((N === "query" && R.isPrimaryKey && !A.values ? $ : j(R.name || "")).add(D), !R.isPrimaryKey) {
                  if (N !== "count") {
                    var V = N === "query" && S && A.values && f.query(i(i({}, A), { values: !1 }));
                    return f[N].apply(this, arguments).then(function(W) {
                      if (N === "query") {
                        if (S && A.values) return V.then(function(Ce) {
                          return Ce = Ce.result, M.addKeys(Ce), W;
                        });
                        var Z = A.values ? W.result.map(v) : W.result;
                        (A.values ? M : $).addKeys(Z);
                      } else if (N === "openCursor") {
                        var J = W, te = A.values;
                        return J && Object.create(J, { key: { get: function() {
                          return $.addKey(J.primaryKey), J.key;
                        } }, primaryKey: { get: function() {
                          var Ce = J.primaryKey;
                          return $.addKey(Ce), Ce;
                        } }, value: { get: function() {
                          return te && M.addKey(J.primaryKey), J.value;
                        } } });
                      }
                      return W;
                    });
                  }
                  $.add(a);
                }
              }
              return f[N].apply(this, arguments);
            };
          }), P;
        } });
      } };
      function Js(n, o, a) {
        if (a.numFailures === 0) return o;
        if (o.type === "deleteRange") return null;
        var l = o.keys ? o.keys.length : "values" in o && o.values ? o.values.length : 1;
        return a.numFailures === l ? null : (o = i({}, o), d(o.keys) && (o.keys = o.keys.filter(function(f, p) {
          return !(p in a.failures);
        })), "values" in o && d(o.values) && (o.values = o.values.filter(function(f, p) {
          return !(p in a.failures);
        })), o);
      }
      function xi(n, o) {
        return a = n, ((l = o).lower === void 0 || (l.lowerOpen ? 0 < Te(a, l.lower) : 0 <= Te(a, l.lower))) && (n = n, (o = o).upper === void 0 || (o.upperOpen ? Te(n, o.upper) < 0 : Te(n, o.upper) <= 0));
        var a, l;
      }
      function Xs(n, o, k, l, f, p) {
        if (!k || k.length === 0) return n;
        var m = o.query.index, v = m.multiEntry, S = o.query.range, E = l.schema.primaryKey.extractKey, P = m.extractKey, _ = (m.lowLevelIndex || m).extractKey, k = k.reduce(function(N, A) {
          var D = N, R = [];
          if (A.type === "add" || A.type === "put") for (var I = new mt(), j = A.values.length - 1; 0 <= j; --j) {
            var M, $ = A.values[j], V = E($);
            I.hasKey(V) || (M = P($), (v && d(M) ? M.some(function(J) {
              return xi(J, S);
            }) : xi(M, S)) && (I.addKey(V), R.push($)));
          }
          switch (A.type) {
            case "add":
              var G = new mt().addKeys(o.values ? N.map(function(te) {
                return E(te);
              }) : N), D = N.concat(o.values ? R.filter(function(te) {
                return te = E(te), !G.hasKey(te) && (G.addKey(te), !0);
              }) : R.map(function(te) {
                return E(te);
              }).filter(function(te) {
                return !G.hasKey(te) && (G.addKey(te), !0);
              }));
              break;
            case "put":
              var H = new mt().addKeys(A.values.map(function(te) {
                return E(te);
              }));
              D = N.filter(function(te) {
                return !H.hasKey(o.values ? E(te) : te);
              }).concat(o.values ? R : R.map(function(te) {
                return E(te);
              }));
              break;
            case "delete":
              var W = new mt().addKeys(A.keys);
              D = N.filter(function(te) {
                return !W.hasKey(o.values ? E(te) : te);
              });
              break;
            case "deleteRange":
              var Z = A.range;
              D = N.filter(function(te) {
                return !xi(E(te), Z);
              });
          }
          return D;
        }, n);
        return k === n ? n : (k.sort(function(N, A) {
          return Te(_(N), _(A)) || Te(E(N), E(A));
        }), o.limit && o.limit < 1 / 0 && (k.length > o.limit ? k.length = o.limit : n.length === o.limit && k.length < o.limit && (f.dirty = !0)), p ? Object.freeze(k) : k);
      }
      function Zs(n, o) {
        return Te(n.lower, o.lower) === 0 && Te(n.upper, o.upper) === 0 && !!n.lowerOpen == !!o.lowerOpen && !!n.upperOpen == !!o.upperOpen;
      }
      function Iu(n, o) {
        return function(a, l, f, p) {
          if (a === void 0) return l !== void 0 ? -1 : 0;
          if (l === void 0) return 1;
          if ((l = Te(a, l)) === 0) {
            if (f && p) return 0;
            if (f) return 1;
            if (p) return -1;
          }
          return l;
        }(n.lower, o.lower, n.lowerOpen, o.lowerOpen) <= 0 && 0 <= function(a, l, f, p) {
          if (a === void 0) return l !== void 0 ? 1 : 0;
          if (l === void 0) return -1;
          if ((l = Te(a, l)) === 0) {
            if (f && p) return 0;
            if (f) return -1;
            if (p) return 1;
          }
          return l;
        }(n.upper, o.upper, n.upperOpen, o.upperOpen);
      }
      function Lu(n, o, a, l) {
        n.subscribers.add(a), l.addEventListener("abort", function() {
          var f, p;
          n.subscribers.delete(a), n.subscribers.size === 0 && (f = n, p = o, setTimeout(function() {
            f.subscribers.size === 0 && Pe(p, f);
          }, 3e3));
        });
      }
      var ju = { stack: "dbcore", level: 0, name: "Cache", create: function(n) {
        var o = n.schema.name;
        return i(i({}, n), { transaction: function(a, l, f) {
          var p, m, v = n.transaction(a, l, f);
          return l === "readwrite" && (m = (p = new AbortController()).signal, f = function(S) {
            return function() {
              if (p.abort(), l === "readwrite") {
                for (var E = /* @__PURE__ */ new Set(), P = 0, _ = a; P < _.length; P++) {
                  var k = _[P], N = Ln["idb://".concat(o, "/").concat(k)];
                  if (N) {
                    var A = n.table(k), D = N.optimisticOps.filter(function(te) {
                      return te.trans === v;
                    });
                    if (v._explicit && S && v.mutatedParts) for (var R = 0, I = Object.values(N.queries.query); R < I.length; R++) for (var j = 0, M = (G = I[R]).slice(); j < M.length; j++) mi((H = M[j]).obsSet, v.mutatedParts) && (Pe(G, H), H.subscribers.forEach(function(te) {
                      return E.add(te);
                    }));
                    else if (0 < D.length) {
                      N.optimisticOps = N.optimisticOps.filter(function(te) {
                        return te.trans !== v;
                      });
                      for (var $ = 0, V = Object.values(N.queries.query); $ < V.length; $++) for (var G, H, W, Z = 0, J = (G = V[$]).slice(); Z < J.length; Z++) (H = J[Z]).res != null && v.mutatedParts && (S && !H.dirty ? (W = Object.isFrozen(H.res), W = Xs(H.res, H.req, D, A, H, W), H.dirty ? (Pe(G, H), H.subscribers.forEach(function(te) {
                        return E.add(te);
                      })) : W !== H.res && (H.res = W, H.promise = ee.resolve({ result: W }))) : (H.dirty && Pe(G, H), H.subscribers.forEach(function(te) {
                        return E.add(te);
                      })));
                    }
                  }
                }
                E.forEach(function(te) {
                  return te();
                });
              }
            };
          }, v.addEventListener("abort", f(!1), { signal: m }), v.addEventListener("error", f(!1), { signal: m }), v.addEventListener("complete", f(!0), { signal: m })), v;
        }, table: function(a) {
          var l = n.table(a), f = l.schema.primaryKey;
          return i(i({}, l), { mutate: function(p) {
            var m = oe.trans;
            if (f.outbound || m.db._options.cache === "disabled" || m.explicit || m.idbtrans.mode !== "readwrite") return l.mutate(p);
            var v = Ln["idb://".concat(o, "/").concat(a)];
            return v ? (m = l.mutate(p), p.type !== "add" && p.type !== "put" || !(50 <= p.values.length || wi(f, p).some(function(S) {
              return S == null;
            })) ? (v.optimisticOps.push(p), p.mutatedParts && co(p.mutatedParts), m.then(function(S) {
              0 < S.numFailures && (Pe(v.optimisticOps, p), (S = Js(0, p, S)) && v.optimisticOps.push(S), p.mutatedParts && co(p.mutatedParts));
            }), m.catch(function() {
              Pe(v.optimisticOps, p), p.mutatedParts && co(p.mutatedParts);
            })) : m.then(function(S) {
              var E = Js(0, i(i({}, p), { values: p.values.map(function(P, _) {
                var k;
                return S.failures[_] ? P : (P = (k = f.keyPath) !== null && k !== void 0 && k.includes(".") ? ht(P) : i({}, P), Se(P, f.keyPath, S.results[_]), P);
              }) }), S);
              v.optimisticOps.push(E), queueMicrotask(function() {
                return p.mutatedParts && co(p.mutatedParts);
              });
            }), m) : l.mutate(p);
          }, query: function(p) {
            if (!Ys(oe, l) || !Qs("query", p)) return l.query(p);
            var m = ((E = oe.trans) === null || E === void 0 ? void 0 : E.db._options.cache) === "immutable", _ = oe, v = _.requery, S = _.signal, E = function(A, D, R, I) {
              var j = Ln["idb://".concat(A, "/").concat(D)];
              if (!j) return [];
              if (!(D = j.queries[R])) return [null, !1, j, null];
              var M = D[(I.query ? I.query.index.name : null) || ""];
              if (!M) return [null, !1, j, null];
              switch (R) {
                case "query":
                  var $ = M.find(function(V) {
                    return V.req.limit === I.limit && V.req.values === I.values && Zs(V.req.query.range, I.query.range);
                  });
                  return $ ? [$, !0, j, M] : [M.find(function(V) {
                    return ("limit" in V.req ? V.req.limit : 1 / 0) >= I.limit && (!I.values || V.req.values) && Iu(V.req.query.range, I.query.range);
                  }), !1, j, M];
                case "count":
                  return $ = M.find(function(V) {
                    return Zs(V.req.query.range, I.query.range);
                  }), [$, !!$, j, M];
              }
            }(o, a, "query", p), P = E[0], _ = E[1], k = E[2], N = E[3];
            return P && _ ? P.obsSet = p.obsSet : (_ = l.query(p).then(function(A) {
              var D = A.result;
              if (P && (P.res = D), m) {
                for (var R = 0, I = D.length; R < I; ++R) Object.freeze(D[R]);
                Object.freeze(D);
              } else A.result = ht(D);
              return A;
            }).catch(function(A) {
              return N && P && Pe(N, P), Promise.reject(A);
            }), P = { obsSet: p.obsSet, promise: _, subscribers: /* @__PURE__ */ new Set(), type: "query", req: p, dirty: !1 }, N ? N.push(P) : (N = [P], (k = k || (Ln["idb://".concat(o, "/").concat(a)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[p.query.index.name || ""] = N)), Lu(P, N, v, S), P.promise.then(function(A) {
              return { result: Xs(A.result, p, k?.optimisticOps, l, P, m) };
            });
          } });
        } });
      } };
      function po(n, o) {
        return new Proxy(n, { get: function(a, l, f) {
          return l === "db" ? o : Reflect.get(a, l, f);
        } });
      }
      var Zt = (Xe.prototype.version = function(n) {
        if (isNaN(n) || n < 0.1) throw new le.Type("Given version is not a positive number");
        if (n = Math.round(10 * n) / 10, this.idbdb || this._state.isBeingOpened) throw new le.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, n);
        var o = this._versions, a = o.filter(function(l) {
          return l._cfg.version === n;
        })[0];
        return a || (a = new this.Version(n), o.push(a), o.sort(Ou), a.stores({}), this._state.autoSchema = !1, a);
      }, Xe.prototype._whenReady = function(n) {
        var o = this;
        return this.idbdb && (this._state.openComplete || oe.letThrough || this._vip) ? n() : new ee(function(a, l) {
          if (o._state.openComplete) return l(new le.DatabaseClosed(o._state.dbOpenError));
          if (!o._state.isBeingOpened) {
            if (!o._state.autoOpen) return void l(new le.DatabaseClosed());
            o.open().catch(g);
          }
          o._state.dbReadyPromise.then(a, l);
        }).then(n);
      }, Xe.prototype.use = function(n) {
        var o = n.stack, a = n.create, l = n.level, f = n.name;
        return f && this.unuse({ stack: o, name: f }), n = this._middlewares[o] || (this._middlewares[o] = []), n.push({ stack: o, create: a, level: l ?? 10, name: f }), n.sort(function(p, m) {
          return p.level - m.level;
        }), this;
      }, Xe.prototype.unuse = function(n) {
        var o = n.stack, a = n.name, l = n.create;
        return o && this._middlewares[o] && (this._middlewares[o] = this._middlewares[o].filter(function(f) {
          return l ? f.create !== l : !!a && f.name !== a;
        })), this;
      }, Xe.prototype.open = function() {
        var n = this;
        return Dn(Ge, function() {
          return Au(n);
        });
      }, Xe.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var n = this._state, o = Jn.indexOf(this);
        if (0 <= o && Jn.splice(o, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        n.isBeingOpened || (n.dbReadyPromise = new ee(function(a) {
          n.dbReadyResolve = a;
        }), n.openCanceller = new ee(function(a, l) {
          n.cancelOpen = l;
        }));
      }, Xe.prototype.close = function(a) {
        var o = (a === void 0 ? { disableAutoOpen: !0 } : a).disableAutoOpen, a = this._state;
        o ? (a.isBeingOpened && a.cancelOpen(new le.DatabaseClosed()), this._close(), a.autoOpen = !1, a.dbOpenError = new le.DatabaseClosed()) : (this._close(), a.autoOpen = this._options.autoOpen || a.isBeingOpened, a.openComplete = !1, a.dbOpenError = null);
      }, Xe.prototype.delete = function(n) {
        var o = this;
        n === void 0 && (n = { disableAutoOpen: !0 });
        var a = 0 < arguments.length && typeof arguments[0] != "object", l = this._state;
        return new ee(function(f, p) {
          function m() {
            o.close(n);
            var v = o._deps.indexedDB.deleteDatabase(o.name);
            v.onsuccess = Ve(function() {
              var S, E, P;
              S = o._deps, E = o.name, P = S.indexedDB, S = S.IDBKeyRange, di(P) || E === Jr || fi(P, S).delete(E).catch(g), f();
            }), v.onerror = Ut(p), v.onblocked = o._fireOnBlocked;
          }
          if (a) throw new le.InvalidArgument("Invalid closeOptions argument to db.delete()");
          l.isBeingOpened ? l.dbReadyPromise.then(m) : m();
        });
      }, Xe.prototype.backendDB = function() {
        return this.idbdb;
      }, Xe.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Xe.prototype.hasBeenClosed = function() {
        var n = this._state.dbOpenError;
        return n && n.name === "DatabaseClosed";
      }, Xe.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Xe.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Xe.prototype, "tables", { get: function() {
        var n = this;
        return c(this._allTables).map(function(o) {
          return n._allTables[o];
        });
      }, enumerable: !1, configurable: !0 }), Xe.prototype.transaction = function() {
        var n = (function(o, a, l) {
          var f = arguments.length;
          if (f < 2) throw new le.InvalidArgument("Too few arguments");
          for (var p = new Array(f - 1); --f; ) p[f - 1] = arguments[f];
          return l = p.pop(), [o, $e(p), l];
        }).apply(this, arguments);
        return this._transaction.apply(this, n);
      }, Xe.prototype._transaction = function(n, o, a) {
        var l = this, f = oe.trans;
        f && f.db === this && n.indexOf("!") === -1 || (f = null);
        var p, m, v = n.indexOf("?") !== -1;
        n = n.replace("!", "").replace("?", "");
        try {
          if (m = o.map(function(E) {
            if (E = E instanceof l.Table ? E.name : E, typeof E != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return E;
          }), n == "r" || n === ei) p = ei;
          else {
            if (n != "rw" && n != ti) throw new le.InvalidArgument("Invalid transaction mode: " + n);
            p = ti;
          }
          if (f) {
            if (f.mode === ei && p === ti) {
              if (!v) throw new le.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              f = null;
            }
            f && m.forEach(function(E) {
              if (f && f.storeNames.indexOf(E) === -1) {
                if (!v) throw new le.SubTransaction("Table " + E + " not included in parent transaction.");
                f = null;
              }
            }), v && f && !f.active && (f = null);
          }
        } catch (E) {
          return f ? f._promise(null, function(P, _) {
            _(E);
          }) : Je(E);
        }
        var S = (function E(P, _, k, N, A) {
          return ee.resolve().then(function() {
            var D = oe.transless || oe, R = P._createTransaction(_, k, P._dbSchema, N);
            if (R.explicit = !0, D = { trans: R, transless: D }, N) R.idbtrans = N.idbtrans;
            else try {
              R.create(), R.idbtrans._explicit = !0, P._state.PR1398_maxLoop = 3;
            } catch (M) {
              return M.name === pn.InvalidState && P.isOpen() && 0 < --P._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), P.close({ disableAutoOpen: !1 }), P.open().then(function() {
                return E(P, _, k, null, A);
              })) : Je(M);
            }
            var I, j = jt(A);
            return j && Qn(), D = ee.follow(function() {
              var M;
              (I = A.call(R, R)) && (j ? (M = gn.bind(null, null), I.then(M, M)) : typeof I.next == "function" && typeof I.throw == "function" && (I = bi(I)));
            }, D), (I && typeof I.then == "function" ? ee.resolve(I).then(function(M) {
              return R.active ? M : Je(new le.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : D.then(function() {
              return I;
            })).then(function(M) {
              return N && R._resolve(), R._completion.then(function() {
                return M;
              });
            }).catch(function(M) {
              return R._reject(M), Je(M);
            });
          });
        }).bind(null, this, p, m, f, a);
        return f ? f._promise(p, S, "lock") : oe.trans ? Dn(oe.transless, function() {
          return l._whenReady(S);
        }) : this._whenReady(S);
      }, Xe.prototype.table = function(n) {
        if (!b(this._allTables, n)) throw new le.InvalidTable("Table ".concat(n, " does not exist"));
        return this._allTables[n];
      }, Xe);
      function Xe(n, o) {
        var a = this;
        this._middlewares = {}, this.verno = 0;
        var l = Xe.dependencies;
        this._options = o = i({ addons: Xe.addons, autoOpen: !0, indexedDB: l.indexedDB, IDBKeyRange: l.IDBKeyRange, cache: "cloned" }, o), this._deps = { indexedDB: o.indexedDB, IDBKeyRange: o.IDBKeyRange }, l = o.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var f, p, m, v, S, E = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: g, dbReadyPromise: null, cancelOpen: g, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: o.autoOpen };
        E.dbReadyPromise = new ee(function(_) {
          E.dbReadyResolve = _;
        }), E.openCanceller = new ee(function(_, k) {
          E.cancelOpen = k;
        }), this._state = E, this.name = n, this.on = hr(this, "populate", "blocked", "versionchange", "close", { ready: [z, g] }), this.once = function(_, k) {
          var N = function() {
            for (var A = [], D = 0; D < arguments.length; D++) A[D] = arguments[D];
            a.on(_).unsubscribe(N), k.apply(a, A);
          };
          return a.on(_, N);
        }, this.on.ready.subscribe = de(this.on.ready.subscribe, function(_) {
          return function(k, N) {
            Xe.vip(function() {
              var A, D = a._state;
              D.openComplete ? (D.dbOpenError || ee.resolve().then(k), N && _(k)) : D.onReadyBeingFired ? (D.onReadyBeingFired.push(k), N && _(k)) : (_(k), A = a, N || _(function R() {
                A.on.ready.unsubscribe(k), A.on.ready.unsubscribe(R);
              }));
            });
          };
        }), this.Collection = (f = this, mr(vu.prototype, function(I, R) {
          this.db = f;
          var N = As, A = null;
          if (R) try {
            N = R();
          } catch (j) {
            A = j;
          }
          var D = I._ctx, R = D.table, I = R.hook.reading.fire;
          this._ctx = { table: R, index: D.index, isPrimKey: !D.index || R.schema.primKey.keyPath && D.index === R.schema.primKey.name, range: N, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: A, or: D.or, valueMapper: I !== T ? I : null };
        })), this.Table = (p = this, mr(ks.prototype, function(_, k, N) {
          this.db = p, this._tx = N, this.name = _, this.schema = k, this.hook = p._allTables[_] ? p._allTables[_].hook : hr(null, { creating: [B, g], reading: [K, T], updating: [X, g], deleting: [U, g] });
        })), this.Transaction = (m = this, mr(wu.prototype, function(_, k, N, A, D) {
          var R = this;
          _ !== "readonly" && k.forEach(function(I) {
            I = (I = N[I]) === null || I === void 0 ? void 0 : I.yProps, I && (k = k.concat(I.map(function(j) {
              return j.updatesTable;
            })));
          }), this.db = m, this.mode = _, this.storeNames = k, this.schema = N, this.chromeTransactionDurability = A, this.idbtrans = null, this.on = hr(this, "complete", "error", "abort"), this.parent = D || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ee(function(I, j) {
            R._resolve = I, R._reject = j;
          }), this._completion.then(function() {
            R.active = !1, R.on.complete.fire();
          }, function(I) {
            var j = R.active;
            return R.active = !1, R.on.error.fire(I), R.parent ? R.parent._reject(I) : j && R.idbtrans && R.idbtrans.abort(), Je(I);
          });
        })), this.Version = (v = this, mr(Eu.prototype, function(_) {
          this.db = v, this._cfg = { version: _, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (S = this, mr(Ks.prototype, function(_, k, N) {
          if (this.db = S, this._ctx = { table: _, index: k === ":id" ? null : k, or: N }, this._cmp = this._ascending = Te, this._descending = function(A, D) {
            return Te(D, A);
          }, this._max = function(A, D) {
            return 0 < Te(A, D) ? A : D;
          }, this._min = function(A, D) {
            return Te(A, D) < 0 ? A : D;
          }, this._IDBKeyRange = S._deps.IDBKeyRange, !this._IDBKeyRange) throw new le.MissingAPI();
        })), this.on("versionchange", function(_) {
          0 < _.newVersion ? console.warn("Another connection wants to upgrade database '".concat(a.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(a.name, "'. Closing db now to resume the delete request.")), a.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(_) {
          !_.newVersion || _.newVersion < _.oldVersion ? console.warn("Dexie.delete('".concat(a.name, "') was blocked")) : console.warn("Upgrade '".concat(a.name, "' blocked by other connection holding version ").concat(_.oldVersion / 10));
        }), this._maxKey = br(o.IDBKeyRange), this._createTransaction = function(_, k, N, A) {
          return new a.Transaction(_, k, N, a._options.chromeTransactionDurability, A);
        }, this._fireOnBlocked = function(_) {
          a.on("blocked").fire(_), Jn.filter(function(k) {
            return k.name === a.name && k !== a && !k._state.vcFired;
          }).map(function(k) {
            return k.on("versionchange").fire(_);
          });
        }, this.use(Du), this.use(ju), this.use(ku), this.use(Pu), this.use(Ru);
        var P = new Proxy(this, { get: function(_, k, N) {
          if (k === "_vip") return !0;
          if (k === "table") return function(D) {
            return po(a.table(D), P);
          };
          var A = Reflect.get(_, k, N);
          return A instanceof ks ? po(A, P) : k === "tables" ? A.map(function(D) {
            return po(D, P);
          }) : k === "_createTransaction" ? function() {
            return po(A.apply(this, arguments), P);
          } : A;
        } });
        this.vip = P, l.forEach(function(_) {
          return _(a);
        });
      }
      var ho, kt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Mu = (Ci.prototype.subscribe = function(n, o, a) {
        return this._subscribe(n && typeof n != "function" ? n : { next: n, error: o, complete: a });
      }, Ci.prototype[kt] = function() {
        return this;
      }, Ci);
      function Ci(n) {
        this._subscribe = n;
      }
      try {
        ho = { indexedDB: u.indexedDB || u.mozIndexedDB || u.webkitIndexedDB || u.msIndexedDB, IDBKeyRange: u.IDBKeyRange || u.webkitIDBKeyRange };
      } catch {
        ho = { indexedDB: null, IDBKeyRange: null };
      }
      function ea(n) {
        var o, a = !1, l = new Mu(function(f) {
          var p = jt(n), m, v = !1, S = {}, E = {}, P = { get closed() {
            return v;
          }, unsubscribe: function() {
            v || (v = !0, m && m.abort(), _ && _n.storagemutated.unsubscribe(N));
          } };
          f.start && f.start(P);
          var _ = !1, k = function() {
            return Zo(A);
          }, N = function(D) {
            uo(S, D), mi(E, S) && k();
          }, A = function() {
            var D, R, I;
            !v && ho.indexedDB && (S = {}, D = {}, m && m.abort(), m = new AbortController(), I = function(j) {
              var M = Gn();
              try {
                p && Qn();
                var $ = yn(n, j);
                return $ = p ? $.finally(gn) : $;
              } finally {
                M && Yn();
              }
            }(R = { subscr: D, signal: m.signal, requery: k, querier: n, trans: null }), Promise.resolve(I).then(function(j) {
              a = !0, o = j, v || R.signal.aborted || (S = {}, function(M) {
                for (var $ in M) if (b(M, $)) return;
                return 1;
              }(E = D) || _ || (_n(vr, N), _ = !0), Zo(function() {
                return !v && f.next && f.next(j);
              }));
            }, function(j) {
              a = !1, ["DatabaseClosedError", "AbortError"].includes(j?.name) || v || Zo(function() {
                v || f.error && f.error(j);
              });
            }));
          };
          return setTimeout(k, 0), P;
        });
        return l.hasValue = function() {
          return a;
        }, l.getValue = function() {
          return o;
        }, l;
      }
      var jn = Zt;
      function Si(n) {
        var o = wn;
        try {
          wn = !0, _n.storagemutated.fire(n), vi(n, !0);
        } finally {
          wn = o;
        }
      }
      x(jn, i(i({}, pr), { delete: function(n) {
        return new jn(n, { addons: [] }).delete();
      }, exists: function(n) {
        return new jn(n, { addons: [] }).open().then(function(o) {
          return o.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(n) {
        try {
          return o = jn.dependencies, a = o.indexedDB, o = o.IDBKeyRange, (di(a) ? Promise.resolve(a.databases()).then(function(l) {
            return l.map(function(f) {
              return f.name;
            }).filter(function(f) {
              return f !== Jr;
            });
          }) : fi(a, o).toCollection().primaryKeys()).then(n);
        } catch {
          return Je(new le.MissingAPI());
        }
        var o, a;
      }, defineClass: function() {
        return function(n) {
          h(this, n);
        };
      }, ignoreTransaction: function(n) {
        return oe.trans ? Dn(oe.transless, n) : n();
      }, vip: pi, async: function(n) {
        return function() {
          try {
            var o = bi(n.apply(this, arguments));
            return o && typeof o.then == "function" ? o : ee.resolve(o);
          } catch (a) {
            return Je(a);
          }
        };
      }, spawn: function(n, o, a) {
        try {
          var l = bi(n.apply(a, o || []));
          return l && typeof l.then == "function" ? l : ee.resolve(l);
        } catch (f) {
          return Je(f);
        }
      }, currentTransaction: { get: function() {
        return oe.trans || null;
      } }, waitFor: function(n, o) {
        return o = ee.resolve(typeof n == "function" ? jn.ignoreTransaction(n) : n).timeout(o || 6e4), oe.trans ? oe.trans.waitFor(o) : o;
      }, Promise: ee, debug: { get: function() {
        return F;
      }, set: function(n) {
        ce(n);
      } }, derive: re, extend: h, props: x, override: de, Events: hr, on: _n, liveQuery: ea, extendObservabilitySet: uo, getByKeyPath: Ne, setByKeyPath: Se, delByKeyPath: function(n, o) {
        typeof o == "string" ? Se(n, o, void 0) : "length" in o && [].map.call(o, function(a) {
          Se(n, a, void 0);
        });
      }, shallowClone: ye, deepClone: ht, getObjectDiff: _i, cmp: Te, asap: be, minKey: -1 / 0, addons: [], connections: Jn, errnames: pn, dependencies: ho, cache: Ln, semVer: "4.2.0", version: "4.2.0".split(".").map(function(n) {
        return parseInt(n);
      }).reduce(function(n, o, a) {
        return n + o / Math.pow(10, 2 * a);
      }) })), jn.maxKey = br(jn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (_n(vr, function(n) {
        wn || (n = new CustomEvent(oi, { detail: n }), wn = !0, dispatchEvent(n), wn = !1);
      }), addEventListener(oi, function(n) {
        n = n.detail, wn || Si(n);
      }));
      var tr, wn = !1, ta = function() {
      };
      return typeof BroadcastChannel < "u" && ((ta = function() {
        (tr = new BroadcastChannel(oi)).onmessage = function(n) {
          return n.data && Si(n.data);
        };
      })(), typeof tr.unref == "function" && tr.unref(), _n(vr, function(n) {
        wn || tr.postMessage(n);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(n) {
        if (!Zt.disableBfCache && n.persisted) {
          F && console.debug("Dexie: handling persisted pagehide"), tr?.close();
          for (var o = 0, a = Jn; o < a.length; o++) a[o].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(n) {
        !Zt.disableBfCache && n.persisted && (F && console.debug("Dexie: handling persisted pageshow"), ta(), Si({ all: new mt(-1 / 0, [[]]) }));
      })), ee.rejectionMapper = function(n, o) {
        return !n || n instanceof Jt || n instanceof TypeError || n instanceof SyntaxError || !n.name || !hn[n.name] ? n : (o = new hn[n.name](o || n.message, n), "stack" in n && L(o, "stack", { get: function() {
          return this.inner.stack;
        } }), o);
      }, ce(F), i(Zt, Object.freeze({ __proto__: null, Dexie: Zt, liveQuery: ea, Entity: Ps, cmp: Te, PropModification: yr, replacePrefix: function(n, o) {
        return new yr({ replacePrefix: [n, o] });
      }, add: function(n) {
        return new yr({ add: n });
      }, remove: function(n) {
        return new yr({ remove: n });
      }, default: Zt, RangeSet: mt, mergeRanges: xr, rangesOverlap: Vs }), { default: Zt }), Zt;
    });
  }(So)), So.exports;
}
var vd = gd();
const Xi = /* @__PURE__ */ md(vd), qa = Symbol.for("Dexie"), Io = globalThis[qa] || (globalThis[qa] = Xi);
if (Xi.semVer !== Io.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Xi.semVer} and ${Io.semVer}`);
const {
  liveQuery: Wh,
  mergeRanges: zh,
  rangesOverlap: Gh,
  RangeSet: Yh,
  cmp: Qh,
  Entity: Jh,
  PropModification: Xh,
  replacePrefix: Zh,
  add: em,
  remove: tm,
  DexieYProvider: nm
} = Io;
var nt = /* @__PURE__ */ ((e) => (e.GOOSE = "GOOSE", e.SMV = "SMV", e.REPORT = "Report", e.INTERNAL = "Internal", e.WIRED = "Wired", e.CONTROL = "Control", e))(nt || {});
const Lo = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Internal: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: []
};
function lu(e) {
  return {
    addRecord: t,
    findChildRecordsByTagName: s,
    ensureRelationship: r,
    removeRelationship: i,
    findParentRecordsWithinDepthAndGivenTagName: u,
    db: e
  };
  async function t(c) {
    const d = {
      ...c,
      id: crypto.randomUUID()
    };
    try {
      const h = await e.table(d.tagName).add(d), C = await e.table(d.tagName).get(h);
      if (!C) {
        const y = { msg: "could not find added record", table: d.tagName, addedId: h };
        throw console.error(y), new Error(JSON.stringify(y));
      }
      return C;
    } catch (h) {
      const C = {
        msg: "could not add record",
        db: e.name,
        table: d.tagName,
        recordToAdd: d,
        err: h
      };
      throw console.error(C), new Error(JSON.stringify(C));
    }
  }
  async function r(c, d) {
    const h = c.children?.some(
      (y) => y.id === d.id && y.tagName === d.tagName
    ), C = d.parent?.id === c.id && d.parent?.tagName === c.tagName;
    h || (c.children || (c.children = []), c.children.push({
      id: d.id,
      tagName: d.tagName
    }), await e.table(c.tagName).update(c.id, c)), C || (d.parent = {
      id: c.id,
      tagName: c.tagName
    }, await e.table(d.tagName).update(d.id, d));
  }
  async function i(c, d) {
    c.children && (c.children = c.children.filter(
      (h) => !(h.id === d.id && h.tagName === d.tagName)
    ), await e.table(c.tagName).update(c.id, c)), d.parent && d.parent.id === c.id && d.parent.tagName === c.tagName && (d.parent = null, await e.table(d.tagName).update(d.id, d));
  }
  async function s(c, d) {
    return !c.children || c.children.length === 0 ? [] : await Promise.all(
      c.children.filter((C) => C.tagName === d).map(async (C) => {
        const y = C.tagName, b = C.id;
        return await e.table(y).get({ id: b });
      })
    );
  }
  async function u(c, d, h = []) {
    const C = [];
    let y = c;
    for (let b = 0; b < d; b++) {
      if (!y.parent)
        return C;
      const x = await e.table(y.parent.tagName).get(y.parent.id);
      if (!x) {
        const w = {
          msg: "Parent record not found",
          table: y.parent.tagName,
          id: y.parent.id
        };
        throw console.error(w), new Error(JSON.stringify(w));
      }
      (h.length == 0 || h.length > 0 && h.includes(x.tagName)) && C.push(x), y = x;
    }
    return C;
  }
}
function bd(e, t) {
  return e.attributes?.find((r) => r.name === t);
}
function Ee(e, t) {
  return e?.attributes?.find((r) => r.name === t)?.value;
}
function _d(e) {
  return {
    findAllEnrichedLNodes: t,
    findAllLNodeTypes: r,
    enrichWithDataObjectSpecifications: u
  };
  async function t() {
    const d = await c();
    return d.length ? await u(d) : [];
  }
  async function r() {
    const d = await e.table("LNodeType").toArray(), h = [];
    for (const C of d)
      h.push({
        id: C.id,
        typeId: Ee(C, "id") ?? "",
        lnClass: Ee(C, "lnClass") ?? "",
        dataObjects: await i(C)
      });
    return h;
  }
  async function i(d) {
    if (!d.children) return [];
    const h = [];
    for (const C of d.children) {
      if (C.tagName !== "DO") continue;
      const y = await e.table("DO").get(C.id);
      y && h.push({
        id: y.id,
        name: Ee(y, "name") ?? "",
        type: Ee(y, "type") ?? "",
        dataAttributes: await s(y),
        lnodeTypeId: d.id
      });
    }
    return h;
  }
  async function s(d) {
    const h = Ee(d, "type");
    if (!h) return [];
    const C = (await e.table("DOType").toArray()).find(
      (b) => b.attributes?.find((x) => x.name === "id" && x.value === h)
    );
    if (!C || !C.children) return [];
    const y = [];
    for (const b of C.children) {
      if (b.tagName !== "DA") continue;
      const x = await e.table("DA").get(b.id);
      x && y.push({
        id: x.id,
        name: Ee(x, "name") ?? "",
        type: Ee(x, "type") ?? "",
        bType: Ee(x, "bType") ?? "",
        fc: Ee(x, "fc") ?? "",
        dataObjectId: d.id
      });
    }
    return y;
  }
  async function u(d) {
    const h = await e.table("Private").toArray(), C = await e.table("DOS").toArray(), y = await e.table("DAS").toArray(), b = await e.table("SubscriberLNode").toArray();
    return Promise.all(
      d.map(async (x) => {
        const w = h.find(
          (re) => re.parent?.id === x.id && re.parent?.tagName === "LNode" && Ee(re, "type") === "eIEC61850-6-100"
        );
        if (!w || !w.children)
          return { ...x, dataObjectSpecifications: [] };
        const L = [];
        for (const re of w.children) {
          if (re.tagName !== "DOS") continue;
          const Le = C.find((se) => se.id === re.id);
          if (!Le) continue;
          const ne = [];
          if (Le.children)
            for (const se of Le.children) {
              if (se.tagName !== "DAS") continue;
              const de = y.find((be) => be.id === se.id);
              if (!de) continue;
              let ae;
              if (de.children) {
                const be = de.children.find((Ne) => Ne.tagName === "SubscriberLNode");
                if (be) {
                  const Ne = b.find((Se) => Se.id === be.id);
                  Ne && (ae = {
                    id: Ne.id,
                    inputName: Ee(Ne, "inputName") ?? "",
                    service: uu(Ne, "service"),
                    pLN: Ee(Ne, "pLN") ?? ""
                  });
                }
              }
              ne.push({
                id: de.id,
                name: Ee(de, "name") ?? "",
                desc: Ee(de, "desc") ?? "",
                dataObjectSpecificationId: Le.id,
                subscriberLNode: ae
              });
            }
          L.push({
            id: Le.id,
            name: Ee(Le, "name") ?? "",
            desc: Ee(Le, "desc") ?? "",
            dataAttributeSpecifications: ne,
            lNodeId: x.id
          });
        }
        return { ...x, dataObjectSpecifications: L };
      })
    );
  }
  async function c() {
    return (await e.table("LNode").toArray()).map((h) => ({
      id: h.id,
      uuid: Ee(h, "uuid") ?? "",
      iedName: Ee(h, "iedName") ?? "",
      prefix: Ee(h, "prefix") ?? "",
      lnClass: Ee(h, "lnClass") ?? "",
      lnInst: Ee(h, "lnInst") ?? "",
      lnType: Ee(h, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function uu(e, t) {
  const r = e?.attributes?.find((s) => s.name === t)?.value;
  if (!r) return;
  switch (r.toUpperCase()) {
    case "GOOSE":
      return nt.GOOSE;
    case "SMV":
      return nt.SMV;
    case "REPORT":
      return nt.REPORT;
    case "INTERNAL":
      return nt.INTERNAL;
    case "WIRED":
      return nt.WIRED;
    case "CONTROL":
      return nt.CONTROL;
    default:
      return;
  }
}
async function Ur(e) {
  try {
    const t = new Io(e);
    return await t.open(), t;
  } catch (t) {
    throw console.error("Error opening database:", t), t;
  }
}
function wd(e) {
  const t = lu(e);
  return {
    findAllExistingConnections: r,
    findAllExistingControlledConnections: i
  };
  async function r() {
    const s = await e.table("SourceRef").toArray();
    if (!s.length) return [];
    const u = [];
    for (const c of s) {
      if (!c.attributes) continue;
      const d = Ee(c, "sourceLNodeUuid"), h = await e.table("LNode").toArray().then(
        (b) => b.find(
          (x) => x.attributes?.some(
            (w) => w.name === "uuid" && w.value === d
          )
        )?.id
      ) || null, C = await t.findParentRecordsWithinDepthAndGivenTagName(
        c,
        3,
        ["LNode"]
      );
      if (C.length != 1) {
        const b = {
          msg: "LNode record not found for SourceRef id",
          id: c.id
        };
        throw console.error(b), new Error(JSON.stringify(b));
      }
      const y = {
        id: c.id,
        sourceLNodeId: h,
        destinationLNodeId: C[0].id,
        sourceDataObject: Ee(c, "sourceDoName") || "",
        sourceDataAttribute: Ee(c, "sourceDaName") || "",
        dataflowType: uu(c, "service"),
        inputInstance: Ee(c, "inputInst") || "",
        input: Ee(c, "input") || "",
        preferredLNode: Ee(c, "pLN") || "",
        preferredDataObject: Ee(c, "pDO") || "",
        preferredDataAttribute: Ee(c, "pDA") || "",
        processResource: Ee(c, "resourceName") || ""
      };
      u.push(y);
    }
    return u;
  }
  async function i() {
    const s = await e.table("ControlRef").toArray();
    if (!s.length) return [];
    const u = [];
    for (const c of s) {
      if (!c.attributes) continue;
      const d = Ee(c, "controlledLNodeUuid"), h = Ee(c, "controlledDoName"), C = await e.table("LNode").toArray().then(
        (x) => x.find(
          (w) => w.attributes?.some(
            (L) => L.name === "uuid" && L.value === d
          )
        )?.id
      ) || null, y = await t.findParentRecordsWithinDepthAndGivenTagName(
        c,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (y.length != 1) {
        const x = {
          msg: "LNode record not found for ControlRef id",
          id: c.id
        };
        throw console.error(x), new Error(JSON.stringify(x));
      }
      const b = {
        controllerLNodeId: y[0].id,
        controlledLNodeId: C,
        controlledDataObject: h || "",
        dataflowType: nt.CONTROL,
        outputInstance: Ee(c, "outputInst") || "",
        outputName: Ee(c, "output") || ""
      };
      u.push(b);
    }
    return u;
  }
}
function Gt(e) {
  return `${e.prefix} ${e.lnClass} ${e.lnInst}`;
}
const xd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Cd = { class: "col-start-1 col-span-1 self-center justify-self-end" }, Sd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Od = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Nd = ["data-testid"], Td = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Ed = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Ad = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Pd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Rd = /* @__PURE__ */ wt({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(e) {
    const t = e, r = lt(() => [...t.connections].sort((i, s) => i.dataflowType < s.dataflowType ? -1 : i.dataflowType > s.dataflowType ? 1 : 0));
    return (i, s) => (ie(!0), fe(Ie, null, dt(r.value, (u, c) => (ie(), fe("div", xd, [
      O("div", Cd, [
        O("span", Sd, we(u.sourceDataObject), 1),
        O("span", Od, we(u.sourceDataAttribute), 1)
      ]),
      s[0] || (s[0] = O("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      O("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-line-${c}`
      }, null, 8, Nd),
      s[1] || (s[1] = O("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        O("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      O("div", Td, we(u.dataflowType), 1),
      s[2] || (s[2] = O("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      O("div", Ed, [
        O("span", Ad, we(u.input), 1),
        O("span", Pd, we(u.inputInstance), 1)
      ])
    ]))), 256));
  }
}), Dd = { key: 0 }, kd = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, Id = /* @__PURE__ */ wt({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(e) {
    return (t, r) => (ie(), fe("div", null, [
      (ie(), fe("div", Dd, [
        r[0] || (r[0] = O("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
        t.placeholder.dataflowType ? (ie(), fe("span", kd, we(t.placeholder.dataflowType), 1)) : $t("", !0),
        O("p", null, "Input: " + we(t.placeholder.input), 1),
        O("p", null, "Preferred LNode: " + we(t.placeholder.preferredLNode || "-"), 1),
        O("p", null, "Preferred DO: " + we(t.placeholder.preferredDataObject || "-"), 1),
        O("p", null, "Preferred DA: " + we(t.placeholder.preferredDataAttribute || "-"), 1),
        O("p", null, "Process Resource: " + we(t.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Ld = ["y1", "x2", "y2"], jd = ["points"], Md = /* @__PURE__ */ wt({
  __name: "arrow",
  props: {
    height: {},
    length: {}
  },
  setup(e) {
    return (t, r) => (ie(), fe(Ie, null, [
      O("line", {
        x1: 0,
        y1: t.height / 2,
        x2: t.length - t.height / 2,
        y2: t.height / 2,
        stroke: "currentColor",
        "stroke-width": "2"
      }, null, 8, Ld),
      O("polygon", {
        points: `${t.length - t.height * 0.7}, 0 ${t.length}, ${t.height / 2} ${t.length - t.height * 0.7}, ${t.height}`,
        fill: "currentColor"
      }, null, 8, jd)
    ], 64));
  }
}), cu = /* @__PURE__ */ pd("dataflow/sidebar", () => {
  const e = Qe(null);
  function t(r) {
    e.value = r;
  }
  return {
    activeElement: e,
    setActiveElement: t
  };
}), $d = ["onClick"], Kd = ["data-testid"], Fd = ["onClick"], Bd = { class: "col-start-5 col-span-1 self-center justify-self-start" }, qd = ["onClick"], Ud = /* @__PURE__ */ wt({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(e) {
    const t = cu(), { activeElement: r } = au(t);
    function i(s) {
      const u = s == r.value ? null : s;
      t.setActiveElement(u);
    }
    return (s, u) => (ie(!0), fe(Ie, null, dt(s.destinationPlaceHolderPorts, (c, d) => (ie(), fe("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
      key: `destination-placeholder-port-${d}`
    }, [
      (ie(), fe("svg", {
        height: "12",
        width: "35",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 text-(--color-ocean-gray-100) hover:cursor-pointer",
        onClick: (h) => i(c.id)
      }, [
        O("g", {
          "data-testid": `placeholder-line-${d}`,
          class: Un({
            "text-(--color-primary)": We(r) === c.id
          })
        }, [
          tt(Md, {
            height: 12,
            length: 35
          })
        ], 10, Kd)
      ], 8, $d)),
      O("div", {
        onClick: (h) => i(c.id),
        class: Un(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": We(r) === c.id
        }])
      }, null, 10, Fd),
      O("div", Bd, [
        O("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
          onClick: (h) => i(c.id)
        }, we(c.input), 9, qd)
      ]),
      We(r) == c.id ? (ie(), Mt(Nl, {
        key: 0,
        to: "#sidebar-details"
      }, [
        tt(Id, { placeholder: c }, null, 8, ["placeholder"])
      ])) : $t("", !0)
    ]))), 128));
  }
}), Cs = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
};
function zo(e) {
  const t = lu(e);
  return {
    createControlledConnection: i,
    createConnection: r,
    createSourcePlaceholder: u,
    createDestinationPlaceholder: s
  };
  async function r(c, d, h) {
    const C = await Ua(e, t, h);
    await Hd(t, d, C, c), await Wd(e, t, d, c);
  }
  async function i(c, d, h) {
    const C = await Vd(e, t, d), y = Gd(
      c,
      h
    ), b = await zd(t, y);
    await t.ensureRelationship(C, b);
    const x = await Go(e, t, h), w = {
      name: c.controlledSignal,
      desc: ""
    }, L = await fu(t, w);
    await t.ensureRelationship(x[0], L);
  }
  async function s(c, d) {
    const h = await Ua(e, t, d), C = await Oo(
      t,
      Yd(c),
      h.namespace
    );
    await t.ensureRelationship(h, C);
  }
  async function u(c) {
    let d = [{ name: "inputName", value: c.inputName }];
    c.preferredLNode && d.push({ name: "pLN", value: c.preferredLNode }), c.dataflowType && d.push({ name: "service", value: c.dataflowType }), c.processResource && d.push({ name: "resourceName", value: c.processResource });
    const h = c.dataAttribute, C = await e.table("DAS").get({ id: h });
    if (!C) throw new Error(`DAS element with id ${h} not found`);
    const y = await e.table("SubscriberLNode").where("parent.id").equals(C.id).toArray();
    if (y.length > 0)
      for (const x of y)
        await t.removeRelationship(C, x), await e.table("SubscriberLNode").delete(x.id);
    const b = await t.addRecord({
      tagName: "SubscriberLNode",
      attributes: d,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await t.ensureRelationship(C, b);
  }
}
async function Ua(e, t, r) {
  const i = await Go(e, t, r), s = await t.findChildRecordsByTagName(
    i[0],
    "LNodeInputs"
  );
  if (s.length != 1) {
    const u = {
      msg: `LNodeInputs element not found or more than one element found in LNode with uuid ${r.uuid}`
    };
    throw console.error(u), new Error(JSON.stringify(u));
  }
  return s[0];
}
async function Vd(e, t, r) {
  const i = await Go(e, t, r), s = await t.findChildRecordsByTagName(
    i[0],
    "LNodeOutputs"
  );
  if (s.length != 1) {
    const u = {
      msg: `LNodeOutputs element not found or more than one element found in LNode with uuid ${r.uuid}`
    };
    throw console.error(u), new Error(JSON.stringify(u));
  }
  return s[0];
}
async function Hd(e, t, r, i) {
  const s = await Oo(
    e,
    Mi(i, t),
    r.namespace
  );
  if (await e.ensureRelationship(r, s), i.includeQuality) {
    let u = structuredClone(Ae(i));
    u.attribute = "q";
    const c = await Oo(
      e,
      Mi(u, t),
      r.namespace
    );
    await e.ensureRelationship(r, c);
  }
  if (i.includeTimestamp) {
    let u = structuredClone(Ae(i));
    u.attribute = "t";
    const c = await Oo(
      e,
      Mi(u, t),
      r.namespace
    );
    await e.ensureRelationship(r, c);
  }
}
async function Go(e, t, r) {
  const i = await e.table("LNode").get({ id: r.id });
  if (!i || !i.children || i.children.length == 0) {
    const c = {
      msg: `LNode element with uuid ${r.uuid} not found or empty`
    };
    throw console.error(c), new Error(JSON.stringify(c));
  }
  const s = await t.findChildRecordsByTagName(i, "Private");
  if (!s.filter((c) => bd(c, "type")?.value === "eIEC61850-6-100").at(0)) {
    const c = {
      msg: `Private element of type 'eIEC61850-6-100' not found in LNode with uuid ${r.uuid}`
    };
    throw console.error(c), new Error(JSON.stringify(c));
  }
  return s;
}
async function Oo(e, t, r) {
  const i = {
    tagName: "SourceRef",
    namespace: r,
    attributes: [
      {
        name: "pLN",
        value: t.pLN
      },
      {
        name: "pDO",
        value: t.pDO
      },
      {
        name: "pDA",
        value: t.pDA
      },
      {
        name: "input",
        value: t.inputName
      },
      {
        name: "inputInst",
        value: t.inputInstance
      },
      {
        name: "service",
        value: t.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: t.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: t.sourceDoName
      },
      {
        name: "sourceDaName",
        value: t.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: t.resourceName
      },
      {
        name: "source",
        value: t.source
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(i);
}
async function Wd(e, t, r, i) {
  const s = r.dataObjectSpecifications?.filter((c) => c.name === i.signal) ?? [];
  let u;
  for (const c of s) {
    const d = c.dataAttributeSpecifications.find((h) => h.name === i.attribute);
    if (d) {
      u = d;
      break;
    }
  }
  if (!u && s[0]) {
    const c = await e.table("DOS").get({ id: s[0].id }), d = {
      name: i.attribute,
      desc: ""
    }, h = await Va(
      t,
      d
    );
    c ? await t.ensureRelationship(c, h) : console.error("Could not find find matching DOS in db");
  } else if (!u && !s[0]) {
    const c = await Go(e, t, r), d = {
      name: i.signal,
      //check done, shoulb be good
      desc: ""
    }, h = await fu(t, d);
    await t.ensureRelationship(c[0], h);
    const C = {
      name: i.attribute,
      //check done, should be good
      desc: ""
    }, y = await Va(
      t,
      C
    );
    await t.ensureRelationship(h, y);
  }
}
async function zd(e, t) {
  const r = {
    tagName: "ControlRef",
    namespace: Cs,
    attributes: [
      {
        name: "pDO",
        value: t.pDO
      },
      {
        name: "pLN",
        value: t.pLN
      },
      {
        name: "controlled",
        value: t.controlled
      },
      {
        name: "output",
        value: t.output
      },
      {
        name: "outputInst",
        value: t.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: t.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: t.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(r);
}
function Mi(e, t) {
  return {
    dataflowType: e.type,
    inputName: e.inputName,
    inputInstance: e.inputInstance,
    sourceLNodeUuid: t.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    source: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: e.signal,
    sourceDaName: e.attribute,
    pLN: t.lnClass,
    pDO: e.signal,
    pDA: e.attribute
  };
}
function Gd(e, t) {
  return {
    pDO: "",
    pLN: "",
    controlled: "",
    //TODO: see "path"-rule (Standart: 6.2.4 ControlRef)
    output: e.outputName,
    outputInst: e.outputInstance,
    controlledLNodeUuid: t.uuid,
    controlledDoName: e.controlledSignal
  };
}
function Yd(e) {
  return {
    dataflowType: e.dataflowType,
    inputName: e.inputName,
    inputInstance: "",
    sourceLNodeUuid: "",
    resourceName: e.processResource,
    source: "",
    sourceDoName: "",
    sourceDaName: "",
    pLN: e.preferredLNode,
    pDO: e.preferredDataObject,
    pDA: e.preferredDataAttribute
  };
}
async function fu(e, t) {
  const r = {
    tagName: "DOS",
    namespace: Cs,
    attributes: [
      {
        name: "name",
        value: t.name
      },
      {
        name: "desc",
        value: t.desc
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(r);
}
async function Va(e, t) {
  const r = {
    tagName: "DAS",
    namespace: Cs,
    attributes: [
      {
        name: "name",
        value: t.name
      },
      {
        name: "desc",
        value: t.desc
      }
    ],
    parent: null,
    value: null,
    children: null
  };
  return await e.addRecord(r);
}
const Qd = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Jd = { class: "modal-box" }, Xd = { class: "grid grid-cols-2 gap-4 mt-4" }, Zd = { class: "grid grid-cols-2 gap-4 mt-4" }, ep = ["value", "disabled"], tp = { class: "grid grid-cols-2 gap-4 mt-4" }, np = ["value"], rp = { class: "grid grid-cols-2 gap-4 mt-4" }, op = ["value"], ip = { class: "grid grid-cols-2 gap-4 mt-4" }, sp = ["value"], ap = { class: "grid grid-cols-2 gap-4 mt-4" }, lp = /* @__PURE__ */ wt({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["placeholderCreated"],
  setup(e, { emit: t }) {
    const r = e, i = t, s = Qe(
      h()
    ), u = Al("dialog"), c = lt(() => {
      const x = r.lnodeTypes.find(
        (w) => w.lnClass === s.value.preferredLNode
      );
      return x ? s.value.dataflowType ? x.dataObjects.filter(
        (w) => w.dataAttributes.some(
          (L) => Lo[s.value.dataflowType].includes(L.fc)
        )
      ).map((w) => w.name) : x.dataObjects.map((w) => w.name) : [];
    }), d = lt(() => {
      const x = r.lnodeTypes.find(
        (L) => L.lnClass === s.value.preferredLNode
      );
      if (!x) return [];
      const w = x.dataObjects.find(
        (L) => L.name === s.value.preferredDataObject
      );
      return w ? s.value.dataflowType ? w.dataAttributes.filter(
        (L) => Lo[s.value.dataflowType].includes(L.fc)
      ).map((L) => L.name) : w.dataAttributes.map((L) => L.name) : [];
    });
    function h() {
      return {
        dataflowType: null,
        inputName: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    async function C() {
      try {
        const x = localStorage.getItem("currentActiveFileDatabaseName");
        if (!x)
          throw new Error("no active file");
        const w = await Ur(x);
        await zo(w).createDestinationPlaceholder(
          s.value,
          r.destinationLNode
        ), w.close(), i("placeholderCreated"), y();
      } catch (x) {
        console.error("Error creating destination placeholder port:", x), alert(`Error creating placeholder: ${x instanceof Error ? x.message : "Unknown error"}`);
      }
    }
    function y() {
      s.value = h();
    }
    function b(x) {
      for (const w of x)
        s.value[w] = "";
    }
    return (x, w) => (ie(), fe("div", Qd, [
      O("button", {
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center",
        onClick: w[0] || (w[0] = (L) => u.value?.showModal()),
        "aria-label": "Add destination placeholder"
      }, w[10] || (w[10] = [
        O("svg", {
          width: "16px",
          height: "16px",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          O("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          O("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      O("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: u
      }, [
        O("div", Jd, [
          w[22] || (w[22] = O("h3", { class: "text-lg font-bold" }, "Create Placeholder - Receive data from", -1)),
          w[23] || (w[23] = O("form", { method: "dialog" }, [
            O("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close destination placeholder creation"
            }, [
              O("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                O("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          O("form", {
            method: "dialog",
            onSubmit: C
          }, [
            O("div", Xd, [
              w[11] || (w[11] = O("label", {
                for: "input-name-input",
                class: "col-start-1 self-center"
              }, "Input", -1)),
              He(O("input", {
                id: "input-name-input",
                type: "text",
                required: "",
                placeholder: "Input Name",
                class: "input col-start-2",
                "onUpdate:modelValue": w[1] || (w[1] = (L) => s.value.inputName = L)
              }, null, 512), [
                [An, s.value.inputName]
              ])
            ]),
            O("div", Zd, [
              w[13] || (w[13] = O("label", {
                for: "dataflow-type-select",
                class: "col-start-1 self-center"
              }, "Dataflow Type", -1)),
              He(O("select", {
                id: "dataflow-type-select",
                class: "select col-start-2",
                "onUpdate:modelValue": w[2] || (w[2] = (L) => s.value.dataflowType = L),
                onChange: w[3] || (w[3] = (L) => b(["preferredDataObject"]))
              }, [
                (ie(!0), fe(Ie, null, dt(Object.values(We(nt)), (L) => (ie(), fe("option", {
                  key: L,
                  value: L,
                  disabled: L === We(nt).CONTROL
                }, we(L), 9, ep))), 128)),
                w[12] || (w[12] = O("option", {
                  key: "empty",
                  value: null
                }, "-", -1))
              ], 544), [
                [Kt, s.value.dataflowType]
              ])
            ]),
            O("div", tp, [
              w[15] || (w[15] = O("label", {
                for: "preferred-lnode-select",
                class: "col-start-1 self-center"
              }, "Preferred LNode", -1)),
              He(O("select", {
                id: "preferred-lnode-select",
                class: "select col-start-2",
                "onUpdate:modelValue": w[4] || (w[4] = (L) => s.value.preferredLNode = L),
                onChange: w[5] || (w[5] = (L) => b(["preferredDataObject"]))
              }, [
                (ie(!0), fe(Ie, null, dt(x.lnodeTypes, (L) => (ie(), fe("option", {
                  key: L.lnClass,
                  value: L.lnClass
                }, we(L.lnClass), 9, np))), 128)),
                w[14] || (w[14] = O("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 544), [
                [Kt, s.value.preferredLNode]
              ])
            ]),
            O("div", rp, [
              w[17] || (w[17] = O("label", {
                for: "data-object-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Object", -1)),
              He(O("select", {
                id: "data-object-select",
                class: "select col-start-2",
                "onUpdate:modelValue": w[6] || (w[6] = (L) => s.value.preferredDataObject = L),
                onChange: w[7] || (w[7] = (L) => b(["preferredDataAttribute"]))
              }, [
                (ie(!0), fe(Ie, null, dt(c.value, (L) => (ie(), fe("option", {
                  key: L,
                  value: L
                }, we(L), 9, op))), 128)),
                w[16] || (w[16] = O("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 544), [
                [Kt, s.value.preferredDataObject]
              ])
            ]),
            O("div", ip, [
              w[19] || (w[19] = O("label", {
                for: "data-attribute-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Attribute", -1)),
              He(O("select", {
                id: "data-attribute-select",
                class: "select col-start-2",
                "onUpdate:modelValue": w[8] || (w[8] = (L) => s.value.preferredDataAttribute = L)
              }, [
                (ie(!0), fe(Ie, null, dt(d.value, (L) => (ie(), fe("option", {
                  key: L,
                  value: L
                }, we(L), 9, sp))), 128)),
                w[18] || (w[18] = O("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 512), [
                [Kt, s.value.preferredDataAttribute]
              ])
            ]),
            O("div", ap, [
              w[20] || (w[20] = O("label", {
                for: "process-resource-input",
                class: "col-start-1 self-center"
              }, "Process Resource", -1)),
              He(O("input", {
                id: "process-resource-input",
                type: "text",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": w[9] || (w[9] = (L) => s.value.processResource = L)
              }, null, 512), [
                [An, s.value.processResource]
              ])
            ]),
            w[21] || (w[21] = O("div", { class: "modal-action" }, [
              O("button", {
                class: "btn bg-(--color-primary) border-none text-white",
                type: "submit"
              }, " Save ")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), up = { key: 0 }, cp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, fp = /* @__PURE__ */ wt({
  __name: "source-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(e) {
    return (t, r) => (ie(), fe("div", null, [
      (ie(), fe("div", up, [
        r[0] || (r[0] = O("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder Details", -1)),
        t.placeholder.dataflowType ? (ie(), fe("span", cp, we(t.placeholder.dataflowType), 1)) : $t("", !0),
        O("p", null, "Input: " + we(t.placeholder.input), 1),
        O("p", null, "Data Object: " + we(t.placeholder.dataObject || "-"), 1),
        O("p", null, "Data Attribute: " + we(t.placeholder.dataAttribute || "-"), 1),
        O("p", null, "Preferred LNode: " + we(t.placeholder.preferredLNode || "-"), 1),
        O("p", null, "Process Resource: " + we(t.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), dp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12 *:pointer-events-auto" }, pp = ["onClick"], hp = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, mp = ["onClick"], yp = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, gp = ["onClick"], vp = {
  height: "12",
  width: "24"
}, bp = { class: "ml-2" }, _p = /* @__PURE__ */ wt({
  __name: "source-placeholder-ports",
  props: {
    dataObjectSpecifications: {}
  },
  setup(e) {
    const t = e, r = lt(
      () => t.dataObjectSpecifications.flatMap(
        (c) => c.dataAttributeSpecifications.flatMap((d) => d.subscriberLNode ? {
          id: d.subscriberLNode.id,
          dataObject: c.name,
          dataAttribute: d.name,
          dataflowType: d.subscriberLNode.service,
          preferredLNode: d.subscriberLNode.pLN,
          input: d.subscriberLNode.inputName,
          processResource: ""
        } : [])
      )
    ), i = cu(), { activeElement: s } = au(i);
    function u(c) {
      const d = c == s.value ? null : c;
      i.setActiveElement(d);
    }
    return (c, d) => (ie(!0), fe(Ie, null, dt(r.value, (h) => (ie(), fe("div", dp, [
      O("div", {
        onClick: (C) => u(h.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        O("span", hp, we(h.dataObject) + "." + we(h.dataAttribute), 1)
      ], 8, pp),
      O("div", {
        onClick: (C) => u(h.id),
        class: Un([{
          "bg-(--color-primary)": We(s) === h.id
        }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
      }, null, 10, mp),
      O("div", yp, [
        O("div", {
          class: "inline-flex items-center h-full max-w-max hover:cursor-pointer",
          onClick: (C) => u(h.id)
        }, [
          (ie(), fe("svg", vp, [
            O("line", {
              x1: "0",
              y1: "6",
              x2: "24",
              y2: "6",
              stroke: "currentColor",
              "stroke-width": "2",
              class: Un({
                "text-(--color-primary)": We(s) === h.id,
                "text-(--color-ocean-gray-100)": We(s) !== h.id
              })
            }, null, 2)
          ])),
          O("span", bp, we(h.input), 1)
        ], 8, gp)
      ]),
      We(s) == h.id ? (ie(), Mt(Nl, {
        key: 0,
        to: "#sidebar-details"
      }, [
        tt(fp, { placeholder: h }, null, 8, ["placeholder"])
      ])) : $t("", !0)
    ]))), 256));
  }
}), wp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, xp = { class: "col-start-1 col-span-1 self-center justify-self-end" }, Cp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Sp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Op = ["data-testid"], Np = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Tp = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Ep = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Ap = /* @__PURE__ */ wt({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(e) {
    return (t, r) => (ie(!0), fe(Ie, null, dt(t.controlledConnections, (i, s) => (ie(), fe("div", wp, [
      O("div", xp, [
        O("span", Cp, we(i.outputName), 1),
        O("span", Sp, we(i.outputInstance), 1)
      ]),
      r[0] || (r[0] = O("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      O("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-controlled-connection-line-${s}`
      }, null, 8, Op),
      r[1] || (r[1] = O("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        O("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      O("div", Np, we(i.dataflowType), 1),
      r[2] || (r[2] = O("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      O("div", Tp, [
        O("span", Ep, we(i.controlledDataObject), 1)
      ])
    ]))), 256));
  }
}), Pp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Rp = { class: "modal-box" }, Dp = { class: "grid grid-cols-2 gap-4 items-center" }, kp = { class: "grid grid-cols-2 gap-4 items-center" }, Ip = ["value", "disabled"], Lp = { class: "grid grid-cols-2 gap-4 items-center" }, jp = ["value"], Mp = { class: "grid grid-cols-2 gap-4 items-center" }, $p = { class: "grid grid-cols-2 gap-4 items-center" }, Kp = ["value"], Fp = /* @__PURE__ */ wt({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {},
    lnodeTypes: {}
  },
  emits: ["placeholderCreated"],
  setup(e, { emit: t }) {
    const r = t, i = e, s = {
      dataAttribute: "",
      inputName: "",
      dataflowType: "",
      processResource: "",
      preferredLNode: ""
    }, u = Qe(s);
    async function c(C) {
      const y = C.target;
      try {
        const b = localStorage.getItem("currentActiveFileDatabaseName");
        if (!b) throw new Error("no active file");
        const x = await Ur(b);
        await zo(x).createSourcePlaceholder(u.value), x.close(), r("placeholderCreated"), u.value = s, y.reset();
      } catch (b) {
        console.error("Error creating source placeholder port:", b), alert(`Error creating placeholder: ${b instanceof Error ? b.message : "Unknown error"}`);
      }
    }
    const d = lt(() => (i.sourceLNode.dataObjectSpecifications ?? []).flatMap((x) => x.dataAttributeSpecifications).filter((x) => {
      const w = u.value.dataflowType;
      return !w || !x.subscriberLNode?.service ? !0 : w == x.subscriberLNode.service;
    }).map((x) => ({ id: x.id, name: x.name })).sort((x, w) => x.name.localeCompare(w.name))), h = Al("dialog");
    return (C, y) => (ie(), fe("div", Pp, [
      O("button", {
        onClick: y[0] || (y[0] = (b) => h.value?.showModal()),
        "aria-label": "Add source placeholder",
        class: "btn btn-primary btn-circle size-5 col-start-3 col-span-1 -ml-[12px] self-center relative z-10"
      }, y[6] || (y[6] = [
        O("svg", {
          width: "16",
          height: "16",
          viewBox: "0 0 20 20",
          fill: "currentColor"
        }, [
          O("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          O("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      O("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: h
      }, [
        O("div", Rp, [
          y[16] || (y[16] = O("h3", { class: "text-lg font-bold" }, "Create Placeholder - Provide data", -1)),
          y[17] || (y[17] = O("form", { method: "dialog" }, [
            O("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close source placeholder creation"
            }, [
              O("svg", {
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                O("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          O("form", {
            onSubmit: c,
            method: "dialog",
            class: "flex flex-col gap-4 mt-4"
          }, [
            O("div", Dp, [
              y[7] || (y[7] = O("label", { for: "input-name" }, "Input", -1)),
              He(O("input", {
                required: "",
                id: "input-name",
                name: "inputName",
                "onUpdate:modelValue": y[1] || (y[1] = (b) => u.value.inputName = b),
                placeholder: "Input Name",
                class: "input col-start-2"
              }, null, 512), [
                [An, u.value.inputName]
              ])
            ]),
            O("div", kp, [
              y[9] || (y[9] = O("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
              He(O("select", {
                id: "dataflow-type-select",
                name: "dataflowType",
                class: "select col-start-2",
                "onUpdate:modelValue": y[2] || (y[2] = (b) => u.value.dataflowType = b)
              }, [
                y[8] || (y[8] = O("option", { value: "" }, "-", -1)),
                (ie(!0), fe(Ie, null, dt(Object.values(We(nt)), (b) => (ie(), fe("option", {
                  key: b,
                  value: b,
                  disabled: b === We(nt).CONTROL
                }, we(b), 9, Ip))), 128))
              ], 512), [
                [Kt, u.value.dataflowType]
              ])
            ]),
            O("div", Lp, [
              y[11] || (y[11] = O("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
              He(O("select", {
                required: "",
                id: "data-attribute-select",
                name: "attribute",
                "onUpdate:modelValue": y[3] || (y[3] = (b) => u.value.dataAttribute = b),
                class: "select col-start-2",
                placeholder: "No Attribute"
              }, [
                y[10] || (y[10] = O("option", {
                  value: "",
                  disabled: ""
                }, "-", -1)),
                (ie(!0), fe(Ie, null, dt(d.value, (b) => (ie(), fe("option", {
                  key: b.id,
                  value: b.id
                }, we(b.name), 9, jp))), 128))
              ], 512), [
                [Kt, u.value.dataAttribute]
              ])
            ]),
            O("div", Mp, [
              y[12] || (y[12] = O("label", { for: "process-resource-input" }, "Process Resource", -1)),
              He(O("input", {
                id: "process-resource-input",
                name: "processResource",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": y[4] || (y[4] = (b) => u.value.processResource = b)
              }, null, 512), [
                [An, u.value.processResource]
              ])
            ]),
            O("div", $p, [
              y[14] || (y[14] = O("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
              He(O("select", {
                id: "preferred-lnode-select",
                name: "preferredLNode",
                class: "select col-start-2",
                "onUpdate:modelValue": y[5] || (y[5] = (b) => u.value.preferredLNode = b)
              }, [
                (ie(!0), fe(Ie, null, dt(C.lnodeTypes, (b) => (ie(), fe("option", {
                  key: b.lnClass,
                  value: b.lnClass
                }, we(b.lnClass), 9, Kp))), 128)),
                y[13] || (y[13] = O("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 512), [
                [Kt, u.value.preferredLNode]
              ])
            ]),
            y[15] || (y[15] = O("div", { class: "modal-action" }, [
              O("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), Bp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, qp = ["value"], Up = ["value"], Vp = ["value"], Hp = ["value"], Wp = { class: "col-span-full row-start-2" }, zp = { class: "grid" }, Gp = { class: "col-start-1 row-start-1 pointer-events-none" }, Yp = { class: "col-start-1 row-start-1 -order-1" }, Qp = /* @__PURE__ */ wt({
  __name: "dataflow-visualisation",
  props: {
    lnodes: {},
    connections: {},
    lnodeTypes: {},
    controlledConnections: {}
  },
  emits: ["sourceLNodeChange", "destinationLNodeChange", "placeholderCreated"],
  setup(e, { emit: t }) {
    const r = t, i = e;
    an(
      () => i.lnodes,
      () => {
        s.value = void 0, u.value = void 0;
      }
    );
    const s = Qe(), u = Qe(), c = Qe(), d = Qe(), h = lt(
      () => i.lnodes.filter((ne) => ne.id !== u.value).sort((ne, se) => Gt(ne).localeCompare(Gt(se)))
    ), C = lt(() => i.lnodes.find((se) => se.id === s.value)?.dataObjectSpecifications ?? []), y = lt(
      () => i.lnodes.filter((ne) => ne.id !== s.value).sort((ne, se) => Gt(ne).localeCompare(Gt(se)))
    ), b = lt(() => !s.value || !u.value ? [] : i.connections.filter(
      (ne) => ne.sourceLNodeId === s.value && ne.destinationLNodeId === u.value
    )), x = lt(() => !s.value || !u.value ? [] : i.controlledConnections.filter(
      (ne) => ne.controllerLNodeId === s.value && ne.controlledLNodeId === u.value
    )), w = lt(() => u.value ? i.connections.filter(
      (ne) => ne.destinationLNodeId === u.value && !ne.sourceLNodeId
    ) : []);
    function L(ne) {
      return i.lnodes.find((se) => se.id === ne) ?? void 0;
    }
    function re(ne) {
      s.value = ne, c.value = L(ne), r("sourceLNodeChange", ne);
    }
    function Le(ne) {
      u.value = ne, d.value = L(ne), r("destinationLNodeChange", ne);
    }
    return (ne, se) => (ie(), fe("div", Bp, [
      se[7] || (se[7] = O("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      O("select", {
        value: s.value ?? "",
        onChange: se[0] || (se[0] = (de) => re(de.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        se[4] || (se[4] = Xl(" > ")),
        se[5] || (se[5] = O("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ie(!0), fe(Ie, null, dt(h.value, (de) => (ie(), fe("option", {
          key: de.id,
          value: de.id
        }, we(We(Gt)(de)), 9, Up))), 128))
      ], 40, qp),
      se[8] || (se[8] = O("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      O("select", {
        value: u.value ?? "",
        onChange: se[1] || (se[1] = (de) => Le(de.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        se[6] || (se[6] = O("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ie(!0), fe(Ie, null, dt(y.value, (de) => (ie(), fe("option", {
          key: de.id,
          value: de.id
        }, we(We(Gt)(de)), 9, Hp))), 128))
      ], 40, Vp),
      O("div", Wp, [
        b.value.length > 0 ? (ie(), Mt(Rd, {
          key: 0,
          connections: b.value
        }, null, 8, ["connections"])) : $t("", !0),
        x.value.length > 0 ? (ie(), Mt(Ap, {
          key: 1,
          controlledConnections: x.value
        }, null, 8, ["controlledConnections"])) : $t("", !0),
        O("div", zp, [
          O("div", Gp, [
            tt(_p, { dataObjectSpecifications: C.value }, null, 8, ["dataObjectSpecifications"])
          ]),
          O("div", Yp, [
            tt(Ud, { destinationPlaceHolderPorts: w.value }, null, 8, ["destinationPlaceHolderPorts"])
          ])
        ])
      ]),
      c.value ? (ie(), Mt(Fp, {
        key: c.value.id,
        sourceLNode: c.value,
        class: "col-span-full row-start-3",
        lnodeTypes: ne.lnodeTypes,
        onPlaceholderCreated: se[2] || (se[2] = (de) => r("placeholderCreated"))
      }, null, 8, ["sourceLNode", "lnodeTypes"])) : $t("", !0),
      d.value ? (ie(), Mt(lp, {
        key: 1,
        destinationLNode: d.value,
        class: "col-span-full row-start-3",
        lnodeTypes: ne.lnodeTypes,
        onPlaceholderCreated: se[3] || (se[3] = (de) => r("placeholderCreated"))
      }, null, 8, ["destinationLNode", "lnodeTypes"])) : $t("", !0)
    ]));
  }
}), Jp = { class: "grid grid-cols-2 gap-4 mt-4" }, Xp = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Zp = ["value"], eh = { class: "grid grid-cols-2 gap-4 mt-4" }, th = ["value"], nh = { class: "grid grid-cols-2 gap-4 mt-4" }, rh = ["value"], oh = { class: "grid grid-cols-2 gap-4 mt-4" }, ih = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, sh = ["value"], ah = { class: "grid grid-cols-2 gap-4 mt-4" }, lh = { class: "grid grid-cols-2 gap-4 mt-4" }, uh = { class: "mt-4" }, ch = { class: "mt-4" }, fh = /* @__PURE__ */ wt({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const r = e, i = t, s = Qe(d());
    Wl(
      () => s.value.inputName = s.value.signal
    ), an(
      () => s.value.inputName,
      () => {
        s.value.inputInstance = "1";
      }
    ), an(
      () => r.dataflowType,
      (x) => {
        switch (b(), s.value.type = x, x) {
          case nt.GOOSE:
          case nt.SMV:
            s.value.includeQuality = !0, s.value.includeTimestamp = !1;
            break;
          case nt.REPORT:
            s.value.includeQuality = !0, s.value.includeTimestamp = !0;
            break;
          default:
            s.value.includeQuality = !1, s.value.includeTimestamp = !1;
        }
      }
    );
    const u = lt(() => !r.dataflowType || !r.sourceLNode ? [] : r.lnodeTypes.find((x) => x.typeId === r.sourceLNode.lnType)?.dataObjects.filter(
      (x) => x.dataAttributes.some(
        (w) => Lo[r.dataflowType]?.includes(w.fc)
      )
    ).map((x) => x.name) || []), c = lt(() => !r.dataflowType || !r.sourceLNode ? [] : r.lnodeTypes.find((x) => x.typeId === r.sourceLNode.lnType)?.dataObjects.find((x) => x.name === s.value.signal)?.dataAttributes.filter(
      (x) => Lo[r.dataflowType]?.includes(x.fc)
    ).filter((x) => x.name !== "t" && x.name !== "q").map((x) => x.name) || []);
    function d() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function h(x) {
      for (const w of x)
        s.value[w] = "";
    }
    async function C() {
      try {
        if (!y(s.value))
          return;
        const x = localStorage.getItem("currentActiveFileDatabaseName");
        if (!x)
          throw new Error("no active file");
        const w = await Ur(x);
        await zo(w).createConnection(
          s.value,
          r.sourceLNode,
          r.destinationLNode
        ), w.close(), i("connectionCreated"), b();
      } catch (x) {
        console.error("Error creating dataflow:", x), alert(`Error creating dataflow: ${x instanceof Error ? x.message : "Unknown error"}`);
      }
    }
    function y(x) {
      return x.type ? x.signal ? x.attribute ? x.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function b() {
      s.value = d();
    }
    return (x, w) => (ie(), fe(Ie, null, [
      w[17] || (w[17] = O("hr", { class: "solid mt-4" }, null, -1)),
      O("div", Jp, [
        w[7] || (w[7] = O("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Source", -1)),
        O("select", Xp, [
          O("option", {
            value: r.sourceLNode.id
          }, we(We(Gt)(x.sourceLNode)), 9, Zp)
        ])
      ]),
      O("div", eh, [
        w[9] || (w[9] = O("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Signal (DO)", -1)),
        He(O("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": w[0] || (w[0] = (L) => s.value.signal = L),
          onChange: w[1] || (w[1] = (L) => h(["attribute"]))
        }, [
          (ie(!0), fe(Ie, null, dt(u.value, (L) => (ie(), fe("option", {
            key: L,
            value: L
          }, we(L), 9, th))), 128)),
          w[8] || (w[8] = O("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 544), [
          [Kt, s.value.signal]
        ])
      ]),
      O("div", nh, [
        w[11] || (w[11] = O("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Attribute (DA)", -1)),
        He(O("select", {
          id: "data-attribute-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": w[2] || (w[2] = (L) => s.value.attribute = L)
        }, [
          (ie(!0), fe(Ie, null, dt(c.value, (L) => (ie(), fe("option", {
            key: L,
            value: L
          }, we(L), 9, rh))), 128)),
          w[10] || (w[10] = O("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [Kt, s.value.attribute]
        ])
      ]),
      w[18] || (w[18] = O("hr", { class: "solid mt-4" }, null, -1)),
      O("div", oh, [
        w[12] || (w[12] = O("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Destination", -1)),
        O("select", ih, [
          O("option", {
            value: r.destinationLNode.id
          }, we(We(Gt)(x.destinationLNode)), 9, sh)
        ])
      ]),
      O("div", ah, [
        w[13] || (w[13] = O("label", {
          for: "input-name-input",
          class: "col-start-1 self-center"
        }, "Input Name", -1)),
        He(O("input", {
          id: "input-name-input",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": w[3] || (w[3] = (L) => s.value.inputName = L)
        }, null, 512), [
          [An, s.value.inputName]
        ])
      ]),
      O("div", lh, [
        w[14] || (w[14] = O("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        He(O("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": w[4] || (w[4] = (L) => s.value.inputInstance = L)
        }, null, 512), [
          [An, s.value.inputInstance]
        ])
      ]),
      w[19] || (w[19] = O("hr", { class: "solid mt-4" }, null, -1)),
      O("div", uh, [
        He(O("input", {
          type: "checkbox",
          "onUpdate:modelValue": w[5] || (w[5] = (L) => s.value.includeQuality = L),
          class: "checkbox mr-2",
          id: "checkbox-include-quality"
        }, null, 512), [
          [Ia, s.value.includeQuality]
        ]),
        w[15] || (w[15] = O("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
      ]),
      O("div", ch, [
        He(O("input", {
          type: "checkbox",
          "onUpdate:modelValue": w[6] || (w[6] = (L) => s.value.includeTimestamp = L),
          class: "checkbox mr-2",
          id: "checkbox-include-timestamp"
        }, null, 512), [
          [Ia, s.value.includeTimestamp]
        ]),
        w[16] || (w[16] = O("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
      ]),
      O("div", { class: "modal-action" }, [
        O("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: C,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), dh = { class: "grid grid-cols-2 gap-4 mt-4" }, ph = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, hh = ["value"], mh = { class: "grid grid-cols-2 gap-4 mt-4" }, yh = ["value"], gh = { class: "grid grid-cols-2 gap-4 mt-4" }, vh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, bh = ["value"], _h = { class: "grid grid-cols-2 gap-4 mt-4" }, wh = { class: "grid grid-cols-2 gap-4 mt-4" }, xh = /* @__PURE__ */ wt({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const r = e, i = t, s = Qe(
      c()
    );
    Wl(
      () => s.value.outputName = s.value.controlledSignal
    ), an(
      () => s.value.outputName,
      () => {
        s.value.outputInstance = "1";
      }
    );
    const u = lt(() => r.destinationLNode ? r.lnodeTypes.find((b) => b.typeId === r.destinationLNode.lnType)?.dataObjects.map((b) => b.name) || [] : []);
    function c() {
      return {
        type: nt.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function d() {
      try {
        if (!h(s.value))
          return;
        const y = localStorage.getItem("currentActiveFileDatabaseName");
        if (!y)
          throw new Error("no active file");
        const b = await Ur(y);
        await zo(b).createControlledConnection(
          s.value,
          r.sourceLNode,
          r.destinationLNode
        ), b.close(), i("connectionCreated"), C();
      } catch (y) {
        console.error("Error creating controlled dataflow:", y), alert(`Error creating controlled dataflow: ${y instanceof Error ? y.message : "Unknown error"}`);
      }
    }
    function h(y) {
      return y.type ? y.outputName ? y.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function C() {
      s.value = c();
    }
    return (y, b) => (ie(), fe(Ie, null, [
      b[9] || (b[9] = O("hr", { class: "solid mt-4" }, null, -1)),
      O("div", dh, [
        b[3] || (b[3] = O("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        O("select", ph, [
          O("option", {
            value: r.destinationLNode.id
          }, we(We(Gt)(y.destinationLNode)), 9, hh)
        ])
      ]),
      O("div", mh, [
        b[5] || (b[5] = O("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        He(O("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": b[0] || (b[0] = (x) => s.value.controlledSignal = x)
        }, [
          (ie(!0), fe(Ie, null, dt(u.value, (x) => (ie(), fe("option", {
            key: x,
            value: x
          }, we(x), 9, yh))), 128)),
          b[4] || (b[4] = O("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [Kt, s.value.controlledSignal]
        ])
      ]),
      b[10] || (b[10] = O("hr", { class: "solid mt-4" }, null, -1)),
      O("div", gh, [
        b[6] || (b[6] = O("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        O("select", vh, [
          O("option", {
            value: r.sourceLNode.id
          }, we(We(Gt)(y.sourceLNode)), 9, bh)
        ])
      ]),
      O("div", _h, [
        b[7] || (b[7] = O("label", {
          for: "output-name-input",
          class: "col-start-1 self-center"
        }, "Controller Output Name", -1)),
        He(O("input", {
          id: "output-name-input",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": b[1] || (b[1] = (x) => s.value.outputName = x)
        }, null, 512), [
          [An, s.value.outputName]
        ])
      ]),
      O("div", wh, [
        b[8] || (b[8] = O("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Ouput Instance", -1)),
        He(O("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": b[2] || (b[2] = (x) => s.value.outputInstance = x)
        }, null, 512), [
          [An, s.value.outputInstance]
        ])
      ]),
      b[11] || (b[11] = O("hr", { class: "solid mt-4" }, null, -1)),
      O("div", { class: "modal-action" }, [
        O("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: d,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), Ch = ["disabled"], Sh = ["open"], Oh = { class: "modal-box" }, Nh = { class: "grid grid-cols-2 gap-4 mt-4" }, Th = ["value", "disabled"], Eh = /* @__PURE__ */ wt({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    lnodeTypes: {}
  },
  emits: ["connectionCreated"],
  setup(e, { emit: t }) {
    const r = e, i = t, s = Qe(!1), u = Qe(null), c = lt(
      () => r.sourceLNode?.lnClass === "IHMI" || r.sourceLNode?.lnClass === "ITCI"
    );
    function d(b) {
      const x = b.target.value;
      u.value = x;
    }
    function h() {
      i("connectionCreated"), y();
    }
    function C() {
      s.value = !0;
    }
    function y() {
      s.value = !1, u.value = null;
    }
    return (b, x) => (ie(), fe(Ie, null, [
      O("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: C,
        disabled: !r.sourceLNode || !r.destinationLNode,
        "aria-label": "Add connection"
      }, " + ", 8, Ch),
      r.sourceLNode && r.destinationLNode ? (ie(), fe("dialog", {
        key: 0,
        class: "modal",
        open: s.value
      }, [
        O("div", Oh, [
          x[4] || (x[4] = O("h3", { class: "text-lg font-bold" }, "Create Connection", -1)),
          O("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: y,
            "aria-label": "Close dataflow creation",
            "data-testId": "close-dataflow-creation"
          }, x[1] || (x[1] = [
            O("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              O("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          O("div", Nh, [
            x[3] || (x[3] = O("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            He(O("select", {
              id: "dataflow-type-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": x[0] || (x[0] = (w) => u.value = w),
              onChange: d
            }, [
              (ie(!0), fe(Ie, null, dt(Object.values(We(nt)), (w) => (ie(), fe("option", {
                key: w,
                value: w,
                disabled: w === We(nt).CONTROL && !c.value
              }, we(w), 9, Th))), 128)),
              x[2] || (x[2] = O("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [Kt, u.value]
            ])
          ]),
          u.value !== We(nt).CONTROL ? (ie(), Mt(fh, {
            key: 0,
            sourceLNode: r.sourceLNode,
            destinationLNode: r.destinationLNode,
            lnodeTypes: r.lnodeTypes,
            dataflowType: u.value,
            onConnectionCreated: h
          }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes", "dataflowType"])) : (ie(), Mt(xh, {
            key: 1,
            sourceLNode: r.sourceLNode,
            destinationLNode: r.destinationLNode,
            lnodeTypes: r.lnodeTypes,
            dataflowType: u.value,
            onConnectionCreated: h
          }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes", "dataflowType"]))
        ])
      ], 8, Sh)) : $t("", !0)
    ], 64));
  }
}), Ah = { class: "flex flex-col items-center justify-center w-full" }, Ph = /* @__PURE__ */ wt({
  __name: "dataflow-view",
  props: {
    sdks: {}
  },
  setup(e) {
    const t = e, r = Qe(), i = Qe(), s = Qe([]), u = Qe([]), c = Qe([]), d = Qe([]);
    an(
      () => t.sdks,
      () => {
        h(), C();
      },
      { immediate: !0 }
    );
    async function h() {
      t.sdks && (s.value = await t.sdks.lnodeSDK.findAllEnrichedLNodes(), u.value = await t.sdks.lnodeSDK.findAllLNodeTypes());
    }
    async function C() {
      t.sdks && (c.value = await t.sdks.connectionSDK.findAllExistingConnections(), d.value = await t.sdks.connectionSDK.findAllExistingControlledConnections());
    }
    function y(w) {
      r.value = x(w);
    }
    function b(w) {
      i.value = x(w);
    }
    function x(w) {
      return s.value.find((L) => L.id === w) ?? void 0;
    }
    return (w, L) => (ie(), fe("div", Ah, [
      tt(Qp, {
        connections: c.value,
        controlledConnections: d.value,
        lnodes: s.value,
        lnodeTypes: u.value,
        onSourceLNodeChange: y,
        onDestinationLNodeChange: b,
        onPlaceholderCreated: C
      }, null, 8, ["connections", "controlledConnections", "lnodes", "lnodeTypes"]),
      tt(Eh, {
        sourceLNode: r.value,
        destinationLNode: i.value,
        lnodeTypes: u.value,
        onConnectionCreated: C
      }, null, 8, ["sourceLNode", "destinationLNode", "lnodeTypes"])
    ]));
  }
}), du = (e, t) => {
  const r = e.__vccOpts || e;
  for (const [i, s] of t)
    r[i] = s;
  return r;
}, Rh = {}, Dh = { class: "layout" }, kh = { class: "main" }, Ih = { class: "sidebar" };
function Lh(e, t) {
  return ie(), fe("div", Dh, [
    O("div", kh, [
      ca(e.$slots, "main", {}, void 0)
    ]),
    O("div", Ih, [
      ca(e.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const jh = /* @__PURE__ */ du(Rh, [["render", Lh], ["__scopeId", "data-v-5f95d421"]]), Mh = {
  name: "sidebar",
  class: "root"
}, $h = { class: "tabs tabs-box" }, Kh = { key: 0 }, Fh = { key: 1 }, Bh = /* @__PURE__ */ wt({
  __name: "sidebar",
  setup(e) {
    const t = Qe("details");
    return (r, i) => (ie(), fe("div", Mh, [
      O("div", $h, [
        He(O("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": i[0] || (i[0] = (s) => t.value = s),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [ja, t.value]
        ]),
        He(O("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": i[1] || (i[1] = (s) => t.value = s),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [ja, t.value]
        ])
      ]),
      O("div", null, [
        t.value === "details" ? (ie(), fe("div", Kh, i[2] || (i[2] = [
          O("div", { id: "sidebar-details" }, null, -1)
        ]))) : $t("", !0),
        t.value === "advanced" ? (ie(), fe("div", Fh)) : $t("", !0)
      ])
    ]));
  }
}), qh = /* @__PURE__ */ du(Bh, [["__scopeId", "data-v-ec5c053a"]]), Uh = ["id"], Vh = { class: "p-10" }, Hh = /* @__PURE__ */ wt({
  __name: "app",
  props: {
    api: {}
  },
  setup(e) {
    const t = "dataflow";
    let r = Qe();
    Dl(() => {
      window.addEventListener("storage", i), s();
    }), ys(() => {
      window.removeEventListener("storage", i);
    });
    async function i(c) {
      if (c.key !== "currentActiveFileDatabaseName")
        return;
      const d = c.newValue;
      if (!d)
        throw new Error("incorrect active file name: " + d);
      await u(d);
    }
    async function s() {
      const c = localStorage.getItem("currentActiveFileDatabaseName");
      c && await u(c);
    }
    async function u(c) {
      r.value && r.value.db.close();
      const d = await Ur(c);
      if (!d) throw new Error("database is not initialized.");
      r.value = {
        db: d,
        lnodeSDK: _d(d),
        connectionSDK: wd(d)
      };
    }
    return (c, d) => (ie(), fe("article", {
      id: We(t),
      style: { height: "100%" }
    }, [
      tt(jh, null, {
        main: qi(() => [
          O("div", Vh, [
            tt(Ph, { sdks: We(r) }, null, 8, ["sdks"])
          ])
        ]),
        sidebar: qi(() => [
          tt(qh)
        ]),
        _: 1
      })
    ], 8, Uh));
  }
});
function rm(e, t) {
  if (!document.getElementById(e)) {
    console.error({ msg: "could not found root element", rootId: e });
    return;
  }
  const i = od(Hh, { api: t });
  return i.use(ad()), i.mount(`#${e}`), i.unmount;
}
export {
  rm as default
};
