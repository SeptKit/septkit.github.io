(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(`.backdrop[data-v-9cc5b747]{position:fixed;inset:0;z-index:5;width:100vw;height:100vh;background:transparent}:where(.custom-plus-btn-left[data-v-350ad1a1]){width:unset}.custom-plus-btn-left[data-v-350ad1a1]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.custom-plus-btn-left[data-v-350ad1a1]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.custom-plus-btn-left[data-v-350ad1a1]{--btn-noise:var(--fx-noise)}.prose .custom-plus-btn-left[data-v-350ad1a1]{text-decoration-line:none}@media (hover:hover){.custom-plus-btn-left[data-v-350ad1a1]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.custom-plus-btn-left[data-v-350ad1a1]:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.custom-plus-btn-left[data-v-350ad1a1]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.custom-plus-btn-left[data-v-350ad1a1]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.custom-plus-btn-left[data-v-350ad1a1]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.custom-plus-btn-left[data-v-350ad1a1]:is(input[type=checkbox],input[type=radio]){appearance:none}.custom-plus-btn-left[data-v-350ad1a1]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.custom-plus-btn-left[data-v-350ad1a1]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.custom-plus-btn-left[data-v-350ad1a1]{z-index:10;width:var(--size);height:var(--size);width:calc(var(--spacing,.25rem)*5);height:calc(var(--spacing,.25rem)*5);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);border-radius:3.40282e38px;grid-column:3/span 1;grid-row-start:4;align-self:center;margin-left:-12px;padding-inline:0}:where(.custom-plus-btn-right[data-v-350ad1a1]){width:unset}.custom-plus-btn-right[data-v-350ad1a1]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.custom-plus-btn-right[data-v-350ad1a1]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.custom-plus-btn-right[data-v-350ad1a1]{--btn-noise:var(--fx-noise)}.prose .custom-plus-btn-right[data-v-350ad1a1]{text-decoration-line:none}@media (hover:hover){.custom-plus-btn-right[data-v-350ad1a1]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.custom-plus-btn-right[data-v-350ad1a1]:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.custom-plus-btn-right[data-v-350ad1a1]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.custom-plus-btn-right[data-v-350ad1a1]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.custom-plus-btn-right[data-v-350ad1a1]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-350ad1a1]:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.custom-plus-btn-right[data-v-350ad1a1]:is(input[type=checkbox],input[type=radio]){appearance:none}.custom-plus-btn-right[data-v-350ad1a1]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.custom-plus-btn-right[data-v-350ad1a1]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.custom-plus-btn-right[data-v-350ad1a1]{width:var(--size);height:var(--size);width:calc(var(--spacing,.25rem)*5);height:calc(var(--spacing,.25rem)*5);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);border-radius:3.40282e38px;grid-column:4/span 1;grid-row-start:4;align-self:center;margin-left:-9px;padding-inline:0}.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-content:""}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-gray-200:oklch(92.8% .006 264.531);--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}.menu{--menu-active-fg:var(--color-neutral-content);--menu-active-bg:var(--color-neutral);flex-flow:column wrap;width:fit-content;padding:.5rem;font-size:.875rem;display:flex}.menu :where(li ul){white-space:nowrap;margin-inline-start:1rem;padding-inline-start:.5rem;position:relative}.menu :where(li ul):before{background-color:var(--color-base-content);opacity:.1;width:var(--border);content:"";inset-inline-start:0;position:absolute;top:.75rem;bottom:.75rem}.menu :where(li>.menu-dropdown:not(.menu-dropdown-show)){display:none}.menu :where(li:not(.menu-title)>:not(ul,details,.menu-title,.btn)),.menu :where(li:not(.menu-title)>details>summary:not(.menu-title)){border-radius:var(--radius-field);text-align:start;text-wrap:balance;-webkit-user-select:none;user-select:none;grid-auto-columns:minmax(auto,max-content) auto max-content;grid-auto-flow:column;align-content:flex-start;align-items:center;gap:.5rem;padding-block:.375rem;padding-inline:.75rem;transition-property:color,background-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:grid}.menu :where(li>details>summary){--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li>details>summary){outline-offset:2px;outline:2px solid #0000}}.menu :where(li>details>summary)::-webkit-details-marker{display:none}:is(.menu :where(li>details>summary),.menu :where(li>.menu-dropdown-toggle)):after{content:"";transform-origin:50%;pointer-events:none;justify-self:flex-end;width:.375rem;height:.375rem;transition-property:rotate,translate;transition-duration:.2s;display:block;translate:0 -1px;rotate:-135deg;box-shadow:inset 2px 2px}.menu :where(li>details[open]>summary):after,.menu :where(li>.menu-dropdown-toggle.menu-dropdown-show):after{translate:0 1px;rotate:45deg}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{cursor:pointer;background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{color:var(--color-base-content);--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{outline-offset:2px;outline:2px solid #0000}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){cursor:pointer;background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){outline-offset:2px;outline:2px solid #0000}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){box-shadow:inset 0 1px #00000003,inset 0 -1px #ffffff03}.menu :where(li:empty){background-color:var(--color-base-content);opacity:.1;height:1px;margin:.5rem 1rem}.menu :where(li){flex-flow:column wrap;flex-shrink:0;align-items:stretch;display:flex;position:relative}.menu :where(li) .badge{justify-self:flex-end}.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{outline-offset:2px;outline:2px solid #0000}}.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{color:var(--menu-active-fg);background-color:var(--menu-active-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise)}:is(.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active):not(:is(.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active):active){box-shadow:0 2px calc(var(--depth)*3px) -2px var(--menu-active-bg)}.menu :where(li).menu-disabled{pointer-events:none;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li).menu-disabled{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.menu .dropdown:focus-within .menu-dropdown-toggle:after{translate:0 1px;rotate:45deg}.menu .dropdown-content{margin-top:.5rem;padding:.5rem}.menu .dropdown-content:before{display:none}.collapse-arrow>.collapse-title:after{content:"";transform-origin:75% 75%;pointer-events:none;top:1.9rem;width:.5rem;height:.5rem;transition-property:all;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);display:block;position:absolute;inset-inline-end:1.4rem;transform:translateY(-100%)rotate(45deg);box-shadow:2px 2px}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999;transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.collapse:not(td,tr,colgroup){visibility:visible}.collapse{border-radius:var(--radius-box,1rem);isolation:isolate;grid-template-rows:max-content 0fr;width:100%;transition:grid-template-rows .2s;display:grid;position:relative;overflow:hidden}.collapse>input:is([type=checkbox],[type=radio]){appearance:none;opacity:0;z-index:1;grid-row-start:1;grid-column-start:1;width:100%;min-height:1lh;padding:1rem;padding-inline-end:3rem;transition:background-color .2s ease-out}.collapse:is([open],:focus:not(.collapse-close)),.collapse:not(.collapse-close):has(>input:is([type=checkbox],[type=radio]):checked){grid-template-rows:max-content 1fr}.collapse:is([open],:focus:not(.collapse-close))>.collapse-content,.collapse:not(.collapse-close)>:where(input:is([type=checkbox],[type=radio]):checked~.collapse-content){visibility:visible;min-height:fit-content}.collapse:focus-visible,.collapse:has(>input:is([type=checkbox],[type=radio]):focus-visible){outline-color:var(--color-base-content);outline-offset:2px;outline-width:2px;outline-style:solid}.collapse:not(.collapse-close)>input[type=checkbox],.collapse:not(.collapse-close)>input[type=radio]:not(:checked),.collapse:not(.collapse-close)>.collapse-title{cursor:pointer}.collapse:focus:not(.collapse-close,.collapse[open])>.collapse-title{cursor:unset}.collapse:is([open],:focus:not(.collapse-close))>:where(.collapse-content),.collapse:not(.collapse-close)>:where(input:is([type=checkbox],[type=radio]):checked~.collapse-content){padding-bottom:1rem;transition:padding .2s ease-out,background-color .2s ease-out}.collapse[open].collapse-arrow>.collapse-title:after,.collapse.collapse-open.collapse-arrow>.collapse-title:after{transform:translateY(-50%)rotate(225deg)}.collapse.collapse-open.collapse-plus>.collapse-title:after{content:"−"}.collapse.collapse-arrow:focus:not(.collapse-close)>.collapse-title:after,.collapse.collapse-arrow:not(.collapse-close)>input:is([type=checkbox],[type=radio]):checked~.collapse-title:after{transform:translateY(-50%)rotate(225deg)}.collapse[open].collapse-plus>.collapse-title:after,.collapse.collapse-plus:focus:not(.collapse-close)>.collapse-title:after,.collapse.collapse-plus:not(.collapse-close)>input:is([type=checkbox],[type=radio]):checked~.collapse-title:after{content:"−"}.collapse:is(details){width:100%}.collapse:is(details) summary{display:block;position:relative}.collapse:is(details) summary::-webkit-details-marker{display:none}.collapse:is(details) summary{outline:none}.collapse-content{visibility:hidden;min-height:0;cursor:unset;grid-row-start:2;grid-column-start:1;padding-left:1rem;padding-right:1rem;transition:visibility .2s,padding .2s ease-out,background-color .2s ease-out}.collapse{visibility:collapse}.toggle{border:var(--border)solid currentColor;color:var(--input-color);cursor:pointer;appearance:none;vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;--radius-selector-max:calc(var(--radius-selector) + var(--radius-selector) + var(--radius-selector));border-radius:calc(var(--radius-selector) + min(var(--toggle-p),var(--radius-selector-max)) + min(var(--border),var(--radius-selector-max)));padding:var(--toggle-p);flex-shrink:0;grid-template-columns:0fr 1fr 1fr;place-content:center;display:inline-grid;position:relative;box-shadow:inset 0 1px}@supports (color:color-mix(in lab,red,red)){.toggle{box-shadow:0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000) inset}}.toggle{--input-color:var(--color-base-content);transition:color .3s,grid-template-columns .2s}@supports (color:color-mix(in lab,red,red)){.toggle{--input-color:color-mix(in oklab,var(--color-base-content)50%,#0000)}}.toggle{--toggle-p:calc(var(--size)*.125);--size:calc(var(--size-selector,.25rem)*6);width:calc((var(--size)*2) - (var(--border) + var(--toggle-p))*2);height:var(--size)}.toggle>*{z-index:1;cursor:pointer;appearance:none;background-color:#0000;border:none;grid-column:2/span 1;grid-row-start:1;height:100%;padding:.125rem;transition:opacity .2s,rotate .4s}.toggle>:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.toggle>:focus{outline-offset:2px;outline:2px solid #0000}}.toggle>:nth-child(2){color:var(--color-base-100);rotate:none}.toggle>:nth-child(3){color:var(--color-base-100);opacity:0;rotate:-15deg}.toggle:has(:checked)>:nth-child(2){opacity:0;rotate:15deg}.toggle:has(:checked)>:nth-child(3){opacity:1;rotate:none}.toggle:before{aspect-ratio:1;border-radius:var(--radius-selector);--tw-content:"";content:var(--tw-content);height:100%;box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor;background-color:currentColor;grid-row-start:1;grid-column-start:2;transition:background-color .1s,translate .2s,inset-inline-start .2s;position:relative;inset-inline-start:0;translate:0}@supports (color:color-mix(in lab,red,red)){.toggle:before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000)}}.toggle:before{background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise)}@media (forced-colors:active){.toggle:before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{.toggle:before{outline-offset:-1rem;outline:.25rem solid}}.toggle:focus-visible,.toggle:has(:focus-visible){outline-offset:2px;outline:2px solid}.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked){background-color:var(--color-base-100);--input-color:var(--color-base-content);grid-template-columns:1fr 1fr 0fr}:is(.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked)):before{background-color:currentColor}@starting-style{:is(.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked)):before{opacity:0}}.toggle:indeterminate{grid-template-columns:.5fr 1fr .5fr}.toggle:disabled{cursor:not-allowed;opacity:.3}.toggle:disabled:before{border:var(--border)solid currentColor;background-color:#0000}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.range{appearance:none;webkit-appearance:none;--range-thumb:var(--color-base-100);--range-thumb-size:calc(var(--size-selector,.25rem)*6);--range-progress:currentColor;--range-fill:1;--range-p:.25rem;--range-bg:currentColor}@supports (color:color-mix(in lab,red,red)){.range{--range-bg:color-mix(in oklab,currentColor 10%,#0000)}}.range{cursor:pointer;vertical-align:middle;--radius-selector-max:calc(var(--radius-selector) + var(--radius-selector) + var(--radius-selector));border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));width:clamp(3rem,20rem,100%);height:var(--range-thumb-size);background-color:#0000;border:none;overflow:hidden}[dir=rtl] .range{--range-dir:-1}.range:focus{outline:none}.range:focus-visible{outline-offset:2px;outline:2px solid}.range::-webkit-slider-runnable-track{background-color:var(--range-bg);border-radius:var(--radius-selector);width:100%;height:calc(var(--range-thumb-size)*.5)}@media (forced-colors:active){.range::-webkit-slider-runnable-track{border:1px solid}.range::-moz-range-track{border:1px solid}}.range::-webkit-slider-thumb{box-sizing:border-box;border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));height:var(--range-thumb-size);width:var(--range-thumb-size);border:var(--range-p)solid;appearance:none;webkit-appearance:none;color:var(--range-progress);box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor,0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill));background-color:currentColor;position:relative;top:50%;transform:translateY(-50%)}@supports (color:color-mix(in lab,red,red)){.range::-webkit-slider-thumb{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000),0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill))}}.range::-moz-range-track{background-color:var(--range-bg);border-radius:var(--radius-selector);width:100%;height:calc(var(--range-thumb-size)*.5)}.range::-moz-range-thumb{box-sizing:border-box;border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));height:var(--range-thumb-size);width:var(--range-thumb-size);border:var(--range-p)solid;color:var(--range-progress);box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor,0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill));background-color:currentColor;position:relative;top:50%}@supports (color:color-mix(in lab,red,red)){.range::-moz-range-thumb{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000),0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill))}}.range:disabled{cursor:not-allowed;opacity:.3}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.collapse-title{grid-row-start:1;grid-column-start:1;width:100%;min-height:1lh;padding:1rem;padding-inline-end:3rem;transition:background-color .2s ease-out;position:relative}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.-top-3{top:calc(var(--spacing)*-3)}.top-2{top:calc(var(--spacing)*2)}.-right-3{right:calc(var(--spacing)*-3)}.right-2{right:calc(var(--spacing)*2)}.left-\\[10\\%\\]{left:10%}.left-\\[70\\%\\]{left:70%}.modal-backdrop{color:#0000;z-index:-1;grid-row-start:1;grid-column-start:1;place-self:stretch stretch;display:grid}.modal-backdrop button{cursor:pointer}.-z-1{z-index:-1}.z-1{z-index:1}.z-2{z-index:2}.z-10{z-index:10}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.row-start-4{grid-row-start:4}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:"×"}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-3{margin-right:calc(var(--spacing)*3)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-6{margin-bottom:calc(var(--spacing)*6)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-3{margin-left:calc(var(--spacing)*3)}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.block{display:block}.flex{display:flex}.grid{display:grid}.inline-block{display:inline-block}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-5{height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-18{height:calc(var(--spacing)*18)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.max-h-\\[85vh\\]{max-height:85vh}.min-h-\\[450px\\]{min-height:450px}.w-1\\/2{width:50%}.w-3\\/4{width:75%}.w-5{width:calc(var(--spacing)*5)}.w-\\[20px\\]{width:20px}.w-\\[50px\\]{width:50px}.w-full{width:100%}.max-w-\\[8ch\\]{max-width:8ch}.max-w-max{max-width:max-content}.max-w-none{max-width:none}.flex-1{flex:1}.link{cursor:pointer;text-decoration-line:underline}.link:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.link:focus{outline-offset:2px;outline:2px solid #0000}}.link:focus-visible{outline-offset:2px;outline:2px solid}.list-disc{list-style-type:disc}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_0\\.5fr_20px_1fr\\]{grid-template-columns:1fr 20px .5fr 20px 1fr}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-cols-\\[max-content_auto\\]{grid-template-columns:max-content auto}.grid-rows-\\[50px_50px_1fr_80px\\]{grid-template-rows:50px 50px 1fr 80px}.grid-rows-\\[50px_50px_80px\\]{grid-template-rows:50px 50px 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.gap-x-2{column-gap:calc(var(--spacing)*2)}.self-center{align-self:center}.self-end{align-self:flex-end}.self-start{align-self:flex-start}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-box{border-radius:var(--radius-box)}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border,.border-1{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-dotted{--tw-border-style:dotted;border-style:dotted}.border-none{--tw-border-style:none;border-style:none}.border-solid{--tw-border-style:solid;border-style:solid}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.border-\\(--color-primary\\){border-color:var(--color-primary)}.border-\\[var\\(--color-gray-200\\)\\]{border-color:var(--color-gray-200)}.border-\\[var\\(--color-primary\\)\\]{border-color:var(--color-primary)}.bg-\\(--color-ocean-gray-25\\){background-color:var(--color-ocean-gray-25)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.bg-base-100{background-color:var(--color-base-100)}.radio-sm{padding:.1875rem}.radio-sm[type=radio]{--size:calc(var(--size-selector,.25rem)*5)}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-5{padding-inline:calc(var(--spacing)*5)}.py-1{padding-block:calc(var(--spacing)*1)}.ps-5{padding-inline-start:calc(var(--spacing)*5)}.pt-1{padding-top:calc(var(--spacing)*1)}.pl-5{padding-left:calc(var(--spacing)*5)}.text-center{text-align:center}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}.after\\:start-0:after{content:var(--tw-content);inset-inline-start:calc(var(--spacing)*0)}.after\\:\\!top-3:after{content:var(--tw-content);top:calc(var(--spacing)*3)!important}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}.\\[\\&_dt\\]\\:mr-1 dt{margin-right:calc(var(--spacing)*1)}.\\[\\&_dt\\,dd\\]\\:inline dt,.\\[\\&_dt\\,dd\\]\\:inline dd{display:inline}.\\[\\&\\>dt\\]\\:text-right>dt{text-align:right}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-content{syntax:"*";inherits:false;initial-value:""}`)),document.head.appendChild(e)}}catch(o){console.error("vite-plugin-css-injected-by-js",o)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Fs(t) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const i of t.split(",")) r[i] = 1;
  return (i) => i in r;
}
const wt = {}, So = [], Xn = () => {
}, Ac = () => !1, ga = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), $s = (t) => t.startsWith("onUpdate:"), on = Object.assign, Ms = (t, r) => {
  const i = t.indexOf(r);
  i > -1 && t.splice(i, 1);
}, Oc = Object.prototype.hasOwnProperty, gt = (t, r) => Oc.call(t, r), We = Array.isArray, Po = (t) => Bi(t) === "[object Map]", Bo = (t) => Bi(t) === "[object Set]", dl = (t) => Bi(t) === "[object Date]", et = (t) => typeof t == "function", Dt = (t) => typeof t == "string", Un = (t) => typeof t == "symbol", Tt = (t) => t !== null && typeof t == "object", au = (t) => (Tt(t) || et(t)) && et(t.then) && et(t.catch), su = Object.prototype.toString, Bi = (t) => su.call(t), Dc = (t) => Bi(t).slice(8, -1), lu = (t) => Bi(t) === "[object Object]", Bs = (t) => Dt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ni = /* @__PURE__ */ Fs(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), ba = (t) => {
  const r = /* @__PURE__ */ Object.create(null);
  return (i) => r[i] || (r[i] = t(i));
}, Sc = /-(\w)/g, Sn = ba(
  (t) => t.replace(Sc, (r, i) => i ? i.toUpperCase() : "")
), Pc = /\B([A-Z])/g, Io = ba(
  (t) => t.replace(Pc, "-$1").toLowerCase()
), wa = ba((t) => t.charAt(0).toUpperCase() + t.slice(1)), is = ba(
  (t) => t ? `on${wa(t)}` : ""
), jr = (t, r) => !Object.is(t, r), Ji = (t, ...r) => {
  for (let i = 0; i < t.length; i++)
    t[i](...r);
}, gs = (t, r, i, s = !1) => {
  Object.defineProperty(t, r, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: i
  });
}, ia = (t) => {
  const r = parseFloat(t);
  return isNaN(r) ? t : r;
};
let pl;
const _a = () => pl || (pl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Br(t) {
  if (We(t)) {
    const r = {};
    for (let i = 0; i < t.length; i++) {
      const s = t[i], c = Dt(s) ? Fc(s) : Br(s);
      if (c)
        for (const d in c)
          r[d] = c[d];
    }
    return r;
  } else if (Dt(t) || Tt(t))
    return t;
}
const Lc = /;(?![^(]*\))/g, kc = /:([^]+)/, jc = /\/\*[^]*?\*\//g;
function Fc(t) {
  const r = {};
  return t.replace(jc, "").split(Lc).forEach((i) => {
    if (i) {
      const s = i.split(kc);
      s.length > 1 && (r[s[0].trim()] = s[1].trim());
    }
  }), r;
}
function Zt(t) {
  let r = "";
  if (Dt(t))
    r = t;
  else if (We(t))
    for (let i = 0; i < t.length; i++) {
      const s = Zt(t[i]);
      s && (r += s + " ");
    }
  else if (Tt(t))
    for (const i in t)
      t[i] && (r += i + " ");
  return r.trim();
}
function $c(t) {
  if (!t) return null;
  let { class: r, style: i } = t;
  return r && !Dt(r) && (t.class = Zt(r)), i && (t.style = Br(i)), t;
}
const Mc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Bc = /* @__PURE__ */ Fs(Mc);
function uu(t) {
  return !!t || t === "";
}
function Kc(t, r) {
  if (t.length !== r.length) return !1;
  let i = !0;
  for (let s = 0; i && s < t.length; s++)
    i = Co(t[s], r[s]);
  return i;
}
function Co(t, r) {
  if (t === r) return !0;
  let i = dl(t), s = dl(r);
  if (i || s)
    return i && s ? t.getTime() === r.getTime() : !1;
  if (i = Un(t), s = Un(r), i || s)
    return t === r;
  if (i = We(t), s = We(r), i || s)
    return i && s ? Kc(t, r) : !1;
  if (i = Tt(t), s = Tt(r), i || s) {
    if (!i || !s)
      return !1;
    const c = Object.keys(t).length, d = Object.keys(r).length;
    if (c !== d)
      return !1;
    for (const u in t) {
      const p = t.hasOwnProperty(u), m = r.hasOwnProperty(u);
      if (p && !m || !p && m || !Co(t[u], r[u]))
        return !1;
    }
  }
  return String(t) === String(r);
}
function Ks(t, r) {
  return t.findIndex((i) => Co(i, r));
}
const cu = (t) => !!(t && t.__v_isRef === !0), le = (t) => Dt(t) ? t : t == null ? "" : We(t) || Tt(t) && (t.toString === su || !et(t.toString)) ? cu(t) ? le(t.value) : JSON.stringify(t, fu, 2) : String(t), fu = (t, r) => cu(r) ? fu(t, r.value) : Po(r) ? {
  [`Map(${r.size})`]: [...r.entries()].reduce(
    (i, [s, c], d) => (i[as(s, d) + " =>"] = c, i),
    {}
  )
} : Bo(r) ? {
  [`Set(${r.size})`]: [...r.values()].map((i) => as(i))
} : Un(r) ? as(r) : Tt(r) && !We(r) && !lu(r) ? String(r) : r, as = (t, r = "") => {
  var i;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Un(t) ? `Symbol(${(i = t.description) != null ? i : r})` : t
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let nn;
class du {
  constructor(r = !1) {
    this.detached = r, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = nn, !r && nn && (this.index = (nn.scopes || (nn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let r, i;
      if (this.scopes)
        for (r = 0, i = this.scopes.length; r < i; r++)
          this.scopes[r].pause();
      for (r = 0, i = this.effects.length; r < i; r++)
        this.effects[r].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let r, i;
      if (this.scopes)
        for (r = 0, i = this.scopes.length; r < i; r++)
          this.scopes[r].resume();
      for (r = 0, i = this.effects.length; r < i; r++)
        this.effects[r].resume();
    }
  }
  run(r) {
    if (this._active) {
      const i = nn;
      try {
        return nn = this, r();
      } finally {
        nn = i;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = nn, nn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (nn = this.prevScope, this.prevScope = void 0);
  }
  stop(r) {
    if (this._active) {
      this._active = !1;
      let i, s;
      for (i = 0, s = this.effects.length; i < s; i++)
        this.effects[i].stop();
      for (this.effects.length = 0, i = 0, s = this.cleanups.length; i < s; i++)
        this.cleanups[i]();
      if (this.cleanups.length = 0, this.scopes) {
        for (i = 0, s = this.scopes.length; i < s; i++)
          this.scopes[i].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !r) {
        const c = this.parent.scopes.pop();
        c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function pu(t) {
  return new du(t);
}
function qs() {
  return nn;
}
function hu(t, r = !1) {
  nn && nn.cleanups.push(t);
}
let Rt;
const ss = /* @__PURE__ */ new WeakSet();
class mu {
  constructor(r) {
    this.fn = r, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, nn && nn.active && nn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, ss.has(this) && (ss.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || yu(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, hl(this), gu(this);
    const r = Rt, i = qn;
    Rt = this, qn = !0;
    try {
      return this.fn();
    } finally {
      bu(this), Rt = r, qn = i, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let r = this.deps; r; r = r.nextDep)
        Ws(r);
      this.deps = this.depsTail = void 0, hl(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? ss.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    bs(this) && this.run();
  }
  get dirty() {
    return bs(this);
  }
}
let vu = 0, Ri, Ci;
function yu(t, r = !1) {
  if (t.flags |= 8, r) {
    t.next = Ci, Ci = t;
    return;
  }
  t.next = Ri, Ri = t;
}
function Us() {
  vu++;
}
function Vs() {
  if (--vu > 0)
    return;
  if (Ci) {
    let r = Ci;
    for (Ci = void 0; r; ) {
      const i = r.next;
      r.next = void 0, r.flags &= -9, r = i;
    }
  }
  let t;
  for (; Ri; ) {
    let r = Ri;
    for (Ri = void 0; r; ) {
      const i = r.next;
      if (r.next = void 0, r.flags &= -9, r.flags & 1)
        try {
          r.trigger();
        } catch (s) {
          t || (t = s);
        }
      r = i;
    }
  }
  if (t) throw t;
}
function gu(t) {
  for (let r = t.deps; r; r = r.nextDep)
    r.version = -1, r.prevActiveLink = r.dep.activeLink, r.dep.activeLink = r;
}
function bu(t) {
  let r, i = t.depsTail, s = i;
  for (; s; ) {
    const c = s.prevDep;
    s.version === -1 ? (s === i && (i = c), Ws(s), qc(s)) : r = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = c;
  }
  t.deps = r, t.depsTail = i;
}
function bs(t) {
  for (let r = t.deps; r; r = r.nextDep)
    if (r.dep.version !== r.version || r.dep.computed && (wu(r.dep.computed) || r.dep.version !== r.version))
      return !0;
  return !!t._dirty;
}
function wu(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === Si) || (t.globalVersion = Si, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !bs(t))))
    return;
  t.flags |= 2;
  const r = t.dep, i = Rt, s = qn;
  Rt = t, qn = !0;
  try {
    gu(t);
    const c = t.fn(t._value);
    (r.version === 0 || jr(c, t._value)) && (t.flags |= 128, t._value = c, r.version++);
  } catch (c) {
    throw r.version++, c;
  } finally {
    Rt = i, qn = s, bu(t), t.flags &= -3;
  }
}
function Ws(t, r = !1) {
  const { dep: i, prevSub: s, nextSub: c } = t;
  if (s && (s.nextSub = c, t.prevSub = void 0), c && (c.prevSub = s, t.nextSub = void 0), i.subs === t && (i.subs = s, !s && i.computed)) {
    i.computed.flags &= -5;
    for (let d = i.computed.deps; d; d = d.nextDep)
      Ws(d, !0);
  }
  !r && !--i.sc && i.map && i.map.delete(i.key);
}
function qc(t) {
  const { prevDep: r, nextDep: i } = t;
  r && (r.nextDep = i, t.prevDep = void 0), i && (i.prevDep = r, t.nextDep = void 0);
}
let qn = !0;
const _u = [];
function Ir() {
  _u.push(qn), qn = !1;
}
function Ar() {
  const t = _u.pop();
  qn = t === void 0 ? !0 : t;
}
function hl(t) {
  const { cleanup: r } = t;
  if (t.cleanup = void 0, r) {
    const i = Rt;
    Rt = void 0;
    try {
      r();
    } finally {
      Rt = i;
    }
  }
}
let Si = 0;
class Uc {
  constructor(r, i) {
    this.sub = r, this.dep = i, this.version = i.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Gs {
  // TODO isolatedDeclarations "__v_skip"
  constructor(r) {
    this.computed = r, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(r) {
    if (!Rt || !qn || Rt === this.computed)
      return;
    let i = this.activeLink;
    if (i === void 0 || i.sub !== Rt)
      i = this.activeLink = new Uc(Rt, this), Rt.deps ? (i.prevDep = Rt.depsTail, Rt.depsTail.nextDep = i, Rt.depsTail = i) : Rt.deps = Rt.depsTail = i, xu(i);
    else if (i.version === -1 && (i.version = this.version, i.nextDep)) {
      const s = i.nextDep;
      s.prevDep = i.prevDep, i.prevDep && (i.prevDep.nextDep = s), i.prevDep = Rt.depsTail, i.nextDep = void 0, Rt.depsTail.nextDep = i, Rt.depsTail = i, Rt.deps === i && (Rt.deps = s);
    }
    return i;
  }
  trigger(r) {
    this.version++, Si++, this.notify(r);
  }
  notify(r) {
    Us();
    try {
      for (let i = this.subs; i; i = i.prevSub)
        i.sub.notify() && i.sub.dep.notify();
    } finally {
      Vs();
    }
  }
}
function xu(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const r = t.dep.computed;
    if (r && !t.dep.subs) {
      r.flags |= 20;
      for (let s = r.deps; s; s = s.nextDep)
        xu(s);
    }
    const i = t.dep.subs;
    i !== t && (t.prevSub = i, i && (i.nextSub = t)), t.dep.subs = t;
  }
}
const aa = /* @__PURE__ */ new WeakMap(), xo = Symbol(
  ""
), ws = Symbol(
  ""
), Pi = Symbol(
  ""
);
function rn(t, r, i) {
  if (qn && Rt) {
    let s = aa.get(t);
    s || aa.set(t, s = /* @__PURE__ */ new Map());
    let c = s.get(i);
    c || (s.set(i, c = new Gs()), c.map = s, c.key = i), c.track();
  }
}
function Rr(t, r, i, s, c, d) {
  const u = aa.get(t);
  if (!u) {
    Si++;
    return;
  }
  const p = (m) => {
    m && m.trigger();
  };
  if (Us(), r === "clear")
    u.forEach(p);
  else {
    const m = We(t), P = m && Bs(i);
    if (m && i === "length") {
      const E = Number(s);
      u.forEach((L, j) => {
        (j === "length" || j === Pi || !Un(j) && j >= E) && p(L);
      });
    } else
      switch ((i !== void 0 || u.has(void 0)) && p(u.get(i)), P && p(u.get(Pi)), r) {
        case "add":
          m ? P && p(u.get("length")) : (p(u.get(xo)), Po(t) && p(u.get(ws)));
          break;
        case "delete":
          m || (p(u.get(xo)), Po(t) && p(u.get(ws)));
          break;
        case "set":
          Po(t) && p(u.get(xo));
          break;
      }
  }
  Vs();
}
function Vc(t, r) {
  const i = aa.get(t);
  return i && i.get(r);
}
function Ao(t) {
  const r = pt(t);
  return r === t ? r : (rn(r, "iterate", Pi), On(t) ? r : r.map(zt));
}
function xa(t) {
  return rn(t = pt(t), "iterate", Pi), t;
}
const Wc = {
  __proto__: null,
  [Symbol.iterator]() {
    return ls(this, Symbol.iterator, zt);
  },
  concat(...t) {
    return Ao(this).concat(
      ...t.map((r) => We(r) ? Ao(r) : r)
    );
  },
  entries() {
    return ls(this, "entries", (t) => (t[1] = zt(t[1]), t));
  },
  every(t, r) {
    return xr(this, "every", t, r, void 0, arguments);
  },
  filter(t, r) {
    return xr(this, "filter", t, r, (i) => i.map(zt), arguments);
  },
  find(t, r) {
    return xr(this, "find", t, r, zt, arguments);
  },
  findIndex(t, r) {
    return xr(this, "findIndex", t, r, void 0, arguments);
  },
  findLast(t, r) {
    return xr(this, "findLast", t, r, zt, arguments);
  },
  findLastIndex(t, r) {
    return xr(this, "findLastIndex", t, r, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, r) {
    return xr(this, "forEach", t, r, void 0, arguments);
  },
  includes(...t) {
    return us(this, "includes", t);
  },
  indexOf(...t) {
    return us(this, "indexOf", t);
  },
  join(t) {
    return Ao(this).join(t);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...t) {
    return us(this, "lastIndexOf", t);
  },
  map(t, r) {
    return xr(this, "map", t, r, void 0, arguments);
  },
  pop() {
    return wi(this, "pop");
  },
  push(...t) {
    return wi(this, "push", t);
  },
  reduce(t, ...r) {
    return ml(this, "reduce", t, r);
  },
  reduceRight(t, ...r) {
    return ml(this, "reduceRight", t, r);
  },
  shift() {
    return wi(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, r) {
    return xr(this, "some", t, r, void 0, arguments);
  },
  splice(...t) {
    return wi(this, "splice", t);
  },
  toReversed() {
    return Ao(this).toReversed();
  },
  toSorted(t) {
    return Ao(this).toSorted(t);
  },
  toSpliced(...t) {
    return Ao(this).toSpliced(...t);
  },
  unshift(...t) {
    return wi(this, "unshift", t);
  },
  values() {
    return ls(this, "values", zt);
  }
};
function ls(t, r, i) {
  const s = xa(t), c = s[r]();
  return s !== t && !On(t) && (c._next = c.next, c.next = () => {
    const d = c._next();
    return d.value && (d.value = i(d.value)), d;
  }), c;
}
const Gc = Array.prototype;
function xr(t, r, i, s, c, d) {
  const u = xa(t), p = u !== t && !On(t), m = u[r];
  if (m !== Gc[r]) {
    const L = m.apply(t, d);
    return p ? zt(L) : L;
  }
  let P = i;
  u !== t && (p ? P = function(L, j) {
    return i.call(this, zt(L), j, t);
  } : i.length > 2 && (P = function(L, j) {
    return i.call(this, L, j, t);
  }));
  const E = m.call(u, P, s);
  return p && c ? c(E) : E;
}
function ml(t, r, i, s) {
  const c = xa(t);
  let d = i;
  return c !== t && (On(t) ? i.length > 3 && (d = function(u, p, m) {
    return i.call(this, u, p, m, t);
  }) : d = function(u, p, m) {
    return i.call(this, u, zt(p), m, t);
  }), c[r](d, ...s);
}
function us(t, r, i) {
  const s = pt(t);
  rn(s, "iterate", Pi);
  const c = s[r](...i);
  return (c === -1 || c === !1) && Hs(i[0]) ? (i[0] = pt(i[0]), s[r](...i)) : c;
}
function wi(t, r, i = []) {
  Ir(), Us();
  const s = pt(t)[r].apply(t, i);
  return Vs(), Ar(), s;
}
const Hc = /* @__PURE__ */ Fs("__proto__,__v_isRef,__isVue"), Nu = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Un)
);
function Yc(t) {
  Un(t) || (t = String(t));
  const r = pt(this);
  return rn(r, "has", t), r.hasOwnProperty(t);
}
class Ru {
  constructor(r = !1, i = !1) {
    this._isReadonly = r, this._isShallow = i;
  }
  get(r, i, s) {
    if (i === "__v_skip") return r.__v_skip;
    const c = this._isReadonly, d = this._isShallow;
    if (i === "__v_isReactive")
      return !c;
    if (i === "__v_isReadonly")
      return c;
    if (i === "__v_isShallow")
      return d;
    if (i === "__v_raw")
      return s === (c ? d ? Ou : Au : d ? Iu : Eu).get(r) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(r) === Object.getPrototypeOf(s) ? r : void 0;
    const u = We(r);
    if (!c) {
      let m;
      if (u && (m = Wc[i]))
        return m;
      if (i === "hasOwnProperty")
        return Yc;
    }
    const p = Reflect.get(
      r,
      i,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      At(r) ? r : s
    );
    return (Un(i) ? Nu.has(i) : Hc(i)) || (c || rn(r, "get", i), d) ? p : At(p) ? u && Bs(i) ? p : p.value : Tt(p) ? c ? Du(p) : Ki(p) : p;
  }
}
class Cu extends Ru {
  constructor(r = !1) {
    super(!1, r);
  }
  set(r, i, s, c) {
    let d = r[i];
    if (!this._isShallow) {
      const m = Fr(d);
      if (!On(s) && !Fr(s) && (d = pt(d), s = pt(s)), !We(r) && At(d) && !At(s))
        return m ? !1 : (d.value = s, !0);
    }
    const u = We(r) && Bs(i) ? Number(i) < r.length : gt(r, i), p = Reflect.set(
      r,
      i,
      s,
      At(r) ? r : c
    );
    return r === pt(c) && (u ? jr(s, d) && Rr(r, "set", i, s) : Rr(r, "add", i, s)), p;
  }
  deleteProperty(r, i) {
    const s = gt(r, i);
    r[i];
    const c = Reflect.deleteProperty(r, i);
    return c && s && Rr(r, "delete", i, void 0), c;
  }
  has(r, i) {
    const s = Reflect.has(r, i);
    return (!Un(i) || !Nu.has(i)) && rn(r, "has", i), s;
  }
  ownKeys(r) {
    return rn(
      r,
      "iterate",
      We(r) ? "length" : xo
    ), Reflect.ownKeys(r);
  }
}
class Tu extends Ru {
  constructor(r = !1) {
    super(!0, r);
  }
  set(r, i) {
    return !0;
  }
  deleteProperty(r, i) {
    return !0;
  }
}
const Xc = /* @__PURE__ */ new Cu(), Qc = /* @__PURE__ */ new Tu(), zc = /* @__PURE__ */ new Cu(!0), Jc = /* @__PURE__ */ new Tu(!0), _s = (t) => t, Wi = (t) => Reflect.getPrototypeOf(t);
function Zc(t, r, i) {
  return function(...s) {
    const c = this.__v_raw, d = pt(c), u = Po(d), p = t === "entries" || t === Symbol.iterator && u, m = t === "keys" && u, P = c[t](...s), E = i ? _s : r ? sa : zt;
    return !r && rn(
      d,
      "iterate",
      m ? ws : xo
    ), {
      // iterator protocol
      next() {
        const { value: L, done: j } = P.next();
        return j ? { value: L, done: j } : {
          value: p ? [E(L[0]), E(L[1])] : E(L),
          done: j
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Gi(t) {
  return function(...r) {
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function ef(t, r) {
  const i = {
    get(c) {
      const d = this.__v_raw, u = pt(d), p = pt(c);
      t || (jr(c, p) && rn(u, "get", c), rn(u, "get", p));
      const { has: m } = Wi(u), P = r ? _s : t ? sa : zt;
      if (m.call(u, c))
        return P(d.get(c));
      if (m.call(u, p))
        return P(d.get(p));
      d !== u && d.get(c);
    },
    get size() {
      const c = this.__v_raw;
      return !t && rn(pt(c), "iterate", xo), Reflect.get(c, "size", c);
    },
    has(c) {
      const d = this.__v_raw, u = pt(d), p = pt(c);
      return t || (jr(c, p) && rn(u, "has", c), rn(u, "has", p)), c === p ? d.has(c) : d.has(c) || d.has(p);
    },
    forEach(c, d) {
      const u = this, p = u.__v_raw, m = pt(p), P = r ? _s : t ? sa : zt;
      return !t && rn(m, "iterate", xo), p.forEach((E, L) => c.call(d, P(E), P(L), u));
    }
  };
  return on(
    i,
    t ? {
      add: Gi("add"),
      set: Gi("set"),
      delete: Gi("delete"),
      clear: Gi("clear")
    } : {
      add(c) {
        !r && !On(c) && !Fr(c) && (c = pt(c));
        const d = pt(this);
        return Wi(d).has.call(d, c) || (d.add(c), Rr(d, "add", c, c)), this;
      },
      set(c, d) {
        !r && !On(d) && !Fr(d) && (d = pt(d));
        const u = pt(this), { has: p, get: m } = Wi(u);
        let P = p.call(u, c);
        P || (c = pt(c), P = p.call(u, c));
        const E = m.call(u, c);
        return u.set(c, d), P ? jr(d, E) && Rr(u, "set", c, d) : Rr(u, "add", c, d), this;
      },
      delete(c) {
        const d = pt(this), { has: u, get: p } = Wi(d);
        let m = u.call(d, c);
        m || (c = pt(c), m = u.call(d, c)), p && p.call(d, c);
        const P = d.delete(c);
        return m && Rr(d, "delete", c, void 0), P;
      },
      clear() {
        const c = pt(this), d = c.size !== 0, u = c.clear();
        return d && Rr(
          c,
          "clear",
          void 0,
          void 0
        ), u;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((c) => {
    i[c] = Zc(c, t, r);
  }), i;
}
function Na(t, r) {
  const i = ef(t, r);
  return (s, c, d) => c === "__v_isReactive" ? !t : c === "__v_isReadonly" ? t : c === "__v_raw" ? s : Reflect.get(
    gt(i, c) && c in s ? i : s,
    c,
    d
  );
}
const tf = {
  get: /* @__PURE__ */ Na(!1, !1)
}, nf = {
  get: /* @__PURE__ */ Na(!1, !0)
}, rf = {
  get: /* @__PURE__ */ Na(!0, !1)
}, of = {
  get: /* @__PURE__ */ Na(!0, !0)
}, Eu = /* @__PURE__ */ new WeakMap(), Iu = /* @__PURE__ */ new WeakMap(), Au = /* @__PURE__ */ new WeakMap(), Ou = /* @__PURE__ */ new WeakMap();
function af(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function sf(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : af(Dc(t));
}
function Ki(t) {
  return Fr(t) ? t : Ra(
    t,
    !1,
    Xc,
    tf,
    Eu
  );
}
function lf(t) {
  return Ra(
    t,
    !1,
    zc,
    nf,
    Iu
  );
}
function Du(t) {
  return Ra(
    t,
    !0,
    Qc,
    rf,
    Au
  );
}
function uf(t) {
  return Ra(
    t,
    !0,
    Jc,
    of,
    Ou
  );
}
function Ra(t, r, i, s, c) {
  if (!Tt(t) || t.__v_raw && !(r && t.__v_isReactive))
    return t;
  const d = sf(t);
  if (d === 0)
    return t;
  const u = c.get(t);
  if (u)
    return u;
  const p = new Proxy(
    t,
    d === 2 ? s : i
  );
  return c.set(t, p), p;
}
function Er(t) {
  return Fr(t) ? Er(t.__v_raw) : !!(t && t.__v_isReactive);
}
function Fr(t) {
  return !!(t && t.__v_isReadonly);
}
function On(t) {
  return !!(t && t.__v_isShallow);
}
function Hs(t) {
  return t ? !!t.__v_raw : !1;
}
function pt(t) {
  const r = t && t.__v_raw;
  return r ? pt(r) : t;
}
function Ca(t) {
  return !gt(t, "__v_skip") && Object.isExtensible(t) && gs(t, "__v_skip", !0), t;
}
const zt = (t) => Tt(t) ? Ki(t) : t, sa = (t) => Tt(t) ? Du(t) : t;
function At(t) {
  return t ? t.__v_isRef === !0 : !1;
}
function Ue(t) {
  return Su(t, !1);
}
function An(t) {
  return Su(t, !0);
}
function Su(t, r) {
  return At(t) ? t : new cf(t, r);
}
class cf {
  constructor(r, i) {
    this.dep = new Gs(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = i ? r : pt(r), this._value = i ? r : zt(r), this.__v_isShallow = i;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(r) {
    const i = this._rawValue, s = this.__v_isShallow || On(r) || Fr(r);
    r = s ? r : pt(r), jr(r, i) && (this._rawValue = r, this._value = s ? r : zt(r), this.dep.trigger());
  }
}
function Le(t) {
  return At(t) ? t.value : t;
}
function ff(t) {
  return et(t) ? t() : Le(t);
}
const df = {
  get: (t, r, i) => r === "__v_raw" ? t : Le(Reflect.get(t, r, i)),
  set: (t, r, i, s) => {
    const c = t[r];
    return At(c) && !At(i) ? (c.value = i, !0) : Reflect.set(t, r, i, s);
  }
};
function Pu(t) {
  return Er(t) ? t : new Proxy(t, df);
}
function pf(t) {
  const r = We(t) ? new Array(t.length) : {};
  for (const i in t)
    r[i] = Lu(t, i);
  return r;
}
class hf {
  constructor(r, i, s) {
    this._object = r, this._key = i, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const r = this._object[this._key];
    return this._value = r === void 0 ? this._defaultValue : r;
  }
  set value(r) {
    this._object[this._key] = r;
  }
  get dep() {
    return Vc(pt(this._object), this._key);
  }
}
class mf {
  constructor(r) {
    this._getter = r, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function vf(t, r, i) {
  return At(t) ? t : et(t) ? new mf(t) : Tt(t) && arguments.length > 1 ? Lu(t, r, i) : Ue(t);
}
function Lu(t, r, i) {
  const s = t[r];
  return At(s) ? s : new hf(t, r, i);
}
class yf {
  constructor(r, i, s) {
    this.fn = r, this.setter = i, this._value = void 0, this.dep = new Gs(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Si - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !i, this.isSSR = s;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Rt !== this)
      return yu(this, !0), !0;
  }
  get value() {
    const r = this.dep.track();
    return wu(this), r && (r.version = this.dep.version), this._value;
  }
  set value(r) {
    this.setter && this.setter(r);
  }
}
function gf(t, r, i = !1) {
  let s, c;
  return et(t) ? s = t : (s = t.get, c = t.set), new yf(s, c, i);
}
const Hi = {}, la = /* @__PURE__ */ new WeakMap();
let _o;
function bf(t, r = !1, i = _o) {
  if (i) {
    let s = la.get(i);
    s || la.set(i, s = []), s.push(t);
  }
}
function wf(t, r, i = wt) {
  const { immediate: s, deep: c, once: d, scheduler: u, augmentJob: p, call: m } = i, P = (q) => c ? q : On(q) || c === !1 || c === 0 ? Cr(q, 1) : Cr(q);
  let E, L, j, Y, z = !1, H = !1;
  if (At(t) ? (L = () => t.value, z = On(t)) : Er(t) ? (L = () => P(t), z = !0) : We(t) ? (H = !0, z = t.some((q) => Er(q) || On(q)), L = () => t.map((q) => {
    if (At(q))
      return q.value;
    if (Er(q))
      return P(q);
    if (et(q))
      return m ? m(q, 2) : q();
  })) : et(t) ? r ? L = m ? () => m(t, 2) : t : L = () => {
    if (j) {
      Ir();
      try {
        j();
      } finally {
        Ar();
      }
    }
    const q = _o;
    _o = E;
    try {
      return m ? m(t, 3, [Y]) : t(Y);
    } finally {
      _o = q;
    }
  } : L = Xn, r && c) {
    const q = L, Te = c === !0 ? 1 / 0 : c;
    L = () => Cr(q(), Te);
  }
  const ie = qs(), W = () => {
    E.stop(), ie && ie.active && Ms(ie.effects, E);
  };
  if (d && r) {
    const q = r;
    r = (...Te) => {
      q(...Te), W();
    };
  }
  let B = H ? new Array(t.length).fill(Hi) : Hi;
  const F = (q) => {
    if (!(!(E.flags & 1) || !E.dirty && !q))
      if (r) {
        const Te = E.run();
        if (c || z || (H ? Te.some((pe, ve) => jr(pe, B[ve])) : jr(Te, B))) {
          j && j();
          const pe = _o;
          _o = E;
          try {
            const ve = [
              Te,
              // pass undefined as the old value when it's changed for the first time
              B === Hi ? void 0 : H && B[0] === Hi ? [] : B,
              Y
            ];
            B = Te, m ? m(r, 3, ve) : (
              // @ts-expect-error
              r(...ve)
            );
          } finally {
            _o = pe;
          }
        }
      } else
        E.run();
  };
  return p && p(F), E = new mu(L), E.scheduler = u ? () => u(F, !1) : F, Y = (q) => bf(q, !1, E), j = E.onStop = () => {
    const q = la.get(E);
    if (q) {
      if (m)
        m(q, 4);
      else
        for (const Te of q) Te();
      la.delete(E);
    }
  }, r ? s ? F(!0) : B = E.run() : u ? u(F.bind(null, !0), !0) : E.run(), W.pause = E.pause.bind(E), W.resume = E.resume.bind(E), W.stop = W, W;
}
function Cr(t, r = 1 / 0, i) {
  if (r <= 0 || !Tt(t) || t.__v_skip || (i = i || /* @__PURE__ */ new Set(), i.has(t)))
    return t;
  if (i.add(t), r--, At(t))
    Cr(t.value, r, i);
  else if (We(t))
    for (let s = 0; s < t.length; s++)
      Cr(t[s], r, i);
  else if (Bo(t) || Po(t))
    t.forEach((s) => {
      Cr(s, r, i);
    });
  else if (lu(t)) {
    for (const s in t)
      Cr(t[s], r, i);
    for (const s of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, s) && Cr(t[s], r, i);
  }
  return t;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function qi(t, r, i, s) {
  try {
    return s ? t(...s) : t();
  } catch (c) {
    Ta(c, r, i);
  }
}
function Qn(t, r, i, s) {
  if (et(t)) {
    const c = qi(t, r, i, s);
    return c && au(c) && c.catch((d) => {
      Ta(d, r, i);
    }), c;
  }
  if (We(t)) {
    const c = [];
    for (let d = 0; d < t.length; d++)
      c.push(Qn(t[d], r, i, s));
    return c;
  }
}
function Ta(t, r, i, s = !0) {
  const c = r ? r.vnode : null, { errorHandler: d, throwUnhandledErrorInProduction: u } = r && r.appContext.config || wt;
  if (r) {
    let p = r.parent;
    const m = r.proxy, P = `https://vuejs.org/error-reference/#runtime-${i}`;
    for (; p; ) {
      const E = p.ec;
      if (E) {
        for (let L = 0; L < E.length; L++)
          if (E[L](t, m, P) === !1)
            return;
      }
      p = p.parent;
    }
    if (d) {
      Ir(), qi(d, null, 10, [
        t,
        m,
        P
      ]), Ar();
      return;
    }
  }
  _f(t, i, c, s, u);
}
function _f(t, r, i, s = !0, c = !1) {
  if (c)
    throw t;
  console.error(t);
}
const yn = [];
let Hn = -1;
const Lo = [];
let Pr = null, Do = 0;
const ku = /* @__PURE__ */ Promise.resolve();
let ua = null;
function Ys(t) {
  const r = ua || ku;
  return t ? r.then(this ? t.bind(this) : t) : r;
}
function xf(t) {
  let r = Hn + 1, i = yn.length;
  for (; r < i; ) {
    const s = r + i >>> 1, c = yn[s], d = Li(c);
    d < t || d === t && c.flags & 2 ? r = s + 1 : i = s;
  }
  return r;
}
function Xs(t) {
  if (!(t.flags & 1)) {
    const r = Li(t), i = yn[yn.length - 1];
    !i || // fast path when the job id is larger than the tail
    !(t.flags & 2) && r >= Li(i) ? yn.push(t) : yn.splice(xf(r), 0, t), t.flags |= 1, ju();
  }
}
function ju() {
  ua || (ua = ku.then($u));
}
function Nf(t) {
  We(t) ? Lo.push(...t) : Pr && t.id === -1 ? Pr.splice(Do + 1, 0, t) : t.flags & 1 || (Lo.push(t), t.flags |= 1), ju();
}
function vl(t, r, i = Hn + 1) {
  for (; i < yn.length; i++) {
    const s = yn[i];
    if (s && s.flags & 2) {
      if (t && s.id !== t.uid)
        continue;
      yn.splice(i, 1), i--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2);
    }
  }
}
function Fu(t) {
  if (Lo.length) {
    const r = [...new Set(Lo)].sort(
      (i, s) => Li(i) - Li(s)
    );
    if (Lo.length = 0, Pr) {
      Pr.push(...r);
      return;
    }
    for (Pr = r, Do = 0; Do < Pr.length; Do++) {
      const i = Pr[Do];
      i.flags & 4 && (i.flags &= -2), i.flags & 8 || i(), i.flags &= -2;
    }
    Pr = null, Do = 0;
  }
}
const Li = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function $u(t) {
  try {
    for (Hn = 0; Hn < yn.length; Hn++) {
      const r = yn[Hn];
      r && !(r.flags & 8) && (r.flags & 4 && (r.flags &= -2), qi(
        r,
        r.i,
        r.i ? 15 : 14
      ), r.flags & 4 || (r.flags &= -2));
    }
  } finally {
    for (; Hn < yn.length; Hn++) {
      const r = yn[Hn];
      r && (r.flags &= -2);
    }
    Hn = -1, yn.length = 0, Fu(), ua = null, (yn.length || Lo.length) && $u();
  }
}
let Kt = null, Mu = null;
function ca(t) {
  const r = Kt;
  return Kt = t, Mu = t && t.type.__scopeId || null, r;
}
function xs(t, r = Kt, i) {
  if (!r || t._n)
    return t;
  const s = (...c) => {
    s._d && Ol(-1);
    const d = ca(r);
    let u;
    try {
      u = t(...c);
    } finally {
      ca(d), s._d && Ol(1);
    }
    return u;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function at(t, r) {
  if (Kt === null)
    return t;
  const i = Da(Kt), s = t.dirs || (t.dirs = []);
  for (let c = 0; c < r.length; c++) {
    let [d, u, p, m = wt] = r[c];
    d && (et(d) && (d = {
      mounted: d,
      updated: d
    }), d.deep && Cr(u), s.push({
      dir: d,
      instance: i,
      value: u,
      oldValue: void 0,
      arg: p,
      modifiers: m
    }));
  }
  return t;
}
function bo(t, r, i, s) {
  const c = t.dirs, d = r && r.dirs;
  for (let u = 0; u < c.length; u++) {
    const p = c[u];
    d && (p.oldValue = d[u].value);
    let m = p.dir[s];
    m && (Ir(), Qn(m, i, 8, [
      t.el,
      p,
      t,
      r
    ]), Ar());
  }
}
const Bu = Symbol("_vte"), Rf = (t) => t.__isTeleport, Ti = (t) => t && (t.disabled || t.disabled === ""), yl = (t) => t && (t.defer || t.defer === ""), gl = (t) => typeof SVGElement < "u" && t instanceof SVGElement, bl = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, Ns = (t, r) => {
  const i = t && t.to;
  return Dt(i) ? r ? r(i) : null : i;
}, Ku = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, r, i, s, c, d, u, p, m, P) {
    const {
      mc: E,
      pc: L,
      pbc: j,
      o: { insert: Y, querySelector: z, createText: H, createComment: ie }
    } = P, W = Ti(r.props);
    let { shapeFlag: B, children: F, dynamicChildren: q } = r;
    if (t == null) {
      const Te = r.el = H(""), pe = r.anchor = H("");
      Y(Te, i, s), Y(pe, i, s);
      const ve = (S, we) => {
        B & 16 && (c && c.isCE && (c.ce._teleportTarget = S), E(
          F,
          S,
          we,
          c,
          d,
          u,
          p,
          m
        ));
      }, se = () => {
        const S = r.target = Ns(r.props, z), we = qu(S, r, H, Y);
        S && (u !== "svg" && gl(S) ? u = "svg" : u !== "mathml" && bl(S) && (u = "mathml"), W || (ve(S, we), Zi(r, !1)));
      };
      W && (ve(i, pe), Zi(r, !0)), yl(r.props) ? (r.el.__isMounted = !1, mn(() => {
        se(), delete r.el.__isMounted;
      }, d)) : se();
    } else {
      if (yl(r.props) && t.el.__isMounted === !1) {
        mn(() => {
          Ku.process(
            t,
            r,
            i,
            s,
            c,
            d,
            u,
            p,
            m,
            P
          );
        }, d);
        return;
      }
      r.el = t.el, r.targetStart = t.targetStart;
      const Te = r.anchor = t.anchor, pe = r.target = t.target, ve = r.targetAnchor = t.targetAnchor, se = Ti(t.props), S = se ? i : pe, we = se ? Te : ve;
      if (u === "svg" || gl(pe) ? u = "svg" : (u === "mathml" || bl(pe)) && (u = "mathml"), q ? (j(
        t.dynamicChildren,
        q,
        S,
        c,
        d,
        u,
        p
      ), el(t, r, !0)) : m || L(
        t,
        r,
        S,
        we,
        c,
        d,
        u,
        p,
        !1
      ), W)
        se ? r.props && t.props && r.props.to !== t.props.to && (r.props.to = t.props.to) : Yi(
          r,
          i,
          Te,
          P,
          1
        );
      else if ((r.props && r.props.to) !== (t.props && t.props.to)) {
        const ue = r.target = Ns(
          r.props,
          z
        );
        ue && Yi(
          r,
          ue,
          null,
          P,
          0
        );
      } else se && Yi(
        r,
        pe,
        ve,
        P,
        1
      );
      Zi(r, W);
    }
  },
  remove(t, r, i, { um: s, o: { remove: c } }, d) {
    const {
      shapeFlag: u,
      children: p,
      anchor: m,
      targetStart: P,
      targetAnchor: E,
      target: L,
      props: j
    } = t;
    if (L && (c(P), c(E)), d && c(m), u & 16) {
      const Y = d || !Ti(j);
      for (let z = 0; z < p.length; z++) {
        const H = p[z];
        s(
          H,
          r,
          i,
          Y,
          !!H.dynamicChildren
        );
      }
    }
  },
  move: Yi,
  hydrate: Cf
};
function Yi(t, r, i, { o: { insert: s }, m: c }, d = 2) {
  d === 0 && s(t.targetAnchor, r, i);
  const { el: u, anchor: p, shapeFlag: m, children: P, props: E } = t, L = d === 2;
  if (L && s(u, r, i), (!L || Ti(E)) && m & 16)
    for (let j = 0; j < P.length; j++)
      c(
        P[j],
        r,
        i,
        2
      );
  L && s(p, r, i);
}
function Cf(t, r, i, s, c, d, {
  o: { nextSibling: u, parentNode: p, querySelector: m, insert: P, createText: E }
}, L) {
  const j = r.target = Ns(
    r.props,
    m
  );
  if (j) {
    const Y = Ti(r.props), z = j._lpa || j.firstChild;
    if (r.shapeFlag & 16)
      if (Y)
        r.anchor = L(
          u(t),
          r,
          p(t),
          i,
          s,
          c,
          d
        ), r.targetStart = z, r.targetAnchor = z && u(z);
      else {
        r.anchor = u(t);
        let H = z;
        for (; H; ) {
          if (H && H.nodeType === 8) {
            if (H.data === "teleport start anchor")
              r.targetStart = H;
            else if (H.data === "teleport anchor") {
              r.targetAnchor = H, j._lpa = r.targetAnchor && u(r.targetAnchor);
              break;
            }
          }
          H = u(H);
        }
        r.targetAnchor || qu(j, r, E, P), L(
          z && u(z),
          r,
          j,
          i,
          s,
          c,
          d
        );
      }
    Zi(r, Y);
  }
  return r.anchor && u(r.anchor);
}
const jo = Ku;
function Zi(t, r) {
  const i = t.ctx;
  if (i && i.ut) {
    let s, c;
    for (r ? (s = t.el, c = t.anchor) : (s = t.targetStart, c = t.targetAnchor); s && s !== c; )
      s.nodeType === 1 && s.setAttribute("data-v-owner", i.uid), s = s.nextSibling;
    i.ut();
  }
}
function qu(t, r, i, s) {
  const c = r.targetStart = i(""), d = r.targetAnchor = i("");
  return c[Bu] = d, t && (s(c, t), s(d, t)), d;
}
function Qs(t, r) {
  t.shapeFlag & 6 && t.component ? (t.transition = r, Qs(t.component.subTree, r)) : t.shapeFlag & 128 ? (t.ssContent.transition = r.clone(t.ssContent), t.ssFallback.transition = r.clone(t.ssFallback)) : t.transition = r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Ot(t, r) {
  return et(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    on({ name: t.name }, r, { setup: t })
  ) : t;
}
function Uu(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
function Tf(t) {
  const r = Nd(), i = An(null);
  if (r) {
    const c = r.refs === wt ? r.refs = {} : r.refs;
    Object.defineProperty(c, t, {
      enumerable: !0,
      get: () => i.value,
      set: (d) => i.value = d
    });
  }
  return i;
}
function Ei(t, r, i, s, c = !1) {
  if (We(t)) {
    t.forEach(
      (z, H) => Ei(
        z,
        r && (We(r) ? r[H] : r),
        i,
        s,
        c
      )
    );
    return;
  }
  if (ko(s) && !c) {
    s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && Ei(t, r, i, s.component.subTree);
    return;
  }
  const d = s.shapeFlag & 4 ? Da(s.component) : s.el, u = c ? null : d, { i: p, r: m } = t, P = r && r.r, E = p.refs === wt ? p.refs = {} : p.refs, L = p.setupState, j = pt(L), Y = L === wt ? () => !1 : (z) => gt(j, z);
  if (P != null && P !== m && (Dt(P) ? (E[P] = null, Y(P) && (L[P] = null)) : At(P) && (P.value = null)), et(m))
    qi(m, p, 12, [u, E]);
  else {
    const z = Dt(m), H = At(m);
    if (z || H) {
      const ie = () => {
        if (t.f) {
          const W = z ? Y(m) ? L[m] : E[m] : m.value;
          c ? We(W) && Ms(W, d) : We(W) ? W.includes(d) || W.push(d) : z ? (E[m] = [d], Y(m) && (L[m] = E[m])) : (m.value = [d], t.k && (E[t.k] = m.value));
        } else z ? (E[m] = u, Y(m) && (L[m] = u)) : H && (m.value = u, t.k && (E[t.k] = u));
      };
      u ? (ie.id = -1, mn(ie, i)) : ie();
    }
  }
}
_a().requestIdleCallback;
_a().cancelIdleCallback;
const ko = (t) => !!t.type.__asyncLoader, Vu = (t) => t.type.__isKeepAlive;
function Ef(t, r) {
  Wu(t, "a", r);
}
function If(t, r) {
  Wu(t, "da", r);
}
function Wu(t, r, i = Vt) {
  const s = t.__wdc || (t.__wdc = () => {
    let c = i;
    for (; c; ) {
      if (c.isDeactivated)
        return;
      c = c.parent;
    }
    return t();
  });
  if (Ea(r, s, i), i) {
    let c = i.parent;
    for (; c && c.parent; )
      Vu(c.parent.vnode) && Af(s, r, i, c), c = c.parent;
  }
}
function Af(t, r, i, s) {
  const c = Ea(
    r,
    t,
    s,
    !0
    /* prepend */
  );
  zs(() => {
    Ms(s[r], c);
  }, i);
}
function Ea(t, r, i = Vt, s = !1) {
  if (i) {
    const c = i[t] || (i[t] = []), d = r.__weh || (r.__weh = (...u) => {
      Ir();
      const p = Ui(i), m = Qn(r, i, t, u);
      return p(), Ar(), m;
    });
    return s ? c.unshift(d) : c.push(d), d;
  }
}
const Dr = (t) => (r, i = Vt) => {
  (!ji || t === "sp") && Ea(t, (...s) => r(...s), i);
}, Of = Dr("bm"), Ko = Dr("m"), Df = Dr(
  "bu"
), Sf = Dr("u"), Pf = Dr(
  "bum"
), zs = Dr("um"), Lf = Dr(
  "sp"
), kf = Dr("rtg"), jf = Dr("rtc");
function Ff(t, r = Vt) {
  Ea("ec", t, r);
}
const $f = "components", Gu = Symbol.for("v-ndc");
function Mf(t) {
  return Dt(t) ? Bf($f, t, !1) || t : t || Gu;
}
function Bf(t, r, i = !0, s = !1) {
  const c = Kt || Vt;
  if (c) {
    const d = c.type;
    {
      const p = Id(
        d,
        !1
      );
      if (p && (p === r || p === Sn(r) || p === wa(Sn(r))))
        return d;
    }
    const u = (
      // local registration
      // check instance[type] first which is resolved for options API
      wl(c[t] || d[t], r) || // global registration
      wl(c.appContext[t], r)
    );
    return !u && s ? d : u;
  }
}
function wl(t, r) {
  return t && (t[r] || t[Sn(r)] || t[wa(Sn(r))]);
}
function bt(t, r, i, s) {
  let c;
  const d = i, u = We(t);
  if (u || Dt(t)) {
    const p = u && Er(t);
    let m = !1, P = !1;
    p && (m = !On(t), P = Fr(t), t = xa(t)), c = new Array(t.length);
    for (let E = 0, L = t.length; E < L; E++)
      c[E] = r(
        m ? P ? sa(zt(t[E])) : zt(t[E]) : t[E],
        E,
        void 0,
        d
      );
  } else if (typeof t == "number") {
    c = new Array(t);
    for (let p = 0; p < t; p++)
      c[p] = r(p + 1, p, void 0, d);
  } else if (Tt(t))
    if (t[Symbol.iterator])
      c = Array.from(
        t,
        (p, m) => r(p, m, void 0, d)
      );
    else {
      const p = Object.keys(t);
      c = new Array(p.length);
      for (let m = 0, P = p.length; m < P; m++) {
        const E = p[m];
        c[m] = r(t[E], E, m, d);
      }
    }
  else
    c = [];
  return c;
}
function _l(t, r, i = {}, s, c) {
  if (Kt.ce || Kt.parent && ko(Kt.parent) && Kt.parent.ce)
    return r !== "default" && (i.name = r), ae(), en(
      qe,
      null,
      [yt("slot", i, s)],
      64
    );
  let d = t[r];
  d && d._c && (d._d = !1), ae();
  const u = d && Hu(d(i)), p = i.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  u && u.key, m = en(
    qe,
    {
      key: (p && !Un(p) ? p : `_${r}`) + // #7256 force differentiate fallback content from actual content
      (!u && s ? "_fb" : "")
    },
    u || [],
    u && t._ === 1 ? 64 : -2
  );
  return d && d._c && (d._d = !0), m;
}
function Hu(t) {
  return t.some((r) => nl(r) ? !(r.type === Or || r.type === qe && !Hu(r.children)) : !0) ? t : null;
}
const Rs = (t) => t ? hc(t) ? Da(t) : Rs(t.parent) : null, Ii = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ on(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => Rs(t.parent),
    $root: (t) => Rs(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Xu(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      Xs(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = Ys.bind(t.proxy)),
    $watch: (t) => ud.bind(t)
  })
), cs = (t, r) => t !== wt && !t.__isScriptSetup && gt(t, r), Kf = {
  get({ _: t }, r) {
    if (r === "__v_skip")
      return !0;
    const { ctx: i, setupState: s, data: c, props: d, accessCache: u, type: p, appContext: m } = t;
    let P;
    if (r[0] !== "$") {
      const Y = u[r];
      if (Y !== void 0)
        switch (Y) {
          case 1:
            return s[r];
          case 2:
            return c[r];
          case 4:
            return i[r];
          case 3:
            return d[r];
        }
      else {
        if (cs(s, r))
          return u[r] = 1, s[r];
        if (c !== wt && gt(c, r))
          return u[r] = 2, c[r];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (P = t.propsOptions[0]) && gt(P, r)
        )
          return u[r] = 3, d[r];
        if (i !== wt && gt(i, r))
          return u[r] = 4, i[r];
        Cs && (u[r] = 0);
      }
    }
    const E = Ii[r];
    let L, j;
    if (E)
      return r === "$attrs" && rn(t.attrs, "get", ""), E(t);
    if (
      // css module (injected by vue-loader)
      (L = p.__cssModules) && (L = L[r])
    )
      return L;
    if (i !== wt && gt(i, r))
      return u[r] = 4, i[r];
    if (
      // global properties
      j = m.config.globalProperties, gt(j, r)
    )
      return j[r];
  },
  set({ _: t }, r, i) {
    const { data: s, setupState: c, ctx: d } = t;
    return cs(c, r) ? (c[r] = i, !0) : s !== wt && gt(s, r) ? (s[r] = i, !0) : gt(t.props, r) || r[0] === "$" && r.slice(1) in t ? !1 : (d[r] = i, !0);
  },
  has({
    _: { data: t, setupState: r, accessCache: i, ctx: s, appContext: c, propsOptions: d }
  }, u) {
    let p;
    return !!i[u] || t !== wt && gt(t, u) || cs(r, u) || (p = d[0]) && gt(p, u) || gt(s, u) || gt(Ii, u) || gt(c.config.globalProperties, u);
  },
  defineProperty(t, r, i) {
    return i.get != null ? t._.accessCache[r] = 0 : gt(i, "value") && this.set(t, r, i.value, null), Reflect.defineProperty(t, r, i);
  }
};
function xl(t) {
  return We(t) ? t.reduce(
    (r, i) => (r[i] = null, r),
    {}
  ) : t;
}
let Cs = !0;
function qf(t) {
  const r = Xu(t), i = t.proxy, s = t.ctx;
  Cs = !1, r.beforeCreate && Nl(r.beforeCreate, t, "bc");
  const {
    // state
    data: c,
    computed: d,
    methods: u,
    watch: p,
    provide: m,
    inject: P,
    // lifecycle
    created: E,
    beforeMount: L,
    mounted: j,
    beforeUpdate: Y,
    updated: z,
    activated: H,
    deactivated: ie,
    beforeDestroy: W,
    beforeUnmount: B,
    destroyed: F,
    unmounted: q,
    render: Te,
    renderTracked: pe,
    renderTriggered: ve,
    errorCaptured: se,
    serverPrefetch: S,
    // public API
    expose: we,
    inheritAttrs: ue,
    // assets
    components: ye,
    directives: be,
    filters: ke
  } = r;
  if (P && Uf(P, s, null), u)
    for (const Oe in u) {
      const Se = u[Oe];
      et(Se) && (s[Oe] = Se.bind(i));
    }
  if (c) {
    const Oe = c.call(i, i);
    Tt(Oe) && (t.data = Ki(Oe));
  }
  if (Cs = !0, d)
    for (const Oe in d) {
      const Se = d[Oe], Qe = et(Se) ? Se.bind(i, i) : et(Se.get) ? Se.get.bind(i, i) : Xn, ht = !et(Se) && et(Se.set) ? Se.set.bind(i) : Xn, Je = ze({
        get: Qe,
        set: ht
      });
      Object.defineProperty(s, Oe, {
        enumerable: !0,
        configurable: !0,
        get: () => Je.value,
        set: (It) => Je.value = It
      });
    }
  if (p)
    for (const Oe in p)
      Yu(p[Oe], s, i, Oe);
  if (m) {
    const Oe = et(m) ? m.call(i) : m;
    Reflect.ownKeys(Oe).forEach((Se) => {
      Xf(Se, Oe[Se]);
    });
  }
  E && Nl(E, t, "c");
  function He(Oe, Se) {
    We(Se) ? Se.forEach((Qe) => Oe(Qe.bind(i))) : Se && Oe(Se.bind(i));
  }
  if (He(Of, L), He(Ko, j), He(Df, Y), He(Sf, z), He(Ef, H), He(If, ie), He(Ff, se), He(jf, pe), He(kf, ve), He(Pf, B), He(zs, q), He(Lf, S), We(we))
    if (we.length) {
      const Oe = t.exposed || (t.exposed = {});
      we.forEach((Se) => {
        Object.defineProperty(Oe, Se, {
          get: () => i[Se],
          set: (Qe) => i[Se] = Qe
        });
      });
    } else t.exposed || (t.exposed = {});
  Te && t.render === Xn && (t.render = Te), ue != null && (t.inheritAttrs = ue), ye && (t.components = ye), be && (t.directives = be), S && Uu(t);
}
function Uf(t, r, i = Xn) {
  We(t) && (t = Ts(t));
  for (const s in t) {
    const c = t[s];
    let d;
    Tt(c) ? "default" in c ? d = Ai(
      c.from || s,
      c.default,
      !0
    ) : d = Ai(c.from || s) : d = Ai(c), At(d) ? Object.defineProperty(r, s, {
      enumerable: !0,
      configurable: !0,
      get: () => d.value,
      set: (u) => d.value = u
    }) : r[s] = d;
  }
}
function Nl(t, r, i) {
  Qn(
    We(t) ? t.map((s) => s.bind(r.proxy)) : t.bind(r.proxy),
    r,
    i
  );
}
function Yu(t, r, i, s) {
  let c = s.includes(".") ? ac(i, s) : () => i[s];
  if (Dt(t)) {
    const d = r[t];
    et(d) && Ut(c, d);
  } else if (et(t))
    Ut(c, t.bind(i));
  else if (Tt(t))
    if (We(t))
      t.forEach((d) => Yu(d, r, i, s));
    else {
      const d = et(t.handler) ? t.handler.bind(i) : r[t.handler];
      et(d) && Ut(c, d, t);
    }
}
function Xu(t) {
  const r = t.type, { mixins: i, extends: s } = r, {
    mixins: c,
    optionsCache: d,
    config: { optionMergeStrategies: u }
  } = t.appContext, p = d.get(r);
  let m;
  return p ? m = p : !c.length && !i && !s ? m = r : (m = {}, c.length && c.forEach(
    (P) => fa(m, P, u, !0)
  ), fa(m, r, u)), Tt(r) && d.set(r, m), m;
}
function fa(t, r, i, s = !1) {
  const { mixins: c, extends: d } = r;
  d && fa(t, d, i, !0), c && c.forEach(
    (u) => fa(t, u, i, !0)
  );
  for (const u in r)
    if (!(s && u === "expose")) {
      const p = Vf[u] || i && i[u];
      t[u] = p ? p(t[u], r[u]) : r[u];
    }
  return t;
}
const Vf = {
  data: Rl,
  props: Cl,
  emits: Cl,
  // objects
  methods: xi,
  computed: xi,
  // lifecycle
  beforeCreate: hn,
  created: hn,
  beforeMount: hn,
  mounted: hn,
  beforeUpdate: hn,
  updated: hn,
  beforeDestroy: hn,
  beforeUnmount: hn,
  destroyed: hn,
  unmounted: hn,
  activated: hn,
  deactivated: hn,
  errorCaptured: hn,
  serverPrefetch: hn,
  // assets
  components: xi,
  directives: xi,
  // watch
  watch: Gf,
  // provide / inject
  provide: Rl,
  inject: Wf
};
function Rl(t, r) {
  return r ? t ? function() {
    return on(
      et(t) ? t.call(this, this) : t,
      et(r) ? r.call(this, this) : r
    );
  } : r : t;
}
function Wf(t, r) {
  return xi(Ts(t), Ts(r));
}
function Ts(t) {
  if (We(t)) {
    const r = {};
    for (let i = 0; i < t.length; i++)
      r[t[i]] = t[i];
    return r;
  }
  return t;
}
function hn(t, r) {
  return t ? [...new Set([].concat(t, r))] : r;
}
function xi(t, r) {
  return t ? on(/* @__PURE__ */ Object.create(null), t, r) : r;
}
function Cl(t, r) {
  return t ? We(t) && We(r) ? [.../* @__PURE__ */ new Set([...t, ...r])] : on(
    /* @__PURE__ */ Object.create(null),
    xl(t),
    xl(r ?? {})
  ) : r;
}
function Gf(t, r) {
  if (!t) return r;
  if (!r) return t;
  const i = on(/* @__PURE__ */ Object.create(null), t);
  for (const s in r)
    i[s] = hn(t[s], r[s]);
  return i;
}
function Qu() {
  return {
    app: null,
    config: {
      isNativeTag: Ac,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Hf = 0;
function Yf(t, r) {
  return function(s, c = null) {
    et(s) || (s = on({}, s)), c != null && !Tt(c) && (c = null);
    const d = Qu(), u = /* @__PURE__ */ new WeakSet(), p = [];
    let m = !1;
    const P = d.app = {
      _uid: Hf++,
      _component: s,
      _props: c,
      _container: null,
      _context: d,
      _instance: null,
      version: Od,
      get config() {
        return d.config;
      },
      set config(E) {
      },
      use(E, ...L) {
        return u.has(E) || (E && et(E.install) ? (u.add(E), E.install(P, ...L)) : et(E) && (u.add(E), E(P, ...L))), P;
      },
      mixin(E) {
        return d.mixins.includes(E) || d.mixins.push(E), P;
      },
      component(E, L) {
        return L ? (d.components[E] = L, P) : d.components[E];
      },
      directive(E, L) {
        return L ? (d.directives[E] = L, P) : d.directives[E];
      },
      mount(E, L, j) {
        if (!m) {
          const Y = P._ceVNode || yt(s, c);
          return Y.appContext = d, j === !0 ? j = "svg" : j === !1 && (j = void 0), t(Y, E, j), m = !0, P._container = E, E.__vue_app__ = P, Da(Y.component);
        }
      },
      onUnmount(E) {
        p.push(E);
      },
      unmount() {
        m && (Qn(
          p,
          P._instance,
          16
        ), t(null, P._container), delete P._container.__vue_app__);
      },
      provide(E, L) {
        return d.provides[E] = L, P;
      },
      runWithContext(E) {
        const L = No;
        No = P;
        try {
          return E();
        } finally {
          No = L;
        }
      }
    };
    return P;
  };
}
let No = null;
function Xf(t, r) {
  if (Vt) {
    let i = Vt.provides;
    const s = Vt.parent && Vt.parent.provides;
    s === i && (i = Vt.provides = Object.create(s)), i[t] = r;
  }
}
function Ai(t, r, i = !1) {
  const s = Vt || Kt;
  if (s || No) {
    let c = No ? No._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (c && t in c)
      return c[t];
    if (arguments.length > 1)
      return i && et(r) ? r.call(s && s.proxy) : r;
  }
}
function Qf() {
  return !!(Vt || Kt || No);
}
const zu = {}, Ju = () => Object.create(zu), Zu = (t) => Object.getPrototypeOf(t) === zu;
function zf(t, r, i, s = !1) {
  const c = {}, d = Ju();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), ec(t, r, c, d);
  for (const u in t.propsOptions[0])
    u in c || (c[u] = void 0);
  i ? t.props = s ? c : lf(c) : t.type.props ? t.props = c : t.props = d, t.attrs = d;
}
function Jf(t, r, i, s) {
  const {
    props: c,
    attrs: d,
    vnode: { patchFlag: u }
  } = t, p = pt(c), [m] = t.propsOptions;
  let P = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (s || u > 0) && !(u & 16)
  ) {
    if (u & 8) {
      const E = t.vnode.dynamicProps;
      for (let L = 0; L < E.length; L++) {
        let j = E[L];
        if (Aa(t.emitsOptions, j))
          continue;
        const Y = r[j];
        if (m)
          if (gt(d, j))
            Y !== d[j] && (d[j] = Y, P = !0);
          else {
            const z = Sn(j);
            c[z] = Es(
              m,
              p,
              z,
              Y,
              t,
              !1
            );
          }
        else
          Y !== d[j] && (d[j] = Y, P = !0);
      }
    }
  } else {
    ec(t, r, c, d) && (P = !0);
    let E;
    for (const L in p)
      (!r || // for camelCase
      !gt(r, L) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((E = Io(L)) === L || !gt(r, E))) && (m ? i && // for camelCase
      (i[L] !== void 0 || // for kebab-case
      i[E] !== void 0) && (c[L] = Es(
        m,
        p,
        L,
        void 0,
        t,
        !0
      )) : delete c[L]);
    if (d !== p)
      for (const L in d)
        (!r || !gt(r, L)) && (delete d[L], P = !0);
  }
  P && Rr(t.attrs, "set", "");
}
function ec(t, r, i, s) {
  const [c, d] = t.propsOptions;
  let u = !1, p;
  if (r)
    for (let m in r) {
      if (Ni(m))
        continue;
      const P = r[m];
      let E;
      c && gt(c, E = Sn(m)) ? !d || !d.includes(E) ? i[E] = P : (p || (p = {}))[E] = P : Aa(t.emitsOptions, m) || (!(m in s) || P !== s[m]) && (s[m] = P, u = !0);
    }
  if (d) {
    const m = pt(i), P = p || wt;
    for (let E = 0; E < d.length; E++) {
      const L = d[E];
      i[L] = Es(
        c,
        m,
        L,
        P[L],
        t,
        !gt(P, L)
      );
    }
  }
  return u;
}
function Es(t, r, i, s, c, d) {
  const u = t[i];
  if (u != null) {
    const p = gt(u, "default");
    if (p && s === void 0) {
      const m = u.default;
      if (u.type !== Function && !u.skipFactory && et(m)) {
        const { propsDefaults: P } = c;
        if (i in P)
          s = P[i];
        else {
          const E = Ui(c);
          s = P[i] = m.call(
            null,
            r
          ), E();
        }
      } else
        s = m;
      c.ce && c.ce._setProp(i, s);
    }
    u[
      0
      /* shouldCast */
    ] && (d && !p ? s = !1 : u[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === Io(i)) && (s = !0));
  }
  return s;
}
const Zf = /* @__PURE__ */ new WeakMap();
function tc(t, r, i = !1) {
  const s = i ? Zf : r.propsCache, c = s.get(t);
  if (c)
    return c;
  const d = t.props, u = {}, p = [];
  let m = !1;
  if (!et(t)) {
    const E = (L) => {
      m = !0;
      const [j, Y] = tc(L, r, !0);
      on(u, j), Y && p.push(...Y);
    };
    !i && r.mixins.length && r.mixins.forEach(E), t.extends && E(t.extends), t.mixins && t.mixins.forEach(E);
  }
  if (!d && !m)
    return Tt(t) && s.set(t, So), So;
  if (We(d))
    for (let E = 0; E < d.length; E++) {
      const L = Sn(d[E]);
      Tl(L) && (u[L] = wt);
    }
  else if (d)
    for (const E in d) {
      const L = Sn(E);
      if (Tl(L)) {
        const j = d[E], Y = u[L] = We(j) || et(j) ? { type: j } : on({}, j), z = Y.type;
        let H = !1, ie = !0;
        if (We(z))
          for (let W = 0; W < z.length; ++W) {
            const B = z[W], F = et(B) && B.name;
            if (F === "Boolean") {
              H = !0;
              break;
            } else F === "String" && (ie = !1);
          }
        else
          H = et(z) && z.name === "Boolean";
        Y[
          0
          /* shouldCast */
        ] = H, Y[
          1
          /* shouldCastTrue */
        ] = ie, (H || gt(Y, "default")) && p.push(L);
      }
    }
  const P = [u, p];
  return Tt(t) && s.set(t, P), P;
}
function Tl(t) {
  return t[0] !== "$" && !Ni(t);
}
const Js = (t) => t[0] === "_" || t === "$stable", Zs = (t) => We(t) ? t.map(Yn) : [Yn(t)], ed = (t, r, i) => {
  if (r._n)
    return r;
  const s = xs((...c) => Zs(r(...c)), i);
  return s._c = !1, s;
}, nc = (t, r, i) => {
  const s = t._ctx;
  for (const c in t) {
    if (Js(c)) continue;
    const d = t[c];
    if (et(d))
      r[c] = ed(c, d, s);
    else if (d != null) {
      const u = Zs(d);
      r[c] = () => u;
    }
  }
}, rc = (t, r) => {
  const i = Zs(r);
  t.slots.default = () => i;
}, oc = (t, r, i) => {
  for (const s in r)
    (i || !Js(s)) && (t[s] = r[s]);
}, td = (t, r, i) => {
  const s = t.slots = Ju();
  if (t.vnode.shapeFlag & 32) {
    const c = r.__;
    c && gs(s, "__", c, !0);
    const d = r._;
    d ? (oc(s, r, i), i && gs(s, "_", d, !0)) : nc(r, s);
  } else r && rc(t, r);
}, nd = (t, r, i) => {
  const { vnode: s, slots: c } = t;
  let d = !0, u = wt;
  if (s.shapeFlag & 32) {
    const p = r._;
    p ? i && p === 1 ? d = !1 : oc(c, r, i) : (d = !r.$stable, nc(r, c)), u = r;
  } else r && (rc(t, r), u = { default: 1 });
  if (d)
    for (const p in c)
      !Js(p) && u[p] == null && delete c[p];
}, mn = vd;
function rd(t) {
  return od(t);
}
function od(t, r) {
  const i = _a();
  i.__VUE__ = !0;
  const {
    insert: s,
    remove: c,
    patchProp: d,
    createElement: u,
    createText: p,
    createComment: m,
    setText: P,
    setElementText: E,
    parentNode: L,
    nextSibling: j,
    setScopeId: Y = Xn,
    insertStaticContent: z
  } = t, H = (O, V, oe, fe = null, ge = null, he = null, Re = void 0, Ee = null, _e = !!V.dynamicChildren) => {
    if (O === V)
      return;
    O && !_i(O, V) && (fe = D(O), It(O, ge, he, !0), O = null), V.patchFlag === -2 && (_e = !1, V.dynamicChildren = null);
    const { type: me, ref: $e, shapeFlag: Ie } = V;
    switch (me) {
      case Oa:
        ie(O, V, oe, fe);
        break;
      case Or:
        W(O, V, oe, fe);
        break;
      case ea:
        O == null && B(V, oe, fe, Re);
        break;
      case qe:
        ye(
          O,
          V,
          oe,
          fe,
          ge,
          he,
          Re,
          Ee,
          _e
        );
        break;
      default:
        Ie & 1 ? Te(
          O,
          V,
          oe,
          fe,
          ge,
          he,
          Re,
          Ee,
          _e
        ) : Ie & 6 ? be(
          O,
          V,
          oe,
          fe,
          ge,
          he,
          Re,
          Ee,
          _e
        ) : (Ie & 64 || Ie & 128) && me.process(
          O,
          V,
          oe,
          fe,
          ge,
          he,
          Re,
          Ee,
          _e,
          Q
        );
    }
    $e != null && ge ? Ei($e, O && O.ref, he, V || O, !V) : $e == null && O && O.ref != null && Ei(O.ref, null, he, O, !0);
  }, ie = (O, V, oe, fe) => {
    if (O == null)
      s(
        V.el = p(V.children),
        oe,
        fe
      );
    else {
      const ge = V.el = O.el;
      V.children !== O.children && P(ge, V.children);
    }
  }, W = (O, V, oe, fe) => {
    O == null ? s(
      V.el = m(V.children || ""),
      oe,
      fe
    ) : V.el = O.el;
  }, B = (O, V, oe, fe) => {
    [O.el, O.anchor] = z(
      O.children,
      V,
      oe,
      fe,
      O.el,
      O.anchor
    );
  }, F = ({ el: O, anchor: V }, oe, fe) => {
    let ge;
    for (; O && O !== V; )
      ge = j(O), s(O, oe, fe), O = ge;
    s(V, oe, fe);
  }, q = ({ el: O, anchor: V }) => {
    let oe;
    for (; O && O !== V; )
      oe = j(O), c(O), O = oe;
    c(V);
  }, Te = (O, V, oe, fe, ge, he, Re, Ee, _e) => {
    V.type === "svg" ? Re = "svg" : V.type === "math" && (Re = "mathml"), O == null ? pe(
      V,
      oe,
      fe,
      ge,
      he,
      Re,
      Ee,
      _e
    ) : S(
      O,
      V,
      ge,
      he,
      Re,
      Ee,
      _e
    );
  }, pe = (O, V, oe, fe, ge, he, Re, Ee) => {
    let _e, me;
    const { props: $e, shapeFlag: Ie, transition: Me, dirs: Ke } = O;
    if (_e = O.el = u(
      O.type,
      he,
      $e && $e.is,
      $e
    ), Ie & 8 ? E(_e, O.children) : Ie & 16 && se(
      O.children,
      _e,
      null,
      fe,
      ge,
      fs(O, he),
      Re,
      Ee
    ), Ke && bo(O, null, fe, "created"), ve(_e, O, O.scopeId, Re, fe), $e) {
      for (const rt in $e)
        rt !== "value" && !Ni(rt) && d(_e, rt, null, $e[rt], he, fe);
      "value" in $e && d(_e, "value", null, $e.value, he), (me = $e.onVnodeBeforeMount) && Gn(me, fe, O);
    }
    Ke && bo(O, null, fe, "beforeMount");
    const Ge = id(ge, Me);
    Ge && Me.beforeEnter(_e), s(_e, V, oe), ((me = $e && $e.onVnodeMounted) || Ge || Ke) && mn(() => {
      me && Gn(me, fe, O), Ge && Me.enter(_e), Ke && bo(O, null, fe, "mounted");
    }, ge);
  }, ve = (O, V, oe, fe, ge) => {
    if (oe && Y(O, oe), fe)
      for (let he = 0; he < fe.length; he++)
        Y(O, fe[he]);
    if (ge) {
      let he = ge.subTree;
      if (V === he || lc(he.type) && (he.ssContent === V || he.ssFallback === V)) {
        const Re = ge.vnode;
        ve(
          O,
          Re,
          Re.scopeId,
          Re.slotScopeIds,
          ge.parent
        );
      }
    }
  }, se = (O, V, oe, fe, ge, he, Re, Ee, _e = 0) => {
    for (let me = _e; me < O.length; me++) {
      const $e = O[me] = Ee ? Lr(O[me]) : Yn(O[me]);
      H(
        null,
        $e,
        V,
        oe,
        fe,
        ge,
        he,
        Re,
        Ee
      );
    }
  }, S = (O, V, oe, fe, ge, he, Re) => {
    const Ee = V.el = O.el;
    let { patchFlag: _e, dynamicChildren: me, dirs: $e } = V;
    _e |= O.patchFlag & 16;
    const Ie = O.props || wt, Me = V.props || wt;
    let Ke;
    if (oe && wo(oe, !1), (Ke = Me.onVnodeBeforeUpdate) && Gn(Ke, oe, V, O), $e && bo(V, O, oe, "beforeUpdate"), oe && wo(oe, !0), (Ie.innerHTML && Me.innerHTML == null || Ie.textContent && Me.textContent == null) && E(Ee, ""), me ? we(
      O.dynamicChildren,
      me,
      Ee,
      oe,
      fe,
      fs(V, ge),
      he
    ) : Re || Se(
      O,
      V,
      Ee,
      null,
      oe,
      fe,
      fs(V, ge),
      he,
      !1
    ), _e > 0) {
      if (_e & 16)
        ue(Ee, Ie, Me, oe, ge);
      else if (_e & 2 && Ie.class !== Me.class && d(Ee, "class", null, Me.class, ge), _e & 4 && d(Ee, "style", Ie.style, Me.style, ge), _e & 8) {
        const Ge = V.dynamicProps;
        for (let rt = 0; rt < Ge.length; rt++) {
          const st = Ge[rt], xt = Ie[st], St = Me[st];
          (St !== xt || st === "value") && d(Ee, st, xt, St, ge, oe);
        }
      }
      _e & 1 && O.children !== V.children && E(Ee, V.children);
    } else !Re && me == null && ue(Ee, Ie, Me, oe, ge);
    ((Ke = Me.onVnodeUpdated) || $e) && mn(() => {
      Ke && Gn(Ke, oe, V, O), $e && bo(V, O, oe, "updated");
    }, fe);
  }, we = (O, V, oe, fe, ge, he, Re) => {
    for (let Ee = 0; Ee < V.length; Ee++) {
      const _e = O[Ee], me = V[Ee], $e = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        _e.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (_e.type === qe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !_i(_e, me) || // - In the case of a component, it could contain anything.
        _e.shapeFlag & 198) ? L(_e.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          oe
        )
      );
      H(
        _e,
        me,
        $e,
        null,
        fe,
        ge,
        he,
        Re,
        !0
      );
    }
  }, ue = (O, V, oe, fe, ge) => {
    if (V !== oe) {
      if (V !== wt)
        for (const he in V)
          !Ni(he) && !(he in oe) && d(
            O,
            he,
            V[he],
            null,
            ge,
            fe
          );
      for (const he in oe) {
        if (Ni(he)) continue;
        const Re = oe[he], Ee = V[he];
        Re !== Ee && he !== "value" && d(O, he, Ee, Re, ge, fe);
      }
      "value" in oe && d(O, "value", V.value, oe.value, ge);
    }
  }, ye = (O, V, oe, fe, ge, he, Re, Ee, _e) => {
    const me = V.el = O ? O.el : p(""), $e = V.anchor = O ? O.anchor : p("");
    let { patchFlag: Ie, dynamicChildren: Me, slotScopeIds: Ke } = V;
    Ke && (Ee = Ee ? Ee.concat(Ke) : Ke), O == null ? (s(me, oe, fe), s($e, oe, fe), se(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      V.children || [],
      oe,
      $e,
      ge,
      he,
      Re,
      Ee,
      _e
    )) : Ie > 0 && Ie & 64 && Me && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    O.dynamicChildren ? (we(
      O.dynamicChildren,
      Me,
      oe,
      ge,
      he,
      Re,
      Ee
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (V.key != null || ge && V === ge.subTree) && el(
      O,
      V,
      !0
      /* shallow */
    )) : Se(
      O,
      V,
      oe,
      $e,
      ge,
      he,
      Re,
      Ee,
      _e
    );
  }, be = (O, V, oe, fe, ge, he, Re, Ee, _e) => {
    V.slotScopeIds = Ee, O == null ? V.shapeFlag & 512 ? ge.ctx.activate(
      V,
      oe,
      fe,
      Re,
      _e
    ) : ke(
      V,
      oe,
      fe,
      ge,
      he,
      Re,
      _e
    ) : Be(O, V, _e);
  }, ke = (O, V, oe, fe, ge, he, Re) => {
    const Ee = O.component = xd(
      O,
      fe,
      ge
    );
    if (Vu(O) && (Ee.ctx.renderer = Q), Rd(Ee, !1, Re), Ee.asyncDep) {
      if (ge && ge.registerDep(Ee, He, Re), !O.el) {
        const _e = Ee.subTree = yt(Or);
        W(null, _e, V, oe);
      }
    } else
      He(
        Ee,
        O,
        V,
        oe,
        ge,
        he,
        Re
      );
  }, Be = (O, V, oe) => {
    const fe = V.component = O.component;
    if (hd(O, V, oe))
      if (fe.asyncDep && !fe.asyncResolved) {
        Oe(fe, V, oe);
        return;
      } else
        fe.next = V, fe.update();
    else
      V.el = O.el, fe.vnode = V;
  }, He = (O, V, oe, fe, ge, he, Re) => {
    const Ee = () => {
      if (O.isMounted) {
        let { next: Ie, bu: Me, u: Ke, parent: Ge, vnode: rt } = O;
        {
          const Nt = ic(O);
          if (Nt) {
            Ie && (Ie.el = rt.el, Oe(O, Ie, Re)), Nt.asyncDep.then(() => {
              O.isUnmounted || Ee();
            });
            return;
          }
        }
        let st = Ie, xt;
        wo(O, !1), Ie ? (Ie.el = rt.el, Oe(O, Ie, Re)) : Ie = rt, Me && Ji(Me), (xt = Ie.props && Ie.props.onVnodeBeforeUpdate) && Gn(xt, Ge, Ie, rt), wo(O, !0);
        const St = Il(O), Ft = O.subTree;
        O.subTree = St, H(
          Ft,
          St,
          // parent may have changed if it's in a teleport
          L(Ft.el),
          // anchor may have changed if it's in a fragment
          D(Ft),
          O,
          ge,
          he
        ), Ie.el = St.el, st === null && md(O, St.el), Ke && mn(Ke, ge), (xt = Ie.props && Ie.props.onVnodeUpdated) && mn(
          () => Gn(xt, Ge, Ie, rt),
          ge
        );
      } else {
        let Ie;
        const { el: Me, props: Ke } = V, { bm: Ge, m: rt, parent: st, root: xt, type: St } = O, Ft = ko(V);
        wo(O, !1), Ge && Ji(Ge), !Ft && (Ie = Ke && Ke.onVnodeBeforeMount) && Gn(Ie, st, V), wo(O, !0);
        {
          xt.ce && // @ts-expect-error _def is private
          xt.ce._def.shadowRoot !== !1 && xt.ce._injectChildStyle(St);
          const Nt = O.subTree = Il(O);
          H(
            null,
            Nt,
            oe,
            fe,
            O,
            ge,
            he
          ), V.el = Nt.el;
        }
        if (rt && mn(rt, ge), !Ft && (Ie = Ke && Ke.onVnodeMounted)) {
          const Nt = V;
          mn(
            () => Gn(Ie, st, Nt),
            ge
          );
        }
        (V.shapeFlag & 256 || st && ko(st.vnode) && st.vnode.shapeFlag & 256) && O.a && mn(O.a, ge), O.isMounted = !0, V = oe = fe = null;
      }
    };
    O.scope.on();
    const _e = O.effect = new mu(Ee);
    O.scope.off();
    const me = O.update = _e.run.bind(_e), $e = O.job = _e.runIfDirty.bind(_e);
    $e.i = O, $e.id = O.uid, _e.scheduler = () => Xs($e), wo(O, !0), me();
  }, Oe = (O, V, oe) => {
    V.component = O;
    const fe = O.vnode.props;
    O.vnode = V, O.next = null, Jf(O, V.props, fe, oe), nd(O, V.children, oe), Ir(), vl(O), Ar();
  }, Se = (O, V, oe, fe, ge, he, Re, Ee, _e = !1) => {
    const me = O && O.children, $e = O ? O.shapeFlag : 0, Ie = V.children, { patchFlag: Me, shapeFlag: Ke } = V;
    if (Me > 0) {
      if (Me & 128) {
        ht(
          me,
          Ie,
          oe,
          fe,
          ge,
          he,
          Re,
          Ee,
          _e
        );
        return;
      } else if (Me & 256) {
        Qe(
          me,
          Ie,
          oe,
          fe,
          ge,
          he,
          Re,
          Ee,
          _e
        );
        return;
      }
    }
    Ke & 8 ? ($e & 16 && Lt(me, ge, he), Ie !== me && E(oe, Ie)) : $e & 16 ? Ke & 16 ? ht(
      me,
      Ie,
      oe,
      fe,
      ge,
      he,
      Re,
      Ee,
      _e
    ) : Lt(me, ge, he, !0) : ($e & 8 && E(oe, ""), Ke & 16 && se(
      Ie,
      oe,
      fe,
      ge,
      he,
      Re,
      Ee,
      _e
    ));
  }, Qe = (O, V, oe, fe, ge, he, Re, Ee, _e) => {
    O = O || So, V = V || So;
    const me = O.length, $e = V.length, Ie = Math.min(me, $e);
    let Me;
    for (Me = 0; Me < Ie; Me++) {
      const Ke = V[Me] = _e ? Lr(V[Me]) : Yn(V[Me]);
      H(
        O[Me],
        Ke,
        oe,
        null,
        ge,
        he,
        Re,
        Ee,
        _e
      );
    }
    me > $e ? Lt(
      O,
      ge,
      he,
      !0,
      !1,
      Ie
    ) : se(
      V,
      oe,
      fe,
      ge,
      he,
      Re,
      Ee,
      _e,
      Ie
    );
  }, ht = (O, V, oe, fe, ge, he, Re, Ee, _e) => {
    let me = 0;
    const $e = V.length;
    let Ie = O.length - 1, Me = $e - 1;
    for (; me <= Ie && me <= Me; ) {
      const Ke = O[me], Ge = V[me] = _e ? Lr(V[me]) : Yn(V[me]);
      if (_i(Ke, Ge))
        H(
          Ke,
          Ge,
          oe,
          null,
          ge,
          he,
          Re,
          Ee,
          _e
        );
      else
        break;
      me++;
    }
    for (; me <= Ie && me <= Me; ) {
      const Ke = O[Ie], Ge = V[Me] = _e ? Lr(V[Me]) : Yn(V[Me]);
      if (_i(Ke, Ge))
        H(
          Ke,
          Ge,
          oe,
          null,
          ge,
          he,
          Re,
          Ee,
          _e
        );
      else
        break;
      Ie--, Me--;
    }
    if (me > Ie) {
      if (me <= Me) {
        const Ke = Me + 1, Ge = Ke < $e ? V[Ke].el : fe;
        for (; me <= Me; )
          H(
            null,
            V[me] = _e ? Lr(V[me]) : Yn(V[me]),
            oe,
            Ge,
            ge,
            he,
            Re,
            Ee,
            _e
          ), me++;
      }
    } else if (me > Me)
      for (; me <= Ie; )
        It(O[me], ge, he, !0), me++;
    else {
      const Ke = me, Ge = me, rt = /* @__PURE__ */ new Map();
      for (me = Ge; me <= Me; me++) {
        const mt = V[me] = _e ? Lr(V[me]) : Yn(V[me]);
        mt.key != null && rt.set(mt.key, me);
      }
      let st, xt = 0;
      const St = Me - Ge + 1;
      let Ft = !1, Nt = 0;
      const an = new Array(St);
      for (me = 0; me < St; me++) an[me] = 0;
      for (me = Ke; me <= Ie; me++) {
        const mt = O[me];
        if (xt >= St) {
          It(mt, ge, he, !0);
          continue;
        }
        let ce;
        if (mt.key != null)
          ce = rt.get(mt.key);
        else
          for (st = Ge; st <= Me; st++)
            if (an[st - Ge] === 0 && _i(mt, V[st])) {
              ce = st;
              break;
            }
        ce === void 0 ? It(mt, ge, he, !0) : (an[ce - Ge] = me + 1, ce >= Nt ? Nt = ce : Ft = !0, H(
          mt,
          V[ce],
          oe,
          null,
          ge,
          he,
          Re,
          Ee,
          _e
        ), xt++);
      }
      const Wn = Ft ? ad(an) : So;
      for (st = Wn.length - 1, me = St - 1; me >= 0; me--) {
        const mt = Ge + me, ce = V[mt], bn = mt + 1 < $e ? V[mt + 1].el : fe;
        an[me] === 0 ? H(
          null,
          ce,
          oe,
          bn,
          ge,
          he,
          Re,
          Ee,
          _e
        ) : Ft && (st < 0 || me !== Wn[st] ? Je(ce, oe, bn, 2) : st--);
      }
    }
  }, Je = (O, V, oe, fe, ge = null) => {
    const { el: he, type: Re, transition: Ee, children: _e, shapeFlag: me } = O;
    if (me & 6) {
      Je(O.component.subTree, V, oe, fe);
      return;
    }
    if (me & 128) {
      O.suspense.move(V, oe, fe);
      return;
    }
    if (me & 64) {
      Re.move(O, V, oe, Q);
      return;
    }
    if (Re === qe) {
      s(he, V, oe);
      for (let Ie = 0; Ie < _e.length; Ie++)
        Je(_e[Ie], V, oe, fe);
      s(O.anchor, V, oe);
      return;
    }
    if (Re === ea) {
      F(O, V, oe);
      return;
    }
    if (fe !== 2 && me & 1 && Ee)
      if (fe === 0)
        Ee.beforeEnter(he), s(he, V, oe), mn(() => Ee.enter(he), ge);
      else {
        const { leave: Ie, delayLeave: Me, afterLeave: Ke } = Ee, Ge = () => {
          O.ctx.isUnmounted ? c(he) : s(he, V, oe);
        }, rt = () => {
          Ie(he, () => {
            Ge(), Ke && Ke();
          });
        };
        Me ? Me(he, Ge, rt) : rt();
      }
    else
      s(he, V, oe);
  }, It = (O, V, oe, fe = !1, ge = !1) => {
    const {
      type: he,
      props: Re,
      ref: Ee,
      children: _e,
      dynamicChildren: me,
      shapeFlag: $e,
      patchFlag: Ie,
      dirs: Me,
      cacheIndex: Ke
    } = O;
    if (Ie === -2 && (ge = !1), Ee != null && (Ir(), Ei(Ee, null, oe, O, !0), Ar()), Ke != null && (V.renderCache[Ke] = void 0), $e & 256) {
      V.ctx.deactivate(O);
      return;
    }
    const Ge = $e & 1 && Me, rt = !ko(O);
    let st;
    if (rt && (st = Re && Re.onVnodeBeforeUnmount) && Gn(st, V, O), $e & 6)
      gn(O.component, oe, fe);
    else {
      if ($e & 128) {
        O.suspense.unmount(oe, fe);
        return;
      }
      Ge && bo(O, null, V, "beforeUnmount"), $e & 64 ? O.type.remove(
        O,
        V,
        oe,
        Q,
        fe
      ) : me && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !me.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (he !== qe || Ie > 0 && Ie & 64) ? Lt(
        me,
        V,
        oe,
        !1,
        !0
      ) : (he === qe && Ie & 384 || !ge && $e & 16) && Lt(_e, V, oe), fe && qt(O);
    }
    (rt && (st = Re && Re.onVnodeUnmounted) || Ge) && mn(() => {
      st && Gn(st, V, O), Ge && bo(O, null, V, "unmounted");
    }, oe);
  }, qt = (O) => {
    const { type: V, el: oe, anchor: fe, transition: ge } = O;
    if (V === qe) {
      Vn(oe, fe);
      return;
    }
    if (V === ea) {
      q(O);
      return;
    }
    const he = () => {
      c(oe), ge && !ge.persisted && ge.afterLeave && ge.afterLeave();
    };
    if (O.shapeFlag & 1 && ge && !ge.persisted) {
      const { leave: Re, delayLeave: Ee } = ge, _e = () => Re(oe, he);
      Ee ? Ee(O.el, he, _e) : _e();
    } else
      he();
  }, Vn = (O, V) => {
    let oe;
    for (; O !== V; )
      oe = j(O), c(O), O = oe;
    c(V);
  }, gn = (O, V, oe) => {
    const {
      bum: fe,
      scope: ge,
      job: he,
      subTree: Re,
      um: Ee,
      m: _e,
      a: me,
      parent: $e,
      slots: { __: Ie }
    } = O;
    El(_e), El(me), fe && Ji(fe), $e && We(Ie) && Ie.forEach((Me) => {
      $e.renderCache[Me] = void 0;
    }), ge.stop(), he && (he.flags |= 8, It(Re, O, V, oe)), Ee && mn(Ee, V), mn(() => {
      O.isUnmounted = !0;
    }, V), V && V.pendingBranch && !V.isUnmounted && O.asyncDep && !O.asyncResolved && O.suspenseId === V.pendingId && (V.deps--, V.deps === 0 && V.resolve());
  }, Lt = (O, V, oe, fe = !1, ge = !1, he = 0) => {
    for (let Re = he; Re < O.length; Re++)
      It(O[Re], V, oe, fe, ge);
  }, D = (O) => {
    if (O.shapeFlag & 6)
      return D(O.component.subTree);
    if (O.shapeFlag & 128)
      return O.suspense.next();
    const V = j(O.anchor || O.el), oe = V && V[Bu];
    return oe ? j(oe) : V;
  };
  let N = !1;
  const U = (O, V, oe) => {
    O == null ? V._vnode && It(V._vnode, null, null, !0) : H(
      V._vnode || null,
      O,
      V,
      null,
      null,
      null,
      oe
    ), V._vnode = O, N || (N = !0, vl(), Fu(), N = !1);
  }, Q = {
    p: H,
    um: It,
    m: Je,
    r: qt,
    mt: ke,
    mc: se,
    pc: Se,
    pbc: we,
    n: D,
    o: t
  };
  return {
    render: U,
    hydrate: void 0,
    createApp: Yf(U)
  };
}
function fs({ type: t, props: r }, i) {
  return i === "svg" && t === "foreignObject" || i === "mathml" && t === "annotation-xml" && r && r.encoding && r.encoding.includes("html") ? void 0 : i;
}
function wo({ effect: t, job: r }, i) {
  i ? (t.flags |= 32, r.flags |= 4) : (t.flags &= -33, r.flags &= -5);
}
function id(t, r) {
  return (!t || t && !t.pendingBranch) && r && !r.persisted;
}
function el(t, r, i = !1) {
  const s = t.children, c = r.children;
  if (We(s) && We(c))
    for (let d = 0; d < s.length; d++) {
      const u = s[d];
      let p = c[d];
      p.shapeFlag & 1 && !p.dynamicChildren && ((p.patchFlag <= 0 || p.patchFlag === 32) && (p = c[d] = Lr(c[d]), p.el = u.el), !i && p.patchFlag !== -2 && el(u, p)), p.type === Oa && (p.el = u.el), p.type === Or && !p.el && (p.el = u.el);
    }
}
function ad(t) {
  const r = t.slice(), i = [0];
  let s, c, d, u, p;
  const m = t.length;
  for (s = 0; s < m; s++) {
    const P = t[s];
    if (P !== 0) {
      if (c = i[i.length - 1], t[c] < P) {
        r[s] = c, i.push(s);
        continue;
      }
      for (d = 0, u = i.length - 1; d < u; )
        p = d + u >> 1, t[i[p]] < P ? d = p + 1 : u = p;
      P < t[i[d]] && (d > 0 && (r[s] = i[d - 1]), i[d] = s);
    }
  }
  for (d = i.length, u = i[d - 1]; d-- > 0; )
    i[d] = u, u = r[u];
  return i;
}
function ic(t) {
  const r = t.subTree.component;
  if (r)
    return r.asyncDep && !r.asyncResolved ? r : ic(r);
}
function El(t) {
  if (t)
    for (let r = 0; r < t.length; r++)
      t[r].flags |= 8;
}
const sd = Symbol.for("v-scx"), ld = () => Ai(sd);
function Ia(t, r) {
  return tl(t, null, r);
}
function Ut(t, r, i) {
  return tl(t, r, i);
}
function tl(t, r, i = wt) {
  const { immediate: s, deep: c, flush: d, once: u } = i, p = on({}, i), m = r && s || !r && d !== "post";
  let P;
  if (ji) {
    if (d === "sync") {
      const Y = ld();
      P = Y.__watcherHandles || (Y.__watcherHandles = []);
    } else if (!m) {
      const Y = () => {
      };
      return Y.stop = Xn, Y.resume = Xn, Y.pause = Xn, Y;
    }
  }
  const E = Vt;
  p.call = (Y, z, H) => Qn(Y, E, z, H);
  let L = !1;
  d === "post" ? p.scheduler = (Y) => {
    mn(Y, E && E.suspense);
  } : d !== "sync" && (L = !0, p.scheduler = (Y, z) => {
    z ? Y() : Xs(Y);
  }), p.augmentJob = (Y) => {
    r && (Y.flags |= 4), L && (Y.flags |= 2, E && (Y.id = E.uid, Y.i = E));
  };
  const j = wf(t, r, p);
  return ji && (P ? P.push(j) : m && j()), j;
}
function ud(t, r, i) {
  const s = this.proxy, c = Dt(t) ? t.includes(".") ? ac(s, t) : () => s[t] : t.bind(s, s);
  let d;
  et(r) ? d = r : (d = r.handler, i = r);
  const u = Ui(this), p = tl(c, d.bind(s), i);
  return u(), p;
}
function ac(t, r) {
  const i = r.split(".");
  return () => {
    let s = t;
    for (let c = 0; c < i.length && s; c++)
      s = s[i[c]];
    return s;
  };
}
const cd = (t, r) => r === "modelValue" || r === "model-value" ? t.modelModifiers : t[`${r}Modifiers`] || t[`${Sn(r)}Modifiers`] || t[`${Io(r)}Modifiers`];
function fd(t, r, ...i) {
  if (t.isUnmounted) return;
  const s = t.vnode.props || wt;
  let c = i;
  const d = r.startsWith("update:"), u = d && cd(s, r.slice(7));
  u && (u.trim && (c = i.map((E) => Dt(E) ? E.trim() : E)), u.number && (c = i.map(ia)));
  let p, m = s[p = is(r)] || // also try camelCase event handler (#2249)
  s[p = is(Sn(r))];
  !m && d && (m = s[p = is(Io(r))]), m && Qn(
    m,
    t,
    6,
    c
  );
  const P = s[p + "Once"];
  if (P) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[p])
      return;
    t.emitted[p] = !0, Qn(
      P,
      t,
      6,
      c
    );
  }
}
function sc(t, r, i = !1) {
  const s = r.emitsCache, c = s.get(t);
  if (c !== void 0)
    return c;
  const d = t.emits;
  let u = {}, p = !1;
  if (!et(t)) {
    const m = (P) => {
      const E = sc(P, r, !0);
      E && (p = !0, on(u, E));
    };
    !i && r.mixins.length && r.mixins.forEach(m), t.extends && m(t.extends), t.mixins && t.mixins.forEach(m);
  }
  return !d && !p ? (Tt(t) && s.set(t, null), null) : (We(d) ? d.forEach((m) => u[m] = null) : on(u, d), Tt(t) && s.set(t, u), u);
}
function Aa(t, r) {
  return !t || !ga(r) ? !1 : (r = r.slice(2).replace(/Once$/, ""), gt(t, r[0].toLowerCase() + r.slice(1)) || gt(t, Io(r)) || gt(t, r));
}
function Il(t) {
  const {
    type: r,
    vnode: i,
    proxy: s,
    withProxy: c,
    propsOptions: [d],
    slots: u,
    attrs: p,
    emit: m,
    render: P,
    renderCache: E,
    props: L,
    data: j,
    setupState: Y,
    ctx: z,
    inheritAttrs: H
  } = t, ie = ca(t);
  let W, B;
  try {
    if (i.shapeFlag & 4) {
      const q = c || s, Te = q;
      W = Yn(
        P.call(
          Te,
          q,
          E,
          L,
          Y,
          j,
          z
        )
      ), B = p;
    } else {
      const q = r;
      W = Yn(
        q.length > 1 ? q(
          L,
          { attrs: p, slots: u, emit: m }
        ) : q(
          L,
          null
        )
      ), B = r.props ? p : dd(p);
    }
  } catch (q) {
    Oi.length = 0, Ta(q, t, 1), W = yt(Or);
  }
  let F = W;
  if (B && H !== !1) {
    const q = Object.keys(B), { shapeFlag: Te } = F;
    q.length && Te & 7 && (d && q.some($s) && (B = pd(
      B,
      d
    )), F = Fo(F, B, !1, !0));
  }
  return i.dirs && (F = Fo(F, null, !1, !0), F.dirs = F.dirs ? F.dirs.concat(i.dirs) : i.dirs), i.transition && Qs(F, i.transition), W = F, ca(ie), W;
}
const dd = (t) => {
  let r;
  for (const i in t)
    (i === "class" || i === "style" || ga(i)) && ((r || (r = {}))[i] = t[i]);
  return r;
}, pd = (t, r) => {
  const i = {};
  for (const s in t)
    (!$s(s) || !(s.slice(9) in r)) && (i[s] = t[s]);
  return i;
};
function hd(t, r, i) {
  const { props: s, children: c, component: d } = t, { props: u, children: p, patchFlag: m } = r, P = d.emitsOptions;
  if (r.dirs || r.transition)
    return !0;
  if (i && m >= 0) {
    if (m & 1024)
      return !0;
    if (m & 16)
      return s ? Al(s, u, P) : !!u;
    if (m & 8) {
      const E = r.dynamicProps;
      for (let L = 0; L < E.length; L++) {
        const j = E[L];
        if (u[j] !== s[j] && !Aa(P, j))
          return !0;
      }
    }
  } else
    return (c || p) && (!p || !p.$stable) ? !0 : s === u ? !1 : s ? u ? Al(s, u, P) : !0 : !!u;
  return !1;
}
function Al(t, r, i) {
  const s = Object.keys(r);
  if (s.length !== Object.keys(t).length)
    return !0;
  for (let c = 0; c < s.length; c++) {
    const d = s[c];
    if (r[d] !== t[d] && !Aa(i, d))
      return !0;
  }
  return !1;
}
function md({ vnode: t, parent: r }, i) {
  for (; r; ) {
    const s = r.subTree;
    if (s.suspense && s.suspense.activeBranch === t && (s.el = t.el), s === t)
      (t = r.vnode).el = i, r = r.parent;
    else
      break;
  }
}
const lc = (t) => t.__isSuspense;
function vd(t, r) {
  r && r.pendingBranch ? We(t) ? r.effects.push(...t) : r.effects.push(t) : Nf(t);
}
const qe = Symbol.for("v-fgt"), Oa = Symbol.for("v-txt"), Or = Symbol.for("v-cmt"), ea = Symbol.for("v-stc"), Oi = [];
let En = null;
function ae(t = !1) {
  Oi.push(En = t ? null : []);
}
function yd() {
  Oi.pop(), En = Oi[Oi.length - 1] || null;
}
let ki = 1;
function Ol(t, r = !1) {
  ki += t, t < 0 && En && r && (En.hasOnce = !0);
}
function uc(t) {
  return t.dynamicChildren = ki > 0 ? En || So : null, yd(), ki > 0 && En && En.push(t), t;
}
function de(t, r, i, s, c, d) {
  return uc(
    y(
      t,
      r,
      i,
      s,
      c,
      d,
      !0
    )
  );
}
function en(t, r, i, s, c) {
  return uc(
    yt(
      t,
      r,
      i,
      s,
      c,
      !0
    )
  );
}
function nl(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function _i(t, r) {
  return t.type === r.type && t.key === r.key;
}
const cc = ({ key: t }) => t ?? null, ta = ({
  ref: t,
  ref_key: r,
  ref_for: i
}) => (typeof t == "number" && (t = "" + t), t != null ? Dt(t) || At(t) || et(t) ? { i: Kt, r: t, k: r, f: !!i } : t : null);
function y(t, r = null, i = null, s = 0, c = null, d = t === qe ? 0 : 1, u = !1, p = !1) {
  const m = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: r,
    key: r && cc(r),
    ref: r && ta(r),
    scopeId: Mu,
    slotScopeIds: null,
    children: i,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: d,
    patchFlag: s,
    dynamicProps: c,
    dynamicChildren: null,
    appContext: null,
    ctx: Kt
  };
  return p ? (rl(m, i), d & 128 && t.normalize(m)) : i && (m.shapeFlag |= Dt(i) ? 8 : 16), ki > 0 && // avoid a block node from tracking itself
  !u && // has current parent block
  En && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (m.patchFlag > 0 || d & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  m.patchFlag !== 32 && En.push(m), m;
}
const yt = gd;
function gd(t, r = null, i = null, s = 0, c = null, d = !1) {
  if ((!t || t === Gu) && (t = Or), nl(t)) {
    const p = Fo(
      t,
      r,
      !0
      /* mergeRef: true */
    );
    return i && rl(p, i), ki > 0 && !d && En && (p.shapeFlag & 6 ? En[En.indexOf(t)] = p : En.push(p)), p.patchFlag = -2, p;
  }
  if (Ad(t) && (t = t.__vccOpts), r) {
    r = bd(r);
    let { class: p, style: m } = r;
    p && !Dt(p) && (r.class = Zt(p)), Tt(m) && (Hs(m) && !We(m) && (m = on({}, m)), r.style = Br(m));
  }
  const u = Dt(t) ? 1 : lc(t) ? 128 : Rf(t) ? 64 : Tt(t) ? 4 : et(t) ? 2 : 0;
  return y(
    t,
    r,
    i,
    s,
    c,
    u,
    d,
    !0
  );
}
function bd(t) {
  return t ? Hs(t) || Zu(t) ? on({}, t) : t : null;
}
function Fo(t, r, i = !1, s = !1) {
  const { props: c, ref: d, patchFlag: u, children: p, transition: m } = t, P = r ? pc(c || {}, r) : c, E = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: P,
    key: P && cc(P),
    ref: r && r.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      i && d ? We(d) ? d.concat(ta(r)) : [d, ta(r)] : ta(r)
    ) : d,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: p,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: r && t.type !== qe ? u === -1 ? 16 : u | 16 : u,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: m,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Fo(t.ssContent),
    ssFallback: t.ssFallback && Fo(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return m && s && Qs(
    E,
    m.clone(E)
  ), E;
}
function fc(t = " ", r = 0) {
  return yt(Oa, null, t, r);
}
function dc(t, r) {
  const i = yt(ea, null, t);
  return i.staticCount = r, i;
}
function Xe(t = "", r = !1) {
  return r ? (ae(), en(Or, null, t)) : yt(Or, null, t);
}
function Yn(t) {
  return t == null || typeof t == "boolean" ? yt(Or) : We(t) ? yt(
    qe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : nl(t) ? Lr(t) : yt(Oa, null, String(t));
}
function Lr(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Fo(t);
}
function rl(t, r) {
  let i = 0;
  const { shapeFlag: s } = t;
  if (r == null)
    r = null;
  else if (We(r))
    i = 16;
  else if (typeof r == "object")
    if (s & 65) {
      const c = r.default;
      c && (c._c && (c._d = !1), rl(t, c()), c._c && (c._d = !0));
      return;
    } else {
      i = 32;
      const c = r._;
      !c && !Zu(r) ? r._ctx = Kt : c === 3 && Kt && (Kt.slots._ === 1 ? r._ = 1 : (r._ = 2, t.patchFlag |= 1024));
    }
  else et(r) ? (r = { default: r, _ctx: Kt }, i = 32) : (r = String(r), s & 64 ? (i = 16, r = [fc(r)]) : i = 8);
  t.children = r, t.shapeFlag |= i;
}
function pc(...t) {
  const r = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    for (const c in s)
      if (c === "class")
        r.class !== s.class && (r.class = Zt([r.class, s.class]));
      else if (c === "style")
        r.style = Br([r.style, s.style]);
      else if (ga(c)) {
        const d = r[c], u = s[c];
        u && d !== u && !(We(d) && d.includes(u)) && (r[c] = d ? [].concat(d, u) : u);
      } else c !== "" && (r[c] = s[c]);
  }
  return r;
}
function Gn(t, r, i, s = null) {
  Qn(t, r, 7, [
    i,
    s
  ]);
}
const wd = Qu();
let _d = 0;
function xd(t, r, i) {
  const s = t.type, c = (r ? r.appContext : t.appContext) || wd, d = {
    uid: _d++,
    vnode: t,
    type: s,
    parent: r,
    appContext: c,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new du(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: r ? r.provides : Object.create(c.provides),
    ids: r ? r.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: tc(s, c),
    emitsOptions: sc(s, c),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: wt,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: wt,
    data: wt,
    props: wt,
    attrs: wt,
    slots: wt,
    refs: wt,
    setupState: wt,
    setupContext: null,
    // suspense related
    suspense: i,
    suspenseId: i ? i.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return d.ctx = { _: d }, d.root = r ? r.root : d, d.emit = fd.bind(null, d), t.ce && t.ce(d), d;
}
let Vt = null;
const Nd = () => Vt || Kt;
let da, Is;
{
  const t = _a(), r = (i, s) => {
    let c;
    return (c = t[i]) || (c = t[i] = []), c.push(s), (d) => {
      c.length > 1 ? c.forEach((u) => u(d)) : c[0](d);
    };
  };
  da = r(
    "__VUE_INSTANCE_SETTERS__",
    (i) => Vt = i
  ), Is = r(
    "__VUE_SSR_SETTERS__",
    (i) => ji = i
  );
}
const Ui = (t) => {
  const r = Vt;
  return da(t), t.scope.on(), () => {
    t.scope.off(), da(r);
  };
}, Dl = () => {
  Vt && Vt.scope.off(), da(null);
};
function hc(t) {
  return t.vnode.shapeFlag & 4;
}
let ji = !1;
function Rd(t, r = !1, i = !1) {
  r && Is(r);
  const { props: s, children: c } = t.vnode, d = hc(t);
  zf(t, s, d, r), td(t, c, i || r);
  const u = d ? Cd(t, r) : void 0;
  return r && Is(!1), u;
}
function Cd(t, r) {
  const i = t.type;
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, Kf);
  const { setup: s } = i;
  if (s) {
    Ir();
    const c = t.setupContext = s.length > 1 ? Ed(t) : null, d = Ui(t), u = qi(
      s,
      t,
      0,
      [
        t.props,
        c
      ]
    ), p = au(u);
    if (Ar(), d(), (p || t.sp) && !ko(t) && Uu(t), p) {
      if (u.then(Dl, Dl), r)
        return u.then((m) => {
          Sl(t, m);
        }).catch((m) => {
          Ta(m, t, 0);
        });
      t.asyncDep = u;
    } else
      Sl(t, u);
  } else
    mc(t);
}
function Sl(t, r, i) {
  et(r) ? t.type.__ssrInlineRender ? t.ssrRender = r : t.render = r : Tt(r) && (t.setupState = Pu(r)), mc(t);
}
function mc(t, r, i) {
  const s = t.type;
  t.render || (t.render = s.render || Xn);
  {
    const c = Ui(t);
    Ir();
    try {
      qf(t);
    } finally {
      Ar(), c();
    }
  }
}
const Td = {
  get(t, r) {
    return rn(t, "get", ""), t[r];
  }
};
function Ed(t) {
  const r = (i) => {
    t.exposed = i || {};
  };
  return {
    attrs: new Proxy(t.attrs, Td),
    slots: t.slots,
    emit: t.emit,
    expose: r
  };
}
function Da(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(Pu(Ca(t.exposed)), {
    get(r, i) {
      if (i in r)
        return r[i];
      if (i in Ii)
        return Ii[i](t);
    },
    has(r, i) {
      return i in r || i in Ii;
    }
  })) : t.proxy;
}
function Id(t, r = !0) {
  return et(t) ? t.displayName || t.name : t.name || r && t.__name;
}
function Ad(t) {
  return et(t) && "__vccOpts" in t;
}
const ze = (t, r) => gf(t, r, ji), Od = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let As;
const Pl = typeof window < "u" && window.trustedTypes;
if (Pl)
  try {
    As = /* @__PURE__ */ Pl.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch {
  }
const vc = As ? (t) => As.createHTML(t) : (t) => t, Dd = "http://www.w3.org/2000/svg", Sd = "http://www.w3.org/1998/Math/MathML", Nr = typeof document < "u" ? document : null, Ll = Nr && /* @__PURE__ */ Nr.createElement("template"), Pd = {
  insert: (t, r, i) => {
    r.insertBefore(t, i || null);
  },
  remove: (t) => {
    const r = t.parentNode;
    r && r.removeChild(t);
  },
  createElement: (t, r, i, s) => {
    const c = r === "svg" ? Nr.createElementNS(Dd, t) : r === "mathml" ? Nr.createElementNS(Sd, t) : i ? Nr.createElement(t, { is: i }) : Nr.createElement(t);
    return t === "select" && s && s.multiple != null && c.setAttribute("multiple", s.multiple), c;
  },
  createText: (t) => Nr.createTextNode(t),
  createComment: (t) => Nr.createComment(t),
  setText: (t, r) => {
    t.nodeValue = r;
  },
  setElementText: (t, r) => {
    t.textContent = r;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Nr.querySelector(t),
  setScopeId(t, r) {
    t.setAttribute(r, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, r, i, s, c, d) {
    const u = i ? i.previousSibling : r.lastChild;
    if (c && (c === d || c.nextSibling))
      for (; r.insertBefore(c.cloneNode(!0), i), !(c === d || !(c = c.nextSibling)); )
        ;
    else {
      Ll.innerHTML = vc(
        s === "svg" ? `<svg>${t}</svg>` : s === "mathml" ? `<math>${t}</math>` : t
      );
      const p = Ll.content;
      if (s === "svg" || s === "mathml") {
        const m = p.firstChild;
        for (; m.firstChild; )
          p.appendChild(m.firstChild);
        p.removeChild(m);
      }
      r.insertBefore(p, i);
    }
    return [
      // first
      u ? u.nextSibling : r.firstChild,
      // last
      i ? i.previousSibling : r.lastChild
    ];
  }
}, Ld = Symbol("_vtc");
function kd(t, r, i) {
  const s = t[Ld];
  s && (r = (r ? [r, ...s] : [...s]).join(" ")), r == null ? t.removeAttribute("class") : i ? t.setAttribute("class", r) : t.className = r;
}
const kl = Symbol("_vod"), jd = Symbol("_vsh"), Fd = Symbol(""), $d = /(^|;)\s*display\s*:/;
function Md(t, r, i) {
  const s = t.style, c = Dt(i);
  let d = !1;
  if (i && !c) {
    if (r)
      if (Dt(r))
        for (const u of r.split(";")) {
          const p = u.slice(0, u.indexOf(":")).trim();
          i[p] == null && na(s, p, "");
        }
      else
        for (const u in r)
          i[u] == null && na(s, u, "");
    for (const u in i)
      u === "display" && (d = !0), na(s, u, i[u]);
  } else if (c) {
    if (r !== i) {
      const u = s[Fd];
      u && (i += ";" + u), s.cssText = i, d = $d.test(i);
    }
  } else r && t.removeAttribute("style");
  kl in t && (t[kl] = d ? s.display : "", t[jd] && (s.display = "none"));
}
const jl = /\s*!important$/;
function na(t, r, i) {
  if (We(i))
    i.forEach((s) => na(t, r, s));
  else if (i == null && (i = ""), r.startsWith("--"))
    t.setProperty(r, i);
  else {
    const s = Bd(t, r);
    jl.test(i) ? t.setProperty(
      Io(s),
      i.replace(jl, ""),
      "important"
    ) : t[s] = i;
  }
}
const Fl = ["Webkit", "Moz", "ms"], ds = {};
function Bd(t, r) {
  const i = ds[r];
  if (i)
    return i;
  let s = Sn(r);
  if (s !== "filter" && s in t)
    return ds[r] = s;
  s = wa(s);
  for (let c = 0; c < Fl.length; c++) {
    const d = Fl[c] + s;
    if (d in t)
      return ds[r] = d;
  }
  return r;
}
const $l = "http://www.w3.org/1999/xlink";
function Ml(t, r, i, s, c, d = Bc(r)) {
  s && r.startsWith("xlink:") ? i == null ? t.removeAttributeNS($l, r.slice(6, r.length)) : t.setAttributeNS($l, r, i) : i == null || d && !uu(i) ? t.removeAttribute(r) : t.setAttribute(
    r,
    d ? "" : Un(i) ? String(i) : i
  );
}
function Bl(t, r, i, s, c) {
  if (r === "innerHTML" || r === "textContent") {
    i != null && (t[r] = r === "innerHTML" ? vc(i) : i);
    return;
  }
  const d = t.tagName;
  if (r === "value" && d !== "PROGRESS" && // custom elements may use _value internally
  !d.includes("-")) {
    const p = d === "OPTION" ? t.getAttribute("value") || "" : t.value, m = i == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(i);
    (p !== m || !("_value" in t)) && (t.value = m), i == null && t.removeAttribute(r), t._value = i;
    return;
  }
  let u = !1;
  if (i === "" || i == null) {
    const p = typeof t[r];
    p === "boolean" ? i = uu(i) : i == null && p === "string" ? (i = "", u = !0) : p === "number" && (i = 0, u = !0);
  }
  try {
    t[r] = i;
  } catch {
  }
  u && t.removeAttribute(c || r);
}
function Tr(t, r, i, s) {
  t.addEventListener(r, i, s);
}
function Kd(t, r, i, s) {
  t.removeEventListener(r, i, s);
}
const Kl = Symbol("_vei");
function qd(t, r, i, s, c = null) {
  const d = t[Kl] || (t[Kl] = {}), u = d[r];
  if (s && u)
    u.value = s;
  else {
    const [p, m] = Ud(r);
    if (s) {
      const P = d[r] = Gd(
        s,
        c
      );
      Tr(t, p, P, m);
    } else u && (Kd(t, p, u, m), d[r] = void 0);
  }
}
const ql = /(?:Once|Passive|Capture)$/;
function Ud(t) {
  let r;
  if (ql.test(t)) {
    r = {};
    let s;
    for (; s = t.match(ql); )
      t = t.slice(0, t.length - s[0].length), r[s[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Io(t.slice(2)), r];
}
let ps = 0;
const Vd = /* @__PURE__ */ Promise.resolve(), Wd = () => ps || (Vd.then(() => ps = 0), ps = Date.now());
function Gd(t, r) {
  const i = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= i.attached)
      return;
    Qn(
      Hd(s, i.value),
      r,
      5,
      [s]
    );
  };
  return i.value = t, i.attached = Wd(), i;
}
function Hd(t, r) {
  if (We(r)) {
    const i = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      i.call(t), t._stopped = !0;
    }, r.map(
      (s) => (c) => !c._stopped && s && s(c)
    );
  } else
    return r;
}
const Ul = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, Yd = (t, r, i, s, c, d) => {
  const u = c === "svg";
  r === "class" ? kd(t, s, u) : r === "style" ? Md(t, i, s) : ga(r) ? $s(r) || qd(t, r, i, s, d) : (r[0] === "." ? (r = r.slice(1), !0) : r[0] === "^" ? (r = r.slice(1), !1) : Xd(t, r, s, u)) ? (Bl(t, r, s), !t.tagName.includes("-") && (r === "value" || r === "checked" || r === "selected") && Ml(t, r, s, u, d, r !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(r) || !Dt(s)) ? Bl(t, Sn(r), s, d, r) : (r === "true-value" ? t._trueValue = s : r === "false-value" && (t._falseValue = s), Ml(t, r, s, u));
};
function Xd(t, r, i, s) {
  if (s)
    return !!(r === "innerHTML" || r === "textContent" || r in t && Ul(r) && et(i));
  if (r === "spellcheck" || r === "draggable" || r === "translate" || r === "autocorrect" || r === "form" || r === "list" && t.tagName === "INPUT" || r === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (r === "width" || r === "height") {
    const c = t.tagName;
    if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE")
      return !1;
  }
  return Ul(r) && Dt(i) ? !1 : r in t;
}
const $r = (t) => {
  const r = t.props["onUpdate:modelValue"] || !1;
  return We(r) ? (i) => Ji(r, i) : r;
};
function Qd(t) {
  t.target.composing = !0;
}
function Vl(t) {
  const r = t.target;
  r.composing && (r.composing = !1, r.dispatchEvent(new Event("input")));
}
const Dn = Symbol("_assign"), To = {
  created(t, { modifiers: { lazy: r, trim: i, number: s } }, c) {
    t[Dn] = $r(c);
    const d = s || c.props && c.props.type === "number";
    Tr(t, r ? "change" : "input", (u) => {
      if (u.target.composing) return;
      let p = t.value;
      i && (p = p.trim()), d && (p = ia(p)), t[Dn](p);
    }), i && Tr(t, "change", () => {
      t.value = t.value.trim();
    }), r || (Tr(t, "compositionstart", Qd), Tr(t, "compositionend", Vl), Tr(t, "change", Vl));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: r }) {
    t.value = r ?? "";
  },
  beforeUpdate(t, { value: r, oldValue: i, modifiers: { lazy: s, trim: c, number: d } }, u) {
    if (t[Dn] = $r(u), t.composing) return;
    const p = (d || t.type === "number") && !/^0\d/.test(t.value) ? ia(t.value) : t.value, m = r ?? "";
    p !== m && (document.activeElement === t && t.type !== "range" && (s && r === i || c && t.value.trim() === m) || (t.value = m));
  }
}, Ro = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, r, i) {
    t[Dn] = $r(i), Tr(t, "change", () => {
      const s = t._modelValue, c = $o(t), d = t.checked, u = t[Dn];
      if (We(s)) {
        const p = Ks(s, c), m = p !== -1;
        if (d && !m)
          u(s.concat(c));
        else if (!d && m) {
          const P = [...s];
          P.splice(p, 1), u(P);
        }
      } else if (Bo(s)) {
        const p = new Set(s);
        d ? p.add(c) : p.delete(c), u(p);
      } else
        u(yc(t, d));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Wl,
  beforeUpdate(t, r, i) {
    t[Dn] = $r(i), Wl(t, r, i);
  }
};
function Wl(t, { value: r, oldValue: i }, s) {
  t._modelValue = r;
  let c;
  if (We(r))
    c = Ks(r, s.props.value) > -1;
  else if (Bo(r))
    c = r.has(s.props.value);
  else {
    if (r === i) return;
    c = Co(r, yc(t, !0));
  }
  t.checked !== c && (t.checked = c);
}
const Mr = {
  created(t, { value: r }, i) {
    t.checked = Co(r, i.props.value), t[Dn] = $r(i), Tr(t, "change", () => {
      t[Dn]($o(t));
    });
  },
  beforeUpdate(t, { value: r, oldValue: i }, s) {
    t[Dn] = $r(s), r !== i && (t.checked = Co(r, s.props.value));
  }
}, Jt = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: r, modifiers: { number: i } }, s) {
    const c = Bo(r);
    Tr(t, "change", () => {
      const d = Array.prototype.filter.call(t.options, (u) => u.selected).map(
        (u) => i ? ia($o(u)) : $o(u)
      );
      t[Dn](
        t.multiple ? c ? new Set(d) : d : d[0]
      ), t._assigning = !0, Ys(() => {
        t._assigning = !1;
      });
    }), t[Dn] = $r(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: r }) {
    Gl(t, r);
  },
  beforeUpdate(t, r, i) {
    t[Dn] = $r(i);
  },
  updated(t, { value: r }) {
    t._assigning || Gl(t, r);
  }
};
function Gl(t, r) {
  const i = t.multiple, s = We(r);
  if (!(i && !s && !Bo(r))) {
    for (let c = 0, d = t.options.length; c < d; c++) {
      const u = t.options[c], p = $o(u);
      if (i)
        if (s) {
          const m = typeof p;
          m === "string" || m === "number" ? u.selected = r.some((P) => String(P) === String(p)) : u.selected = Ks(r, p) > -1;
        } else
          u.selected = r.has(p);
      else if (Co($o(u), r)) {
        t.selectedIndex !== c && (t.selectedIndex = c);
        return;
      }
    }
    !i && t.selectedIndex !== -1 && (t.selectedIndex = -1);
  }
}
function $o(t) {
  return "_value" in t ? t._value : t.value;
}
function yc(t, r) {
  const i = r ? "_trueValue" : "_falseValue";
  return i in t ? t[i] : r;
}
const zd = ["ctrl", "shift", "alt", "meta"], Jd = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, r) => zd.some((i) => t[`${i}Key`] && !r.includes(i))
}, pa = (t, r) => {
  const i = t._withMods || (t._withMods = {}), s = r.join(".");
  return i[s] || (i[s] = (c, ...d) => {
    for (let u = 0; u < r.length; u++) {
      const p = Jd[r[u]];
      if (p && p(c, r)) return;
    }
    return t(c, ...d);
  });
}, Zd = /* @__PURE__ */ on({ patchProp: Yd }, Pd);
let Hl;
function ep() {
  return Hl || (Hl = rd(Zd));
}
const tp = (...t) => {
  const r = ep().createApp(...t), { mount: i } = r;
  return r.mount = (s) => {
    const c = rp(s);
    if (!c) return;
    const d = r._component;
    !et(d) && !d.render && !d.template && (d.template = c.innerHTML), c.nodeType === 1 && (c.textContent = "");
    const u = i(c, !1, np(c));
    return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), u;
  }, r;
};
function np(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function rp(t) {
  return Dt(t) ? document.querySelector(t) : t;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let gc;
const Sa = (t) => gc = t, bc = (
  /* istanbul ignore next */
  Symbol()
);
function Os(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var Di;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(Di || (Di = {}));
function op() {
  const t = pu(!0), r = t.run(() => Ue({}));
  let i = [], s = [];
  const c = Ca({
    install(d) {
      Sa(c), c._a = d, d.provide(bc, c), d.config.globalProperties.$pinia = c, s.forEach((u) => i.push(u)), s = [];
    },
    use(d) {
      return this._a ? i.push(d) : s.push(d), this;
    },
    _p: i,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: r
  });
  return c;
}
const wc = () => {
};
function Yl(t, r, i, s = wc) {
  t.push(r);
  const c = () => {
    const d = t.indexOf(r);
    d > -1 && (t.splice(d, 1), s());
  };
  return !i && qs() && hu(c), c;
}
function Oo(t, ...r) {
  t.slice().forEach((i) => {
    i(...r);
  });
}
const ip = (t) => t(), Xl = Symbol(), hs = Symbol();
function Ds(t, r) {
  t instanceof Map && r instanceof Map ? r.forEach((i, s) => t.set(s, i)) : t instanceof Set && r instanceof Set && r.forEach(t.add, t);
  for (const i in r) {
    if (!r.hasOwnProperty(i))
      continue;
    const s = r[i], c = t[i];
    Os(c) && Os(s) && t.hasOwnProperty(i) && !At(s) && !Er(s) ? t[i] = Ds(c, s) : t[i] = s;
  }
  return t;
}
const ap = (
  /* istanbul ignore next */
  Symbol()
);
function sp(t) {
  return !Os(t) || !Object.prototype.hasOwnProperty.call(t, ap);
}
const { assign: Sr } = Object;
function lp(t) {
  return !!(At(t) && t.effect);
}
function up(t, r, i, s) {
  const { state: c, actions: d, getters: u } = r, p = i.state.value[t];
  let m;
  function P() {
    p || (i.state.value[t] = c ? c() : {});
    const E = pf(i.state.value[t]);
    return Sr(E, d, Object.keys(u || {}).reduce((L, j) => (L[j] = Ca(ze(() => {
      Sa(i);
      const Y = i._s.get(t);
      return u[j].call(Y, Y);
    })), L), {}));
  }
  return m = _c(t, P, r, i, s, !0), m;
}
function _c(t, r, i = {}, s, c, d) {
  let u;
  const p = Sr({ actions: {} }, i), m = { deep: !0 };
  let P, E, L = [], j = [], Y;
  const z = s.state.value[t];
  !d && !z && (s.state.value[t] = {}), Ue({});
  let H;
  function ie(se) {
    let S;
    P = E = !1, typeof se == "function" ? (se(s.state.value[t]), S = {
      type: Di.patchFunction,
      storeId: t,
      events: Y
    }) : (Ds(s.state.value[t], se), S = {
      type: Di.patchObject,
      payload: se,
      storeId: t,
      events: Y
    });
    const we = H = Symbol();
    Ys().then(() => {
      H === we && (P = !0);
    }), E = !0, Oo(L, S, s.state.value[t]);
  }
  const W = d ? function() {
    const { state: S } = i, we = S ? S() : {};
    this.$patch((ue) => {
      Sr(ue, we);
    });
  } : (
    /* istanbul ignore next */
    wc
  );
  function B() {
    u.stop(), L = [], j = [], s._s.delete(t);
  }
  const F = (se, S = "") => {
    if (Xl in se)
      return se[hs] = S, se;
    const we = function() {
      Sa(s);
      const ue = Array.from(arguments), ye = [], be = [];
      function ke(Oe) {
        ye.push(Oe);
      }
      function Be(Oe) {
        be.push(Oe);
      }
      Oo(j, {
        args: ue,
        name: we[hs],
        store: Te,
        after: ke,
        onError: Be
      });
      let He;
      try {
        He = se.apply(this && this.$id === t ? this : Te, ue);
      } catch (Oe) {
        throw Oo(be, Oe), Oe;
      }
      return He instanceof Promise ? He.then((Oe) => (Oo(ye, Oe), Oe)).catch((Oe) => (Oo(be, Oe), Promise.reject(Oe))) : (Oo(ye, He), He);
    };
    return we[Xl] = !0, we[hs] = S, we;
  }, q = {
    _p: s,
    // _s: scope,
    $id: t,
    $onAction: Yl.bind(null, j),
    $patch: ie,
    $reset: W,
    $subscribe(se, S = {}) {
      const we = Yl(L, se, S.detached, () => ue()), ue = u.run(() => Ut(() => s.state.value[t], (ye) => {
        (S.flush === "sync" ? E : P) && se({
          storeId: t,
          type: Di.direct,
          events: Y
        }, ye);
      }, Sr({}, m, S)));
      return we;
    },
    $dispose: B
  }, Te = Ki(q);
  s._s.set(t, Te);
  const ve = (s._a && s._a.runWithContext || ip)(() => s._e.run(() => (u = pu()).run(() => r({ action: F }))));
  for (const se in ve) {
    const S = ve[se];
    if (At(S) && !lp(S) || Er(S))
      d || (z && sp(S) && (At(S) ? S.value = z[se] : Ds(S, z[se])), s.state.value[t][se] = S);
    else if (typeof S == "function") {
      const we = F(S, se);
      ve[se] = we, p.actions[se] = S;
    }
  }
  return Sr(Te, ve), Sr(pt(Te), ve), Object.defineProperty(Te, "$state", {
    get: () => s.state.value[t],
    set: (se) => {
      ie((S) => {
        Sr(S, se);
      });
    }
  }), s._p.forEach((se) => {
    Sr(Te, u.run(() => se({
      store: Te,
      app: s._a,
      pinia: s,
      options: p
    })));
  }), z && d && i.hydrate && i.hydrate(Te.$state, z), P = !0, E = !0, Te;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function ol(t, r, i) {
  let s;
  const c = typeof r == "function";
  s = c ? i : r;
  function d(u, p) {
    const m = Qf();
    return u = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    u || (m ? Ai(bc, null) : null), u && Sa(u), u = gc, u._s.has(t) || (c ? _c(t, r, s, u) : up(t, s, u)), u._s.get(t);
  }
  return d.$id = t, d;
}
function $t(t) {
  const r = pt(t), i = {};
  for (const s in r) {
    const c = r[s];
    c.effect ? i[s] = // ...
    ze({
      get: () => t[s],
      set(d) {
        t[s] = d;
      }
    }) : (At(c) || Er(c)) && (i[s] = // ---
    vf(t, s));
  }
  return i;
}
const Fi = ["q", "t"];
function ha(t) {
  return `${t.prefix}${t.lnClass}${t.lnInst}`;
}
var ot = /* @__PURE__ */ ((t) => (t.GOOSE = "GOOSE", t.SMV = "SMV", t.REPORT = "Report", t.INTERNAL = "Internal", t.WIRED = "Wired", t.CONTROL = "Control", t))(ot || {});
const Mo = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: [],
  Internal: []
}, Pa = /* @__PURE__ */ ol("dataflow/sidebar", () => {
  const t = Ue(null);
  function r(s) {
    t.value = s;
  }
  function i(s) {
    const c = s === t.value ? null : s;
    r(c);
  }
  return {
    activeElement: t,
    setActiveElement: r,
    setOrResetActiveElement: i
  };
});
var cp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fp(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ra = { exports: {} }, dp = ra.exports, Ql;
function pp() {
  return Ql || (Ql = 1, function(t, r) {
    (function(i, s) {
      t.exports = s();
    })(dp, function() {
      var i = function(e, n) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {
          o.__proto__ = a;
        } || function(o, a) {
          for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = a[l]);
        })(e, n);
      }, s = function() {
        return (s = Object.assign || function(e) {
          for (var n, o = 1, a = arguments.length; o < a; o++) for (var l in n = arguments[o]) Object.prototype.hasOwnProperty.call(n, l) && (e[l] = n[l]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, n, o) {
        for (var a, l = 0, f = n.length; l < f; l++) !a && l in n || ((a = a || Array.prototype.slice.call(n, 0, l))[l] = n[l]);
        return e.concat(a || Array.prototype.slice.call(n));
      }
      var d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : cp, u = Object.keys, p = Array.isArray;
      function m(e, n) {
        return typeof n != "object" || u(n).forEach(function(o) {
          e[o] = n[o];
        }), e;
      }
      typeof Promise > "u" || d.Promise || (d.Promise = Promise);
      var P = Object.getPrototypeOf, E = {}.hasOwnProperty;
      function L(e, n) {
        return E.call(e, n);
      }
      function j(e, n) {
        typeof n == "function" && (n = n(P(e))), (typeof Reflect > "u" ? u : Reflect.ownKeys)(n).forEach(function(o) {
          z(e, o, n[o]);
        });
      }
      var Y = Object.defineProperty;
      function z(e, n, o, a) {
        Y(e, n, m(o && L(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, a));
      }
      function H(e) {
        return { from: function(n) {
          return e.prototype = Object.create(n.prototype), z(e.prototype, "constructor", e), { extend: j.bind(null, e.prototype) };
        } };
      }
      var ie = Object.getOwnPropertyDescriptor, W = [].slice;
      function B(e, n, o) {
        return W.call(e, n, o);
      }
      function F(e, n) {
        return n(e);
      }
      function q(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function Te(e) {
        d.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function pe(e, n) {
        if (typeof n == "string" && L(e, n)) return e[n];
        if (!n) return e;
        if (typeof n != "string") {
          for (var o = [], a = 0, l = n.length; a < l; ++a) {
            var f = pe(e, n[a]);
            o.push(f);
          }
          return o;
        }
        var h = n.indexOf(".");
        if (h !== -1) {
          var v = e[n.substr(0, h)];
          return v == null ? void 0 : pe(v, n.substr(h + 1));
        }
      }
      function ve(e, n, o) {
        if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof n != "string" && "length" in n) {
          q(typeof o != "string" && "length" in o);
          for (var a = 0, l = n.length; a < l; ++a) ve(e, n[a], o[a]);
        } else {
          var f, h, v = n.indexOf(".");
          v !== -1 ? (f = n.substr(0, v), (h = n.substr(v + 1)) === "" ? o === void 0 ? p(e) && !isNaN(parseInt(f)) ? e.splice(f, 1) : delete e[f] : e[f] = o : ve(v = !(v = e[f]) || !L(e, f) ? e[f] = {} : v, h, o)) : o === void 0 ? p(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = o;
        }
      }
      function se(e) {
        var n, o = {};
        for (n in e) L(e, n) && (o[n] = e[n]);
        return o;
      }
      var S = [].concat;
      function we(e) {
        return S.apply([], e);
      }
      var Ge = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(we([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(n) {
          return n + e + "Array";
        });
      }))).filter(function(e) {
        return d[e];
      }), ue = new Set(Ge.map(function(e) {
        return d[e];
      })), ye = null;
      function be(e) {
        return ye = /* @__PURE__ */ new WeakMap(), e = function n(o) {
          if (!o || typeof o != "object") return o;
          var a = ye.get(o);
          if (a) return a;
          if (p(o)) {
            a = [], ye.set(o, a);
            for (var l = 0, f = o.length; l < f; ++l) a.push(n(o[l]));
          } else if (ue.has(o.constructor)) a = o;
          else {
            var h, v = P(o);
            for (h in a = v === Object.prototype ? {} : Object.create(v), ye.set(o, a), o) L(o, h) && (a[h] = n(o[h]));
          }
          return a;
        }(e), ye = null, e;
      }
      var ke = {}.toString;
      function Be(e) {
        return ke.call(e).slice(8, -1);
      }
      var He = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Oe = typeof He == "symbol" ? function(e) {
        var n;
        return e != null && (n = e[He]) && n.apply(e);
      } : function() {
        return null;
      };
      function Se(e, n) {
        return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n;
      }
      var Qe = {};
      function ht(e) {
        var n, o, a, l;
        if (arguments.length === 1) {
          if (p(e)) return e.slice();
          if (this === Qe && typeof e == "string") return [e];
          if (l = Oe(e)) {
            for (o = []; !(a = l.next()).done; ) o.push(a.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (n = e.length) != "number") return [e];
          for (o = new Array(n); n--; ) o[n] = e[n];
          return o;
        }
        for (n = arguments.length, o = new Array(n); n--; ) o[n] = arguments[n];
        return o;
      }
      var Je = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ke = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Et = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ke), It = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function qt(e, n) {
        this.name = e, this.message = n;
      }
      function Vn(e, n) {
        return e + ". Errors: " + Object.keys(n).map(function(o) {
          return n[o].toString();
        }).filter(function(o, a, l) {
          return l.indexOf(o) === a;
        }).join(`
`);
      }
      function gn(e, n, o, a) {
        this.failures = n, this.failedKeys = a, this.successCount = o, this.message = Vn(e, n);
      }
      function Lt(e, n) {
        this.name = "BulkError", this.failures = Object.keys(n).map(function(o) {
          return n[o];
        }), this.failuresByPos = n, this.message = Vn(e, this.failures);
      }
      H(qt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), H(gn).from(qt), H(Lt).from(qt);
      var D = Et.reduce(function(e, n) {
        return e[n] = n + "Error", e;
      }, {}), N = qt, U = Et.reduce(function(e, n) {
        var o = n + "Error";
        function a(l, f) {
          this.name = o, l ? typeof l == "string" ? (this.message = "".concat(l).concat(f ? `
 ` + f : ""), this.inner = f || null) : typeof l == "object" && (this.message = "".concat(l.name, " ").concat(l.message), this.inner = l) : (this.message = It[n] || o, this.inner = null);
        }
        return H(a).from(N), e[n] = a, e;
      }, {});
      U.Syntax = SyntaxError, U.Type = TypeError, U.Range = RangeError;
      var Q = Ke.reduce(function(e, n) {
        return e[n + "Error"] = U[n], e;
      }, {}), it = Et.reduce(function(e, n) {
        return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = U[n]), e;
      }, {});
      function O() {
      }
      function V(e) {
        return e;
      }
      function oe(e, n) {
        return e == null || e === V ? n : function(o) {
          return n(e(o));
        };
      }
      function fe(e, n) {
        return function() {
          e.apply(this, arguments), n.apply(this, arguments);
        };
      }
      function ge(e, n) {
        return e === O ? n : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var a = this.onsuccess, l = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var f = n.apply(this, arguments);
          return a && (this.onsuccess = this.onsuccess ? fe(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? fe(l, this.onerror) : l), f !== void 0 ? f : o;
        };
      }
      function he(e, n) {
        return e === O ? n : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, a = this.onerror;
          this.onsuccess = this.onerror = null, n.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? fe(o, this.onsuccess) : o), a && (this.onerror = this.onerror ? fe(a, this.onerror) : a);
        };
      }
      function Re(e, n) {
        return e === O ? n : function(o) {
          var a = e.apply(this, arguments);
          m(o, a);
          var l = this.onsuccess, f = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = n.apply(this, arguments), l && (this.onsuccess = this.onsuccess ? fe(l, this.onsuccess) : l), f && (this.onerror = this.onerror ? fe(f, this.onerror) : f), a === void 0 ? o === void 0 ? void 0 : o : m(a, o);
        };
      }
      function Ee(e, n) {
        return e === O ? n : function() {
          return n.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function _e(e, n) {
        return e === O ? n : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var a = this, l = arguments.length, f = new Array(l); l--; ) f[l] = arguments[l];
            return o.then(function() {
              return n.apply(a, f);
            });
          }
          return n.apply(this, arguments);
        };
      }
      it.ModifyError = gn, it.DexieError = qt, it.BulkError = Lt;
      var me = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function $e(e) {
        me = e;
      }
      var Ie = {}, Me = 100, Ge = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, P(e), e];
        var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [n, P(n), e];
      }(), Ke = Ge[0], Et = Ge[1], Ge = Ge[2], Et = Et && Et.then, rt = Ke && Ke.constructor, st = !!Ge, xt = function(e, n) {
        bn.push([e, n]), Ft && (queueMicrotask(ka), Ft = !1);
      }, St = !0, Ft = !0, Nt = [], an = [], Wn = V, mt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: O, pgp: !1, env: {}, finalize: O }, ce = mt, bn = [], sn = 0, Jn = [];
      function ne(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var n = this._PSD = ce;
        if (typeof e != "function") {
          if (e !== Ie) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qr(this, this._value));
        }
        this._state = null, this._value = null, ++n.ref, function o(a, l) {
          try {
            l(function(f) {
              if (a._state === null) {
                if (f === a) throw new TypeError("A promise cannot be resolved with itself.");
                var h = a._lib && wn();
                f && typeof f.then == "function" ? o(a, function(v, b) {
                  f instanceof ne ? f._then(v, b) : f.then(v, b);
                }) : (a._state = !0, a._value = f, Uo(a)), h && _n();
              }
            }, qr.bind(null, a));
          } catch (f) {
            qr(a, f);
          }
        }(this, e);
      }
      var Kr = { get: function() {
        var e = ce, n = nr;
        function o(a, l) {
          var f = this, h = !e.global && (e !== ce || n !== nr), v = h && !Gt(), b = new ne(function(_, R) {
            Ur(f, new qo(Wo(a, e, h, v), Wo(l, e, h, v), _, R, e));
          });
          return this._consoleTask && (b._consoleTask = this._consoleTask), b;
        }
        return o.prototype = Ie, o;
      }, set: function(e) {
        z(this, "then", e && e.prototype === Ie ? Kr : { get: function() {
          return e;
        }, set: Kr.set });
      } };
      function qo(e, n, o, a, l) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = o, this.reject = a, this.psd = l;
      }
      function qr(e, n) {
        var o, a;
        an.push(n), e._state === null && (o = e._lib && wn(), n = Wn(n), e._state = !1, e._value = n, a = e, Nt.some(function(l) {
          return l._value === a._value;
        }) || Nt.push(a), Uo(e), o && _n());
      }
      function Uo(e) {
        var n = e._listeners;
        e._listeners = [];
        for (var o = 0, a = n.length; o < a; ++o) Ur(e, n[o]);
        var l = e._PSD;
        --l.ref || l.finalize(), sn === 0 && (++sn, xt(function() {
          --sn == 0 && Vr();
        }, []));
      }
      function Ur(e, n) {
        if (e._state !== null) {
          var o = e._state ? n.onFulfilled : n.onRejected;
          if (o === null) return (e._state ? n.resolve : n.reject)(e._value);
          ++n.psd.ref, ++sn, xt(La, [o, e, n]);
        } else e._listeners.push(n);
      }
      function La(e, n, o) {
        try {
          var a, l = n._value;
          !n._state && an.length && (an = []), a = me && n._consoleTask ? n._consoleTask.run(function() {
            return e(l);
          }) : e(l), n._state || an.indexOf(l) !== -1 || function(f) {
            for (var h = Nt.length; h; ) if (Nt[--h]._value === f._value) return Nt.splice(h, 1);
          }(n), o.resolve(a);
        } catch (f) {
          o.reject(f);
        } finally {
          --sn == 0 && Vr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function ka() {
        ln(mt, function() {
          wn() && _n();
        });
      }
      function wn() {
        var e = St;
        return Ft = St = !1, e;
      }
      function _n() {
        var e, n, o;
        do
          for (; 0 < bn.length; ) for (e = bn, bn = [], o = e.length, n = 0; n < o; ++n) {
            var a = e[n];
            a[0].apply(null, a[1]);
          }
        while (0 < bn.length);
        Ft = St = !0;
      }
      function Vr() {
        var e = Nt;
        Nt = [], e.forEach(function(a) {
          a._PSD.onunhandled.call(null, a._value, a);
        });
        for (var n = Jn.slice(0), o = n.length; o; ) n[--o]();
      }
      function Zn(e) {
        return new ne(Ie, !1, e);
      }
      function Ye(e, n) {
        var o = ce;
        return function() {
          var a = wn(), l = ce;
          try {
            return Ht(o, !0), e.apply(this, arguments);
          } catch (f) {
            n && n(f);
          } finally {
            Ht(l, !1), a && _n();
          }
        };
      }
      j(ne.prototype, { then: Kr, _then: function(e, n) {
        Ur(this, new qo(null, null, e, n, ce));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var n = e, o = arguments[1];
        return typeof n == "function" ? this.then(null, function(a) {
          return (a instanceof n ? o : Zn)(a);
        }) : this.then(null, function(a) {
          return (a && a.name === n ? o : Zn)(a);
        });
      }, finally: function(e) {
        return this.then(function(n) {
          return ne.resolve(e()).then(function() {
            return n;
          });
        }, function(n) {
          return ne.resolve(e()).then(function() {
            return Zn(n);
          });
        });
      }, timeout: function(e, n) {
        var o = this;
        return e < 1 / 0 ? new ne(function(a, l) {
          var f = setTimeout(function() {
            return l(new U.Timeout(n));
          }, e);
          o.then(a, l).finally(clearTimeout.bind(null, f));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && z(ne.prototype, Symbol.toStringTag, "Dexie.Promise"), mt.env = Vo(), j(ne, { all: function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n, o) {
          e.length === 0 && n([]);
          var a = e.length;
          e.forEach(function(l, f) {
            return ne.resolve(l).then(function(h) {
              e[f] = h, --a || n(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof ne ? e : e && typeof e.then == "function" ? new ne(function(n, o) {
          e.then(n, o);
        }) : new ne(Ie, !0, e);
      }, reject: Zn, race: function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n, o) {
          e.map(function(a) {
            return ne.resolve(a).then(n, o);
          });
        });
      }, PSD: { get: function() {
        return ce;
      }, set: function(e) {
        return ce = e;
      } }, totalEchoes: { get: function() {
        return nr;
      } }, newPSD: Wt, usePSD: ln, scheduler: { get: function() {
        return xt;
      }, set: function(e) {
        xt = e;
      } }, rejectionMapper: { get: function() {
        return Wn;
      }, set: function(e) {
        Wn = e;
      } }, follow: function(e, n) {
        return new ne(function(o, a) {
          return Wt(function(l, f) {
            var h = ce;
            h.unhandleds = [], h.onunhandled = f, h.finalize = fe(function() {
              var v, b = this;
              v = function() {
                b.unhandleds.length === 0 ? l() : f(b.unhandleds[0]);
              }, Jn.push(function _() {
                v(), Jn.splice(Jn.indexOf(_), 1);
              }), ++sn, xt(function() {
                --sn == 0 && Vr();
              }, []);
            }, h.finalize), e();
          }, n, o, a);
        });
      } }), rt && (rt.allSettled && z(ne, "allSettled", function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n) {
          e.length === 0 && n([]);
          var o = e.length, a = new Array(o);
          e.forEach(function(l, f) {
            return ne.resolve(l).then(function(h) {
              return a[f] = { status: "fulfilled", value: h };
            }, function(h) {
              return a[f] = { status: "rejected", reason: h };
            }).then(function() {
              return --o || n(a);
            });
          });
        });
      }), rt.any && typeof AggregateError < "u" && z(ne, "any", function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n, o) {
          e.length === 0 && o(new AggregateError([]));
          var a = e.length, l = new Array(a);
          e.forEach(function(f, h) {
            return ne.resolve(f).then(function(v) {
              return n(v);
            }, function(v) {
              l[h] = v, --a || o(new AggregateError(l));
            });
          });
        });
      }), rt.withResolvers && (ne.withResolvers = rt.withResolvers));
      var lt = { awaits: 0, echoes: 0, id: 0 }, ja = 0, er = [], tr = 0, nr = 0, Fa = 0;
      function Wt(e, n, o, a) {
        var l = ce, f = Object.create(l);
        return f.parent = l, f.ref = 0, f.global = !1, f.id = ++Fa, mt.env, f.env = st ? { Promise: ne, PromiseProp: { value: ne, configurable: !0, writable: !0 }, all: ne.all, race: ne.race, allSettled: ne.allSettled, any: ne.any, resolve: ne.resolve, reject: ne.reject } : {}, n && m(f, n), ++l.ref, f.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, a = ln(f, e, o, a), f.ref === 0 && f.finalize(), a;
      }
      function xn() {
        return lt.id || (lt.id = ++ja), ++lt.awaits, lt.echoes += Me, lt.id;
      }
      function Gt() {
        return !!lt.awaits && (--lt.awaits == 0 && (lt.id = 0), lt.echoes = lt.awaits * Me, !0);
      }
      function rr(e) {
        return lt.echoes && e && e.constructor === rt ? (xn(), e.then(function(n) {
          return Gt(), n;
        }, function(n) {
          return Gt(), tt(n);
        })) : e;
      }
      function $a() {
        var e = er[er.length - 1];
        er.pop(), Ht(e, !1);
      }
      function Ht(e, n) {
        var o, a = ce;
        (n ? !lt.echoes || tr++ && e === ce : !tr || --tr && e === ce) || queueMicrotask(n ? (function(l) {
          ++nr, lt.echoes && --lt.echoes != 0 || (lt.echoes = lt.awaits = lt.id = 0), er.push(ce), Ht(l, !0);
        }).bind(null, e) : $a), e !== ce && (ce = e, a === mt && (mt.env = Vo()), st && (o = mt.env.Promise, n = e.env, (a.global || e.global) && (Object.defineProperty(d, "Promise", n.PromiseProp), o.all = n.all, o.race = n.race, o.resolve = n.resolve, o.reject = n.reject, n.allSettled && (o.allSettled = n.allSettled), n.any && (o.any = n.any))));
      }
      function Vo() {
        var e = d.Promise;
        return st ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(d, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function ln(e, n, o, a, l) {
        var f = ce;
        try {
          return Ht(e, !0), n(o, a, l);
        } finally {
          Ht(f, !1);
        }
      }
      function Wo(e, n, o, a) {
        return typeof e != "function" ? e : function() {
          var l = ce;
          o && xn(), Ht(n, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Ht(l, !1), a && queueMicrotask(Gt);
          }
        };
      }
      function Wr(e) {
        Promise === rt && lt.echoes === 0 ? tr === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + Et).indexOf("[native code]") === -1 && (xn = Gt = O);
      var tt = ne.reject, un = "￿", Mt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Go = "String expected.", Nn = [], or = "__dbnames", Gr = "readonly", Hr = "readwrite";
      function cn(e, n) {
        return e ? n ? function() {
          return e.apply(this, arguments) && n.apply(this, arguments);
        } : e : n;
      }
      var Ho = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function ir(e) {
        return typeof e != "string" || /\./.test(e) ? function(n) {
          return n;
        } : function(n) {
          return n[e] === void 0 && e in n && delete (n = be(n))[e], n;
        };
      }
      function Yo() {
        throw U.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function De(e, n) {
        try {
          var o = Xo(e), a = Xo(n);
          if (o !== a) return o === "Array" ? 1 : a === "Array" ? -1 : o === "binary" ? 1 : a === "binary" ? -1 : o === "string" ? 1 : a === "string" ? -1 : o === "Date" ? 1 : a !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return n < e ? 1 : e < n ? -1 : 0;
            case "binary":
              return function(l, f) {
                for (var h = l.length, v = f.length, b = h < v ? h : v, _ = 0; _ < b; ++_) if (l[_] !== f[_]) return l[_] < f[_] ? -1 : 1;
                return h === v ? 0 : h < v ? -1 : 1;
              }(Qo(e), Qo(n));
            case "Array":
              return function(l, f) {
                for (var h = l.length, v = f.length, b = h < v ? h : v, _ = 0; _ < b; ++_) {
                  var R = De(l[_], f[_]);
                  if (R !== 0) return R;
                }
                return h === v ? 0 : h < v ? -1 : 1;
              }(e, n);
          }
        } catch {
        }
        return NaN;
      }
      function Xo(e) {
        var n = typeof e;
        return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = Be(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function Qo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function ar(e, n, o) {
        var a = e.schema.yProps;
        return a ? (n && 0 < o.numFailures && (n = n.filter(function(l, f) {
          return !o.failures[f];
        })), Promise.all(a.map(function(l) {
          return l = l.updatesTable, n ? e.db.table(l).where("k").anyOf(n).delete() : e.db.table(l).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var zo = (Ve.prototype._trans = function(e, n, o) {
        var a = this._tx || ce.trans, l = this.name, f = me && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function h(_, R, g) {
          if (!g.schema[l]) throw new U.NotFound("Table " + l + " not part of transaction");
          return n(g.idbtrans, g);
        }
        var v = wn();
        try {
          var b = a && a.db._novip === this.db._novip ? a === ce.trans ? a._promise(e, h, o) : Wt(function() {
            return a._promise(e, h, o);
          }, { trans: a, transless: ce.transless || ce }) : function _(R, g, I, w) {
            if (R.idbdb && (R._state.openComplete || ce.letThrough || R._vip)) {
              var x = R._createTransaction(g, I, R._dbSchema);
              try {
                x.create(), R._state.PR1398_maxLoop = 3;
              } catch (T) {
                return T.name === D.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                  return _(R, g, I, w);
                })) : tt(T);
              }
              return x._promise(g, function(T, C) {
                return Wt(function() {
                  return ce.trans = x, w(T, C, x);
                });
              }).then(function(T) {
                if (g === "readwrite") try {
                  x.idbtrans.commit();
                } catch {
                }
                return g === "readonly" ? T : x._completion.then(function() {
                  return T;
                });
              });
            }
            if (R._state.openComplete) return tt(new U.DatabaseClosed(R._state.dbOpenError));
            if (!R._state.isBeingOpened) {
              if (!R._state.autoOpen) return tt(new U.DatabaseClosed());
              R.open().catch(O);
            }
            return R._state.dbReadyPromise.then(function() {
              return _(R, g, I, w);
            });
          }(this.db, e, [this.name], h);
          return f && (b._consoleTask = f, b = b.catch(function(_) {
            return console.trace(_), tt(_);
          })), b;
        } finally {
          v && _n();
        }
      }, Ve.prototype.get = function(e, n) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(n) : e == null ? tt(new U.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(a) {
          return o.core.get({ trans: a, key: e }).then(function(l) {
            return o.hook.reading.fire(l);
          });
        }).then(n);
      }, Ve.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (p(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var n = u(e);
        if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(v) {
          if (v.compound && n.every(function(_) {
            return 0 <= v.keyPath.indexOf(_);
          })) {
            for (var b = 0; b < n.length; ++b) if (n.indexOf(v.keyPath[b]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(v, b) {
          return v.keyPath.length - b.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== un) {
          var f = o.keyPath.slice(0, n.length);
          return this.where(f).equals(f.map(function(b) {
            return e[b];
          }));
        }
        !o && me && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
        var a = this.schema.idxByName;
        function l(v, b) {
          return De(v, b) === 0;
        }
        var h = n.reduce(function(g, b) {
          var _ = g[0], R = g[1], g = a[b], I = e[b];
          return [_ || g, _ || !g ? cn(R, g && g.multi ? function(w) {
            return w = pe(w, b), p(w) && w.some(function(x) {
              return l(I, x);
            });
          } : function(w) {
            return l(I, pe(w, b));
          }) : R];
        }, [null, null]), f = h[0], h = h[1];
        return f ? this.where(f.name).equals(e[f.keyPath]).filter(h) : o ? this.filter(h) : this.where(n).equals("");
      }, Ve.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Ve.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Ve.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Ve.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Ve.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Ve.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, p(e) ? "[".concat(e.join("+"), "]") : e));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(e) {
        var n, o = this.db, a = this.name;
        function l() {
          return n !== null && n.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Yo && (function(b, _) {
          if (typeof _ != "function" && _ !== null) throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
          function R() {
            this.constructor = b;
          }
          i(b, _), b.prototype = _ === null ? Object.create(_) : (R.prototype = _.prototype, new R());
        }(l, n = e), Object.defineProperty(l.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), l.prototype.table = function() {
          return a;
        }, e = l);
        for (var f = /* @__PURE__ */ new Set(), h = e.prototype; h; h = P(h)) Object.getOwnPropertyNames(h).forEach(function(b) {
          return f.add(b);
        });
        function v(b) {
          if (!b) return b;
          var _, R = Object.create(e.prototype);
          for (_ in b) if (!f.has(_)) try {
            R[_] = b[_];
          } catch {
          }
          return R;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = v, this.hook("reading", v), e;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          m(this, e);
        });
      }, Ve.prototype.add = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, f = a.keyPath, h = e;
        return f && l && (h = ir(f)(e)), this._trans("readwrite", function(v) {
          return o.core.mutate({ trans: v, type: "add", keys: n != null ? [n] : null, values: [h] });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (f) try {
            ve(e, f, v);
          } catch {
          }
          return v;
        });
      }, Ve.prototype.update = function(e, n) {
        return typeof e != "object" || p(e) ? this.where(":id").equals(e).modify(n) : (e = pe(e, this.schema.primKey.keyPath), e === void 0 ? tt(new U.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n));
      }, Ve.prototype.put = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, f = a.keyPath, h = e;
        return f && l && (h = ir(f)(e)), this._trans("readwrite", function(v) {
          return o.core.mutate({ trans: v, type: "put", values: [h], keys: n != null ? [n] : null });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (f) try {
            ve(e, f, v);
          } catch {
          }
          return v;
        });
      }, Ve.prototype.delete = function(e) {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(a) {
            return ar(n, [e], a);
          }).then(function(a) {
            return a.numFailures ? ne.reject(a.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(n) {
          return e.core.mutate({ trans: n, type: "deleteRange", range: Ho }).then(function(o) {
            return ar(e, null, o);
          });
        }).then(function(n) {
          return n.numFailures ? ne.reject(n.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(e) {
        var n = this;
        return this._trans("readonly", function(o) {
          return n.core.getMany({ keys: e, trans: o }).then(function(a) {
            return a.map(function(l) {
              return n.hook.reading.fire(l);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, f = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(h) {
          var _ = a.schema.primKey, v = _.auto, _ = _.keyPath;
          if (_ && l) throw new U.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new U.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && v ? e.map(ir(_)) : e;
          return a.core.mutate({ trans: h, type: "add", keys: l, values: _, wantResults: f }).then(function(x) {
            var g = x.numFailures, I = x.results, w = x.lastResult, x = x.failures;
            if (g === 0) return f ? I : w;
            throw new Lt("".concat(a.name, ".bulkAdd(): ").concat(g, " of ").concat(b, " operations failed"), x);
          });
        });
      }, Ve.prototype.bulkPut = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, f = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(h) {
          var _ = a.schema.primKey, v = _.auto, _ = _.keyPath;
          if (_ && l) throw new U.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new U.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && v ? e.map(ir(_)) : e;
          return a.core.mutate({ trans: h, type: "put", keys: l, values: _, wantResults: f }).then(function(x) {
            var g = x.numFailures, I = x.results, w = x.lastResult, x = x.failures;
            if (g === 0) return f ? I : w;
            throw new Lt("".concat(a.name, ".bulkPut(): ").concat(g, " of ").concat(b, " operations failed"), x);
          });
        });
      }, Ve.prototype.bulkUpdate = function(e) {
        var n = this, o = this.core, a = e.map(function(h) {
          return h.key;
        }), l = e.map(function(h) {
          return h.changes;
        }), f = [];
        return this._trans("readwrite", function(h) {
          return o.getMany({ trans: h, keys: a, cache: "clone" }).then(function(v) {
            var b = [], _ = [];
            e.forEach(function(g, I) {
              var w = g.key, x = g.changes, T = v[I];
              if (T) {
                for (var C = 0, A = Object.keys(x); C < A.length; C++) {
                  var k = A[C], $ = x[k];
                  if (k === n.schema.primKey.keyPath) {
                    if (De($, w) !== 0) throw new U.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ve(T, k, $);
                }
                f.push(I), b.push(w), _.push(T);
              }
            });
            var R = b.length;
            return o.mutate({ trans: h, type: "put", keys: b, values: _, updates: { keys: a, changeSpecs: l } }).then(function(g) {
              var I = g.numFailures, w = g.failures;
              if (I === 0) return R;
              for (var x = 0, T = Object.keys(w); x < T.length; x++) {
                var C, A = T[x], k = f[Number(A)];
                k != null && (C = w[A], delete w[A], w[k] = C);
              }
              throw new Lt("".concat(n.name, ".bulkUpdate(): ").concat(I, " of ").concat(R, " operations failed"), w);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(e) {
        var n = this, o = e.length;
        return this._trans("readwrite", function(a) {
          return n.core.mutate({ trans: a, type: "delete", keys: e }).then(function(l) {
            return ar(n, e, l);
          });
        }).then(function(h) {
          var l = h.numFailures, f = h.lastResult, h = h.failures;
          if (l === 0) return f;
          throw new Lt("".concat(n.name, ".bulkDelete(): ").concat(l, " of ").concat(o, " operations failed"), h);
        });
      }, Ve);
      function Ve() {
      }
      function Pn(e) {
        function n(h, v) {
          if (v) {
            for (var b = arguments.length, _ = new Array(b - 1); --b; ) _[b - 1] = arguments[b];
            return o[h].subscribe.apply(null, _), e;
          }
          if (typeof h == "string") return o[h];
        }
        var o = {};
        n.addEventType = f;
        for (var a = 1, l = arguments.length; a < l; ++a) f(arguments[a]);
        return n;
        function f(h, v, b) {
          if (typeof h != "object") {
            var _;
            v = v || Ee;
            var R = { subscribers: [], fire: b = b || O, subscribe: function(g) {
              R.subscribers.indexOf(g) === -1 && (R.subscribers.push(g), R.fire = v(R.fire, g));
            }, unsubscribe: function(g) {
              R.subscribers = R.subscribers.filter(function(I) {
                return I !== g;
              }), R.fire = R.subscribers.reduce(v, b);
            } };
            return o[h] = n[h] = R;
          }
          u(_ = h).forEach(function(g) {
            var I = _[g];
            if (p(I)) f(g, _[g][0], _[g][1]);
            else {
              if (I !== "asap") throw new U.InvalidArgument("Invalid event config");
              var w = f(g, V, function() {
                for (var x = arguments.length, T = new Array(x); x--; ) T[x] = arguments[x];
                w.subscribers.forEach(function(C) {
                  Te(function() {
                    C.apply(null, T);
                  });
                });
              });
            }
          });
        }
      }
      function Ln(e, n) {
        return H(n).from({ prototype: e }), n;
      }
      function Rn(e, n) {
        return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter);
      }
      function Yr(e, n) {
        e.filter = cn(e.filter, n);
      }
      function Xr(e, n, o) {
        var a = e.replayFilter;
        e.replayFilter = a ? function() {
          return cn(a(), n());
        } : n, e.justLimit = o && !a;
      }
      function sr(e, n) {
        if (e.isPrimKey) return n.primaryKey;
        var o = n.getIndexByKeyPath(e.index);
        if (!o) throw new U.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
        return o;
      }
      function Jo(e, n, o) {
        var a = sr(e, n.schema);
        return n.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: a, range: e.range } });
      }
      function lr(e, n, o, a) {
        var l = e.replayFilter ? cn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var f = {}, h = function(v, b, _) {
            var R, g;
            l && !l(b, _, function(I) {
              return b.stop(I);
            }, function(I) {
              return b.fail(I);
            }) || ((g = "" + (R = b.primaryKey)) == "[object ArrayBuffer]" && (g = "" + new Uint8Array(R)), L(f, g) || (f[g] = !0, n(v, b, _)));
          };
          return Promise.all([e.or._iterate(h, o), Zo(Jo(e, a, o), e.algorithm, h, !e.keysOnly && e.valueMapper)]);
        }
        return Zo(Jo(e, a, o), cn(e.algorithm, l), n, !e.keysOnly && e.valueMapper);
      }
      function Zo(e, n, o, a) {
        var l = Ye(a ? function(f, h, v) {
          return o(a(f), h, v);
        } : o);
        return e.then(function(f) {
          if (f) return f.start(function() {
            var h = function() {
              return f.continue();
            };
            n && !n(f, function(v) {
              return h = v;
            }, function(v) {
              f.stop(v), h = O;
            }, function(v) {
              f.fail(v), h = O;
            }) || l(f.value, f, function(v) {
              return h = v;
            }), h();
          });
        });
      }
      var kn = (ei.prototype.execute = function(e) {
        var n = this["@@propmod"];
        if (n.add !== void 0) {
          var o = n.add;
          if (p(o)) return c(c([], p(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (n.remove !== void 0) {
          var a = n.remove;
          if (p(a)) return p(e) ? e.filter(function(l) {
            return !a.includes(l);
          }).sort() : [];
          if (typeof a == "number") return Number(e) - a;
          if (typeof a == "bigint") try {
            return BigInt(e) - a;
          } catch {
            return BigInt(0) - a;
          }
          throw new TypeError("Invalid subtrahend ".concat(a));
        }
        return o = (o = n.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? n.replacePrefix[1] + e.substring(o.length) : e;
      }, ei);
      function ei(e) {
        this["@@propmod"] = e;
      }
      var Ma = (Fe.prototype._read = function(e, n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, tt.bind(null, o.error)) : o.table._trans("readonly", e).then(n);
      }, Fe.prototype._write = function(e) {
        var n = this._ctx;
        return n.error ? n.table._trans(null, tt.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
      }, Fe.prototype._addAlgorithm = function(e) {
        var n = this._ctx;
        n.algorithm = cn(n.algorithm, e);
      }, Fe.prototype._iterate = function(e, n) {
        return lr(this._ctx, e, n, this._ctx.table.core);
      }, Fe.prototype.clone = function(e) {
        var n = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && m(o, e), n._ctx = o, n;
      }, Fe.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Fe.prototype.each = function(e) {
        var n = this._ctx;
        return this._read(function(o) {
          return lr(n, e, o, n.table.core);
        });
      }, Fe.prototype.count = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx, l = a.table.core;
          if (Rn(a, !0)) return l.count({ trans: o, query: { index: sr(a, l.schema), range: a.range } }).then(function(h) {
            return Math.min(h, a.limit);
          });
          var f = 0;
          return lr(a, function() {
            return ++f, !1;
          }, o, l).then(function() {
            return f;
          });
        }).then(e);
      }, Fe.prototype.sortBy = function(e, n) {
        var o = e.split(".").reverse(), a = o[0], l = o.length - 1;
        function f(b, _) {
          return _ ? f(b[o[_]], _ - 1) : b[a];
        }
        var h = this._ctx.dir === "next" ? 1 : -1;
        function v(b, _) {
          return De(f(b, l), f(_, l)) * h;
        }
        return this.toArray(function(b) {
          return b.sort(v);
        }).then(n);
      }, Fe.prototype.toArray = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx;
          if (a.dir === "next" && Rn(a, !0) && 0 < a.limit) {
            var l = a.valueMapper, f = sr(a, a.table.core.schema);
            return a.table.core.query({ trans: o, limit: a.limit, values: !0, query: { index: f, range: a.range } }).then(function(v) {
              return v = v.result, l ? v.map(l) : v;
            });
          }
          var h = [];
          return lr(a, function(v) {
            return h.push(v);
          }, o, a.table.core).then(function() {
            return h;
          });
        }, e);
      }, Fe.prototype.offset = function(e) {
        var n = this._ctx;
        return e <= 0 || (n.offset += e, Rn(n) ? Xr(n, function() {
          var o = e;
          return function(a, l) {
            return o === 0 || (o === 1 ? --o : l(function() {
              a.advance(o), o = 0;
            }), !1);
          };
        }) : Xr(n, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Fe.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Xr(this._ctx, function() {
          var n = e;
          return function(o, a, l) {
            return --n <= 0 && a(l), 0 <= n;
          };
        }, !0), this;
      }, Fe.prototype.until = function(e, n) {
        return Yr(this._ctx, function(o, a, l) {
          return !e(o.value) || (a(l), n);
        }), this;
      }, Fe.prototype.first = function(e) {
        return this.limit(1).toArray(function(n) {
          return n[0];
        }).then(e);
      }, Fe.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Fe.prototype.filter = function(e) {
        var n;
        return Yr(this._ctx, function(o) {
          return e(o.value);
        }), (n = this._ctx).isMatch = cn(n.isMatch, e), this;
      }, Fe.prototype.and = function(e) {
        return this.filter(e);
      }, Fe.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Fe.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Fe.prototype.desc = function() {
        return this.reverse();
      }, Fe.prototype.eachKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.key, a);
        });
      }, Fe.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Fe.prototype.eachPrimaryKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.primaryKey, a);
        });
      }, Fe.prototype.keys = function(e) {
        var n = this._ctx;
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Fe.prototype.primaryKeys = function(e) {
        var n = this._ctx;
        if (n.dir === "next" && Rn(n, !0) && 0 < n.limit) return this._read(function(a) {
          var l = sr(n, n.table.core.schema);
          return n.table.core.query({ trans: a, values: !1, limit: n.limit, query: { index: l, range: n.range } });
        }).then(function(a) {
          return a.result;
        }).then(e);
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Fe.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Fe.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(n) {
          return n[0];
        }).then(e);
      }, Fe.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Fe.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var n = {};
        return Yr(this._ctx, function(l) {
          var a = l.primaryKey.toString(), l = L(n, a);
          return n[a] = !0, !l;
        }), this;
      }, Fe.prototype.modify = function(e) {
        var n = this, o = this._ctx;
        return this._write(function(a) {
          var l, f, h;
          h = typeof e == "function" ? e : (l = u(e), f = l.length, function(A) {
            for (var k = !1, $ = 0; $ < f; ++$) {
              var M = l[$], G = e[M], Z = pe(A, M);
              G instanceof kn ? (ve(A, M, G.execute(Z)), k = !0) : Z !== G && (ve(A, M, G), k = !0);
            }
            return k;
          });
          var v = o.table.core, g = v.schema.primaryKey, b = g.outbound, _ = g.extractKey, R = 200, g = n.db._options.modifyChunkSize;
          g && (R = typeof g == "object" ? g[v.name] || g["*"] || 200 : g);
          function I(A, M) {
            var $ = M.failures, M = M.numFailures;
            x += A - M;
            for (var G = 0, Z = u($); G < Z.length; G++) {
              var X = Z[G];
              w.push($[X]);
            }
          }
          var w = [], x = 0, T = [], C = e === ti;
          return n.clone().primaryKeys().then(function(A) {
            function k(M) {
              var G = Math.min(R, A.length - M), Z = A.slice(M, M + G);
              return (C ? Promise.resolve([]) : v.getMany({ trans: a, keys: Z, cache: "immutable" })).then(function(X) {
                var J = [], te = [], ee = b ? [] : null, re = C ? Z : [];
                if (!C) for (var Ce = 0; Ce < G; ++Ce) {
                  var Pe = X[Ce], Ne = { value: be(Pe), primKey: A[M + Ce] };
                  h.call(Ne, Ne.value, Ne) !== !1 && (Ne.value == null ? re.push(A[M + Ce]) : b || De(_(Pe), _(Ne.value)) === 0 ? (te.push(Ne.value), b && ee.push(A[M + Ce])) : (re.push(A[M + Ce]), J.push(Ne.value)));
                }
                return Promise.resolve(0 < J.length && v.mutate({ trans: a, type: "add", values: J }).then(function(Ze) {
                  for (var xe in Ze.failures) re.splice(parseInt(xe), 1);
                  I(J.length, Ze);
                })).then(function() {
                  return (0 < te.length || $ && typeof e == "object") && v.mutate({ trans: a, type: "put", keys: ee, values: te, criteria: $, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < M }).then(function(Ze) {
                    return I(te.length, Ze);
                  });
                }).then(function() {
                  return (0 < re.length || $ && C) && v.mutate({ trans: a, type: "delete", keys: re, criteria: $, isAdditionalChunk: 0 < M }).then(function(Ze) {
                    return ar(o.table, re, Ze);
                  }).then(function(Ze) {
                    return I(re.length, Ze);
                  });
                }).then(function() {
                  return A.length > M + G && k(M + R);
                });
              });
            }
            var $ = Rn(o) && o.limit === 1 / 0 && (typeof e != "function" || C) && { index: o.index, range: o.range };
            return k(0).then(function() {
              if (0 < w.length) throw new gn("Error modifying one or more objects", w, x, T);
              return A.length;
            });
          });
        });
      }, Fe.prototype.delete = function() {
        var e = this._ctx, n = e.range;
        return !Rn(e) || e.table.schema.yProps || !e.isPrimKey && n.type !== 3 ? this.modify(ti) : this._write(function(o) {
          var a = e.table.core.schema.primaryKey, l = n;
          return e.table.core.count({ trans: o, query: { index: a, range: l } }).then(function(f) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: l }).then(function(b) {
              var v = b.failures, b = b.numFailures;
              if (b) throw new gn("Could not delete some values", Object.keys(v).map(function(_) {
                return v[_];
              }), f - b);
              return f - b;
            });
          });
        });
      }, Fe);
      function Fe() {
      }
      var ti = function(e, n) {
        return n.value = null;
      };
      function Ba(e, n) {
        return e < n ? -1 : e === n ? 0 : 1;
      }
      function Ka(e, n) {
        return n < e ? -1 : e === n ? 0 : 1;
      }
      function _t(e, n, o) {
        return e = e instanceof ri ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(n), e;
      }
      function Cn(e) {
        return new e.Collection(e, function() {
          return ni("");
        }).limit(0);
      }
      function ur(e, n, o, a) {
        var l, f, h, v, b, _, R, g = o.length;
        if (!o.every(function(x) {
          return typeof x == "string";
        })) return _t(e, Go);
        function I(x) {
          l = x === "next" ? function(C) {
            return C.toUpperCase();
          } : function(C) {
            return C.toLowerCase();
          }, f = x === "next" ? function(C) {
            return C.toLowerCase();
          } : function(C) {
            return C.toUpperCase();
          }, h = x === "next" ? Ba : Ka;
          var T = o.map(function(C) {
            return { lower: f(C), upper: l(C) };
          }).sort(function(C, A) {
            return h(C.lower, A.lower);
          });
          v = T.map(function(C) {
            return C.upper;
          }), b = T.map(function(C) {
            return C.lower;
          }), R = (_ = x) === "next" ? "" : a;
        }
        I("next"), e = new e.Collection(e, function() {
          return Yt(v[0], b[g - 1] + a);
        }), e._ondirectionchange = function(x) {
          I(x);
        };
        var w = 0;
        return e._addAlgorithm(function(x, T, C) {
          var A = x.key;
          if (typeof A != "string") return !1;
          var k = f(A);
          if (n(k, b, w)) return !0;
          for (var $ = null, M = w; M < g; ++M) {
            var G = function(Z, X, J, te, ee, re) {
              for (var Ce = Math.min(Z.length, te.length), Pe = -1, Ne = 0; Ne < Ce; ++Ne) {
                var Ze = X[Ne];
                if (Ze !== te[Ne]) return ee(Z[Ne], J[Ne]) < 0 ? Z.substr(0, Ne) + J[Ne] + J.substr(Ne + 1) : ee(Z[Ne], te[Ne]) < 0 ? Z.substr(0, Ne) + te[Ne] + J.substr(Ne + 1) : 0 <= Pe ? Z.substr(0, Pe) + X[Pe] + J.substr(Pe + 1) : null;
                ee(Z[Ne], Ze) < 0 && (Pe = Ne);
              }
              return Ce < te.length && re === "next" ? Z + J.substr(Z.length) : Ce < Z.length && re === "prev" ? Z.substr(0, J.length) : Pe < 0 ? null : Z.substr(0, Pe) + te[Pe] + J.substr(Pe + 1);
            }(A, k, v[M], b[M], h, _);
            G === null && $ === null ? w = M + 1 : ($ === null || 0 < h($, G)) && ($ = G);
          }
          return T($ !== null ? function() {
            x.continue($ + R);
          } : C), !1;
        }), e;
      }
      function Yt(e, n, o, a) {
        return { type: 2, lower: e, upper: n, lowerOpen: o, upperOpen: a };
      }
      function ni(e) {
        return { type: 1, lower: e, upper: e };
      }
      var ri = (Object.defineProperty(ut.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), ut.prototype.between = function(e, n, o, a) {
        o = o !== !1, a = a === !0;
        try {
          return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (o || a) && (!o || !a) ? Cn(this) : new this.Collection(this, function() {
            return Yt(e, n, !o, !a);
          });
        } catch {
          return _t(this, Mt);
        }
      }, ut.prototype.equals = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return ni(e);
        });
      }, ut.prototype.above = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(e, void 0, !0);
        });
      }, ut.prototype.aboveOrEqual = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(e, void 0, !1);
        });
      }, ut.prototype.below = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(void 0, e, !1, !0);
        });
      }, ut.prototype.belowOrEqual = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(void 0, e);
        });
      }, ut.prototype.startsWith = function(e) {
        return typeof e != "string" ? _t(this, Go) : this.between(e, e + un, !0, !0);
      }, ut.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : ur(this, function(n, o) {
          return n.indexOf(o[0]) === 0;
        }, [e], un);
      }, ut.prototype.equalsIgnoreCase = function(e) {
        return ur(this, function(n, o) {
          return n === o[0];
        }, [e], "");
      }, ut.prototype.anyOfIgnoreCase = function() {
        var e = ht.apply(Qe, arguments);
        return e.length === 0 ? Cn(this) : ur(this, function(n, o) {
          return o.indexOf(n) !== -1;
        }, e, "");
      }, ut.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ht.apply(Qe, arguments);
        return e.length === 0 ? Cn(this) : ur(this, function(n, o) {
          return o.some(function(a) {
            return n.indexOf(a) === 0;
          });
        }, e, un);
      }, ut.prototype.anyOf = function() {
        var e = this, n = ht.apply(Qe, arguments), o = this._cmp;
        try {
          n.sort(o);
        } catch {
          return _t(this, Mt);
        }
        if (n.length === 0) return Cn(this);
        var a = new this.Collection(this, function() {
          return Yt(n[0], n[n.length - 1]);
        });
        a._ondirectionchange = function(f) {
          o = f === "next" ? e._ascending : e._descending, n.sort(o);
        };
        var l = 0;
        return a._addAlgorithm(function(f, h, v) {
          for (var b = f.key; 0 < o(b, n[l]); ) if (++l === n.length) return h(v), !1;
          return o(b, n[l]) === 0 || (h(function() {
            f.continue(n[l]);
          }), !1);
        }), a;
      }, ut.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, ut.prototype.noneOf = function() {
        var e = ht.apply(Qe, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return _t(this, Mt);
        }
        var n = e.reduce(function(o, a) {
          return o ? o.concat([[o[o.length - 1][1], a]]) : [[-1 / 0, a]];
        }, null);
        return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
      }, ut.prototype.inAnyRange = function(A, n) {
        var o = this, a = this._cmp, l = this._ascending, f = this._descending, h = this._min, v = this._max;
        if (A.length === 0) return Cn(this);
        if (!A.every(function(k) {
          return k[0] !== void 0 && k[1] !== void 0 && l(k[0], k[1]) <= 0;
        })) return _t(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", U.InvalidArgument);
        var b = !n || n.includeLowers !== !1, _ = n && n.includeUppers === !0, R, g = l;
        function I(k, $) {
          return g(k[0], $[0]);
        }
        try {
          (R = A.reduce(function(k, $) {
            for (var M = 0, G = k.length; M < G; ++M) {
              var Z = k[M];
              if (a($[0], Z[1]) < 0 && 0 < a($[1], Z[0])) {
                Z[0] = h(Z[0], $[0]), Z[1] = v(Z[1], $[1]);
                break;
              }
            }
            return M === G && k.push($), k;
          }, [])).sort(I);
        } catch {
          return _t(this, Mt);
        }
        var w = 0, x = _ ? function(k) {
          return 0 < l(k, R[w][1]);
        } : function(k) {
          return 0 <= l(k, R[w][1]);
        }, T = b ? function(k) {
          return 0 < f(k, R[w][0]);
        } : function(k) {
          return 0 <= f(k, R[w][0]);
        }, C = x, A = new this.Collection(this, function() {
          return Yt(R[0][0], R[R.length - 1][1], !b, !_);
        });
        return A._ondirectionchange = function(k) {
          g = k === "next" ? (C = x, l) : (C = T, f), R.sort(I);
        }, A._addAlgorithm(function(k, $, M) {
          for (var G, Z = k.key; C(Z); ) if (++w === R.length) return $(M), !1;
          return !x(G = Z) && !T(G) || (o._cmp(Z, R[w][1]) === 0 || o._cmp(Z, R[w][0]) === 0 || $(function() {
            g === l ? k.continue(R[w][0]) : k.continue(R[w][1]);
          }), !1);
        }), A;
      }, ut.prototype.startsWithAnyOf = function() {
        var e = ht.apply(Qe, arguments);
        return e.every(function(n) {
          return typeof n == "string";
        }) ? e.length === 0 ? Cn(this) : this.inAnyRange(e.map(function(n) {
          return [n, n + un];
        })) : _t(this, "startsWithAnyOf() only works with strings");
      }, ut);
      function ut() {
      }
      function kt(e) {
        return Ye(function(n) {
          return jn(n), e(n.target.error), !1;
        });
      }
      function jn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Fn = "storagemutated", Qr = "x-storagemutated-1", Xt = Pn(null, Fn), qa = (jt.prototype._lock = function() {
        return q(!ce.global), ++this._reculock, this._reculock !== 1 || ce.global || (ce.lockOwnerFor = this), this;
      }, jt.prototype._unlock = function() {
        if (q(!ce.global), --this._reculock == 0) for (ce.global || (ce.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            ln(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, jt.prototype._locked = function() {
        return this._reculock && ce.lockOwnerFor !== this;
      }, jt.prototype.create = function(e) {
        var n = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, a = this.db._state.dbOpenError;
        if (q(!this.idbtrans), !e && !o) switch (a && a.name) {
          case "DatabaseClosedError":
            throw new U.DatabaseClosed(a);
          case "MissingAPIError":
            throw new U.MissingAPI(a.message, a);
          default:
            throw new U.OpenFailed(a);
        }
        if (!this.active) throw new U.TransactionInactive();
        return q(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ye(function(l) {
          jn(l), n._reject(e.error);
        }), e.onabort = Ye(function(l) {
          jn(l), n.active && n._reject(new U.Abort(e.error)), n.active = !1, n.on("abort").fire(l);
        }), e.oncomplete = Ye(function() {
          n.active = !1, n._resolve(), "mutatedParts" in e && Xt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, jt.prototype._promise = function(e, n, o) {
        var a = this;
        if (e === "readwrite" && this.mode !== "readwrite") return tt(new U.ReadOnly("Transaction is readonly"));
        if (!this.active) return tt(new U.TransactionInactive());
        if (this._locked()) return new ne(function(f, h) {
          a._blockedFuncs.push([function() {
            a._promise(e, n, o).then(f, h);
          }, ce]);
        });
        if (o) return Wt(function() {
          var f = new ne(function(h, v) {
            a._lock();
            var b = n(h, v, a);
            b && b.then && b.then(h, v);
          });
          return f.finally(function() {
            return a._unlock();
          }), f._lib = !0, f;
        });
        var l = new ne(function(f, h) {
          var v = n(f, h, a);
          v && v.then && v.then(f, h);
        });
        return l._lib = !0, l;
      }, jt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, jt.prototype.waitFor = function(e) {
        var n, o = this._root(), a = ne.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return a;
        }) : (o._waitingFor = a, o._waitingQueue = [], n = o.idbtrans.objectStore(o.storeNames[0]), function f() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (n.get(-1 / 0).onsuccess = f);
        }());
        var l = o._waitingFor;
        return new ne(function(f, h) {
          a.then(function(v) {
            return o._waitingQueue.push(Ye(f.bind(null, v)));
          }, function(v) {
            return o._waitingQueue.push(Ye(h.bind(null, v)));
          }).finally(function() {
            o._waitingFor === l && (o._waitingFor = null);
          });
        });
      }, jt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new U.Abort()));
      }, jt.prototype.table = function(e) {
        var n = this._memoizedTables || (this._memoizedTables = {});
        if (L(n, e)) return n[e];
        var o = this.schema[e];
        if (!o) throw new U.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), n[e] = o;
      }, jt);
      function jt() {
      }
      function zr(e, n, o, a, l, f, h, v) {
        return { name: e, keyPath: n, unique: o, multi: a, auto: l, compound: f, src: (o && !h ? "&" : "") + (a ? "*" : "") + (l ? "++" : "") + oi(n), type: v };
      }
      function oi(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Jr(e, n, o) {
        return { name: e, primKey: n, indexes: o, mappedClass: null, idxByName: (a = function(l) {
          return [l.name, l];
        }, o.reduce(function(l, f, h) {
          return h = a(f, h), h && (l[h[0]] = h[1]), l;
        }, {})) };
        var a;
      }
      var $n = function(e) {
        try {
          return e.only([[]]), $n = function() {
            return [[]];
          }, [[]];
        } catch {
          return $n = function() {
            return un;
          }, un;
        }
      };
      function Zr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (n = e).split(".").length === 1 ? function(o) {
          return o[n];
        } : function(o) {
          return pe(o, n);
        } : function(o) {
          return pe(o, e);
        };
        var n;
      }
      function ii(e) {
        return [].slice.call(e);
      }
      var Ua = 0;
      function Mn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Va(e, n, b) {
        function a(C) {
          if (C.type === 3) return null;
          if (C.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var w = C.lower, x = C.upper, T = C.lowerOpen, C = C.upperOpen;
          return w === void 0 ? x === void 0 ? null : n.upperBound(x, !!C) : x === void 0 ? n.lowerBound(w, !!T) : n.bound(w, x, !!T, !!C);
        }
        function l(I) {
          var w, x = I.name;
          return { name: x, schema: I, mutate: function(T) {
            var C = T.trans, A = T.type, k = T.keys, $ = T.values, M = T.range;
            return new Promise(function(G, Z) {
              G = Ye(G);
              var X = C.objectStore(x), J = X.keyPath == null, te = A === "put" || A === "add";
              if (!te && A !== "delete" && A !== "deleteRange") throw new Error("Invalid operation type: " + A);
              var ee, re = (k || $ || { length: 1 }).length;
              if (k && $ && k.length !== $.length) throw new Error("Given keys array must have same length as given values array.");
              if (re === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Ce(vt) {
                ++Ze, jn(vt);
              }
              var Pe = [], Ne = [], Ze = 0;
              if (A === "deleteRange") {
                if (M.type === 4) return G({ numFailures: Ze, failures: Ne, results: [], lastResult: void 0 });
                M.type === 3 ? Pe.push(ee = X.clear()) : Pe.push(ee = X.delete(a(M)));
              } else {
                var J = te ? J ? [$, k] : [$, null] : [k, null], xe = J[0], ft = J[1];
                if (te) for (var dt = 0; dt < re; ++dt) Pe.push(ee = ft && ft[dt] !== void 0 ? X[A](xe[dt], ft[dt]) : X[A](xe[dt])), ee.onerror = Ce;
                else for (dt = 0; dt < re; ++dt) Pe.push(ee = X[A](xe[dt])), ee.onerror = Ce;
              }
              function _r(vt) {
                vt = vt.target.result, Pe.forEach(function(pn, go) {
                  return pn.error != null && (Ne[go] = pn.error);
                }), G({ numFailures: Ze, failures: Ne, results: A === "delete" ? k : Pe.map(function(pn) {
                  return pn.result;
                }), lastResult: vt });
              }
              ee.onerror = function(vt) {
                Ce(vt), _r(vt);
              }, ee.onsuccess = _r;
            });
          }, getMany: function(T) {
            var C = T.trans, A = T.keys;
            return new Promise(function(k, $) {
              k = Ye(k);
              for (var M, G = C.objectStore(x), Z = A.length, X = new Array(Z), J = 0, te = 0, ee = function(Pe) {
                Pe = Pe.target, X[Pe._pos] = Pe.result, ++te === J && k(X);
              }, re = kt($), Ce = 0; Ce < Z; ++Ce) A[Ce] != null && ((M = G.get(A[Ce]))._pos = Ce, M.onsuccess = ee, M.onerror = re, ++J);
              J === 0 && k(X);
            });
          }, get: function(T) {
            var C = T.trans, A = T.key;
            return new Promise(function(k, $) {
              k = Ye(k);
              var M = C.objectStore(x).get(A);
              M.onsuccess = function(G) {
                return k(G.target.result);
              }, M.onerror = kt($);
            });
          }, query: (w = _, function(T) {
            return new Promise(function(C, A) {
              C = Ye(C);
              var k, $, M, J = T.trans, G = T.values, Z = T.limit, ee = T.query, X = Z === 1 / 0 ? void 0 : Z, te = ee.index, ee = ee.range, J = J.objectStore(x), te = te.isPrimaryKey ? J : J.index(te.name), ee = a(ee);
              if (Z === 0) return C({ result: [] });
              w ? ((X = G ? te.getAll(ee, X) : te.getAllKeys(ee, X)).onsuccess = function(re) {
                return C({ result: re.target.result });
              }, X.onerror = kt(A)) : (k = 0, $ = !G && "openKeyCursor" in te ? te.openKeyCursor(ee) : te.openCursor(ee), M = [], $.onsuccess = function(re) {
                var Ce = $.result;
                return Ce ? (M.push(G ? Ce.value : Ce.primaryKey), ++k === Z ? C({ result: M }) : void Ce.continue()) : C({ result: M });
              }, $.onerror = kt(A));
            });
          }), openCursor: function(T) {
            var C = T.trans, A = T.values, k = T.query, $ = T.reverse, M = T.unique;
            return new Promise(function(G, Z) {
              G = Ye(G);
              var te = k.index, X = k.range, J = C.objectStore(x), J = te.isPrimaryKey ? J : J.index(te.name), te = $ ? M ? "prevunique" : "prev" : M ? "nextunique" : "next", ee = !A && "openKeyCursor" in J ? J.openKeyCursor(a(X), te) : J.openCursor(a(X), te);
              ee.onerror = kt(Z), ee.onsuccess = Ye(function(re) {
                var Ce, Pe, Ne, Ze, xe = ee.result;
                xe ? (xe.___id = ++Ua, xe.done = !1, Ce = xe.continue.bind(xe), Pe = (Pe = xe.continuePrimaryKey) && Pe.bind(xe), Ne = xe.advance.bind(xe), Ze = function() {
                  throw new Error("Cursor not stopped");
                }, xe.trans = C, xe.stop = xe.continue = xe.continuePrimaryKey = xe.advance = function() {
                  throw new Error("Cursor not started");
                }, xe.fail = Ye(Z), xe.next = function() {
                  var ft = this, dt = 1;
                  return this.start(function() {
                    return dt-- ? ft.continue() : ft.stop();
                  }).then(function() {
                    return ft;
                  });
                }, xe.start = function(ft) {
                  function dt() {
                    if (ee.result) try {
                      ft();
                    } catch (vt) {
                      xe.fail(vt);
                    }
                    else xe.done = !0, xe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, xe.stop();
                  }
                  var _r = new Promise(function(vt, pn) {
                    vt = Ye(vt), ee.onerror = kt(pn), xe.fail = pn, xe.stop = function(go) {
                      xe.stop = xe.continue = xe.continuePrimaryKey = xe.advance = Ze, vt(go);
                    };
                  });
                  return ee.onsuccess = Ye(function(vt) {
                    ee.onsuccess = dt, dt();
                  }), xe.continue = Ce, xe.continuePrimaryKey = Pe, xe.advance = Ne, dt(), _r;
                }, G(xe)) : G(null);
              }, Z);
            });
          }, count: function(T) {
            var C = T.query, A = T.trans, k = C.index, $ = C.range;
            return new Promise(function(M, G) {
              var Z = A.objectStore(x), X = k.isPrimaryKey ? Z : Z.index(k.name), Z = a($), X = Z ? X.count(Z) : X.count();
              X.onsuccess = Ye(function(J) {
                return M(J.target.result);
              }), X.onerror = kt(G);
            });
          } };
        }
        var f, h, v, R = (h = b, v = ii((f = e).objectStoreNames), { schema: { name: f.name, tables: v.map(function(I) {
          return h.objectStore(I);
        }).map(function(I) {
          var w = I.keyPath, C = I.autoIncrement, x = p(w), T = {}, C = { name: I.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: w == null, compound: x, keyPath: w, autoIncrement: C, unique: !0, extractKey: Zr(w) }, indexes: ii(I.indexNames).map(function(A) {
            return I.index(A);
          }).map(function(M) {
            var k = M.name, $ = M.unique, G = M.multiEntry, M = M.keyPath, G = { name: k, compound: p(M), keyPath: M, unique: $, multiEntry: G, extractKey: Zr(M) };
            return T[Mn(M)] = G;
          }), getIndexByKeyPath: function(A) {
            return T[Mn(A)];
          } };
          return T[":id"] = C.primaryKey, w != null && (T[Mn(w)] = C.primaryKey), C;
        }) }, hasGetAll: 0 < v.length && "getAll" in h.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), b = R.schema, _ = R.hasGetAll, R = b.tables.map(l), g = {};
        return R.forEach(function(I) {
          return g[I.name] = I;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(I) {
          if (!g[I]) throw new Error("Table '".concat(I, "' not found"));
          return g[I];
        }, MIN_KEY: -1 / 0, MAX_KEY: $n(n), schema: b };
      }
      function Wa(e, n, o, a) {
        var l = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (a = Va(n, l, a), e.dbcore.reduce(function(f, h) {
          return h = h.create, s(s({}, f), h(f));
        }, a)) };
      }
      function cr(e, a) {
        var o = a.db, a = Wa(e._middlewares, o, e._deps, a);
        e.core = a.dbcore, e.tables.forEach(function(l) {
          var f = l.name;
          e.core.schema.tables.some(function(h) {
            return h.name === f;
          }) && (l.core = e.core.table(f), e[f] instanceof e.Table && (e[f].core = l.core));
        });
      }
      function fr(e, n, o, a) {
        o.forEach(function(l) {
          var f = a[l];
          n.forEach(function(h) {
            var v = function b(_, R) {
              return ie(_, R) || (_ = P(_)) && b(_, R);
            }(h, l);
            (!v || "value" in v && v.value === void 0) && (h === e.Transaction.prototype || h instanceof e.Transaction ? z(h, l, { get: function() {
              return this.table(l);
            }, set: function(b) {
              Y(this, l, { value: b, writable: !0, configurable: !0, enumerable: !0 });
            } }) : h[l] = new e.Table(l, f));
          });
        });
      }
      function eo(e, n) {
        n.forEach(function(o) {
          for (var a in o) o[a] instanceof e.Table && delete o[a];
        });
      }
      function Ga(e, n) {
        return e._cfg.version - n._cfg.version;
      }
      function Ha(e, n, o, a) {
        var l = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !l.$meta && (l.$meta = Jr("$meta", si("")[0], []), e._storeNames.push("$meta"));
        var f = e._createTransaction("readwrite", e._storeNames, l);
        f.create(o), f._completion.catch(a);
        var h = f._reject.bind(f), v = ce.transless || ce;
        Wt(function() {
          return ce.trans = f, ce.transless = v, n !== 0 ? (cr(e, o), _ = n, ((b = f).storeNames.includes("$meta") ? b.table("$meta").get("version").then(function(R) {
            return R ?? _;
          }) : ne.resolve(_)).then(function(R) {
            return I = R, w = f, x = o, T = [], R = (g = e)._versions, C = g._dbSchema = pr(0, g.idbdb, x), (R = R.filter(function(A) {
              return A._cfg.version >= I;
            })).length !== 0 ? (R.forEach(function(A) {
              T.push(function() {
                var k = C, $ = A._cfg.dbschema;
                hr(g, k, x), hr(g, $, x), C = g._dbSchema = $;
                var M = to(k, $);
                M.add.forEach(function(te) {
                  no(x, te[0], te[1].primKey, te[1].indexes);
                }), M.change.forEach(function(te) {
                  if (te.recreate) throw new U.Upgrade("Not yet support for changing primary key");
                  var ee = x.objectStore(te.name);
                  te.add.forEach(function(re) {
                    return dr(ee, re);
                  }), te.change.forEach(function(re) {
                    ee.deleteIndex(re.name), dr(ee, re);
                  }), te.del.forEach(function(re) {
                    return ee.deleteIndex(re);
                  });
                });
                var G = A._cfg.contentUpgrade;
                if (G && A._cfg.version > I) {
                  cr(g, x), w._memoizedTables = {};
                  var Z = se($);
                  M.del.forEach(function(te) {
                    Z[te] = k[te];
                  }), eo(g, [g.Transaction.prototype]), fr(g, [g.Transaction.prototype], u(Z), Z), w.schema = Z;
                  var X, J = Je(G);
                  return J && xn(), M = ne.follow(function() {
                    var te;
                    (X = G(w)) && J && (te = Gt.bind(null, null), X.then(te, te));
                  }), X && typeof X.then == "function" ? ne.resolve(X) : M.then(function() {
                    return X;
                  });
                }
              }), T.push(function(k) {
                var $, M, G = A._cfg.dbschema;
                $ = G, M = k, [].slice.call(M.db.objectStoreNames).forEach(function(Z) {
                  return $[Z] == null && M.db.deleteObjectStore(Z);
                }), eo(g, [g.Transaction.prototype]), fr(g, [g.Transaction.prototype], g._storeNames, g._dbSchema), w.schema = g._dbSchema;
              }), T.push(function(k) {
                g.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(g.idbdb.version / 10) === A._cfg.version ? (g.idbdb.deleteObjectStore("$meta"), delete g._dbSchema.$meta, g._storeNames = g._storeNames.filter(function($) {
                  return $ !== "$meta";
                })) : k.objectStore("$meta").put(A._cfg.version, "version"));
              });
            }), function A() {
              return T.length ? ne.resolve(T.shift()(w.idbtrans)).then(A) : ne.resolve();
            }().then(function() {
              ai(C, x);
            })) : ne.resolve();
            var g, I, w, x, T, C;
          }).catch(h)) : (u(l).forEach(function(R) {
            no(o, R, l[R].primKey, l[R].indexes);
          }), cr(e, o), void ne.follow(function() {
            return e.on.populate.fire(f);
          }).catch(h));
          var b, _;
        });
      }
      function Ya(e, n) {
        ai(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
        var o = pr(0, e.idbdb, n);
        hr(e, e._dbSchema, n);
        for (var a = 0, l = to(o, e._dbSchema).change; a < l.length; a++) {
          var f = function(h) {
            if (h.change.length || h.recreate) return console.warn("Unable to patch indexes of table ".concat(h.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var v = n.objectStore(h.name);
            h.add.forEach(function(b) {
              me && console.debug("Dexie upgrade patch: Creating missing index ".concat(h.name, ".").concat(b.src)), dr(v, b);
            });
          }(l[a]);
          if (typeof f == "object") return f.value;
        }
      }
      function to(e, n) {
        var o, a = { del: [], add: [], change: [] };
        for (o in e) n[o] || a.del.push(o);
        for (o in n) {
          var l = e[o], f = n[o];
          if (l) {
            var h = { name: o, def: f, recreate: !1, del: [], add: [], change: [] };
            if ("" + (l.primKey.keyPath || "") != "" + (f.primKey.keyPath || "") || l.primKey.auto !== f.primKey.auto) h.recreate = !0, a.change.push(h);
            else {
              var v = l.idxByName, b = f.idxByName, _ = void 0;
              for (_ in v) b[_] || h.del.push(_);
              for (_ in b) {
                var R = v[_], g = b[_];
                R ? R.src !== g.src && h.change.push(g) : h.add.push(g);
              }
              (0 < h.del.length || 0 < h.add.length || 0 < h.change.length) && a.change.push(h);
            }
          } else a.add.push([o, f]);
        }
        return a;
      }
      function no(e, n, o, a) {
        var l = e.db.createObjectStore(n, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return a.forEach(function(f) {
          return dr(l, f);
        }), l;
      }
      function ai(e, n) {
        u(e).forEach(function(o) {
          n.db.objectStoreNames.contains(o) || (me && console.debug("Dexie: Creating missing table", o), no(n, o, e[o].primKey, e[o].indexes));
        });
      }
      function dr(e, n) {
        e.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi });
      }
      function pr(e, n, o) {
        var a = {};
        return B(n.objectStoreNames, 0).forEach(function(l) {
          for (var f = o.objectStore(l), h = zr(oi(_ = f.keyPath), _ || "", !0, !1, !!f.autoIncrement, _ && typeof _ != "string", !0), v = [], b = 0; b < f.indexNames.length; ++b) {
            var R = f.index(f.indexNames[b]), _ = R.keyPath, R = zr(R.name, _, !!R.unique, !!R.multiEntry, !1, _ && typeof _ != "string", !1);
            v.push(R);
          }
          a[l] = Jr(l, h, v);
        }), a;
      }
      function hr(e, n, o) {
        for (var a = o.db.objectStoreNames, l = 0; l < a.length; ++l) {
          var f = a[l], h = o.objectStore(f);
          e._hasGetAll = "getAll" in h;
          for (var v = 0; v < h.indexNames.length; ++v) {
            var b = h.indexNames[v], _ = h.index(b).keyPath, R = typeof _ == "string" ? _ : "[" + B(_).join("+") + "]";
            !n[f] || (_ = n[f].idxByName[R]) && (_.name = b, delete n[f].idxByName[R], n[f].idxByName[b] = _);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && d.WorkerGlobalScope && d instanceof d.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function si(e) {
        return e.split(",").map(function(n, o) {
          var f = n.split(":"), a = (l = f[1]) === null || l === void 0 ? void 0 : l.trim(), l = (n = f[0].trim()).replace(/([&*]|\+\+)/g, ""), f = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return zr(l, f || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), p(f), o === 0, a);
        });
      }
      var Xa = (Tn.prototype._createTableSchema = Jr, Tn.prototype._parseIndexSyntax = si, Tn.prototype._parseStoresSpec = function(e, n) {
        var o = this;
        u(e).forEach(function(a) {
          if (e[a] !== null) {
            var l = o._parseIndexSyntax(e[a]), f = l.shift();
            if (!f) throw new U.Schema("Invalid schema for table " + a + ": " + e[a]);
            if (f.unique = !0, f.multi) throw new U.Schema("Primary key cannot be multiEntry*");
            l.forEach(function(h) {
              if (h.auto) throw new U.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!h.keyPath) throw new U.Schema("Index must have a name and cannot be an empty string");
            }), l = o._createTableSchema(a, f, l), n[a] = l;
          }
        });
      }, Tn.prototype.stores = function(o) {
        var n = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? m(this._cfg.storesSource, o) : o;
        var o = n._versions, a = {}, l = {};
        return o.forEach(function(f) {
          m(a, f._cfg.storesSource), l = f._cfg.dbschema = {}, f._parseStoresSpec(a, l);
        }), n._dbSchema = l, eo(n, [n._allTables, n, n.Transaction.prototype]), fr(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], u(l), l), n._storeNames = u(l), this;
      }, Tn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = _e(this._cfg.contentUpgrade || O, e), this;
      }, Tn);
      function Tn() {
      }
      function ro(e, n) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Bt(or, { addons: [], indexedDB: e, IDBKeyRange: n })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function oo(e) {
        return e && typeof e.databases == "function";
      }
      function io(e) {
        return Wt(function() {
          return ce.letThrough = !0, e();
        });
      }
      function ao(e) {
        return !("from" in e);
      }
      var ct = function(e, n) {
        if (!this) {
          var o = new ct();
          return e && "d" in e && m(o, e), o;
        }
        m(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? n : e } : { d: 0 });
      };
      function Bn(e, n, o) {
        var a = De(n, o);
        if (!isNaN(a)) {
          if (0 < a) throw RangeError();
          if (ao(e)) return m(e, { from: n, to: o, d: 1 });
          var l = e.l, a = e.r;
          if (De(o, e.from) < 0) return l ? Bn(l, n, o) : e.l = { from: n, to: o, d: 1, l: null, r: null }, ui(e);
          if (0 < De(n, e.to)) return a ? Bn(a, n, o) : e.r = { from: n, to: o, d: 1, l: null, r: null }, ui(e);
          De(n, e.from) < 0 && (e.from = n, e.l = null, e.d = a ? a.d + 1 : 1), 0 < De(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, l && !e.l && Kn(e, l), a && o && Kn(e, a);
        }
      }
      function Kn(e, n) {
        ao(n) || function o(a, b) {
          var f = b.from, h = b.to, v = b.l, b = b.r;
          Bn(a, f, h), v && o(a, v), b && o(a, b);
        }(e, n);
      }
      function li(e, n) {
        var o = mr(n), a = o.next();
        if (a.done) return !1;
        for (var l = a.value, f = mr(e), h = f.next(l.from), v = h.value; !a.done && !h.done; ) {
          if (De(v.from, l.to) <= 0 && 0 <= De(v.to, l.from)) return !0;
          De(l.from, v.from) < 0 ? l = (a = o.next(v.from)).value : v = (h = f.next(l.from)).value;
        }
        return !1;
      }
      function mr(e) {
        var n = ao(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var a = 0 < arguments.length; n; ) switch (n.s) {
            case 0:
              if (n.s = 1, a) for (; n.n.l && De(o, n.n.from) < 0; ) n = { up: n, n: n.n.l, s: 1 };
              else for (; n.n.l; ) n = { up: n, n: n.n.l, s: 1 };
            case 1:
              if (n.s = 2, !a || De(o, n.n.to) <= 0) return { value: n.n, done: !1 };
            case 2:
              if (n.n.r) {
                n.s = 3, n = { up: n, n: n.n.r, s: 0 };
                continue;
              }
            case 3:
              n = n.up;
          }
          return { done: !0 };
        } };
      }
      function ui(e) {
        var n, o, a = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), l = 1 < a ? "r" : a < -1 ? "l" : "";
        l && (n = l == "r" ? "l" : "r", o = s({}, e), a = e[l], e.from = a.from, e.to = a.to, e[l] = a[l], o[l] = a[n], (e[n] = o).d = ci(o)), e.d = ci(e);
      }
      function ci(o) {
        var n = o.r, o = o.l;
        return (n ? o ? Math.max(n.d, o.d) : n.d : o ? o.d : 0) + 1;
      }
      function vr(e, n) {
        return u(n).forEach(function(o) {
          e[o] ? Kn(e[o], n[o]) : e[o] = function a(l) {
            var f, h, v = {};
            for (f in l) L(l, f) && (h = l[f], v[f] = !h || typeof h != "object" || ue.has(h.constructor) ? h : a(h));
            return v;
          }(n[o]);
        }), e;
      }
      function so(e, n) {
        return e.all || n.all || Object.keys(e).some(function(o) {
          return n[o] && li(n[o], e[o]);
        });
      }
      j(ct.prototype, ((Et = { add: function(e) {
        return Kn(this, e), this;
      }, addKey: function(e) {
        return Bn(this, e, e), this;
      }, addKeys: function(e) {
        var n = this;
        return e.forEach(function(o) {
          return Bn(n, o, o);
        }), this;
      }, hasKey: function(e) {
        var n = mr(this).next(e).value;
        return n && De(n.from, e) <= 0 && 0 <= De(n.to, e);
      } })[He] = function() {
        return mr(this);
      }, Et));
      var fn = {}, lo = {}, uo = !1;
      function yr(e) {
        vr(lo, e), uo || (uo = !0, setTimeout(function() {
          uo = !1, co(lo, !(lo = {}));
        }, 0));
      }
      function co(e, n) {
        n === void 0 && (n = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var a = 0, l = Object.values(fn); a < l.length; a++) fi(h = l[a], e, o, n);
        else for (var f in e) {
          var h, v = /^idb\:\/\/(.*)\/(.*)\//.exec(f);
          v && (f = v[1], v = v[2], (h = fn["idb://".concat(f, "/").concat(v)]) && fi(h, e, o, n));
        }
        o.forEach(function(b) {
          return b();
        });
      }
      function fi(e, n, o, a) {
        for (var l = [], f = 0, h = Object.entries(e.queries.query); f < h.length; f++) {
          for (var v = h[f], b = v[0], _ = [], R = 0, g = v[1]; R < g.length; R++) {
            var I = g[R];
            so(n, I.obsSet) ? I.subscribers.forEach(function(C) {
              return o.add(C);
            }) : a && _.push(I);
          }
          a && l.push([b, _]);
        }
        if (a) for (var w = 0, x = l; w < x.length; w++) {
          var T = x[w], b = T[0], _ = T[1];
          e.queries.query[b] = _;
        }
      }
      function Qa(e) {
        var n = e._state, o = e._deps.indexedDB;
        if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
          return n.dbOpenError ? tt(n.dbOpenError) : e;
        });
        n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
        var a = n.openCanceller, l = Math.round(10 * e.verno), f = !1;
        function h() {
          if (n.openCanceller !== a) throw new U.DatabaseClosed("db.open() was cancelled");
        }
        function v() {
          return new ne(function(I, w) {
            if (h(), !o) throw new U.MissingAPI();
            var x = e.name, T = n.autoSchema || !l ? o.open(x) : o.open(x, l);
            if (!T) throw new U.MissingAPI();
            T.onerror = kt(w), T.onblocked = Ye(e._fireOnBlocked), T.onupgradeneeded = Ye(function(C) {
              var A;
              R = T.transaction, n.autoSchema && !e._options.allowEmptyDB ? (T.onerror = jn, R.abort(), T.result.close(), (A = o.deleteDatabase(x)).onsuccess = A.onerror = Ye(function() {
                w(new U.NoSuchDatabase("Database ".concat(x, " doesnt exist")));
              })) : (R.onerror = kt(w), C = C.oldVersion > Math.pow(2, 62) ? 0 : C.oldVersion, g = C < 1, e.idbdb = T.result, f && Ya(e, R), Ha(e, C / 10, R, w));
            }, w), T.onsuccess = Ye(function() {
              R = null;
              var C, A, k, $, M, G = e.idbdb = T.result, Z = B(G.objectStoreNames);
              if (0 < Z.length) try {
                var X = G.transaction(($ = Z).length === 1 ? $[0] : $, "readonly");
                if (n.autoSchema) A = G, k = X, (C = e).verno = A.version / 10, k = C._dbSchema = pr(0, A, k), C._storeNames = B(A.objectStoreNames, 0), fr(C, [C._allTables], u(k), k);
                else if (hr(e, e._dbSchema, X), ((M = to(pr(0, (M = e).idbdb, X), M._dbSchema)).add.length || M.change.some(function(J) {
                  return J.add.length || J.change.length;
                })) && !f) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), l = G.version + 1, f = !0, I(v());
                cr(e, X);
              } catch {
              }
              Nn.push(e), G.onversionchange = Ye(function(J) {
                n.vcFired = !0, e.on("versionchange").fire(J);
              }), G.onclose = Ye(function(J) {
                e.on("close").fire(J);
              }), g && (M = e._deps, X = x, G = M.indexedDB, M = M.IDBKeyRange, oo(G) || X === or || ro(G, M).put({ name: X }).catch(O)), I();
            }, w);
          }).catch(function(I) {
            switch (I?.name) {
              case "UnknownError":
                if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), v();
                break;
              case "VersionError":
                if (0 < l) return l = 0, v();
            }
            return ne.reject(I);
          });
        }
        var b, _ = n.dbReadyResolve, R = null, g = !1;
        return ne.race([a, (typeof navigator > "u" ? ne.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(I) {
          function w() {
            return indexedDB.databases().finally(I);
          }
          b = setInterval(w, 100), w();
        }).finally(function() {
          return clearInterval(b);
        }) : Promise.resolve()).then(v)]).then(function() {
          return h(), n.onReadyBeingFired = [], ne.resolve(io(function() {
            return e.on.ready.fire(e.vip);
          })).then(function I() {
            if (0 < n.onReadyBeingFired.length) {
              var w = n.onReadyBeingFired.reduce(_e, O);
              return n.onReadyBeingFired = [], ne.resolve(io(function() {
                return w(e.vip);
              })).then(I);
            }
          });
        }).finally(function() {
          n.openCanceller === a && (n.onReadyBeingFired = null, n.isBeingOpened = !1);
        }).catch(function(I) {
          n.dbOpenError = I;
          try {
            R && R.abort();
          } catch {
          }
          return a === n.openCanceller && e._close(), tt(I);
        }).finally(function() {
          n.openComplete = !0, _();
        }).then(function() {
          var I;
          return g && (I = {}, e.tables.forEach(function(w) {
            w.schema.indexes.forEach(function(x) {
              x.name && (I["idb://".concat(e.name, "/").concat(w.name, "/").concat(x.name)] = new ct(-1 / 0, [[[]]]));
            }), I["idb://".concat(e.name, "/").concat(w.name, "/")] = I["idb://".concat(e.name, "/").concat(w.name, "/:dels")] = new ct(-1 / 0, [[[]]]);
          }), Xt(Fn).fire(I), co(I, !0)), e;
        });
      }
      function fo(e) {
        function n(f) {
          return e.next(f);
        }
        var o = l(n), a = l(function(f) {
          return e.throw(f);
        });
        function l(f) {
          return function(b) {
            var v = f(b), b = v.value;
            return v.done ? b : b && typeof b.then == "function" ? b.then(o, a) : p(b) ? Promise.all(b).then(o, a) : o(b);
          };
        }
        return l(n)();
      }
      function gr(e, n, o) {
        for (var a = p(e) ? e.slice() : [e], l = 0; l < o; ++l) a.push(n);
        return a;
      }
      var za = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema, l = {}, f = [];
          function h(g, I, w) {
            var x = Mn(g), T = l[x] = l[x] || [], C = g == null ? 0 : typeof g == "string" ? 1 : g.length, A = 0 < I, A = s(s({}, w), { name: A ? "".concat(x, "(virtual-from:").concat(w.name, ")") : w.name, lowLevelIndex: w, isVirtual: A, keyTail: I, keyLength: C, extractKey: Zr(g), unique: !A && w.unique });
            return T.push(A), A.isPrimaryKey || f.push(A), 1 < C && h(C === 2 ? g[0] : g.slice(0, C - 1), I + 1, w), T.sort(function(k, $) {
              return k.keyTail - $.keyTail;
            }), A;
          }
          n = h(a.primaryKey.keyPath, 0, a.primaryKey), l[":id"] = [n];
          for (var v = 0, b = a.indexes; v < b.length; v++) {
            var _ = b[v];
            h(_.keyPath, 0, _);
          }
          function R(g) {
            var I, w = g.query.index;
            return w.isVirtual ? s(s({}, g), { query: { index: w.lowLevelIndex, range: (I = g.query.range, w = w.keyTail, { type: I.type === 1 ? 2 : I.type, lower: gr(I.lower, I.lowerOpen ? e.MAX_KEY : e.MIN_KEY, w), lowerOpen: !0, upper: gr(I.upper, I.upperOpen ? e.MIN_KEY : e.MAX_KEY, w), upperOpen: !0 }) } }) : g;
          }
          return s(s({}, o), { schema: s(s({}, a), { primaryKey: n, indexes: f, getIndexByKeyPath: function(g) {
            return (g = l[Mn(g)]) && g[0];
          } }), count: function(g) {
            return o.count(R(g));
          }, query: function(g) {
            return o.query(R(g));
          }, openCursor: function(g) {
            var I = g.query.index, w = I.keyTail, x = I.isVirtual, T = I.keyLength;
            return x ? o.openCursor(R(g)).then(function(A) {
              return A && C(A);
            }) : o.openCursor(g);
            function C(A) {
              return Object.create(A, { continue: { value: function(k) {
                k != null ? A.continue(gr(k, g.reverse ? e.MAX_KEY : e.MIN_KEY, w)) : g.unique ? A.continue(A.key.slice(0, T).concat(g.reverse ? e.MIN_KEY : e.MAX_KEY, w)) : A.continue();
              } }, continuePrimaryKey: { value: function(k, $) {
                A.continuePrimaryKey(gr(k, e.MAX_KEY, w), $);
              } }, primaryKey: { get: function() {
                return A.primaryKey;
              } }, key: { get: function() {
                var k = A.key;
                return T === 1 ? k[0] : k.slice(0, T);
              } }, value: { get: function() {
                return A.value;
              } } });
            }
          } });
        } });
      } };
      function po(e, n, o, a) {
        return o = o || {}, a = a || "", u(e).forEach(function(l) {
          var f, h, v;
          L(n, l) ? (f = e[l], h = n[l], typeof f == "object" && typeof h == "object" && f && h ? (v = Be(f)) !== Be(h) ? o[a + l] = n[l] : v === "Object" ? po(f, h, o, a + l + ".") : f !== h && (o[a + l] = n[l]) : f !== h && (o[a + l] = n[l])) : o[a + l] = void 0;
        }), u(n).forEach(function(l) {
          L(e, l) || (o[a + l] = n[l]);
        }), o;
      }
      function ho(e, n) {
        return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey);
      }
      var Ja = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema.primaryKey;
          return s(s({}, o), { mutate: function(l) {
            var f = ce.trans, h = f.table(n).hook, v = h.deleting, b = h.creating, _ = h.updating;
            switch (l.type) {
              case "add":
                if (b.fire === O) break;
                return f._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "put":
                if (b.fire === O && _.fire === O) break;
                return f._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "delete":
                if (v.fire === O) break;
                return f._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "deleteRange":
                if (v.fire === O) break;
                return f._promise("readwrite", function() {
                  return function g(I, w, x) {
                    return o.query({ trans: I, values: !1, query: { index: a, range: w }, limit: x }).then(function(T) {
                      var C = T.result;
                      return R({ type: "delete", keys: C, trans: I }).then(function(A) {
                        return 0 < A.numFailures ? Promise.reject(A.failures[0]) : C.length < x ? { failures: [], numFailures: 0, lastResult: void 0 } : g(I, s(s({}, w), { lower: C[C.length - 1], lowerOpen: !0 }), x);
                      });
                    });
                  }(l.trans, l.range, 1e4);
                }, !0);
            }
            return o.mutate(l);
            function R(g) {
              var I, w, x, T = ce.trans, C = g.keys || ho(a, g);
              if (!C) throw new Error("Keys missing");
              return (g = g.type === "add" || g.type === "put" ? s(s({}, g), { keys: C }) : s({}, g)).type !== "delete" && (g.values = c([], g.values)), g.keys && (g.keys = c([], g.keys)), I = o, x = C, ((w = g).type === "add" ? Promise.resolve([]) : I.getMany({ trans: w.trans, keys: x, cache: "immutable" })).then(function(A) {
                var k = C.map(function($, M) {
                  var G, Z, X, J = A[M], te = { onerror: null, onsuccess: null };
                  return g.type === "delete" ? v.fire.call(te, $, J, T) : g.type === "add" || J === void 0 ? (G = b.fire.call(te, $, g.values[M], T), $ == null && G != null && (g.keys[M] = $ = G, a.outbound || ve(g.values[M], a.keyPath, $))) : (G = po(J, g.values[M]), (Z = _.fire.call(te, G, $, J, T)) && (X = g.values[M], Object.keys(Z).forEach(function(ee) {
                    L(X, ee) ? X[ee] = Z[ee] : ve(X, ee, Z[ee]);
                  }))), te;
                });
                return o.mutate(g).then(function($) {
                  for (var M = $.failures, G = $.results, Z = $.numFailures, $ = $.lastResult, X = 0; X < C.length; ++X) {
                    var J = (G || C)[X], te = k[X];
                    J == null ? te.onerror && te.onerror(M[X]) : te.onsuccess && te.onsuccess(g.type === "put" && A[X] ? g.values[X] : J);
                  }
                  return { failures: M, results: G, numFailures: Z, lastResult: $ };
                }).catch(function($) {
                  return k.forEach(function(M) {
                    return M.onerror && M.onerror($);
                  }), Promise.reject($);
                });
              });
            }
          } });
        } });
      } };
      function di(e, n, o) {
        try {
          if (!n || n.keys.length < e.length) return null;
          for (var a = [], l = 0, f = 0; l < n.keys.length && f < e.length; ++l) De(n.keys[l], e[f]) === 0 && (a.push(o ? be(n.values[l]) : n.values[l]), ++f);
          return a.length === e.length ? a : null;
        } catch {
          return null;
        }
      }
      var Za = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(n) {
          var o = e.table(n);
          return s(s({}, o), { getMany: function(a) {
            if (!a.cache) return o.getMany(a);
            var l = di(a.keys, a.trans._cache, a.cache === "clone");
            return l ? ne.resolve(l) : o.getMany(a).then(function(f) {
              return a.trans._cache = { keys: a.keys, values: a.cache === "clone" ? be(f) : f }, f;
            });
          }, mutate: function(a) {
            return a.type !== "add" && (a.trans._cache = null), o.mutate(a);
          } });
        } };
      } };
      function pi(e, n) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound;
      }
      function hi(e, n) {
        switch (e) {
          case "query":
            return n.values && !n.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var es = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var n = e.schema.name, o = new ct(e.MIN_KEY, e.MAX_KEY);
        return s(s({}, e), { transaction: function(a, l, f) {
          if (ce.subscr && l !== "readonly") throw new U.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ce.querier));
          return e.transaction(a, l, f);
        }, table: function(a) {
          var l = e.table(a), f = l.schema, h = f.primaryKey, g = f.indexes, v = h.extractKey, b = h.outbound, _ = h.autoIncrement && g.filter(function(w) {
            return w.compound && w.keyPath.includes(h.keyPath);
          }), R = s(s({}, l), { mutate: function(w) {
            function x(ee) {
              return ee = "idb://".concat(n, "/").concat(a, "/").concat(ee), $[ee] || ($[ee] = new ct());
            }
            var T, C, A, k = w.trans, $ = w.mutatedParts || (w.mutatedParts = {}), M = x(""), G = x(":dels"), Z = w.type, te = w.type === "deleteRange" ? [w.range] : w.type === "delete" ? [w.keys] : w.values.length < 50 ? [ho(h, w).filter(function(ee) {
              return ee;
            }), w.values] : [], X = te[0], J = te[1], te = w.trans._cache;
            return p(X) ? (M.addKeys(X), (te = Z === "delete" || X.length === J.length ? di(X, te) : null) || G.addKeys(X), (te || J) && (T = x, C = te, A = J, f.indexes.forEach(function(ee) {
              var re = T(ee.name || "");
              function Ce(Ne) {
                return Ne != null ? ee.extractKey(Ne) : null;
              }
              function Pe(Ne) {
                return ee.multiEntry && p(Ne) ? Ne.forEach(function(Ze) {
                  return re.addKey(Ze);
                }) : re.addKey(Ne);
              }
              (C || A).forEach(function(Ne, ft) {
                var xe = C && Ce(C[ft]), ft = A && Ce(A[ft]);
                De(xe, ft) !== 0 && (xe != null && Pe(xe), ft != null && Pe(ft));
              });
            }))) : X ? (J = { from: (J = X.lower) !== null && J !== void 0 ? J : e.MIN_KEY, to: (J = X.upper) !== null && J !== void 0 ? J : e.MAX_KEY }, G.add(J), M.add(J)) : (M.add(o), G.add(o), f.indexes.forEach(function(ee) {
              return x(ee.name).add(o);
            })), l.mutate(w).then(function(ee) {
              return !X || w.type !== "add" && w.type !== "put" || (M.addKeys(ee.results), _ && _.forEach(function(re) {
                for (var Ce = w.values.map(function(xe) {
                  return re.extractKey(xe);
                }), Pe = re.keyPath.findIndex(function(xe) {
                  return xe === h.keyPath;
                }), Ne = 0, Ze = ee.results.length; Ne < Ze; ++Ne) Ce[Ne][Pe] = ee.results[Ne];
                x(re.name).addKeys(Ce);
              })), k.mutatedParts = vr(k.mutatedParts || {}, $), ee;
            });
          } }), g = function(x) {
            var T = x.query, x = T.index, T = T.range;
            return [x, new ct((x = T.lower) !== null && x !== void 0 ? x : e.MIN_KEY, (T = T.upper) !== null && T !== void 0 ? T : e.MAX_KEY)];
          }, I = { get: function(w) {
            return [h, new ct(w.key)];
          }, getMany: function(w) {
            return [h, new ct().addKeys(w.keys)];
          }, count: g, query: g, openCursor: g };
          return u(I).forEach(function(w) {
            R[w] = function(x) {
              var T = ce.subscr, C = !!T, A = pi(ce, l) && hi(w, x) ? x.obsSet = {} : T;
              if (C) {
                var k = function(J) {
                  return J = "idb://".concat(n, "/").concat(a, "/").concat(J), A[J] || (A[J] = new ct());
                }, $ = k(""), M = k(":dels"), T = I[w](x), C = T[0], T = T[1];
                if ((w === "query" && C.isPrimaryKey && !x.values ? M : k(C.name || "")).add(T), !C.isPrimaryKey) {
                  if (w !== "count") {
                    var G = w === "query" && b && x.values && l.query(s(s({}, x), { values: !1 }));
                    return l[w].apply(this, arguments).then(function(J) {
                      if (w === "query") {
                        if (b && x.values) return G.then(function(Ce) {
                          return Ce = Ce.result, $.addKeys(Ce), J;
                        });
                        var te = x.values ? J.result.map(v) : J.result;
                        (x.values ? $ : M).addKeys(te);
                      } else if (w === "openCursor") {
                        var ee = J, re = x.values;
                        return ee && Object.create(ee, { key: { get: function() {
                          return M.addKey(ee.primaryKey), ee.key;
                        } }, primaryKey: { get: function() {
                          var Ce = ee.primaryKey;
                          return M.addKey(Ce), Ce;
                        } }, value: { get: function() {
                          return re && $.addKey(ee.primaryKey), ee.value;
                        } } });
                      }
                      return J;
                    });
                  }
                  M.add(o);
                }
              }
              return l[w].apply(this, arguments);
            };
          }), R;
        } });
      } };
      function mi(e, n, o) {
        if (o.numFailures === 0) return n;
        if (n.type === "deleteRange") return null;
        var a = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
        return o.numFailures === a ? null : (n = s({}, n), p(n.keys) && (n.keys = n.keys.filter(function(l, f) {
          return !(f in o.failures);
        })), "values" in n && p(n.values) && (n.values = n.values.filter(function(l, f) {
          return !(f in o.failures);
        })), n);
      }
      function mo(e, n) {
        return o = e, ((a = n).lower === void 0 || (a.lowerOpen ? 0 < De(o, a.lower) : 0 <= De(o, a.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? De(e, n.upper) < 0 : De(e, n.upper) <= 0));
        var o, a;
      }
      function vi(e, n, I, a, l, f) {
        if (!I || I.length === 0) return e;
        var h = n.query.index, v = h.multiEntry, b = n.query.range, _ = a.schema.primaryKey.extractKey, R = h.extractKey, g = (h.lowLevelIndex || h).extractKey, I = I.reduce(function(w, x) {
          var T = w, C = [];
          if (x.type === "add" || x.type === "put") for (var A = new ct(), k = x.values.length - 1; 0 <= k; --k) {
            var $, M = x.values[k], G = _(M);
            A.hasKey(G) || ($ = R(M), (v && p($) ? $.some(function(ee) {
              return mo(ee, b);
            }) : mo($, b)) && (A.addKey(G), C.push(M)));
          }
          switch (x.type) {
            case "add":
              var Z = new ct().addKeys(n.values ? w.map(function(re) {
                return _(re);
              }) : w), T = w.concat(n.values ? C.filter(function(re) {
                return re = _(re), !Z.hasKey(re) && (Z.addKey(re), !0);
              }) : C.map(function(re) {
                return _(re);
              }).filter(function(re) {
                return !Z.hasKey(re) && (Z.addKey(re), !0);
              }));
              break;
            case "put":
              var X = new ct().addKeys(x.values.map(function(re) {
                return _(re);
              }));
              T = w.filter(function(re) {
                return !X.hasKey(n.values ? _(re) : re);
              }).concat(n.values ? C : C.map(function(re) {
                return _(re);
              }));
              break;
            case "delete":
              var J = new ct().addKeys(x.keys);
              T = w.filter(function(re) {
                return !J.hasKey(n.values ? _(re) : re);
              });
              break;
            case "deleteRange":
              var te = x.range;
              T = w.filter(function(re) {
                return !mo(_(re), te);
              });
          }
          return T;
        }, e);
        return I === e ? e : (I.sort(function(w, x) {
          return De(g(w), g(x)) || De(_(w), _(x));
        }), n.limit && n.limit < 1 / 0 && (I.length > n.limit ? I.length = n.limit : e.length === n.limit && I.length < n.limit && (l.dirty = !0)), f ? Object.freeze(I) : I);
      }
      function yi(e, n) {
        return De(e.lower, n.lower) === 0 && De(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen;
      }
      function ts(e, n) {
        return function(o, a, l, f) {
          if (o === void 0) return a !== void 0 ? -1 : 0;
          if (a === void 0) return 1;
          if ((a = De(o, a)) === 0) {
            if (l && f) return 0;
            if (l) return 1;
            if (f) return -1;
          }
          return a;
        }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(o, a, l, f) {
          if (o === void 0) return a !== void 0 ? 1 : 0;
          if (a === void 0) return -1;
          if ((a = De(o, a)) === 0) {
            if (l && f) return 0;
            if (l) return -1;
            if (f) return 1;
          }
          return a;
        }(e.upper, n.upper, e.upperOpen, n.upperOpen);
      }
      function ns(e, n, o, a) {
        e.subscribers.add(o), a.addEventListener("abort", function() {
          var l, f;
          e.subscribers.delete(o), e.subscribers.size === 0 && (l = e, f = n, setTimeout(function() {
            l.subscribers.size === 0 && Se(f, l);
          }, 3e3));
        });
      }
      var rs = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var n = e.schema.name;
        return s(s({}, e), { transaction: function(o, a, l) {
          var f, h, v = e.transaction(o, a, l);
          return a === "readwrite" && (h = (f = new AbortController()).signal, l = function(b) {
            return function() {
              if (f.abort(), a === "readwrite") {
                for (var _ = /* @__PURE__ */ new Set(), R = 0, g = o; R < g.length; R++) {
                  var I = g[R], w = fn["idb://".concat(n, "/").concat(I)];
                  if (w) {
                    var x = e.table(I), T = w.optimisticOps.filter(function(re) {
                      return re.trans === v;
                    });
                    if (v._explicit && b && v.mutatedParts) for (var C = 0, A = Object.values(w.queries.query); C < A.length; C++) for (var k = 0, $ = (Z = A[C]).slice(); k < $.length; k++) so((X = $[k]).obsSet, v.mutatedParts) && (Se(Z, X), X.subscribers.forEach(function(re) {
                      return _.add(re);
                    }));
                    else if (0 < T.length) {
                      w.optimisticOps = w.optimisticOps.filter(function(re) {
                        return re.trans !== v;
                      });
                      for (var M = 0, G = Object.values(w.queries.query); M < G.length; M++) for (var Z, X, J, te = 0, ee = (Z = G[M]).slice(); te < ee.length; te++) (X = ee[te]).res != null && v.mutatedParts && (b && !X.dirty ? (J = Object.isFrozen(X.res), J = vi(X.res, X.req, T, x, X, J), X.dirty ? (Se(Z, X), X.subscribers.forEach(function(re) {
                        return _.add(re);
                      })) : J !== X.res && (X.res = J, X.promise = ne.resolve({ result: J }))) : (X.dirty && Se(Z, X), X.subscribers.forEach(function(re) {
                        return _.add(re);
                      })));
                    }
                  }
                }
                _.forEach(function(re) {
                  return re();
                });
              }
            };
          }, v.addEventListener("abort", l(!1), { signal: h }), v.addEventListener("error", l(!1), { signal: h }), v.addEventListener("complete", l(!0), { signal: h })), v;
        }, table: function(o) {
          var a = e.table(o), l = a.schema.primaryKey;
          return s(s({}, a), { mutate: function(f) {
            var h = ce.trans;
            if (l.outbound || h.db._options.cache === "disabled" || h.explicit || h.idbtrans.mode !== "readwrite") return a.mutate(f);
            var v = fn["idb://".concat(n, "/").concat(o)];
            return v ? (h = a.mutate(f), f.type !== "add" && f.type !== "put" || !(50 <= f.values.length || ho(l, f).some(function(b) {
              return b == null;
            })) ? (v.optimisticOps.push(f), f.mutatedParts && yr(f.mutatedParts), h.then(function(b) {
              0 < b.numFailures && (Se(v.optimisticOps, f), (b = mi(0, f, b)) && v.optimisticOps.push(b), f.mutatedParts && yr(f.mutatedParts));
            }), h.catch(function() {
              Se(v.optimisticOps, f), f.mutatedParts && yr(f.mutatedParts);
            })) : h.then(function(b) {
              var _ = mi(0, s(s({}, f), { values: f.values.map(function(R, g) {
                var I;
                return b.failures[g] ? R : (R = (I = l.keyPath) !== null && I !== void 0 && I.includes(".") ? be(R) : s({}, R), ve(R, l.keyPath, b.results[g]), R);
              }) }), b);
              v.optimisticOps.push(_), queueMicrotask(function() {
                return f.mutatedParts && yr(f.mutatedParts);
              });
            }), h) : a.mutate(f);
          }, query: function(f) {
            if (!pi(ce, a) || !hi("query", f)) return a.query(f);
            var h = ((_ = ce.trans) === null || _ === void 0 ? void 0 : _.db._options.cache) === "immutable", g = ce, v = g.requery, b = g.signal, _ = function(x, T, C, A) {
              var k = fn["idb://".concat(x, "/").concat(T)];
              if (!k) return [];
              if (!(T = k.queries[C])) return [null, !1, k, null];
              var $ = T[(A.query ? A.query.index.name : null) || ""];
              if (!$) return [null, !1, k, null];
              switch (C) {
                case "query":
                  var M = $.find(function(G) {
                    return G.req.limit === A.limit && G.req.values === A.values && yi(G.req.query.range, A.query.range);
                  });
                  return M ? [M, !0, k, $] : [$.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= A.limit && (!A.values || G.req.values) && ts(G.req.query.range, A.query.range);
                  }), !1, k, $];
                case "count":
                  return M = $.find(function(G) {
                    return yi(G.req.query.range, A.query.range);
                  }), [M, !!M, k, $];
              }
            }(n, o, "query", f), R = _[0], g = _[1], I = _[2], w = _[3];
            return R && g ? R.obsSet = f.obsSet : (g = a.query(f).then(function(x) {
              var T = x.result;
              if (R && (R.res = T), h) {
                for (var C = 0, A = T.length; C < A; ++C) Object.freeze(T[C]);
                Object.freeze(T);
              } else x.result = be(T);
              return x;
            }).catch(function(x) {
              return w && R && Se(w, R), Promise.reject(x);
            }), R = { obsSet: f.obsSet, promise: g, subscribers: /* @__PURE__ */ new Set(), type: "query", req: f, dirty: !1 }, w ? w.push(R) : (w = [R], (I = I || (fn["idb://".concat(n, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[f.query.index.name || ""] = w)), ns(R, w, v, b), R.promise.then(function(x) {
              return { result: vi(x.result, f, I?.optimisticOps, a, R, h) };
            });
          } });
        } });
      } };
      function br(e, n) {
        return new Proxy(e, { get: function(o, a, l) {
          return a === "db" ? n : Reflect.get(o, a, l);
        } });
      }
      var Bt = (nt.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new U.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new U.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var n = this._versions, o = n.filter(function(a) {
          return a._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), n.push(o), n.sort(Ga), o.stores({}), this._state.autoSchema = !1, o);
      }, nt.prototype._whenReady = function(e) {
        var n = this;
        return this.idbdb && (this._state.openComplete || ce.letThrough || this._vip) ? e() : new ne(function(o, a) {
          if (n._state.openComplete) return a(new U.DatabaseClosed(n._state.dbOpenError));
          if (!n._state.isBeingOpened) {
            if (!n._state.autoOpen) return void a(new U.DatabaseClosed());
            n.open().catch(O);
          }
          n._state.dbReadyPromise.then(o, a);
        }).then(e);
      }, nt.prototype.use = function(e) {
        var n = e.stack, o = e.create, a = e.level, l = e.name;
        return l && this.unuse({ stack: n, name: l }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({ stack: n, create: o, level: a ?? 10, name: l }), e.sort(function(f, h) {
          return f.level - h.level;
        }), this;
      }, nt.prototype.unuse = function(e) {
        var n = e.stack, o = e.name, a = e.create;
        return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(l) {
          return a ? l.create !== a : !!o && l.name !== o;
        })), this;
      }, nt.prototype.open = function() {
        var e = this;
        return ln(mt, function() {
          return Qa(e);
        });
      }, nt.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, n = Nn.indexOf(this);
        if (0 <= n && Nn.splice(n, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new ne(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new ne(function(o, a) {
          e.cancelOpen = a;
        }));
      }, nt.prototype.close = function(o) {
        var n = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        n ? (o.isBeingOpened && o.cancelOpen(new U.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new U.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, nt.prototype.delete = function(e) {
        var n = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", a = this._state;
        return new ne(function(l, f) {
          function h() {
            n.close(e);
            var v = n._deps.indexedDB.deleteDatabase(n.name);
            v.onsuccess = Ye(function() {
              var b, _, R;
              b = n._deps, _ = n.name, R = b.indexedDB, b = b.IDBKeyRange, oo(R) || _ === or || ro(R, b).delete(_).catch(O), l();
            }), v.onerror = kt(f), v.onblocked = n._fireOnBlocked;
          }
          if (o) throw new U.InvalidArgument("Invalid closeOptions argument to db.delete()");
          a.isBeingOpened ? a.dbReadyPromise.then(h) : h();
        });
      }, nt.prototype.backendDB = function() {
        return this.idbdb;
      }, nt.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, nt.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, nt.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, nt.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(nt.prototype, "tables", { get: function() {
        var e = this;
        return u(this._allTables).map(function(n) {
          return e._allTables[n];
        });
      }, enumerable: !1, configurable: !0 }), nt.prototype.transaction = function() {
        var e = (function(n, o, a) {
          var l = arguments.length;
          if (l < 2) throw new U.InvalidArgument("Too few arguments");
          for (var f = new Array(l - 1); --l; ) f[l - 1] = arguments[l];
          return a = f.pop(), [n, we(f), a];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, nt.prototype._transaction = function(e, n, o) {
        var a = this, l = ce.trans;
        l && l.db === this && e.indexOf("!") === -1 || (l = null);
        var f, h, v = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (h = n.map(function(_) {
            if (_ = _ instanceof a.Table ? _.name : _, typeof _ != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return _;
          }), e == "r" || e === Gr) f = Gr;
          else {
            if (e != "rw" && e != Hr) throw new U.InvalidArgument("Invalid transaction mode: " + e);
            f = Hr;
          }
          if (l) {
            if (l.mode === Gr && f === Hr) {
              if (!v) throw new U.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              l = null;
            }
            l && h.forEach(function(_) {
              if (l && l.storeNames.indexOf(_) === -1) {
                if (!v) throw new U.SubTransaction("Table " + _ + " not included in parent transaction.");
                l = null;
              }
            }), v && l && !l.active && (l = null);
          }
        } catch (_) {
          return l ? l._promise(null, function(R, g) {
            g(_);
          }) : tt(_);
        }
        var b = (function _(R, g, I, w, x) {
          return ne.resolve().then(function() {
            var T = ce.transless || ce, C = R._createTransaction(g, I, R._dbSchema, w);
            if (C.explicit = !0, T = { trans: C, transless: T }, w) C.idbtrans = w.idbtrans;
            else try {
              C.create(), C.idbtrans._explicit = !0, R._state.PR1398_maxLoop = 3;
            } catch ($) {
              return $.name === D.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                return _(R, g, I, null, x);
              })) : tt($);
            }
            var A, k = Je(x);
            return k && xn(), T = ne.follow(function() {
              var $;
              (A = x.call(C, C)) && (k ? ($ = Gt.bind(null, null), A.then($, $)) : typeof A.next == "function" && typeof A.throw == "function" && (A = fo(A)));
            }, T), (A && typeof A.then == "function" ? ne.resolve(A).then(function($) {
              return C.active ? $ : tt(new U.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : T.then(function() {
              return A;
            })).then(function($) {
              return w && C._resolve(), C._completion.then(function() {
                return $;
              });
            }).catch(function($) {
              return C._reject($), tt($);
            });
          });
        }).bind(null, this, f, h, l, o);
        return l ? l._promise(f, b, "lock") : ce.trans ? ln(ce.transless, function() {
          return a._whenReady(b);
        }) : this._whenReady(b);
      }, nt.prototype.table = function(e) {
        if (!L(this._allTables, e)) throw new U.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, nt);
      function nt(e, n) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var a = nt.dependencies;
        this._options = n = s({ addons: nt.addons, autoOpen: !0, indexedDB: a.indexedDB, IDBKeyRange: a.IDBKeyRange, cache: "cloned" }, n), this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange }, a = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var l, f, h, v, b, _ = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: O, dbReadyPromise: null, cancelOpen: O, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: n.autoOpen };
        _.dbReadyPromise = new ne(function(g) {
          _.dbReadyResolve = g;
        }), _.openCanceller = new ne(function(g, I) {
          _.cancelOpen = I;
        }), this._state = _, this.name = e, this.on = Pn(this, "populate", "blocked", "versionchange", "close", { ready: [_e, O] }), this.once = function(g, I) {
          var w = function() {
            for (var x = [], T = 0; T < arguments.length; T++) x[T] = arguments[T];
            o.on(g).unsubscribe(w), I.apply(o, x);
          };
          return o.on(g, w);
        }, this.on.ready.subscribe = F(this.on.ready.subscribe, function(g) {
          return function(I, w) {
            nt.vip(function() {
              var x, T = o._state;
              T.openComplete ? (T.dbOpenError || ne.resolve().then(I), w && g(I)) : T.onReadyBeingFired ? (T.onReadyBeingFired.push(I), w && g(I)) : (g(I), x = o, w || g(function C() {
                x.on.ready.unsubscribe(I), x.on.ready.unsubscribe(C);
              }));
            });
          };
        }), this.Collection = (l = this, Ln(Ma.prototype, function(A, C) {
          this.db = l;
          var w = Ho, x = null;
          if (C) try {
            w = C();
          } catch (k) {
            x = k;
          }
          var T = A._ctx, C = T.table, A = C.hook.reading.fire;
          this._ctx = { table: C, index: T.index, isPrimKey: !T.index || C.schema.primKey.keyPath && T.index === C.schema.primKey.name, range: w, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: x, or: T.or, valueMapper: A !== V ? A : null };
        })), this.Table = (f = this, Ln(zo.prototype, function(g, I, w) {
          this.db = f, this._tx = w, this.name = g, this.schema = I, this.hook = f._allTables[g] ? f._allTables[g].hook : Pn(null, { creating: [ge, O], reading: [oe, V], updating: [Re, O], deleting: [he, O] });
        })), this.Transaction = (h = this, Ln(qa.prototype, function(g, I, w, x, T) {
          var C = this;
          g !== "readonly" && I.forEach(function(A) {
            A = (A = w[A]) === null || A === void 0 ? void 0 : A.yProps, A && (I = I.concat(A.map(function(k) {
              return k.updatesTable;
            })));
          }), this.db = h, this.mode = g, this.storeNames = I, this.schema = w, this.chromeTransactionDurability = x, this.idbtrans = null, this.on = Pn(this, "complete", "error", "abort"), this.parent = T || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ne(function(A, k) {
            C._resolve = A, C._reject = k;
          }), this._completion.then(function() {
            C.active = !1, C.on.complete.fire();
          }, function(A) {
            var k = C.active;
            return C.active = !1, C.on.error.fire(A), C.parent ? C.parent._reject(A) : k && C.idbtrans && C.idbtrans.abort(), tt(A);
          });
        })), this.Version = (v = this, Ln(Xa.prototype, function(g) {
          this.db = v, this._cfg = { version: g, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (b = this, Ln(ri.prototype, function(g, I, w) {
          if (this.db = b, this._ctx = { table: g, index: I === ":id" ? null : I, or: w }, this._cmp = this._ascending = De, this._descending = function(x, T) {
            return De(T, x);
          }, this._max = function(x, T) {
            return 0 < De(x, T) ? x : T;
          }, this._min = function(x, T) {
            return De(x, T) < 0 ? x : T;
          }, this._IDBKeyRange = b._deps.IDBKeyRange, !this._IDBKeyRange) throw new U.MissingAPI();
        })), this.on("versionchange", function(g) {
          0 < g.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(g) {
          !g.newVersion || g.newVersion < g.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(g.oldVersion / 10));
        }), this._maxKey = $n(n.IDBKeyRange), this._createTransaction = function(g, I, w, x) {
          return new o.Transaction(g, I, w, o._options.chromeTransactionDurability, x);
        }, this._fireOnBlocked = function(g) {
          o.on("blocked").fire(g), Nn.filter(function(I) {
            return I.name === o.name && I !== o && !I._state.vcFired;
          }).map(function(I) {
            return I.on("versionchange").fire(g);
          });
        }, this.use(Za), this.use(rs), this.use(es), this.use(za), this.use(Ja);
        var R = new Proxy(this, { get: function(g, I, w) {
          if (I === "_vip") return !0;
          if (I === "table") return function(T) {
            return br(o.table(T), R);
          };
          var x = Reflect.get(g, I, w);
          return x instanceof zo ? br(x, R) : I === "tables" ? x.map(function(T) {
            return br(T, R);
          }) : I === "_createTransaction" ? function() {
            return br(x.apply(this, arguments), R);
          } : x;
        } });
        this.vip = R, a.forEach(function(g) {
          return g(o);
        });
      }
      var wr, Et = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", os = (vo.prototype.subscribe = function(e, n, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: o });
      }, vo.prototype[Et] = function() {
        return this;
      }, vo);
      function vo(e) {
        this._subscribe = e;
      }
      try {
        wr = { indexedDB: d.indexedDB || d.mozIndexedDB || d.webkitIndexedDB || d.msIndexedDB, IDBKeyRange: d.IDBKeyRange || d.webkitIDBKeyRange };
      } catch {
        wr = { indexedDB: null, IDBKeyRange: null };
      }
      function gi(e) {
        var n, o = !1, a = new os(function(l) {
          var f = Je(e), h, v = !1, b = {}, _ = {}, R = { get closed() {
            return v;
          }, unsubscribe: function() {
            v || (v = !0, h && h.abort(), g && Xt.storagemutated.unsubscribe(w));
          } };
          l.start && l.start(R);
          var g = !1, I = function() {
            return Wr(x);
          }, w = function(T) {
            vr(b, T), so(_, b) && I();
          }, x = function() {
            var T, C, A;
            !v && wr.indexedDB && (b = {}, T = {}, h && h.abort(), h = new AbortController(), A = function(k) {
              var $ = wn();
              try {
                f && xn();
                var M = Wt(e, k);
                return M = f ? M.finally(Gt) : M;
              } finally {
                $ && _n();
              }
            }(C = { subscr: T, signal: h.signal, requery: I, querier: e, trans: null }), Promise.resolve(A).then(function(k) {
              o = !0, n = k, v || C.signal.aborted || (b = {}, function($) {
                for (var M in $) if (L($, M)) return;
                return 1;
              }(_ = T) || g || (Xt(Fn, w), g = !0), Wr(function() {
                return !v && l.next && l.next(k);
              }));
            }, function(k) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(k?.name) || v || Wr(function() {
                v || l.error && l.error(k);
              });
            }));
          };
          return setTimeout(I, 0), R;
        });
        return a.hasValue = function() {
          return o;
        }, a.getValue = function() {
          return n;
        }, a;
      }
      var dn = Bt;
      function yo(e) {
        var n = Qt;
        try {
          Qt = !0, Xt.storagemutated.fire(e), co(e, !0);
        } finally {
          Qt = n;
        }
      }
      j(dn, s(s({}, it), { delete: function(e) {
        return new dn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new dn(e, { addons: [] }).open().then(function(n) {
          return n.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return n = dn.dependencies, o = n.indexedDB, n = n.IDBKeyRange, (oo(o) ? Promise.resolve(o.databases()).then(function(a) {
            return a.map(function(l) {
              return l.name;
            }).filter(function(l) {
              return l !== or;
            });
          }) : ro(o, n).toCollection().primaryKeys()).then(e);
        } catch {
          return tt(new U.MissingAPI());
        }
        var n, o;
      }, defineClass: function() {
        return function(e) {
          m(this, e);
        };
      }, ignoreTransaction: function(e) {
        return ce.trans ? ln(ce.transless, e) : e();
      }, vip: io, async: function(e) {
        return function() {
          try {
            var n = fo(e.apply(this, arguments));
            return n && typeof n.then == "function" ? n : ne.resolve(n);
          } catch (o) {
            return tt(o);
          }
        };
      }, spawn: function(e, n, o) {
        try {
          var a = fo(e.apply(o, n || []));
          return a && typeof a.then == "function" ? a : ne.resolve(a);
        } catch (l) {
          return tt(l);
        }
      }, currentTransaction: { get: function() {
        return ce.trans || null;
      } }, waitFor: function(e, n) {
        return n = ne.resolve(typeof e == "function" ? dn.ignoreTransaction(e) : e).timeout(n || 6e4), ce.trans ? ce.trans.waitFor(n) : n;
      }, Promise: ne, debug: { get: function() {
        return me;
      }, set: function(e) {
        $e(e);
      } }, derive: H, extend: m, props: j, override: F, Events: Pn, on: Xt, liveQuery: gi, extendObservabilitySet: vr, getByKeyPath: pe, setByKeyPath: ve, delByKeyPath: function(e, n) {
        typeof n == "string" ? ve(e, n, void 0) : "length" in n && [].map.call(n, function(o) {
          ve(e, o, void 0);
        });
      }, shallowClone: se, deepClone: be, getObjectDiff: po, cmp: De, asap: Te, minKey: -1 / 0, addons: [], connections: Nn, errnames: D, dependencies: wr, cache: fn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, n, o) {
        return e + n / Math.pow(10, 2 * o);
      }) })), dn.maxKey = $n(dn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Xt(Fn, function(e) {
        Qt || (e = new CustomEvent(Qr, { detail: e }), Qt = !0, dispatchEvent(e), Qt = !1);
      }), addEventListener(Qr, function(e) {
        e = e.detail, Qt || yo(e);
      }));
      var In, Qt = !1, bi = function() {
      };
      return typeof BroadcastChannel < "u" && ((bi = function() {
        (In = new BroadcastChannel(Qr)).onmessage = function(e) {
          return e.data && yo(e.data);
        };
      })(), typeof In.unref == "function" && In.unref(), Xt(Fn, function(e) {
        Qt || In.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Bt.disableBfCache && e.persisted) {
          me && console.debug("Dexie: handling persisted pagehide"), In?.close();
          for (var n = 0, o = Nn; n < o.length; n++) o[n].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Bt.disableBfCache && e.persisted && (me && console.debug("Dexie: handling persisted pageshow"), bi(), yo({ all: new ct(-1 / 0, [[]]) }));
      })), ne.rejectionMapper = function(e, n) {
        return !e || e instanceof qt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Q[e.name] ? e : (n = new Q[e.name](n || e.message, e), "stack" in e && z(n, "stack", { get: function() {
          return this.inner.stack;
        } }), n);
      }, $e(me), s(Bt, Object.freeze({ __proto__: null, Dexie: Bt, liveQuery: gi, Entity: Yo, cmp: De, PropModification: kn, replacePrefix: function(e, n) {
        return new kn({ replacePrefix: [e, n] });
      }, add: function(e) {
        return new kn({ add: e });
      }, remove: function(e) {
        return new kn({ remove: e });
      }, default: Bt, RangeSet: ct, mergeRanges: Kn, rangesOverlap: li }), { default: Bt }), Bt;
    });
  }(ra)), ra.exports;
}
var hp = pp();
const Ss = /* @__PURE__ */ fp(hp), zl = Symbol.for("Dexie"), ma = globalThis[zl] || (globalThis[zl] = Ss);
if (Ss.semVer !== ma.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Ss.semVer} and ${ma.semVer}`);
const {
  liveQuery: Tg,
  mergeRanges: Eg,
  rangesOverlap: Ig,
  RangeSet: Ag,
  cmp: Og,
  Entity: Dg,
  PropModification: Sg,
  replacePrefix: Pg,
  add: Lg,
  remove: kg,
  DexieYProvider: jg
} = ma;
var mp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function vp(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function yp(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var r = t.default;
  if (typeof r == "function") {
    var i = function s() {
      var c = !1;
      try {
        c = this instanceof s;
      } catch {
      }
      return c ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    i.prototype = r.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(t).forEach(function(s) {
    var c = Object.getOwnPropertyDescriptor(t, s);
    Object.defineProperty(i, s, c.get ? c : {
      enumerable: !0,
      get: function() {
        return t[s];
      }
    });
  }), i;
}
var Jl = {};
const gp = {}, bp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: gp
}, Symbol.toStringTag, { value: "Module" })), Zl = /* @__PURE__ */ yp(bp);
var eu;
function wp() {
  return eu || (eu = 1, function(t) {
    (function(r) {
      r.parser = function(D, N) {
        return new s(D, N);
      }, r.SAXParser = s, r.SAXStream = E, r.createStream = P, r.MAX_BUFFER_LENGTH = 64 * 1024;
      var i = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      r.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function s(D, N) {
        if (!(this instanceof s))
          return new s(D, N);
        var U = this;
        d(U), U.q = U.c = "", U.bufferCheckPosition = r.MAX_BUFFER_LENGTH, U.opt = N || {}, U.opt.lowercase = U.opt.lowercase || U.opt.lowercasetags, U.looseCase = U.opt.lowercase ? "toLowerCase" : "toUpperCase", U.tags = [], U.closed = U.closedRoot = U.sawRoot = !1, U.tag = U.error = null, U.strict = !!D, U.noscript = !!(D || U.opt.noscript), U.state = S.BEGIN, U.strictEntities = U.opt.strictEntities, U.ENTITIES = U.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), U.attribList = [], U.opt.xmlns && (U.ns = Object.create(H)), U.opt.unquotedAttributeValues === void 0 && (U.opt.unquotedAttributeValues = !D), U.trackPosition = U.opt.position !== !1, U.trackPosition && (U.position = U.line = U.column = 0), ue(U, "onready");
      }
      Object.create || (Object.create = function(D) {
        function N() {
        }
        N.prototype = D;
        var U = new N();
        return U;
      }), Object.keys || (Object.keys = function(D) {
        var N = [];
        for (var U in D) D.hasOwnProperty(U) && N.push(U);
        return N;
      });
      function c(D) {
        for (var N = Math.max(r.MAX_BUFFER_LENGTH, 10), U = 0, Q = 0, it = i.length; Q < it; Q++) {
          var O = D[i[Q]].length;
          if (O > N)
            switch (i[Q]) {
              case "textNode":
                be(D);
                break;
              case "cdata":
                ye(D, "oncdata", D.cdata), D.cdata = "";
                break;
              case "script":
                ye(D, "onscript", D.script), D.script = "";
                break;
              default:
                Be(D, "Max buffer length exceeded: " + i[Q]);
            }
          U = Math.max(U, O);
        }
        var V = r.MAX_BUFFER_LENGTH - U;
        D.bufferCheckPosition = V + D.position;
      }
      function d(D) {
        for (var N = 0, U = i.length; N < U; N++)
          D[i[N]] = "";
      }
      function u(D) {
        be(D), D.cdata !== "" && (ye(D, "oncdata", D.cdata), D.cdata = ""), D.script !== "" && (ye(D, "onscript", D.script), D.script = "");
      }
      s.prototype = {
        end: function() {
          He(this);
        },
        write: Lt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          u(this);
        }
      };
      var p;
      try {
        p = Zl.Stream;
      } catch {
        p = function() {
        };
      }
      p || (p = function() {
      });
      var m = r.EVENTS.filter(function(D) {
        return D !== "error" && D !== "end";
      });
      function P(D, N) {
        return new E(D, N);
      }
      function E(D, N) {
        if (!(this instanceof E))
          return new E(D, N);
        p.apply(this), this._parser = new s(D, N), this.writable = !0, this.readable = !0;
        var U = this;
        this._parser.onend = function() {
          U.emit("end");
        }, this._parser.onerror = function(Q) {
          U.emit("error", Q), U._parser.error = null;
        }, this._decoder = null, m.forEach(function(Q) {
          Object.defineProperty(U, "on" + Q, {
            get: function() {
              return U._parser["on" + Q];
            },
            set: function(it) {
              if (!it)
                return U.removeAllListeners(Q), U._parser["on" + Q] = it, it;
              U.on(Q, it);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      E.prototype = Object.create(p.prototype, {
        constructor: {
          value: E
        }
      }), E.prototype.write = function(D) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(D)) {
          if (!this._decoder) {
            var N = Zl.StringDecoder;
            this._decoder = new N("utf8");
          }
          D = this._decoder.write(D);
        }
        return this._parser.write(D.toString()), this.emit("data", D), !0;
      }, E.prototype.end = function(D) {
        return D && D.length && this.write(D), this._parser.end(), !0;
      }, E.prototype.on = function(D, N) {
        var U = this;
        return !U._parser["on" + D] && m.indexOf(D) !== -1 && (U._parser["on" + D] = function() {
          var Q = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          Q.splice(0, 0, D), U.emit.apply(U, Q);
        }), p.prototype.on.call(U, D, N);
      };
      var L = "[CDATA[", j = "DOCTYPE", Y = "http://www.w3.org/XML/1998/namespace", z = "http://www.w3.org/2000/xmlns/", H = { xml: Y, xmlns: z }, ie = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, W = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, B = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, F = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function q(D) {
        return D === " " || D === `
` || D === "\r" || D === "	";
      }
      function Te(D) {
        return D === '"' || D === "'";
      }
      function pe(D) {
        return D === ">" || q(D);
      }
      function ve(D, N) {
        return D.test(N);
      }
      function se(D, N) {
        return !ve(D, N);
      }
      var S = 0;
      r.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      }, r.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, r.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(r.ENTITIES).forEach(function(D) {
        var N = r.ENTITIES[D], U = typeof N == "number" ? String.fromCharCode(N) : N;
        r.ENTITIES[D] = U;
      });
      for (var we in r.STATE)
        r.STATE[r.STATE[we]] = we;
      S = r.STATE;
      function ue(D, N, U) {
        D[N] && D[N](U);
      }
      function ye(D, N, U) {
        D.textNode && be(D), ue(D, N, U);
      }
      function be(D) {
        D.textNode = ke(D.opt, D.textNode), D.textNode && ue(D, "ontext", D.textNode), D.textNode = "";
      }
      function ke(D, N) {
        return D.trim && (N = N.trim()), D.normalize && (N = N.replace(/\s+/g, " ")), N;
      }
      function Be(D, N) {
        return be(D), D.trackPosition && (N += `
Line: ` + D.line + `
Column: ` + D.column + `
Char: ` + D.c), N = new Error(N), D.error = N, ue(D, "onerror", N), D;
      }
      function He(D) {
        return D.sawRoot && !D.closedRoot && Oe(D, "Unclosed root tag"), D.state !== S.BEGIN && D.state !== S.BEGIN_WHITESPACE && D.state !== S.TEXT && Be(D, "Unexpected end"), be(D), D.c = "", D.closed = !0, ue(D, "onend"), s.call(D, D.strict, D.opt), D;
      }
      function Oe(D, N) {
        if (typeof D != "object" || !(D instanceof s))
          throw new Error("bad call to strictFail");
        D.strict && Be(D, N);
      }
      function Se(D) {
        D.strict || (D.tagName = D.tagName[D.looseCase]());
        var N = D.tags[D.tags.length - 1] || D, U = D.tag = { name: D.tagName, attributes: {} };
        D.opt.xmlns && (U.ns = N.ns), D.attribList.length = 0, ye(D, "onopentagstart", U);
      }
      function Qe(D, N) {
        var U = D.indexOf(":"), Q = U < 0 ? ["", D] : D.split(":"), it = Q[0], O = Q[1];
        return N && D === "xmlns" && (it = "xmlns", O = ""), { prefix: it, local: O };
      }
      function ht(D) {
        if (D.strict || (D.attribName = D.attribName[D.looseCase]()), D.attribList.indexOf(D.attribName) !== -1 || D.tag.attributes.hasOwnProperty(D.attribName)) {
          D.attribName = D.attribValue = "";
          return;
        }
        if (D.opt.xmlns) {
          var N = Qe(D.attribName, !0), U = N.prefix, Q = N.local;
          if (U === "xmlns")
            if (Q === "xml" && D.attribValue !== Y)
              Oe(
                D,
                "xml: prefix must be bound to " + Y + `
Actual: ` + D.attribValue
              );
            else if (Q === "xmlns" && D.attribValue !== z)
              Oe(
                D,
                "xmlns: prefix must be bound to " + z + `
Actual: ` + D.attribValue
              );
            else {
              var it = D.tag, O = D.tags[D.tags.length - 1] || D;
              it.ns === O.ns && (it.ns = Object.create(O.ns)), it.ns[Q] = D.attribValue;
            }
          D.attribList.push([D.attribName, D.attribValue]);
        } else
          D.tag.attributes[D.attribName] = D.attribValue, ye(D, "onattribute", {
            name: D.attribName,
            value: D.attribValue
          });
        D.attribName = D.attribValue = "";
      }
      function Je(D, N) {
        if (D.opt.xmlns) {
          var U = D.tag, Q = Qe(D.tagName);
          U.prefix = Q.prefix, U.local = Q.local, U.uri = U.ns[Q.prefix] || "", U.prefix && !U.uri && (Oe(D, "Unbound namespace prefix: " + JSON.stringify(D.tagName)), U.uri = Q.prefix);
          var it = D.tags[D.tags.length - 1] || D;
          U.ns && it.ns !== U.ns && Object.keys(U.ns).forEach(function($e) {
            ye(D, "onopennamespace", {
              prefix: $e,
              uri: U.ns[$e]
            });
          });
          for (var O = 0, V = D.attribList.length; O < V; O++) {
            var oe = D.attribList[O], fe = oe[0], ge = oe[1], he = Qe(fe, !0), Re = he.prefix, Ee = he.local, _e = Re === "" ? "" : U.ns[Re] || "", me = {
              name: fe,
              value: ge,
              prefix: Re,
              local: Ee,
              uri: _e
            };
            Re && Re !== "xmlns" && !_e && (Oe(D, "Unbound namespace prefix: " + JSON.stringify(Re)), me.uri = Re), D.tag.attributes[fe] = me, ye(D, "onattribute", me);
          }
          D.attribList.length = 0;
        }
        D.tag.isSelfClosing = !!N, D.sawRoot = !0, D.tags.push(D.tag), ye(D, "onopentag", D.tag), N || (!D.noscript && D.tagName.toLowerCase() === "script" ? D.state = S.SCRIPT : D.state = S.TEXT, D.tag = null, D.tagName = ""), D.attribName = D.attribValue = "", D.attribList.length = 0;
      }
      function It(D) {
        if (!D.tagName) {
          Oe(D, "Weird empty close tag."), D.textNode += "</>", D.state = S.TEXT;
          return;
        }
        if (D.script) {
          if (D.tagName !== "script") {
            D.script += "</" + D.tagName + ">", D.tagName = "", D.state = S.SCRIPT;
            return;
          }
          ye(D, "onscript", D.script), D.script = "";
        }
        var N = D.tags.length, U = D.tagName;
        D.strict || (U = U[D.looseCase]());
        for (var Q = U; N--; ) {
          var it = D.tags[N];
          if (it.name !== Q)
            Oe(D, "Unexpected close tag");
          else
            break;
        }
        if (N < 0) {
          Oe(D, "Unmatched closing tag: " + D.tagName), D.textNode += "</" + D.tagName + ">", D.state = S.TEXT;
          return;
        }
        D.tagName = U;
        for (var O = D.tags.length; O-- > N; ) {
          var V = D.tag = D.tags.pop();
          D.tagName = D.tag.name, ye(D, "onclosetag", D.tagName);
          var oe = {};
          for (var fe in V.ns)
            oe[fe] = V.ns[fe];
          var ge = D.tags[D.tags.length - 1] || D;
          D.opt.xmlns && V.ns !== ge.ns && Object.keys(V.ns).forEach(function(he) {
            var Re = V.ns[he];
            ye(D, "onclosenamespace", { prefix: he, uri: Re });
          });
        }
        N === 0 && (D.closedRoot = !0), D.tagName = D.attribValue = D.attribName = "", D.attribList.length = 0, D.state = S.TEXT;
      }
      function qt(D) {
        var N = D.entity, U = N.toLowerCase(), Q, it = "";
        return D.ENTITIES[N] ? D.ENTITIES[N] : D.ENTITIES[U] ? D.ENTITIES[U] : (N = U, N.charAt(0) === "#" && (N.charAt(1) === "x" ? (N = N.slice(2), Q = parseInt(N, 16), it = Q.toString(16)) : (N = N.slice(1), Q = parseInt(N, 10), it = Q.toString(10))), N = N.replace(/^0+/, ""), isNaN(Q) || it.toLowerCase() !== N ? (Oe(D, "Invalid character entity"), "&" + D.entity + ";") : String.fromCodePoint(Q));
      }
      function Vn(D, N) {
        N === "<" ? (D.state = S.OPEN_WAKA, D.startTagPosition = D.position) : q(N) || (Oe(D, "Non-whitespace before first tag."), D.textNode = N, D.state = S.TEXT);
      }
      function gn(D, N) {
        var U = "";
        return N < D.length && (U = D.charAt(N)), U;
      }
      function Lt(D) {
        var N = this;
        if (this.error)
          throw this.error;
        if (N.closed)
          return Be(
            N,
            "Cannot write after close. Assign an onready handler."
          );
        if (D === null)
          return He(N);
        typeof D == "object" && (D = D.toString());
        for (var U = 0, Q = ""; Q = gn(D, U++), N.c = Q, !!Q; )
          switch (N.trackPosition && (N.position++, Q === `
` ? (N.line++, N.column = 0) : N.column++), N.state) {
            case S.BEGIN:
              if (N.state = S.BEGIN_WHITESPACE, Q === "\uFEFF")
                continue;
              Vn(N, Q);
              continue;
            case S.BEGIN_WHITESPACE:
              Vn(N, Q);
              continue;
            case S.TEXT:
              if (N.sawRoot && !N.closedRoot) {
                for (var it = U - 1; Q && Q !== "<" && Q !== "&"; )
                  Q = gn(D, U++), Q && N.trackPosition && (N.position++, Q === `
` ? (N.line++, N.column = 0) : N.column++);
                N.textNode += D.substring(it, U - 1);
              }
              Q === "<" && !(N.sawRoot && N.closedRoot && !N.strict) ? (N.state = S.OPEN_WAKA, N.startTagPosition = N.position) : (!q(Q) && (!N.sawRoot || N.closedRoot) && Oe(N, "Text data outside of root node."), Q === "&" ? N.state = S.TEXT_ENTITY : N.textNode += Q);
              continue;
            case S.SCRIPT:
              Q === "<" ? N.state = S.SCRIPT_ENDING : N.script += Q;
              continue;
            case S.SCRIPT_ENDING:
              Q === "/" ? N.state = S.CLOSE_TAG : (N.script += "<" + Q, N.state = S.SCRIPT);
              continue;
            case S.OPEN_WAKA:
              if (Q === "!")
                N.state = S.SGML_DECL, N.sgmlDecl = "";
              else if (!q(Q)) if (ve(ie, Q))
                N.state = S.OPEN_TAG, N.tagName = Q;
              else if (Q === "/")
                N.state = S.CLOSE_TAG, N.tagName = "";
              else if (Q === "?")
                N.state = S.PROC_INST, N.procInstName = N.procInstBody = "";
              else {
                if (Oe(N, "Unencoded <"), N.startTagPosition + 1 < N.position) {
                  var O = N.position - N.startTagPosition;
                  Q = new Array(O).join(" ") + Q;
                }
                N.textNode += "<" + Q, N.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if (N.sgmlDecl + Q === "--") {
                N.state = S.COMMENT, N.comment = "", N.sgmlDecl = "";
                continue;
              }
              N.doctype && N.doctype !== !0 && N.sgmlDecl ? (N.state = S.DOCTYPE_DTD, N.doctype += "<!" + N.sgmlDecl + Q, N.sgmlDecl = "") : (N.sgmlDecl + Q).toUpperCase() === L ? (ye(N, "onopencdata"), N.state = S.CDATA, N.sgmlDecl = "", N.cdata = "") : (N.sgmlDecl + Q).toUpperCase() === j ? (N.state = S.DOCTYPE, (N.doctype || N.sawRoot) && Oe(
                N,
                "Inappropriately located doctype declaration"
              ), N.doctype = "", N.sgmlDecl = "") : Q === ">" ? (ye(N, "onsgmldeclaration", N.sgmlDecl), N.sgmlDecl = "", N.state = S.TEXT) : (Te(Q) && (N.state = S.SGML_DECL_QUOTED), N.sgmlDecl += Q);
              continue;
            case S.SGML_DECL_QUOTED:
              Q === N.q && (N.state = S.SGML_DECL, N.q = ""), N.sgmlDecl += Q;
              continue;
            case S.DOCTYPE:
              Q === ">" ? (N.state = S.TEXT, ye(N, "ondoctype", N.doctype), N.doctype = !0) : (N.doctype += Q, Q === "[" ? N.state = S.DOCTYPE_DTD : Te(Q) && (N.state = S.DOCTYPE_QUOTED, N.q = Q));
              continue;
            case S.DOCTYPE_QUOTED:
              N.doctype += Q, Q === N.q && (N.q = "", N.state = S.DOCTYPE);
              continue;
            case S.DOCTYPE_DTD:
              Q === "]" ? (N.doctype += Q, N.state = S.DOCTYPE) : Q === "<" ? (N.state = S.OPEN_WAKA, N.startTagPosition = N.position) : Te(Q) ? (N.doctype += Q, N.state = S.DOCTYPE_DTD_QUOTED, N.q = Q) : N.doctype += Q;
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              N.doctype += Q, Q === N.q && (N.state = S.DOCTYPE_DTD, N.q = "");
              continue;
            case S.COMMENT:
              Q === "-" ? N.state = S.COMMENT_ENDING : N.comment += Q;
              continue;
            case S.COMMENT_ENDING:
              Q === "-" ? (N.state = S.COMMENT_ENDED, N.comment = ke(N.opt, N.comment), N.comment && ye(N, "oncomment", N.comment), N.comment = "") : (N.comment += "-" + Q, N.state = S.COMMENT);
              continue;
            case S.COMMENT_ENDED:
              Q !== ">" ? (Oe(N, "Malformed comment"), N.comment += "--" + Q, N.state = S.COMMENT) : N.doctype && N.doctype !== !0 ? N.state = S.DOCTYPE_DTD : N.state = S.TEXT;
              continue;
            case S.CDATA:
              Q === "]" ? N.state = S.CDATA_ENDING : N.cdata += Q;
              continue;
            case S.CDATA_ENDING:
              Q === "]" ? N.state = S.CDATA_ENDING_2 : (N.cdata += "]" + Q, N.state = S.CDATA);
              continue;
            case S.CDATA_ENDING_2:
              Q === ">" ? (N.cdata && ye(N, "oncdata", N.cdata), ye(N, "onclosecdata"), N.cdata = "", N.state = S.TEXT) : Q === "]" ? N.cdata += "]" : (N.cdata += "]]" + Q, N.state = S.CDATA);
              continue;
            case S.PROC_INST:
              Q === "?" ? N.state = S.PROC_INST_ENDING : q(Q) ? N.state = S.PROC_INST_BODY : N.procInstName += Q;
              continue;
            case S.PROC_INST_BODY:
              if (!N.procInstBody && q(Q))
                continue;
              Q === "?" ? N.state = S.PROC_INST_ENDING : N.procInstBody += Q;
              continue;
            case S.PROC_INST_ENDING:
              Q === ">" ? (ye(N, "onprocessinginstruction", {
                name: N.procInstName,
                body: N.procInstBody
              }), N.procInstName = N.procInstBody = "", N.state = S.TEXT) : (N.procInstBody += "?" + Q, N.state = S.PROC_INST_BODY);
              continue;
            case S.OPEN_TAG:
              ve(W, Q) ? N.tagName += Q : (Se(N), Q === ">" ? Je(N) : Q === "/" ? N.state = S.OPEN_TAG_SLASH : (q(Q) || Oe(N, "Invalid character in tag name"), N.state = S.ATTRIB));
              continue;
            case S.OPEN_TAG_SLASH:
              Q === ">" ? (Je(N, !0), It(N)) : (Oe(N, "Forward-slash in opening tag not followed by >"), N.state = S.ATTRIB);
              continue;
            case S.ATTRIB:
              if (q(Q))
                continue;
              Q === ">" ? Je(N) : Q === "/" ? N.state = S.OPEN_TAG_SLASH : ve(ie, Q) ? (N.attribName = Q, N.attribValue = "", N.state = S.ATTRIB_NAME) : Oe(N, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME:
              Q === "=" ? N.state = S.ATTRIB_VALUE : Q === ">" ? (Oe(N, "Attribute without value"), N.attribValue = N.attribName, ht(N), Je(N)) : q(Q) ? N.state = S.ATTRIB_NAME_SAW_WHITE : ve(W, Q) ? N.attribName += Q : Oe(N, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (Q === "=")
                N.state = S.ATTRIB_VALUE;
              else {
                if (q(Q))
                  continue;
                Oe(N, "Attribute without value"), N.tag.attributes[N.attribName] = "", N.attribValue = "", ye(N, "onattribute", {
                  name: N.attribName,
                  value: ""
                }), N.attribName = "", Q === ">" ? Je(N) : ve(ie, Q) ? (N.attribName = Q, N.state = S.ATTRIB_NAME) : (Oe(N, "Invalid attribute name"), N.state = S.ATTRIB);
              }
              continue;
            case S.ATTRIB_VALUE:
              if (q(Q))
                continue;
              Te(Q) ? (N.q = Q, N.state = S.ATTRIB_VALUE_QUOTED) : (N.opt.unquotedAttributeValues || Be(N, "Unquoted attribute value"), N.state = S.ATTRIB_VALUE_UNQUOTED, N.attribValue = Q);
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (Q !== N.q) {
                Q === "&" ? N.state = S.ATTRIB_VALUE_ENTITY_Q : N.attribValue += Q;
                continue;
              }
              ht(N), N.q = "", N.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              q(Q) ? N.state = S.ATTRIB : Q === ">" ? Je(N) : Q === "/" ? N.state = S.OPEN_TAG_SLASH : ve(ie, Q) ? (Oe(N, "No whitespace between attributes"), N.attribName = Q, N.attribValue = "", N.state = S.ATTRIB_NAME) : Oe(N, "Invalid attribute name");
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!pe(Q)) {
                Q === "&" ? N.state = S.ATTRIB_VALUE_ENTITY_U : N.attribValue += Q;
                continue;
              }
              ht(N), Q === ">" ? Je(N) : N.state = S.ATTRIB;
              continue;
            case S.CLOSE_TAG:
              if (N.tagName)
                Q === ">" ? It(N) : ve(W, Q) ? N.tagName += Q : N.script ? (N.script += "</" + N.tagName, N.tagName = "", N.state = S.SCRIPT) : (q(Q) || Oe(N, "Invalid tagname in closing tag"), N.state = S.CLOSE_TAG_SAW_WHITE);
              else {
                if (q(Q))
                  continue;
                se(ie, Q) ? N.script ? (N.script += "</" + Q, N.state = S.SCRIPT) : Oe(N, "Invalid tagname in closing tag.") : N.tagName = Q;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (q(Q))
                continue;
              Q === ">" ? It(N) : Oe(N, "Invalid characters in closing tag");
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var V, oe;
              switch (N.state) {
                case S.TEXT_ENTITY:
                  V = S.TEXT, oe = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  V = S.ATTRIB_VALUE_QUOTED, oe = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  V = S.ATTRIB_VALUE_UNQUOTED, oe = "attribValue";
                  break;
              }
              if (Q === ";") {
                var fe = qt(N);
                N.opt.unparsedEntities && !Object.values(r.XML_ENTITIES).includes(fe) ? (N.entity = "", N.state = V, N.write(fe)) : (N[oe] += fe, N.entity = "", N.state = V);
              } else ve(N.entity.length ? F : B, Q) ? N.entity += Q : (Oe(N, "Invalid character in entity name"), N[oe] += "&" + N.entity + Q, N.entity = "", N.state = V);
              continue;
            default:
              throw new Error(N, "Unknown state: " + N.state);
          }
        return N.position >= N.bufferCheckPosition && c(N), N;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var D = String.fromCharCode, N = Math.floor, U = function() {
          var Q = 16384, it = [], O, V, oe = -1, fe = arguments.length;
          if (!fe)
            return "";
          for (var ge = ""; ++oe < fe; ) {
            var he = Number(arguments[oe]);
            if (!isFinite(he) || // `NaN`, `+Infinity`, or `-Infinity`
            he < 0 || // not a valid Unicode code point
            he > 1114111 || // not a valid Unicode code point
            N(he) !== he)
              throw RangeError("Invalid code point: " + he);
            he <= 65535 ? it.push(he) : (he -= 65536, O = (he >> 10) + 55296, V = he % 1024 + 56320, it.push(O, V)), (oe + 1 === fe || it.length > Q) && (ge += D.apply(null, it), it.length = 0);
          }
          return ge;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: U,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = U;
      }();
    })(t);
  }(Jl)), Jl;
}
wp();
const je = "sclElements", Ct = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
var Ps = { exports: {} }, _p = Ps.exports, tu;
function xp() {
  return tu || (tu = 1, function(t, r) {
    (function(i, s) {
      t.exports = s();
    })(_p, function() {
      var i = function(e, n) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {
          o.__proto__ = a;
        } || function(o, a) {
          for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = a[l]);
        })(e, n);
      }, s = function() {
        return (s = Object.assign || function(e) {
          for (var n, o = 1, a = arguments.length; o < a; o++) for (var l in n = arguments[o]) Object.prototype.hasOwnProperty.call(n, l) && (e[l] = n[l]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, n, o) {
        for (var a, l = 0, f = n.length; l < f; l++) !a && l in n || ((a = a || Array.prototype.slice.call(n, 0, l))[l] = n[l]);
        return e.concat(a || Array.prototype.slice.call(n));
      }
      var d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : mp, u = Object.keys, p = Array.isArray;
      function m(e, n) {
        return typeof n != "object" || u(n).forEach(function(o) {
          e[o] = n[o];
        }), e;
      }
      typeof Promise > "u" || d.Promise || (d.Promise = Promise);
      var P = Object.getPrototypeOf, E = {}.hasOwnProperty;
      function L(e, n) {
        return E.call(e, n);
      }
      function j(e, n) {
        typeof n == "function" && (n = n(P(e))), (typeof Reflect > "u" ? u : Reflect.ownKeys)(n).forEach(function(o) {
          z(e, o, n[o]);
        });
      }
      var Y = Object.defineProperty;
      function z(e, n, o, a) {
        Y(e, n, m(o && L(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, a));
      }
      function H(e) {
        return { from: function(n) {
          return e.prototype = Object.create(n.prototype), z(e.prototype, "constructor", e), { extend: j.bind(null, e.prototype) };
        } };
      }
      var ie = Object.getOwnPropertyDescriptor, W = [].slice;
      function B(e, n, o) {
        return W.call(e, n, o);
      }
      function F(e, n) {
        return n(e);
      }
      function q(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function Te(e) {
        d.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function pe(e, n) {
        if (typeof n == "string" && L(e, n)) return e[n];
        if (!n) return e;
        if (typeof n != "string") {
          for (var o = [], a = 0, l = n.length; a < l; ++a) {
            var f = pe(e, n[a]);
            o.push(f);
          }
          return o;
        }
        var h = n.indexOf(".");
        if (h !== -1) {
          var v = e[n.substr(0, h)];
          return v == null ? void 0 : pe(v, n.substr(h + 1));
        }
      }
      function ve(e, n, o) {
        if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof n != "string" && "length" in n) {
          q(typeof o != "string" && "length" in o);
          for (var a = 0, l = n.length; a < l; ++a) ve(e, n[a], o[a]);
        } else {
          var f, h, v = n.indexOf(".");
          v !== -1 ? (f = n.substr(0, v), (h = n.substr(v + 1)) === "" ? o === void 0 ? p(e) && !isNaN(parseInt(f)) ? e.splice(f, 1) : delete e[f] : e[f] = o : ve(v = !(v = e[f]) || !L(e, f) ? e[f] = {} : v, h, o)) : o === void 0 ? p(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = o;
        }
      }
      function se(e) {
        var n, o = {};
        for (n in e) L(e, n) && (o[n] = e[n]);
        return o;
      }
      var S = [].concat;
      function we(e) {
        return S.apply([], e);
      }
      var Ge = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(we([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(n) {
          return n + e + "Array";
        });
      }))).filter(function(e) {
        return d[e];
      }), ue = new Set(Ge.map(function(e) {
        return d[e];
      })), ye = null;
      function be(e) {
        return ye = /* @__PURE__ */ new WeakMap(), e = function n(o) {
          if (!o || typeof o != "object") return o;
          var a = ye.get(o);
          if (a) return a;
          if (p(o)) {
            a = [], ye.set(o, a);
            for (var l = 0, f = o.length; l < f; ++l) a.push(n(o[l]));
          } else if (ue.has(o.constructor)) a = o;
          else {
            var h, v = P(o);
            for (h in a = v === Object.prototype ? {} : Object.create(v), ye.set(o, a), o) L(o, h) && (a[h] = n(o[h]));
          }
          return a;
        }(e), ye = null, e;
      }
      var ke = {}.toString;
      function Be(e) {
        return ke.call(e).slice(8, -1);
      }
      var He = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Oe = typeof He == "symbol" ? function(e) {
        var n;
        return e != null && (n = e[He]) && n.apply(e);
      } : function() {
        return null;
      };
      function Se(e, n) {
        return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n;
      }
      var Qe = {};
      function ht(e) {
        var n, o, a, l;
        if (arguments.length === 1) {
          if (p(e)) return e.slice();
          if (this === Qe && typeof e == "string") return [e];
          if (l = Oe(e)) {
            for (o = []; !(a = l.next()).done; ) o.push(a.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (n = e.length) != "number") return [e];
          for (o = new Array(n); n--; ) o[n] = e[n];
          return o;
        }
        for (n = arguments.length, o = new Array(n); n--; ) o[n] = arguments[n];
        return o;
      }
      var Je = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ke = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Et = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ke), It = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function qt(e, n) {
        this.name = e, this.message = n;
      }
      function Vn(e, n) {
        return e + ". Errors: " + Object.keys(n).map(function(o) {
          return n[o].toString();
        }).filter(function(o, a, l) {
          return l.indexOf(o) === a;
        }).join(`
`);
      }
      function gn(e, n, o, a) {
        this.failures = n, this.failedKeys = a, this.successCount = o, this.message = Vn(e, n);
      }
      function Lt(e, n) {
        this.name = "BulkError", this.failures = Object.keys(n).map(function(o) {
          return n[o];
        }), this.failuresByPos = n, this.message = Vn(e, this.failures);
      }
      H(qt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), H(gn).from(qt), H(Lt).from(qt);
      var D = Et.reduce(function(e, n) {
        return e[n] = n + "Error", e;
      }, {}), N = qt, U = Et.reduce(function(e, n) {
        var o = n + "Error";
        function a(l, f) {
          this.name = o, l ? typeof l == "string" ? (this.message = "".concat(l).concat(f ? `
 ` + f : ""), this.inner = f || null) : typeof l == "object" && (this.message = "".concat(l.name, " ").concat(l.message), this.inner = l) : (this.message = It[n] || o, this.inner = null);
        }
        return H(a).from(N), e[n] = a, e;
      }, {});
      U.Syntax = SyntaxError, U.Type = TypeError, U.Range = RangeError;
      var Q = Ke.reduce(function(e, n) {
        return e[n + "Error"] = U[n], e;
      }, {}), it = Et.reduce(function(e, n) {
        return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = U[n]), e;
      }, {});
      function O() {
      }
      function V(e) {
        return e;
      }
      function oe(e, n) {
        return e == null || e === V ? n : function(o) {
          return n(e(o));
        };
      }
      function fe(e, n) {
        return function() {
          e.apply(this, arguments), n.apply(this, arguments);
        };
      }
      function ge(e, n) {
        return e === O ? n : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var a = this.onsuccess, l = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var f = n.apply(this, arguments);
          return a && (this.onsuccess = this.onsuccess ? fe(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? fe(l, this.onerror) : l), f !== void 0 ? f : o;
        };
      }
      function he(e, n) {
        return e === O ? n : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, a = this.onerror;
          this.onsuccess = this.onerror = null, n.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? fe(o, this.onsuccess) : o), a && (this.onerror = this.onerror ? fe(a, this.onerror) : a);
        };
      }
      function Re(e, n) {
        return e === O ? n : function(o) {
          var a = e.apply(this, arguments);
          m(o, a);
          var l = this.onsuccess, f = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = n.apply(this, arguments), l && (this.onsuccess = this.onsuccess ? fe(l, this.onsuccess) : l), f && (this.onerror = this.onerror ? fe(f, this.onerror) : f), a === void 0 ? o === void 0 ? void 0 : o : m(a, o);
        };
      }
      function Ee(e, n) {
        return e === O ? n : function() {
          return n.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function _e(e, n) {
        return e === O ? n : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var a = this, l = arguments.length, f = new Array(l); l--; ) f[l] = arguments[l];
            return o.then(function() {
              return n.apply(a, f);
            });
          }
          return n.apply(this, arguments);
        };
      }
      it.ModifyError = gn, it.DexieError = qt, it.BulkError = Lt;
      var me = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function $e(e) {
        me = e;
      }
      var Ie = {}, Me = 100, Ge = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, P(e), e];
        var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [n, P(n), e];
      }(), Ke = Ge[0], Et = Ge[1], Ge = Ge[2], Et = Et && Et.then, rt = Ke && Ke.constructor, st = !!Ge, xt = function(e, n) {
        bn.push([e, n]), Ft && (queueMicrotask(ka), Ft = !1);
      }, St = !0, Ft = !0, Nt = [], an = [], Wn = V, mt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: O, pgp: !1, env: {}, finalize: O }, ce = mt, bn = [], sn = 0, Jn = [];
      function ne(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var n = this._PSD = ce;
        if (typeof e != "function") {
          if (e !== Ie) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && qr(this, this._value));
        }
        this._state = null, this._value = null, ++n.ref, function o(a, l) {
          try {
            l(function(f) {
              if (a._state === null) {
                if (f === a) throw new TypeError("A promise cannot be resolved with itself.");
                var h = a._lib && wn();
                f && typeof f.then == "function" ? o(a, function(v, b) {
                  f instanceof ne ? f._then(v, b) : f.then(v, b);
                }) : (a._state = !0, a._value = f, Uo(a)), h && _n();
              }
            }, qr.bind(null, a));
          } catch (f) {
            qr(a, f);
          }
        }(this, e);
      }
      var Kr = { get: function() {
        var e = ce, n = nr;
        function o(a, l) {
          var f = this, h = !e.global && (e !== ce || n !== nr), v = h && !Gt(), b = new ne(function(_, R) {
            Ur(f, new qo(Wo(a, e, h, v), Wo(l, e, h, v), _, R, e));
          });
          return this._consoleTask && (b._consoleTask = this._consoleTask), b;
        }
        return o.prototype = Ie, o;
      }, set: function(e) {
        z(this, "then", e && e.prototype === Ie ? Kr : { get: function() {
          return e;
        }, set: Kr.set });
      } };
      function qo(e, n, o, a, l) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = o, this.reject = a, this.psd = l;
      }
      function qr(e, n) {
        var o, a;
        an.push(n), e._state === null && (o = e._lib && wn(), n = Wn(n), e._state = !1, e._value = n, a = e, Nt.some(function(l) {
          return l._value === a._value;
        }) || Nt.push(a), Uo(e), o && _n());
      }
      function Uo(e) {
        var n = e._listeners;
        e._listeners = [];
        for (var o = 0, a = n.length; o < a; ++o) Ur(e, n[o]);
        var l = e._PSD;
        --l.ref || l.finalize(), sn === 0 && (++sn, xt(function() {
          --sn == 0 && Vr();
        }, []));
      }
      function Ur(e, n) {
        if (e._state !== null) {
          var o = e._state ? n.onFulfilled : n.onRejected;
          if (o === null) return (e._state ? n.resolve : n.reject)(e._value);
          ++n.psd.ref, ++sn, xt(La, [o, e, n]);
        } else e._listeners.push(n);
      }
      function La(e, n, o) {
        try {
          var a, l = n._value;
          !n._state && an.length && (an = []), a = me && n._consoleTask ? n._consoleTask.run(function() {
            return e(l);
          }) : e(l), n._state || an.indexOf(l) !== -1 || function(f) {
            for (var h = Nt.length; h; ) if (Nt[--h]._value === f._value) return Nt.splice(h, 1);
          }(n), o.resolve(a);
        } catch (f) {
          o.reject(f);
        } finally {
          --sn == 0 && Vr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function ka() {
        ln(mt, function() {
          wn() && _n();
        });
      }
      function wn() {
        var e = St;
        return Ft = St = !1, e;
      }
      function _n() {
        var e, n, o;
        do
          for (; 0 < bn.length; ) for (e = bn, bn = [], o = e.length, n = 0; n < o; ++n) {
            var a = e[n];
            a[0].apply(null, a[1]);
          }
        while (0 < bn.length);
        Ft = St = !0;
      }
      function Vr() {
        var e = Nt;
        Nt = [], e.forEach(function(a) {
          a._PSD.onunhandled.call(null, a._value, a);
        });
        for (var n = Jn.slice(0), o = n.length; o; ) n[--o]();
      }
      function Zn(e) {
        return new ne(Ie, !1, e);
      }
      function Ye(e, n) {
        var o = ce;
        return function() {
          var a = wn(), l = ce;
          try {
            return Ht(o, !0), e.apply(this, arguments);
          } catch (f) {
            n && n(f);
          } finally {
            Ht(l, !1), a && _n();
          }
        };
      }
      j(ne.prototype, { then: Kr, _then: function(e, n) {
        Ur(this, new qo(null, null, e, n, ce));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var n = e, o = arguments[1];
        return typeof n == "function" ? this.then(null, function(a) {
          return (a instanceof n ? o : Zn)(a);
        }) : this.then(null, function(a) {
          return (a && a.name === n ? o : Zn)(a);
        });
      }, finally: function(e) {
        return this.then(function(n) {
          return ne.resolve(e()).then(function() {
            return n;
          });
        }, function(n) {
          return ne.resolve(e()).then(function() {
            return Zn(n);
          });
        });
      }, timeout: function(e, n) {
        var o = this;
        return e < 1 / 0 ? new ne(function(a, l) {
          var f = setTimeout(function() {
            return l(new U.Timeout(n));
          }, e);
          o.then(a, l).finally(clearTimeout.bind(null, f));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && z(ne.prototype, Symbol.toStringTag, "Dexie.Promise"), mt.env = Vo(), j(ne, { all: function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n, o) {
          e.length === 0 && n([]);
          var a = e.length;
          e.forEach(function(l, f) {
            return ne.resolve(l).then(function(h) {
              e[f] = h, --a || n(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof ne ? e : e && typeof e.then == "function" ? new ne(function(n, o) {
          e.then(n, o);
        }) : new ne(Ie, !0, e);
      }, reject: Zn, race: function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n, o) {
          e.map(function(a) {
            return ne.resolve(a).then(n, o);
          });
        });
      }, PSD: { get: function() {
        return ce;
      }, set: function(e) {
        return ce = e;
      } }, totalEchoes: { get: function() {
        return nr;
      } }, newPSD: Wt, usePSD: ln, scheduler: { get: function() {
        return xt;
      }, set: function(e) {
        xt = e;
      } }, rejectionMapper: { get: function() {
        return Wn;
      }, set: function(e) {
        Wn = e;
      } }, follow: function(e, n) {
        return new ne(function(o, a) {
          return Wt(function(l, f) {
            var h = ce;
            h.unhandleds = [], h.onunhandled = f, h.finalize = fe(function() {
              var v, b = this;
              v = function() {
                b.unhandleds.length === 0 ? l() : f(b.unhandleds[0]);
              }, Jn.push(function _() {
                v(), Jn.splice(Jn.indexOf(_), 1);
              }), ++sn, xt(function() {
                --sn == 0 && Vr();
              }, []);
            }, h.finalize), e();
          }, n, o, a);
        });
      } }), rt && (rt.allSettled && z(ne, "allSettled", function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n) {
          e.length === 0 && n([]);
          var o = e.length, a = new Array(o);
          e.forEach(function(l, f) {
            return ne.resolve(l).then(function(h) {
              return a[f] = { status: "fulfilled", value: h };
            }, function(h) {
              return a[f] = { status: "rejected", reason: h };
            }).then(function() {
              return --o || n(a);
            });
          });
        });
      }), rt.any && typeof AggregateError < "u" && z(ne, "any", function() {
        var e = ht.apply(null, arguments).map(rr);
        return new ne(function(n, o) {
          e.length === 0 && o(new AggregateError([]));
          var a = e.length, l = new Array(a);
          e.forEach(function(f, h) {
            return ne.resolve(f).then(function(v) {
              return n(v);
            }, function(v) {
              l[h] = v, --a || o(new AggregateError(l));
            });
          });
        });
      }), rt.withResolvers && (ne.withResolvers = rt.withResolvers));
      var lt = { awaits: 0, echoes: 0, id: 0 }, ja = 0, er = [], tr = 0, nr = 0, Fa = 0;
      function Wt(e, n, o, a) {
        var l = ce, f = Object.create(l);
        return f.parent = l, f.ref = 0, f.global = !1, f.id = ++Fa, mt.env, f.env = st ? { Promise: ne, PromiseProp: { value: ne, configurable: !0, writable: !0 }, all: ne.all, race: ne.race, allSettled: ne.allSettled, any: ne.any, resolve: ne.resolve, reject: ne.reject } : {}, n && m(f, n), ++l.ref, f.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, a = ln(f, e, o, a), f.ref === 0 && f.finalize(), a;
      }
      function xn() {
        return lt.id || (lt.id = ++ja), ++lt.awaits, lt.echoes += Me, lt.id;
      }
      function Gt() {
        return !!lt.awaits && (--lt.awaits == 0 && (lt.id = 0), lt.echoes = lt.awaits * Me, !0);
      }
      function rr(e) {
        return lt.echoes && e && e.constructor === rt ? (xn(), e.then(function(n) {
          return Gt(), n;
        }, function(n) {
          return Gt(), tt(n);
        })) : e;
      }
      function $a() {
        var e = er[er.length - 1];
        er.pop(), Ht(e, !1);
      }
      function Ht(e, n) {
        var o, a = ce;
        (n ? !lt.echoes || tr++ && e === ce : !tr || --tr && e === ce) || queueMicrotask(n ? (function(l) {
          ++nr, lt.echoes && --lt.echoes != 0 || (lt.echoes = lt.awaits = lt.id = 0), er.push(ce), Ht(l, !0);
        }).bind(null, e) : $a), e !== ce && (ce = e, a === mt && (mt.env = Vo()), st && (o = mt.env.Promise, n = e.env, (a.global || e.global) && (Object.defineProperty(d, "Promise", n.PromiseProp), o.all = n.all, o.race = n.race, o.resolve = n.resolve, o.reject = n.reject, n.allSettled && (o.allSettled = n.allSettled), n.any && (o.any = n.any))));
      }
      function Vo() {
        var e = d.Promise;
        return st ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(d, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function ln(e, n, o, a, l) {
        var f = ce;
        try {
          return Ht(e, !0), n(o, a, l);
        } finally {
          Ht(f, !1);
        }
      }
      function Wo(e, n, o, a) {
        return typeof e != "function" ? e : function() {
          var l = ce;
          o && xn(), Ht(n, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Ht(l, !1), a && queueMicrotask(Gt);
          }
        };
      }
      function Wr(e) {
        Promise === rt && lt.echoes === 0 ? tr === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + Et).indexOf("[native code]") === -1 && (xn = Gt = O);
      var tt = ne.reject, un = "￿", Mt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Go = "String expected.", Nn = [], or = "__dbnames", Gr = "readonly", Hr = "readwrite";
      function cn(e, n) {
        return e ? n ? function() {
          return e.apply(this, arguments) && n.apply(this, arguments);
        } : e : n;
      }
      var Ho = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function ir(e) {
        return typeof e != "string" || /\./.test(e) ? function(n) {
          return n;
        } : function(n) {
          return n[e] === void 0 && e in n && delete (n = be(n))[e], n;
        };
      }
      function Yo() {
        throw U.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function De(e, n) {
        try {
          var o = Xo(e), a = Xo(n);
          if (o !== a) return o === "Array" ? 1 : a === "Array" ? -1 : o === "binary" ? 1 : a === "binary" ? -1 : o === "string" ? 1 : a === "string" ? -1 : o === "Date" ? 1 : a !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return n < e ? 1 : e < n ? -1 : 0;
            case "binary":
              return function(l, f) {
                for (var h = l.length, v = f.length, b = h < v ? h : v, _ = 0; _ < b; ++_) if (l[_] !== f[_]) return l[_] < f[_] ? -1 : 1;
                return h === v ? 0 : h < v ? -1 : 1;
              }(Qo(e), Qo(n));
            case "Array":
              return function(l, f) {
                for (var h = l.length, v = f.length, b = h < v ? h : v, _ = 0; _ < b; ++_) {
                  var R = De(l[_], f[_]);
                  if (R !== 0) return R;
                }
                return h === v ? 0 : h < v ? -1 : 1;
              }(e, n);
          }
        } catch {
        }
        return NaN;
      }
      function Xo(e) {
        var n = typeof e;
        return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = Be(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function Qo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function ar(e, n, o) {
        var a = e.schema.yProps;
        return a ? (n && 0 < o.numFailures && (n = n.filter(function(l, f) {
          return !o.failures[f];
        })), Promise.all(a.map(function(l) {
          return l = l.updatesTable, n ? e.db.table(l).where("k").anyOf(n).delete() : e.db.table(l).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var zo = (Ve.prototype._trans = function(e, n, o) {
        var a = this._tx || ce.trans, l = this.name, f = me && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function h(_, R, g) {
          if (!g.schema[l]) throw new U.NotFound("Table " + l + " not part of transaction");
          return n(g.idbtrans, g);
        }
        var v = wn();
        try {
          var b = a && a.db._novip === this.db._novip ? a === ce.trans ? a._promise(e, h, o) : Wt(function() {
            return a._promise(e, h, o);
          }, { trans: a, transless: ce.transless || ce }) : function _(R, g, I, w) {
            if (R.idbdb && (R._state.openComplete || ce.letThrough || R._vip)) {
              var x = R._createTransaction(g, I, R._dbSchema);
              try {
                x.create(), R._state.PR1398_maxLoop = 3;
              } catch (T) {
                return T.name === D.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                  return _(R, g, I, w);
                })) : tt(T);
              }
              return x._promise(g, function(T, C) {
                return Wt(function() {
                  return ce.trans = x, w(T, C, x);
                });
              }).then(function(T) {
                if (g === "readwrite") try {
                  x.idbtrans.commit();
                } catch {
                }
                return g === "readonly" ? T : x._completion.then(function() {
                  return T;
                });
              });
            }
            if (R._state.openComplete) return tt(new U.DatabaseClosed(R._state.dbOpenError));
            if (!R._state.isBeingOpened) {
              if (!R._state.autoOpen) return tt(new U.DatabaseClosed());
              R.open().catch(O);
            }
            return R._state.dbReadyPromise.then(function() {
              return _(R, g, I, w);
            });
          }(this.db, e, [this.name], h);
          return f && (b._consoleTask = f, b = b.catch(function(_) {
            return console.trace(_), tt(_);
          })), b;
        } finally {
          v && _n();
        }
      }, Ve.prototype.get = function(e, n) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(n) : e == null ? tt(new U.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(a) {
          return o.core.get({ trans: a, key: e }).then(function(l) {
            return o.hook.reading.fire(l);
          });
        }).then(n);
      }, Ve.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (p(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var n = u(e);
        if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(v) {
          if (v.compound && n.every(function(_) {
            return 0 <= v.keyPath.indexOf(_);
          })) {
            for (var b = 0; b < n.length; ++b) if (n.indexOf(v.keyPath[b]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(v, b) {
          return v.keyPath.length - b.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== un) {
          var f = o.keyPath.slice(0, n.length);
          return this.where(f).equals(f.map(function(b) {
            return e[b];
          }));
        }
        !o && me && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
        var a = this.schema.idxByName;
        function l(v, b) {
          return De(v, b) === 0;
        }
        var h = n.reduce(function(g, b) {
          var _ = g[0], R = g[1], g = a[b], I = e[b];
          return [_ || g, _ || !g ? cn(R, g && g.multi ? function(w) {
            return w = pe(w, b), p(w) && w.some(function(x) {
              return l(I, x);
            });
          } : function(w) {
            return l(I, pe(w, b));
          }) : R];
        }, [null, null]), f = h[0], h = h[1];
        return f ? this.where(f.name).equals(e[f.keyPath]).filter(h) : o ? this.filter(h) : this.where(n).equals("");
      }, Ve.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Ve.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Ve.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Ve.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Ve.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Ve.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Ve.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ve.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, p(e) ? "[".concat(e.join("+"), "]") : e));
      }, Ve.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ve.prototype.mapToClass = function(e) {
        var n, o = this.db, a = this.name;
        function l() {
          return n !== null && n.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Yo && (function(b, _) {
          if (typeof _ != "function" && _ !== null) throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
          function R() {
            this.constructor = b;
          }
          i(b, _), b.prototype = _ === null ? Object.create(_) : (R.prototype = _.prototype, new R());
        }(l, n = e), Object.defineProperty(l.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), l.prototype.table = function() {
          return a;
        }, e = l);
        for (var f = /* @__PURE__ */ new Set(), h = e.prototype; h; h = P(h)) Object.getOwnPropertyNames(h).forEach(function(b) {
          return f.add(b);
        });
        function v(b) {
          if (!b) return b;
          var _, R = Object.create(e.prototype);
          for (_ in b) if (!f.has(_)) try {
            R[_] = b[_];
          } catch {
          }
          return R;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = v, this.hook("reading", v), e;
      }, Ve.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          m(this, e);
        });
      }, Ve.prototype.add = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, f = a.keyPath, h = e;
        return f && l && (h = ir(f)(e)), this._trans("readwrite", function(v) {
          return o.core.mutate({ trans: v, type: "add", keys: n != null ? [n] : null, values: [h] });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (f) try {
            ve(e, f, v);
          } catch {
          }
          return v;
        });
      }, Ve.prototype.update = function(e, n) {
        return typeof e != "object" || p(e) ? this.where(":id").equals(e).modify(n) : (e = pe(e, this.schema.primKey.keyPath), e === void 0 ? tt(new U.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n));
      }, Ve.prototype.put = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, f = a.keyPath, h = e;
        return f && l && (h = ir(f)(e)), this._trans("readwrite", function(v) {
          return o.core.mutate({ trans: v, type: "put", values: [h], keys: n != null ? [n] : null });
        }).then(function(v) {
          return v.numFailures ? ne.reject(v.failures[0]) : v.lastResult;
        }).then(function(v) {
          if (f) try {
            ve(e, f, v);
          } catch {
          }
          return v;
        });
      }, Ve.prototype.delete = function(e) {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(a) {
            return ar(n, [e], a);
          }).then(function(a) {
            return a.numFailures ? ne.reject(a.failures[0]) : void 0;
          });
        });
      }, Ve.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(n) {
          return e.core.mutate({ trans: n, type: "deleteRange", range: Ho }).then(function(o) {
            return ar(e, null, o);
          });
        }).then(function(n) {
          return n.numFailures ? ne.reject(n.failures[0]) : void 0;
        });
      }, Ve.prototype.bulkGet = function(e) {
        var n = this;
        return this._trans("readonly", function(o) {
          return n.core.getMany({ keys: e, trans: o }).then(function(a) {
            return a.map(function(l) {
              return n.hook.reading.fire(l);
            });
          });
        });
      }, Ve.prototype.bulkAdd = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, f = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(h) {
          var _ = a.schema.primKey, v = _.auto, _ = _.keyPath;
          if (_ && l) throw new U.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new U.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && v ? e.map(ir(_)) : e;
          return a.core.mutate({ trans: h, type: "add", keys: l, values: _, wantResults: f }).then(function(x) {
            var g = x.numFailures, I = x.results, w = x.lastResult, x = x.failures;
            if (g === 0) return f ? I : w;
            throw new Lt("".concat(a.name, ".bulkAdd(): ").concat(g, " of ").concat(b, " operations failed"), x);
          });
        });
      }, Ve.prototype.bulkPut = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, f = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(h) {
          var _ = a.schema.primKey, v = _.auto, _ = _.keyPath;
          if (_ && l) throw new U.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new U.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && v ? e.map(ir(_)) : e;
          return a.core.mutate({ trans: h, type: "put", keys: l, values: _, wantResults: f }).then(function(x) {
            var g = x.numFailures, I = x.results, w = x.lastResult, x = x.failures;
            if (g === 0) return f ? I : w;
            throw new Lt("".concat(a.name, ".bulkPut(): ").concat(g, " of ").concat(b, " operations failed"), x);
          });
        });
      }, Ve.prototype.bulkUpdate = function(e) {
        var n = this, o = this.core, a = e.map(function(h) {
          return h.key;
        }), l = e.map(function(h) {
          return h.changes;
        }), f = [];
        return this._trans("readwrite", function(h) {
          return o.getMany({ trans: h, keys: a, cache: "clone" }).then(function(v) {
            var b = [], _ = [];
            e.forEach(function(g, I) {
              var w = g.key, x = g.changes, T = v[I];
              if (T) {
                for (var C = 0, A = Object.keys(x); C < A.length; C++) {
                  var k = A[C], $ = x[k];
                  if (k === n.schema.primKey.keyPath) {
                    if (De($, w) !== 0) throw new U.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ve(T, k, $);
                }
                f.push(I), b.push(w), _.push(T);
              }
            });
            var R = b.length;
            return o.mutate({ trans: h, type: "put", keys: b, values: _, updates: { keys: a, changeSpecs: l } }).then(function(g) {
              var I = g.numFailures, w = g.failures;
              if (I === 0) return R;
              for (var x = 0, T = Object.keys(w); x < T.length; x++) {
                var C, A = T[x], k = f[Number(A)];
                k != null && (C = w[A], delete w[A], w[k] = C);
              }
              throw new Lt("".concat(n.name, ".bulkUpdate(): ").concat(I, " of ").concat(R, " operations failed"), w);
            });
          });
        });
      }, Ve.prototype.bulkDelete = function(e) {
        var n = this, o = e.length;
        return this._trans("readwrite", function(a) {
          return n.core.mutate({ trans: a, type: "delete", keys: e }).then(function(l) {
            return ar(n, e, l);
          });
        }).then(function(h) {
          var l = h.numFailures, f = h.lastResult, h = h.failures;
          if (l === 0) return f;
          throw new Lt("".concat(n.name, ".bulkDelete(): ").concat(l, " of ").concat(o, " operations failed"), h);
        });
      }, Ve);
      function Ve() {
      }
      function Pn(e) {
        function n(h, v) {
          if (v) {
            for (var b = arguments.length, _ = new Array(b - 1); --b; ) _[b - 1] = arguments[b];
            return o[h].subscribe.apply(null, _), e;
          }
          if (typeof h == "string") return o[h];
        }
        var o = {};
        n.addEventType = f;
        for (var a = 1, l = arguments.length; a < l; ++a) f(arguments[a]);
        return n;
        function f(h, v, b) {
          if (typeof h != "object") {
            var _;
            v = v || Ee;
            var R = { subscribers: [], fire: b = b || O, subscribe: function(g) {
              R.subscribers.indexOf(g) === -1 && (R.subscribers.push(g), R.fire = v(R.fire, g));
            }, unsubscribe: function(g) {
              R.subscribers = R.subscribers.filter(function(I) {
                return I !== g;
              }), R.fire = R.subscribers.reduce(v, b);
            } };
            return o[h] = n[h] = R;
          }
          u(_ = h).forEach(function(g) {
            var I = _[g];
            if (p(I)) f(g, _[g][0], _[g][1]);
            else {
              if (I !== "asap") throw new U.InvalidArgument("Invalid event config");
              var w = f(g, V, function() {
                for (var x = arguments.length, T = new Array(x); x--; ) T[x] = arguments[x];
                w.subscribers.forEach(function(C) {
                  Te(function() {
                    C.apply(null, T);
                  });
                });
              });
            }
          });
        }
      }
      function Ln(e, n) {
        return H(n).from({ prototype: e }), n;
      }
      function Rn(e, n) {
        return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter);
      }
      function Yr(e, n) {
        e.filter = cn(e.filter, n);
      }
      function Xr(e, n, o) {
        var a = e.replayFilter;
        e.replayFilter = a ? function() {
          return cn(a(), n());
        } : n, e.justLimit = o && !a;
      }
      function sr(e, n) {
        if (e.isPrimKey) return n.primaryKey;
        var o = n.getIndexByKeyPath(e.index);
        if (!o) throw new U.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
        return o;
      }
      function Jo(e, n, o) {
        var a = sr(e, n.schema);
        return n.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: a, range: e.range } });
      }
      function lr(e, n, o, a) {
        var l = e.replayFilter ? cn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var f = {}, h = function(v, b, _) {
            var R, g;
            l && !l(b, _, function(I) {
              return b.stop(I);
            }, function(I) {
              return b.fail(I);
            }) || ((g = "" + (R = b.primaryKey)) == "[object ArrayBuffer]" && (g = "" + new Uint8Array(R)), L(f, g) || (f[g] = !0, n(v, b, _)));
          };
          return Promise.all([e.or._iterate(h, o), Zo(Jo(e, a, o), e.algorithm, h, !e.keysOnly && e.valueMapper)]);
        }
        return Zo(Jo(e, a, o), cn(e.algorithm, l), n, !e.keysOnly && e.valueMapper);
      }
      function Zo(e, n, o, a) {
        var l = Ye(a ? function(f, h, v) {
          return o(a(f), h, v);
        } : o);
        return e.then(function(f) {
          if (f) return f.start(function() {
            var h = function() {
              return f.continue();
            };
            n && !n(f, function(v) {
              return h = v;
            }, function(v) {
              f.stop(v), h = O;
            }, function(v) {
              f.fail(v), h = O;
            }) || l(f.value, f, function(v) {
              return h = v;
            }), h();
          });
        });
      }
      var kn = (ei.prototype.execute = function(e) {
        var n = this["@@propmod"];
        if (n.add !== void 0) {
          var o = n.add;
          if (p(o)) return c(c([], p(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (n.remove !== void 0) {
          var a = n.remove;
          if (p(a)) return p(e) ? e.filter(function(l) {
            return !a.includes(l);
          }).sort() : [];
          if (typeof a == "number") return Number(e) - a;
          if (typeof a == "bigint") try {
            return BigInt(e) - a;
          } catch {
            return BigInt(0) - a;
          }
          throw new TypeError("Invalid subtrahend ".concat(a));
        }
        return o = (o = n.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? n.replacePrefix[1] + e.substring(o.length) : e;
      }, ei);
      function ei(e) {
        this["@@propmod"] = e;
      }
      var Ma = (Fe.prototype._read = function(e, n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, tt.bind(null, o.error)) : o.table._trans("readonly", e).then(n);
      }, Fe.prototype._write = function(e) {
        var n = this._ctx;
        return n.error ? n.table._trans(null, tt.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
      }, Fe.prototype._addAlgorithm = function(e) {
        var n = this._ctx;
        n.algorithm = cn(n.algorithm, e);
      }, Fe.prototype._iterate = function(e, n) {
        return lr(this._ctx, e, n, this._ctx.table.core);
      }, Fe.prototype.clone = function(e) {
        var n = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && m(o, e), n._ctx = o, n;
      }, Fe.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Fe.prototype.each = function(e) {
        var n = this._ctx;
        return this._read(function(o) {
          return lr(n, e, o, n.table.core);
        });
      }, Fe.prototype.count = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx, l = a.table.core;
          if (Rn(a, !0)) return l.count({ trans: o, query: { index: sr(a, l.schema), range: a.range } }).then(function(h) {
            return Math.min(h, a.limit);
          });
          var f = 0;
          return lr(a, function() {
            return ++f, !1;
          }, o, l).then(function() {
            return f;
          });
        }).then(e);
      }, Fe.prototype.sortBy = function(e, n) {
        var o = e.split(".").reverse(), a = o[0], l = o.length - 1;
        function f(b, _) {
          return _ ? f(b[o[_]], _ - 1) : b[a];
        }
        var h = this._ctx.dir === "next" ? 1 : -1;
        function v(b, _) {
          return De(f(b, l), f(_, l)) * h;
        }
        return this.toArray(function(b) {
          return b.sort(v);
        }).then(n);
      }, Fe.prototype.toArray = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx;
          if (a.dir === "next" && Rn(a, !0) && 0 < a.limit) {
            var l = a.valueMapper, f = sr(a, a.table.core.schema);
            return a.table.core.query({ trans: o, limit: a.limit, values: !0, query: { index: f, range: a.range } }).then(function(v) {
              return v = v.result, l ? v.map(l) : v;
            });
          }
          var h = [];
          return lr(a, function(v) {
            return h.push(v);
          }, o, a.table.core).then(function() {
            return h;
          });
        }, e);
      }, Fe.prototype.offset = function(e) {
        var n = this._ctx;
        return e <= 0 || (n.offset += e, Rn(n) ? Xr(n, function() {
          var o = e;
          return function(a, l) {
            return o === 0 || (o === 1 ? --o : l(function() {
              a.advance(o), o = 0;
            }), !1);
          };
        }) : Xr(n, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Fe.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Xr(this._ctx, function() {
          var n = e;
          return function(o, a, l) {
            return --n <= 0 && a(l), 0 <= n;
          };
        }, !0), this;
      }, Fe.prototype.until = function(e, n) {
        return Yr(this._ctx, function(o, a, l) {
          return !e(o.value) || (a(l), n);
        }), this;
      }, Fe.prototype.first = function(e) {
        return this.limit(1).toArray(function(n) {
          return n[0];
        }).then(e);
      }, Fe.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Fe.prototype.filter = function(e) {
        var n;
        return Yr(this._ctx, function(o) {
          return e(o.value);
        }), (n = this._ctx).isMatch = cn(n.isMatch, e), this;
      }, Fe.prototype.and = function(e) {
        return this.filter(e);
      }, Fe.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Fe.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Fe.prototype.desc = function() {
        return this.reverse();
      }, Fe.prototype.eachKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.key, a);
        });
      }, Fe.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Fe.prototype.eachPrimaryKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.primaryKey, a);
        });
      }, Fe.prototype.keys = function(e) {
        var n = this._ctx;
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Fe.prototype.primaryKeys = function(e) {
        var n = this._ctx;
        if (n.dir === "next" && Rn(n, !0) && 0 < n.limit) return this._read(function(a) {
          var l = sr(n, n.table.core.schema);
          return n.table.core.query({ trans: a, values: !1, limit: n.limit, query: { index: l, range: n.range } });
        }).then(function(a) {
          return a.result;
        }).then(e);
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Fe.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Fe.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(n) {
          return n[0];
        }).then(e);
      }, Fe.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Fe.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var n = {};
        return Yr(this._ctx, function(l) {
          var a = l.primaryKey.toString(), l = L(n, a);
          return n[a] = !0, !l;
        }), this;
      }, Fe.prototype.modify = function(e) {
        var n = this, o = this._ctx;
        return this._write(function(a) {
          var l, f, h;
          h = typeof e == "function" ? e : (l = u(e), f = l.length, function(A) {
            for (var k = !1, $ = 0; $ < f; ++$) {
              var M = l[$], G = e[M], Z = pe(A, M);
              G instanceof kn ? (ve(A, M, G.execute(Z)), k = !0) : Z !== G && (ve(A, M, G), k = !0);
            }
            return k;
          });
          var v = o.table.core, g = v.schema.primaryKey, b = g.outbound, _ = g.extractKey, R = 200, g = n.db._options.modifyChunkSize;
          g && (R = typeof g == "object" ? g[v.name] || g["*"] || 200 : g);
          function I(A, M) {
            var $ = M.failures, M = M.numFailures;
            x += A - M;
            for (var G = 0, Z = u($); G < Z.length; G++) {
              var X = Z[G];
              w.push($[X]);
            }
          }
          var w = [], x = 0, T = [], C = e === ti;
          return n.clone().primaryKeys().then(function(A) {
            function k(M) {
              var G = Math.min(R, A.length - M), Z = A.slice(M, M + G);
              return (C ? Promise.resolve([]) : v.getMany({ trans: a, keys: Z, cache: "immutable" })).then(function(X) {
                var J = [], te = [], ee = b ? [] : null, re = C ? Z : [];
                if (!C) for (var Ce = 0; Ce < G; ++Ce) {
                  var Pe = X[Ce], Ne = { value: be(Pe), primKey: A[M + Ce] };
                  h.call(Ne, Ne.value, Ne) !== !1 && (Ne.value == null ? re.push(A[M + Ce]) : b || De(_(Pe), _(Ne.value)) === 0 ? (te.push(Ne.value), b && ee.push(A[M + Ce])) : (re.push(A[M + Ce]), J.push(Ne.value)));
                }
                return Promise.resolve(0 < J.length && v.mutate({ trans: a, type: "add", values: J }).then(function(Ze) {
                  for (var xe in Ze.failures) re.splice(parseInt(xe), 1);
                  I(J.length, Ze);
                })).then(function() {
                  return (0 < te.length || $ && typeof e == "object") && v.mutate({ trans: a, type: "put", keys: ee, values: te, criteria: $, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < M }).then(function(Ze) {
                    return I(te.length, Ze);
                  });
                }).then(function() {
                  return (0 < re.length || $ && C) && v.mutate({ trans: a, type: "delete", keys: re, criteria: $, isAdditionalChunk: 0 < M }).then(function(Ze) {
                    return ar(o.table, re, Ze);
                  }).then(function(Ze) {
                    return I(re.length, Ze);
                  });
                }).then(function() {
                  return A.length > M + G && k(M + R);
                });
              });
            }
            var $ = Rn(o) && o.limit === 1 / 0 && (typeof e != "function" || C) && { index: o.index, range: o.range };
            return k(0).then(function() {
              if (0 < w.length) throw new gn("Error modifying one or more objects", w, x, T);
              return A.length;
            });
          });
        });
      }, Fe.prototype.delete = function() {
        var e = this._ctx, n = e.range;
        return !Rn(e) || e.table.schema.yProps || !e.isPrimKey && n.type !== 3 ? this.modify(ti) : this._write(function(o) {
          var a = e.table.core.schema.primaryKey, l = n;
          return e.table.core.count({ trans: o, query: { index: a, range: l } }).then(function(f) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: l }).then(function(b) {
              var v = b.failures, b = b.numFailures;
              if (b) throw new gn("Could not delete some values", Object.keys(v).map(function(_) {
                return v[_];
              }), f - b);
              return f - b;
            });
          });
        });
      }, Fe);
      function Fe() {
      }
      var ti = function(e, n) {
        return n.value = null;
      };
      function Ba(e, n) {
        return e < n ? -1 : e === n ? 0 : 1;
      }
      function Ka(e, n) {
        return n < e ? -1 : e === n ? 0 : 1;
      }
      function _t(e, n, o) {
        return e = e instanceof ri ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(n), e;
      }
      function Cn(e) {
        return new e.Collection(e, function() {
          return ni("");
        }).limit(0);
      }
      function ur(e, n, o, a) {
        var l, f, h, v, b, _, R, g = o.length;
        if (!o.every(function(x) {
          return typeof x == "string";
        })) return _t(e, Go);
        function I(x) {
          l = x === "next" ? function(C) {
            return C.toUpperCase();
          } : function(C) {
            return C.toLowerCase();
          }, f = x === "next" ? function(C) {
            return C.toLowerCase();
          } : function(C) {
            return C.toUpperCase();
          }, h = x === "next" ? Ba : Ka;
          var T = o.map(function(C) {
            return { lower: f(C), upper: l(C) };
          }).sort(function(C, A) {
            return h(C.lower, A.lower);
          });
          v = T.map(function(C) {
            return C.upper;
          }), b = T.map(function(C) {
            return C.lower;
          }), R = (_ = x) === "next" ? "" : a;
        }
        I("next"), e = new e.Collection(e, function() {
          return Yt(v[0], b[g - 1] + a);
        }), e._ondirectionchange = function(x) {
          I(x);
        };
        var w = 0;
        return e._addAlgorithm(function(x, T, C) {
          var A = x.key;
          if (typeof A != "string") return !1;
          var k = f(A);
          if (n(k, b, w)) return !0;
          for (var $ = null, M = w; M < g; ++M) {
            var G = function(Z, X, J, te, ee, re) {
              for (var Ce = Math.min(Z.length, te.length), Pe = -1, Ne = 0; Ne < Ce; ++Ne) {
                var Ze = X[Ne];
                if (Ze !== te[Ne]) return ee(Z[Ne], J[Ne]) < 0 ? Z.substr(0, Ne) + J[Ne] + J.substr(Ne + 1) : ee(Z[Ne], te[Ne]) < 0 ? Z.substr(0, Ne) + te[Ne] + J.substr(Ne + 1) : 0 <= Pe ? Z.substr(0, Pe) + X[Pe] + J.substr(Pe + 1) : null;
                ee(Z[Ne], Ze) < 0 && (Pe = Ne);
              }
              return Ce < te.length && re === "next" ? Z + J.substr(Z.length) : Ce < Z.length && re === "prev" ? Z.substr(0, J.length) : Pe < 0 ? null : Z.substr(0, Pe) + te[Pe] + J.substr(Pe + 1);
            }(A, k, v[M], b[M], h, _);
            G === null && $ === null ? w = M + 1 : ($ === null || 0 < h($, G)) && ($ = G);
          }
          return T($ !== null ? function() {
            x.continue($ + R);
          } : C), !1;
        }), e;
      }
      function Yt(e, n, o, a) {
        return { type: 2, lower: e, upper: n, lowerOpen: o, upperOpen: a };
      }
      function ni(e) {
        return { type: 1, lower: e, upper: e };
      }
      var ri = (Object.defineProperty(ut.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), ut.prototype.between = function(e, n, o, a) {
        o = o !== !1, a = a === !0;
        try {
          return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (o || a) && (!o || !a) ? Cn(this) : new this.Collection(this, function() {
            return Yt(e, n, !o, !a);
          });
        } catch {
          return _t(this, Mt);
        }
      }, ut.prototype.equals = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return ni(e);
        });
      }, ut.prototype.above = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(e, void 0, !0);
        });
      }, ut.prototype.aboveOrEqual = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(e, void 0, !1);
        });
      }, ut.prototype.below = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(void 0, e, !1, !0);
        });
      }, ut.prototype.belowOrEqual = function(e) {
        return e == null ? _t(this, Mt) : new this.Collection(this, function() {
          return Yt(void 0, e);
        });
      }, ut.prototype.startsWith = function(e) {
        return typeof e != "string" ? _t(this, Go) : this.between(e, e + un, !0, !0);
      }, ut.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : ur(this, function(n, o) {
          return n.indexOf(o[0]) === 0;
        }, [e], un);
      }, ut.prototype.equalsIgnoreCase = function(e) {
        return ur(this, function(n, o) {
          return n === o[0];
        }, [e], "");
      }, ut.prototype.anyOfIgnoreCase = function() {
        var e = ht.apply(Qe, arguments);
        return e.length === 0 ? Cn(this) : ur(this, function(n, o) {
          return o.indexOf(n) !== -1;
        }, e, "");
      }, ut.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ht.apply(Qe, arguments);
        return e.length === 0 ? Cn(this) : ur(this, function(n, o) {
          return o.some(function(a) {
            return n.indexOf(a) === 0;
          });
        }, e, un);
      }, ut.prototype.anyOf = function() {
        var e = this, n = ht.apply(Qe, arguments), o = this._cmp;
        try {
          n.sort(o);
        } catch {
          return _t(this, Mt);
        }
        if (n.length === 0) return Cn(this);
        var a = new this.Collection(this, function() {
          return Yt(n[0], n[n.length - 1]);
        });
        a._ondirectionchange = function(f) {
          o = f === "next" ? e._ascending : e._descending, n.sort(o);
        };
        var l = 0;
        return a._addAlgorithm(function(f, h, v) {
          for (var b = f.key; 0 < o(b, n[l]); ) if (++l === n.length) return h(v), !1;
          return o(b, n[l]) === 0 || (h(function() {
            f.continue(n[l]);
          }), !1);
        }), a;
      }, ut.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, ut.prototype.noneOf = function() {
        var e = ht.apply(Qe, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return _t(this, Mt);
        }
        var n = e.reduce(function(o, a) {
          return o ? o.concat([[o[o.length - 1][1], a]]) : [[-1 / 0, a]];
        }, null);
        return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
      }, ut.prototype.inAnyRange = function(A, n) {
        var o = this, a = this._cmp, l = this._ascending, f = this._descending, h = this._min, v = this._max;
        if (A.length === 0) return Cn(this);
        if (!A.every(function(k) {
          return k[0] !== void 0 && k[1] !== void 0 && l(k[0], k[1]) <= 0;
        })) return _t(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", U.InvalidArgument);
        var b = !n || n.includeLowers !== !1, _ = n && n.includeUppers === !0, R, g = l;
        function I(k, $) {
          return g(k[0], $[0]);
        }
        try {
          (R = A.reduce(function(k, $) {
            for (var M = 0, G = k.length; M < G; ++M) {
              var Z = k[M];
              if (a($[0], Z[1]) < 0 && 0 < a($[1], Z[0])) {
                Z[0] = h(Z[0], $[0]), Z[1] = v(Z[1], $[1]);
                break;
              }
            }
            return M === G && k.push($), k;
          }, [])).sort(I);
        } catch {
          return _t(this, Mt);
        }
        var w = 0, x = _ ? function(k) {
          return 0 < l(k, R[w][1]);
        } : function(k) {
          return 0 <= l(k, R[w][1]);
        }, T = b ? function(k) {
          return 0 < f(k, R[w][0]);
        } : function(k) {
          return 0 <= f(k, R[w][0]);
        }, C = x, A = new this.Collection(this, function() {
          return Yt(R[0][0], R[R.length - 1][1], !b, !_);
        });
        return A._ondirectionchange = function(k) {
          g = k === "next" ? (C = x, l) : (C = T, f), R.sort(I);
        }, A._addAlgorithm(function(k, $, M) {
          for (var G, Z = k.key; C(Z); ) if (++w === R.length) return $(M), !1;
          return !x(G = Z) && !T(G) || (o._cmp(Z, R[w][1]) === 0 || o._cmp(Z, R[w][0]) === 0 || $(function() {
            g === l ? k.continue(R[w][0]) : k.continue(R[w][1]);
          }), !1);
        }), A;
      }, ut.prototype.startsWithAnyOf = function() {
        var e = ht.apply(Qe, arguments);
        return e.every(function(n) {
          return typeof n == "string";
        }) ? e.length === 0 ? Cn(this) : this.inAnyRange(e.map(function(n) {
          return [n, n + un];
        })) : _t(this, "startsWithAnyOf() only works with strings");
      }, ut);
      function ut() {
      }
      function kt(e) {
        return Ye(function(n) {
          return jn(n), e(n.target.error), !1;
        });
      }
      function jn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Fn = "storagemutated", Qr = "x-storagemutated-1", Xt = Pn(null, Fn), qa = (jt.prototype._lock = function() {
        return q(!ce.global), ++this._reculock, this._reculock !== 1 || ce.global || (ce.lockOwnerFor = this), this;
      }, jt.prototype._unlock = function() {
        if (q(!ce.global), --this._reculock == 0) for (ce.global || (ce.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            ln(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, jt.prototype._locked = function() {
        return this._reculock && ce.lockOwnerFor !== this;
      }, jt.prototype.create = function(e) {
        var n = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, a = this.db._state.dbOpenError;
        if (q(!this.idbtrans), !e && !o) switch (a && a.name) {
          case "DatabaseClosedError":
            throw new U.DatabaseClosed(a);
          case "MissingAPIError":
            throw new U.MissingAPI(a.message, a);
          default:
            throw new U.OpenFailed(a);
        }
        if (!this.active) throw new U.TransactionInactive();
        return q(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ye(function(l) {
          jn(l), n._reject(e.error);
        }), e.onabort = Ye(function(l) {
          jn(l), n.active && n._reject(new U.Abort(e.error)), n.active = !1, n.on("abort").fire(l);
        }), e.oncomplete = Ye(function() {
          n.active = !1, n._resolve(), "mutatedParts" in e && Xt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, jt.prototype._promise = function(e, n, o) {
        var a = this;
        if (e === "readwrite" && this.mode !== "readwrite") return tt(new U.ReadOnly("Transaction is readonly"));
        if (!this.active) return tt(new U.TransactionInactive());
        if (this._locked()) return new ne(function(f, h) {
          a._blockedFuncs.push([function() {
            a._promise(e, n, o).then(f, h);
          }, ce]);
        });
        if (o) return Wt(function() {
          var f = new ne(function(h, v) {
            a._lock();
            var b = n(h, v, a);
            b && b.then && b.then(h, v);
          });
          return f.finally(function() {
            return a._unlock();
          }), f._lib = !0, f;
        });
        var l = new ne(function(f, h) {
          var v = n(f, h, a);
          v && v.then && v.then(f, h);
        });
        return l._lib = !0, l;
      }, jt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, jt.prototype.waitFor = function(e) {
        var n, o = this._root(), a = ne.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return a;
        }) : (o._waitingFor = a, o._waitingQueue = [], n = o.idbtrans.objectStore(o.storeNames[0]), function f() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (n.get(-1 / 0).onsuccess = f);
        }());
        var l = o._waitingFor;
        return new ne(function(f, h) {
          a.then(function(v) {
            return o._waitingQueue.push(Ye(f.bind(null, v)));
          }, function(v) {
            return o._waitingQueue.push(Ye(h.bind(null, v)));
          }).finally(function() {
            o._waitingFor === l && (o._waitingFor = null);
          });
        });
      }, jt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new U.Abort()));
      }, jt.prototype.table = function(e) {
        var n = this._memoizedTables || (this._memoizedTables = {});
        if (L(n, e)) return n[e];
        var o = this.schema[e];
        if (!o) throw new U.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), n[e] = o;
      }, jt);
      function jt() {
      }
      function zr(e, n, o, a, l, f, h, v) {
        return { name: e, keyPath: n, unique: o, multi: a, auto: l, compound: f, src: (o && !h ? "&" : "") + (a ? "*" : "") + (l ? "++" : "") + oi(n), type: v };
      }
      function oi(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Jr(e, n, o) {
        return { name: e, primKey: n, indexes: o, mappedClass: null, idxByName: (a = function(l) {
          return [l.name, l];
        }, o.reduce(function(l, f, h) {
          return h = a(f, h), h && (l[h[0]] = h[1]), l;
        }, {})) };
        var a;
      }
      var $n = function(e) {
        try {
          return e.only([[]]), $n = function() {
            return [[]];
          }, [[]];
        } catch {
          return $n = function() {
            return un;
          }, un;
        }
      };
      function Zr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (n = e).split(".").length === 1 ? function(o) {
          return o[n];
        } : function(o) {
          return pe(o, n);
        } : function(o) {
          return pe(o, e);
        };
        var n;
      }
      function ii(e) {
        return [].slice.call(e);
      }
      var Ua = 0;
      function Mn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Va(e, n, b) {
        function a(C) {
          if (C.type === 3) return null;
          if (C.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var w = C.lower, x = C.upper, T = C.lowerOpen, C = C.upperOpen;
          return w === void 0 ? x === void 0 ? null : n.upperBound(x, !!C) : x === void 0 ? n.lowerBound(w, !!T) : n.bound(w, x, !!T, !!C);
        }
        function l(I) {
          var w, x = I.name;
          return { name: x, schema: I, mutate: function(T) {
            var C = T.trans, A = T.type, k = T.keys, $ = T.values, M = T.range;
            return new Promise(function(G, Z) {
              G = Ye(G);
              var X = C.objectStore(x), J = X.keyPath == null, te = A === "put" || A === "add";
              if (!te && A !== "delete" && A !== "deleteRange") throw new Error("Invalid operation type: " + A);
              var ee, re = (k || $ || { length: 1 }).length;
              if (k && $ && k.length !== $.length) throw new Error("Given keys array must have same length as given values array.");
              if (re === 0) return G({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Ce(vt) {
                ++Ze, jn(vt);
              }
              var Pe = [], Ne = [], Ze = 0;
              if (A === "deleteRange") {
                if (M.type === 4) return G({ numFailures: Ze, failures: Ne, results: [], lastResult: void 0 });
                M.type === 3 ? Pe.push(ee = X.clear()) : Pe.push(ee = X.delete(a(M)));
              } else {
                var J = te ? J ? [$, k] : [$, null] : [k, null], xe = J[0], ft = J[1];
                if (te) for (var dt = 0; dt < re; ++dt) Pe.push(ee = ft && ft[dt] !== void 0 ? X[A](xe[dt], ft[dt]) : X[A](xe[dt])), ee.onerror = Ce;
                else for (dt = 0; dt < re; ++dt) Pe.push(ee = X[A](xe[dt])), ee.onerror = Ce;
              }
              function _r(vt) {
                vt = vt.target.result, Pe.forEach(function(pn, go) {
                  return pn.error != null && (Ne[go] = pn.error);
                }), G({ numFailures: Ze, failures: Ne, results: A === "delete" ? k : Pe.map(function(pn) {
                  return pn.result;
                }), lastResult: vt });
              }
              ee.onerror = function(vt) {
                Ce(vt), _r(vt);
              }, ee.onsuccess = _r;
            });
          }, getMany: function(T) {
            var C = T.trans, A = T.keys;
            return new Promise(function(k, $) {
              k = Ye(k);
              for (var M, G = C.objectStore(x), Z = A.length, X = new Array(Z), J = 0, te = 0, ee = function(Pe) {
                Pe = Pe.target, X[Pe._pos] = Pe.result, ++te === J && k(X);
              }, re = kt($), Ce = 0; Ce < Z; ++Ce) A[Ce] != null && ((M = G.get(A[Ce]))._pos = Ce, M.onsuccess = ee, M.onerror = re, ++J);
              J === 0 && k(X);
            });
          }, get: function(T) {
            var C = T.trans, A = T.key;
            return new Promise(function(k, $) {
              k = Ye(k);
              var M = C.objectStore(x).get(A);
              M.onsuccess = function(G) {
                return k(G.target.result);
              }, M.onerror = kt($);
            });
          }, query: (w = _, function(T) {
            return new Promise(function(C, A) {
              C = Ye(C);
              var k, $, M, J = T.trans, G = T.values, Z = T.limit, ee = T.query, X = Z === 1 / 0 ? void 0 : Z, te = ee.index, ee = ee.range, J = J.objectStore(x), te = te.isPrimaryKey ? J : J.index(te.name), ee = a(ee);
              if (Z === 0) return C({ result: [] });
              w ? ((X = G ? te.getAll(ee, X) : te.getAllKeys(ee, X)).onsuccess = function(re) {
                return C({ result: re.target.result });
              }, X.onerror = kt(A)) : (k = 0, $ = !G && "openKeyCursor" in te ? te.openKeyCursor(ee) : te.openCursor(ee), M = [], $.onsuccess = function(re) {
                var Ce = $.result;
                return Ce ? (M.push(G ? Ce.value : Ce.primaryKey), ++k === Z ? C({ result: M }) : void Ce.continue()) : C({ result: M });
              }, $.onerror = kt(A));
            });
          }), openCursor: function(T) {
            var C = T.trans, A = T.values, k = T.query, $ = T.reverse, M = T.unique;
            return new Promise(function(G, Z) {
              G = Ye(G);
              var te = k.index, X = k.range, J = C.objectStore(x), J = te.isPrimaryKey ? J : J.index(te.name), te = $ ? M ? "prevunique" : "prev" : M ? "nextunique" : "next", ee = !A && "openKeyCursor" in J ? J.openKeyCursor(a(X), te) : J.openCursor(a(X), te);
              ee.onerror = kt(Z), ee.onsuccess = Ye(function(re) {
                var Ce, Pe, Ne, Ze, xe = ee.result;
                xe ? (xe.___id = ++Ua, xe.done = !1, Ce = xe.continue.bind(xe), Pe = (Pe = xe.continuePrimaryKey) && Pe.bind(xe), Ne = xe.advance.bind(xe), Ze = function() {
                  throw new Error("Cursor not stopped");
                }, xe.trans = C, xe.stop = xe.continue = xe.continuePrimaryKey = xe.advance = function() {
                  throw new Error("Cursor not started");
                }, xe.fail = Ye(Z), xe.next = function() {
                  var ft = this, dt = 1;
                  return this.start(function() {
                    return dt-- ? ft.continue() : ft.stop();
                  }).then(function() {
                    return ft;
                  });
                }, xe.start = function(ft) {
                  function dt() {
                    if (ee.result) try {
                      ft();
                    } catch (vt) {
                      xe.fail(vt);
                    }
                    else xe.done = !0, xe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, xe.stop();
                  }
                  var _r = new Promise(function(vt, pn) {
                    vt = Ye(vt), ee.onerror = kt(pn), xe.fail = pn, xe.stop = function(go) {
                      xe.stop = xe.continue = xe.continuePrimaryKey = xe.advance = Ze, vt(go);
                    };
                  });
                  return ee.onsuccess = Ye(function(vt) {
                    ee.onsuccess = dt, dt();
                  }), xe.continue = Ce, xe.continuePrimaryKey = Pe, xe.advance = Ne, dt(), _r;
                }, G(xe)) : G(null);
              }, Z);
            });
          }, count: function(T) {
            var C = T.query, A = T.trans, k = C.index, $ = C.range;
            return new Promise(function(M, G) {
              var Z = A.objectStore(x), X = k.isPrimaryKey ? Z : Z.index(k.name), Z = a($), X = Z ? X.count(Z) : X.count();
              X.onsuccess = Ye(function(J) {
                return M(J.target.result);
              }), X.onerror = kt(G);
            });
          } };
        }
        var f, h, v, R = (h = b, v = ii((f = e).objectStoreNames), { schema: { name: f.name, tables: v.map(function(I) {
          return h.objectStore(I);
        }).map(function(I) {
          var w = I.keyPath, C = I.autoIncrement, x = p(w), T = {}, C = { name: I.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: w == null, compound: x, keyPath: w, autoIncrement: C, unique: !0, extractKey: Zr(w) }, indexes: ii(I.indexNames).map(function(A) {
            return I.index(A);
          }).map(function(M) {
            var k = M.name, $ = M.unique, G = M.multiEntry, M = M.keyPath, G = { name: k, compound: p(M), keyPath: M, unique: $, multiEntry: G, extractKey: Zr(M) };
            return T[Mn(M)] = G;
          }), getIndexByKeyPath: function(A) {
            return T[Mn(A)];
          } };
          return T[":id"] = C.primaryKey, w != null && (T[Mn(w)] = C.primaryKey), C;
        }) }, hasGetAll: 0 < v.length && "getAll" in h.objectStore(v[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), b = R.schema, _ = R.hasGetAll, R = b.tables.map(l), g = {};
        return R.forEach(function(I) {
          return g[I.name] = I;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(I) {
          if (!g[I]) throw new Error("Table '".concat(I, "' not found"));
          return g[I];
        }, MIN_KEY: -1 / 0, MAX_KEY: $n(n), schema: b };
      }
      function Wa(e, n, o, a) {
        var l = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (a = Va(n, l, a), e.dbcore.reduce(function(f, h) {
          return h = h.create, s(s({}, f), h(f));
        }, a)) };
      }
      function cr(e, a) {
        var o = a.db, a = Wa(e._middlewares, o, e._deps, a);
        e.core = a.dbcore, e.tables.forEach(function(l) {
          var f = l.name;
          e.core.schema.tables.some(function(h) {
            return h.name === f;
          }) && (l.core = e.core.table(f), e[f] instanceof e.Table && (e[f].core = l.core));
        });
      }
      function fr(e, n, o, a) {
        o.forEach(function(l) {
          var f = a[l];
          n.forEach(function(h) {
            var v = function b(_, R) {
              return ie(_, R) || (_ = P(_)) && b(_, R);
            }(h, l);
            (!v || "value" in v && v.value === void 0) && (h === e.Transaction.prototype || h instanceof e.Transaction ? z(h, l, { get: function() {
              return this.table(l);
            }, set: function(b) {
              Y(this, l, { value: b, writable: !0, configurable: !0, enumerable: !0 });
            } }) : h[l] = new e.Table(l, f));
          });
        });
      }
      function eo(e, n) {
        n.forEach(function(o) {
          for (var a in o) o[a] instanceof e.Table && delete o[a];
        });
      }
      function Ga(e, n) {
        return e._cfg.version - n._cfg.version;
      }
      function Ha(e, n, o, a) {
        var l = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !l.$meta && (l.$meta = Jr("$meta", si("")[0], []), e._storeNames.push("$meta"));
        var f = e._createTransaction("readwrite", e._storeNames, l);
        f.create(o), f._completion.catch(a);
        var h = f._reject.bind(f), v = ce.transless || ce;
        Wt(function() {
          return ce.trans = f, ce.transless = v, n !== 0 ? (cr(e, o), _ = n, ((b = f).storeNames.includes("$meta") ? b.table("$meta").get("version").then(function(R) {
            return R ?? _;
          }) : ne.resolve(_)).then(function(R) {
            return I = R, w = f, x = o, T = [], R = (g = e)._versions, C = g._dbSchema = pr(0, g.idbdb, x), (R = R.filter(function(A) {
              return A._cfg.version >= I;
            })).length !== 0 ? (R.forEach(function(A) {
              T.push(function() {
                var k = C, $ = A._cfg.dbschema;
                hr(g, k, x), hr(g, $, x), C = g._dbSchema = $;
                var M = to(k, $);
                M.add.forEach(function(te) {
                  no(x, te[0], te[1].primKey, te[1].indexes);
                }), M.change.forEach(function(te) {
                  if (te.recreate) throw new U.Upgrade("Not yet support for changing primary key");
                  var ee = x.objectStore(te.name);
                  te.add.forEach(function(re) {
                    return dr(ee, re);
                  }), te.change.forEach(function(re) {
                    ee.deleteIndex(re.name), dr(ee, re);
                  }), te.del.forEach(function(re) {
                    return ee.deleteIndex(re);
                  });
                });
                var G = A._cfg.contentUpgrade;
                if (G && A._cfg.version > I) {
                  cr(g, x), w._memoizedTables = {};
                  var Z = se($);
                  M.del.forEach(function(te) {
                    Z[te] = k[te];
                  }), eo(g, [g.Transaction.prototype]), fr(g, [g.Transaction.prototype], u(Z), Z), w.schema = Z;
                  var X, J = Je(G);
                  return J && xn(), M = ne.follow(function() {
                    var te;
                    (X = G(w)) && J && (te = Gt.bind(null, null), X.then(te, te));
                  }), X && typeof X.then == "function" ? ne.resolve(X) : M.then(function() {
                    return X;
                  });
                }
              }), T.push(function(k) {
                var $, M, G = A._cfg.dbschema;
                $ = G, M = k, [].slice.call(M.db.objectStoreNames).forEach(function(Z) {
                  return $[Z] == null && M.db.deleteObjectStore(Z);
                }), eo(g, [g.Transaction.prototype]), fr(g, [g.Transaction.prototype], g._storeNames, g._dbSchema), w.schema = g._dbSchema;
              }), T.push(function(k) {
                g.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(g.idbdb.version / 10) === A._cfg.version ? (g.idbdb.deleteObjectStore("$meta"), delete g._dbSchema.$meta, g._storeNames = g._storeNames.filter(function($) {
                  return $ !== "$meta";
                })) : k.objectStore("$meta").put(A._cfg.version, "version"));
              });
            }), function A() {
              return T.length ? ne.resolve(T.shift()(w.idbtrans)).then(A) : ne.resolve();
            }().then(function() {
              ai(C, x);
            })) : ne.resolve();
            var g, I, w, x, T, C;
          }).catch(h)) : (u(l).forEach(function(R) {
            no(o, R, l[R].primKey, l[R].indexes);
          }), cr(e, o), void ne.follow(function() {
            return e.on.populate.fire(f);
          }).catch(h));
          var b, _;
        });
      }
      function Ya(e, n) {
        ai(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
        var o = pr(0, e.idbdb, n);
        hr(e, e._dbSchema, n);
        for (var a = 0, l = to(o, e._dbSchema).change; a < l.length; a++) {
          var f = function(h) {
            if (h.change.length || h.recreate) return console.warn("Unable to patch indexes of table ".concat(h.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var v = n.objectStore(h.name);
            h.add.forEach(function(b) {
              me && console.debug("Dexie upgrade patch: Creating missing index ".concat(h.name, ".").concat(b.src)), dr(v, b);
            });
          }(l[a]);
          if (typeof f == "object") return f.value;
        }
      }
      function to(e, n) {
        var o, a = { del: [], add: [], change: [] };
        for (o in e) n[o] || a.del.push(o);
        for (o in n) {
          var l = e[o], f = n[o];
          if (l) {
            var h = { name: o, def: f, recreate: !1, del: [], add: [], change: [] };
            if ("" + (l.primKey.keyPath || "") != "" + (f.primKey.keyPath || "") || l.primKey.auto !== f.primKey.auto) h.recreate = !0, a.change.push(h);
            else {
              var v = l.idxByName, b = f.idxByName, _ = void 0;
              for (_ in v) b[_] || h.del.push(_);
              for (_ in b) {
                var R = v[_], g = b[_];
                R ? R.src !== g.src && h.change.push(g) : h.add.push(g);
              }
              (0 < h.del.length || 0 < h.add.length || 0 < h.change.length) && a.change.push(h);
            }
          } else a.add.push([o, f]);
        }
        return a;
      }
      function no(e, n, o, a) {
        var l = e.db.createObjectStore(n, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return a.forEach(function(f) {
          return dr(l, f);
        }), l;
      }
      function ai(e, n) {
        u(e).forEach(function(o) {
          n.db.objectStoreNames.contains(o) || (me && console.debug("Dexie: Creating missing table", o), no(n, o, e[o].primKey, e[o].indexes));
        });
      }
      function dr(e, n) {
        e.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi });
      }
      function pr(e, n, o) {
        var a = {};
        return B(n.objectStoreNames, 0).forEach(function(l) {
          for (var f = o.objectStore(l), h = zr(oi(_ = f.keyPath), _ || "", !0, !1, !!f.autoIncrement, _ && typeof _ != "string", !0), v = [], b = 0; b < f.indexNames.length; ++b) {
            var R = f.index(f.indexNames[b]), _ = R.keyPath, R = zr(R.name, _, !!R.unique, !!R.multiEntry, !1, _ && typeof _ != "string", !1);
            v.push(R);
          }
          a[l] = Jr(l, h, v);
        }), a;
      }
      function hr(e, n, o) {
        for (var a = o.db.objectStoreNames, l = 0; l < a.length; ++l) {
          var f = a[l], h = o.objectStore(f);
          e._hasGetAll = "getAll" in h;
          for (var v = 0; v < h.indexNames.length; ++v) {
            var b = h.indexNames[v], _ = h.index(b).keyPath, R = typeof _ == "string" ? _ : "[" + B(_).join("+") + "]";
            !n[f] || (_ = n[f].idxByName[R]) && (_.name = b, delete n[f].idxByName[R], n[f].idxByName[b] = _);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && d.WorkerGlobalScope && d instanceof d.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function si(e) {
        return e.split(",").map(function(n, o) {
          var f = n.split(":"), a = (l = f[1]) === null || l === void 0 ? void 0 : l.trim(), l = (n = f[0].trim()).replace(/([&*]|\+\+)/g, ""), f = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return zr(l, f || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), p(f), o === 0, a);
        });
      }
      var Xa = (Tn.prototype._createTableSchema = Jr, Tn.prototype._parseIndexSyntax = si, Tn.prototype._parseStoresSpec = function(e, n) {
        var o = this;
        u(e).forEach(function(a) {
          if (e[a] !== null) {
            var l = o._parseIndexSyntax(e[a]), f = l.shift();
            if (!f) throw new U.Schema("Invalid schema for table " + a + ": " + e[a]);
            if (f.unique = !0, f.multi) throw new U.Schema("Primary key cannot be multiEntry*");
            l.forEach(function(h) {
              if (h.auto) throw new U.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!h.keyPath) throw new U.Schema("Index must have a name and cannot be an empty string");
            }), l = o._createTableSchema(a, f, l), n[a] = l;
          }
        });
      }, Tn.prototype.stores = function(o) {
        var n = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? m(this._cfg.storesSource, o) : o;
        var o = n._versions, a = {}, l = {};
        return o.forEach(function(f) {
          m(a, f._cfg.storesSource), l = f._cfg.dbschema = {}, f._parseStoresSpec(a, l);
        }), n._dbSchema = l, eo(n, [n._allTables, n, n.Transaction.prototype]), fr(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], u(l), l), n._storeNames = u(l), this;
      }, Tn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = _e(this._cfg.contentUpgrade || O, e), this;
      }, Tn);
      function Tn() {
      }
      function ro(e, n) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Bt(or, { addons: [], indexedDB: e, IDBKeyRange: n })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function oo(e) {
        return e && typeof e.databases == "function";
      }
      function io(e) {
        return Wt(function() {
          return ce.letThrough = !0, e();
        });
      }
      function ao(e) {
        return !("from" in e);
      }
      var ct = function(e, n) {
        if (!this) {
          var o = new ct();
          return e && "d" in e && m(o, e), o;
        }
        m(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? n : e } : { d: 0 });
      };
      function Bn(e, n, o) {
        var a = De(n, o);
        if (!isNaN(a)) {
          if (0 < a) throw RangeError();
          if (ao(e)) return m(e, { from: n, to: o, d: 1 });
          var l = e.l, a = e.r;
          if (De(o, e.from) < 0) return l ? Bn(l, n, o) : e.l = { from: n, to: o, d: 1, l: null, r: null }, ui(e);
          if (0 < De(n, e.to)) return a ? Bn(a, n, o) : e.r = { from: n, to: o, d: 1, l: null, r: null }, ui(e);
          De(n, e.from) < 0 && (e.from = n, e.l = null, e.d = a ? a.d + 1 : 1), 0 < De(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, l && !e.l && Kn(e, l), a && o && Kn(e, a);
        }
      }
      function Kn(e, n) {
        ao(n) || function o(a, b) {
          var f = b.from, h = b.to, v = b.l, b = b.r;
          Bn(a, f, h), v && o(a, v), b && o(a, b);
        }(e, n);
      }
      function li(e, n) {
        var o = mr(n), a = o.next();
        if (a.done) return !1;
        for (var l = a.value, f = mr(e), h = f.next(l.from), v = h.value; !a.done && !h.done; ) {
          if (De(v.from, l.to) <= 0 && 0 <= De(v.to, l.from)) return !0;
          De(l.from, v.from) < 0 ? l = (a = o.next(v.from)).value : v = (h = f.next(l.from)).value;
        }
        return !1;
      }
      function mr(e) {
        var n = ao(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var a = 0 < arguments.length; n; ) switch (n.s) {
            case 0:
              if (n.s = 1, a) for (; n.n.l && De(o, n.n.from) < 0; ) n = { up: n, n: n.n.l, s: 1 };
              else for (; n.n.l; ) n = { up: n, n: n.n.l, s: 1 };
            case 1:
              if (n.s = 2, !a || De(o, n.n.to) <= 0) return { value: n.n, done: !1 };
            case 2:
              if (n.n.r) {
                n.s = 3, n = { up: n, n: n.n.r, s: 0 };
                continue;
              }
            case 3:
              n = n.up;
          }
          return { done: !0 };
        } };
      }
      function ui(e) {
        var n, o, a = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), l = 1 < a ? "r" : a < -1 ? "l" : "";
        l && (n = l == "r" ? "l" : "r", o = s({}, e), a = e[l], e.from = a.from, e.to = a.to, e[l] = a[l], o[l] = a[n], (e[n] = o).d = ci(o)), e.d = ci(e);
      }
      function ci(o) {
        var n = o.r, o = o.l;
        return (n ? o ? Math.max(n.d, o.d) : n.d : o ? o.d : 0) + 1;
      }
      function vr(e, n) {
        return u(n).forEach(function(o) {
          e[o] ? Kn(e[o], n[o]) : e[o] = function a(l) {
            var f, h, v = {};
            for (f in l) L(l, f) && (h = l[f], v[f] = !h || typeof h != "object" || ue.has(h.constructor) ? h : a(h));
            return v;
          }(n[o]);
        }), e;
      }
      function so(e, n) {
        return e.all || n.all || Object.keys(e).some(function(o) {
          return n[o] && li(n[o], e[o]);
        });
      }
      j(ct.prototype, ((Et = { add: function(e) {
        return Kn(this, e), this;
      }, addKey: function(e) {
        return Bn(this, e, e), this;
      }, addKeys: function(e) {
        var n = this;
        return e.forEach(function(o) {
          return Bn(n, o, o);
        }), this;
      }, hasKey: function(e) {
        var n = mr(this).next(e).value;
        return n && De(n.from, e) <= 0 && 0 <= De(n.to, e);
      } })[He] = function() {
        return mr(this);
      }, Et));
      var fn = {}, lo = {}, uo = !1;
      function yr(e) {
        vr(lo, e), uo || (uo = !0, setTimeout(function() {
          uo = !1, co(lo, !(lo = {}));
        }, 0));
      }
      function co(e, n) {
        n === void 0 && (n = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var a = 0, l = Object.values(fn); a < l.length; a++) fi(h = l[a], e, o, n);
        else for (var f in e) {
          var h, v = /^idb\:\/\/(.*)\/(.*)\//.exec(f);
          v && (f = v[1], v = v[2], (h = fn["idb://".concat(f, "/").concat(v)]) && fi(h, e, o, n));
        }
        o.forEach(function(b) {
          return b();
        });
      }
      function fi(e, n, o, a) {
        for (var l = [], f = 0, h = Object.entries(e.queries.query); f < h.length; f++) {
          for (var v = h[f], b = v[0], _ = [], R = 0, g = v[1]; R < g.length; R++) {
            var I = g[R];
            so(n, I.obsSet) ? I.subscribers.forEach(function(C) {
              return o.add(C);
            }) : a && _.push(I);
          }
          a && l.push([b, _]);
        }
        if (a) for (var w = 0, x = l; w < x.length; w++) {
          var T = x[w], b = T[0], _ = T[1];
          e.queries.query[b] = _;
        }
      }
      function Qa(e) {
        var n = e._state, o = e._deps.indexedDB;
        if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
          return n.dbOpenError ? tt(n.dbOpenError) : e;
        });
        n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
        var a = n.openCanceller, l = Math.round(10 * e.verno), f = !1;
        function h() {
          if (n.openCanceller !== a) throw new U.DatabaseClosed("db.open() was cancelled");
        }
        function v() {
          return new ne(function(I, w) {
            if (h(), !o) throw new U.MissingAPI();
            var x = e.name, T = n.autoSchema || !l ? o.open(x) : o.open(x, l);
            if (!T) throw new U.MissingAPI();
            T.onerror = kt(w), T.onblocked = Ye(e._fireOnBlocked), T.onupgradeneeded = Ye(function(C) {
              var A;
              R = T.transaction, n.autoSchema && !e._options.allowEmptyDB ? (T.onerror = jn, R.abort(), T.result.close(), (A = o.deleteDatabase(x)).onsuccess = A.onerror = Ye(function() {
                w(new U.NoSuchDatabase("Database ".concat(x, " doesnt exist")));
              })) : (R.onerror = kt(w), C = C.oldVersion > Math.pow(2, 62) ? 0 : C.oldVersion, g = C < 1, e.idbdb = T.result, f && Ya(e, R), Ha(e, C / 10, R, w));
            }, w), T.onsuccess = Ye(function() {
              R = null;
              var C, A, k, $, M, G = e.idbdb = T.result, Z = B(G.objectStoreNames);
              if (0 < Z.length) try {
                var X = G.transaction(($ = Z).length === 1 ? $[0] : $, "readonly");
                if (n.autoSchema) A = G, k = X, (C = e).verno = A.version / 10, k = C._dbSchema = pr(0, A, k), C._storeNames = B(A.objectStoreNames, 0), fr(C, [C._allTables], u(k), k);
                else if (hr(e, e._dbSchema, X), ((M = to(pr(0, (M = e).idbdb, X), M._dbSchema)).add.length || M.change.some(function(J) {
                  return J.add.length || J.change.length;
                })) && !f) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), G.close(), l = G.version + 1, f = !0, I(v());
                cr(e, X);
              } catch {
              }
              Nn.push(e), G.onversionchange = Ye(function(J) {
                n.vcFired = !0, e.on("versionchange").fire(J);
              }), G.onclose = Ye(function(J) {
                e.on("close").fire(J);
              }), g && (M = e._deps, X = x, G = M.indexedDB, M = M.IDBKeyRange, oo(G) || X === or || ro(G, M).put({ name: X }).catch(O)), I();
            }, w);
          }).catch(function(I) {
            switch (I?.name) {
              case "UnknownError":
                if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), v();
                break;
              case "VersionError":
                if (0 < l) return l = 0, v();
            }
            return ne.reject(I);
          });
        }
        var b, _ = n.dbReadyResolve, R = null, g = !1;
        return ne.race([a, (typeof navigator > "u" ? ne.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(I) {
          function w() {
            return indexedDB.databases().finally(I);
          }
          b = setInterval(w, 100), w();
        }).finally(function() {
          return clearInterval(b);
        }) : Promise.resolve()).then(v)]).then(function() {
          return h(), n.onReadyBeingFired = [], ne.resolve(io(function() {
            return e.on.ready.fire(e.vip);
          })).then(function I() {
            if (0 < n.onReadyBeingFired.length) {
              var w = n.onReadyBeingFired.reduce(_e, O);
              return n.onReadyBeingFired = [], ne.resolve(io(function() {
                return w(e.vip);
              })).then(I);
            }
          });
        }).finally(function() {
          n.openCanceller === a && (n.onReadyBeingFired = null, n.isBeingOpened = !1);
        }).catch(function(I) {
          n.dbOpenError = I;
          try {
            R && R.abort();
          } catch {
          }
          return a === n.openCanceller && e._close(), tt(I);
        }).finally(function() {
          n.openComplete = !0, _();
        }).then(function() {
          var I;
          return g && (I = {}, e.tables.forEach(function(w) {
            w.schema.indexes.forEach(function(x) {
              x.name && (I["idb://".concat(e.name, "/").concat(w.name, "/").concat(x.name)] = new ct(-1 / 0, [[[]]]));
            }), I["idb://".concat(e.name, "/").concat(w.name, "/")] = I["idb://".concat(e.name, "/").concat(w.name, "/:dels")] = new ct(-1 / 0, [[[]]]);
          }), Xt(Fn).fire(I), co(I, !0)), e;
        });
      }
      function fo(e) {
        function n(f) {
          return e.next(f);
        }
        var o = l(n), a = l(function(f) {
          return e.throw(f);
        });
        function l(f) {
          return function(b) {
            var v = f(b), b = v.value;
            return v.done ? b : b && typeof b.then == "function" ? b.then(o, a) : p(b) ? Promise.all(b).then(o, a) : o(b);
          };
        }
        return l(n)();
      }
      function gr(e, n, o) {
        for (var a = p(e) ? e.slice() : [e], l = 0; l < o; ++l) a.push(n);
        return a;
      }
      var za = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema, l = {}, f = [];
          function h(g, I, w) {
            var x = Mn(g), T = l[x] = l[x] || [], C = g == null ? 0 : typeof g == "string" ? 1 : g.length, A = 0 < I, A = s(s({}, w), { name: A ? "".concat(x, "(virtual-from:").concat(w.name, ")") : w.name, lowLevelIndex: w, isVirtual: A, keyTail: I, keyLength: C, extractKey: Zr(g), unique: !A && w.unique });
            return T.push(A), A.isPrimaryKey || f.push(A), 1 < C && h(C === 2 ? g[0] : g.slice(0, C - 1), I + 1, w), T.sort(function(k, $) {
              return k.keyTail - $.keyTail;
            }), A;
          }
          n = h(a.primaryKey.keyPath, 0, a.primaryKey), l[":id"] = [n];
          for (var v = 0, b = a.indexes; v < b.length; v++) {
            var _ = b[v];
            h(_.keyPath, 0, _);
          }
          function R(g) {
            var I, w = g.query.index;
            return w.isVirtual ? s(s({}, g), { query: { index: w.lowLevelIndex, range: (I = g.query.range, w = w.keyTail, { type: I.type === 1 ? 2 : I.type, lower: gr(I.lower, I.lowerOpen ? e.MAX_KEY : e.MIN_KEY, w), lowerOpen: !0, upper: gr(I.upper, I.upperOpen ? e.MIN_KEY : e.MAX_KEY, w), upperOpen: !0 }) } }) : g;
          }
          return s(s({}, o), { schema: s(s({}, a), { primaryKey: n, indexes: f, getIndexByKeyPath: function(g) {
            return (g = l[Mn(g)]) && g[0];
          } }), count: function(g) {
            return o.count(R(g));
          }, query: function(g) {
            return o.query(R(g));
          }, openCursor: function(g) {
            var I = g.query.index, w = I.keyTail, x = I.isVirtual, T = I.keyLength;
            return x ? o.openCursor(R(g)).then(function(A) {
              return A && C(A);
            }) : o.openCursor(g);
            function C(A) {
              return Object.create(A, { continue: { value: function(k) {
                k != null ? A.continue(gr(k, g.reverse ? e.MAX_KEY : e.MIN_KEY, w)) : g.unique ? A.continue(A.key.slice(0, T).concat(g.reverse ? e.MIN_KEY : e.MAX_KEY, w)) : A.continue();
              } }, continuePrimaryKey: { value: function(k, $) {
                A.continuePrimaryKey(gr(k, e.MAX_KEY, w), $);
              } }, primaryKey: { get: function() {
                return A.primaryKey;
              } }, key: { get: function() {
                var k = A.key;
                return T === 1 ? k[0] : k.slice(0, T);
              } }, value: { get: function() {
                return A.value;
              } } });
            }
          } });
        } });
      } };
      function po(e, n, o, a) {
        return o = o || {}, a = a || "", u(e).forEach(function(l) {
          var f, h, v;
          L(n, l) ? (f = e[l], h = n[l], typeof f == "object" && typeof h == "object" && f && h ? (v = Be(f)) !== Be(h) ? o[a + l] = n[l] : v === "Object" ? po(f, h, o, a + l + ".") : f !== h && (o[a + l] = n[l]) : f !== h && (o[a + l] = n[l])) : o[a + l] = void 0;
        }), u(n).forEach(function(l) {
          L(e, l) || (o[a + l] = n[l]);
        }), o;
      }
      function ho(e, n) {
        return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey);
      }
      var Ja = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema.primaryKey;
          return s(s({}, o), { mutate: function(l) {
            var f = ce.trans, h = f.table(n).hook, v = h.deleting, b = h.creating, _ = h.updating;
            switch (l.type) {
              case "add":
                if (b.fire === O) break;
                return f._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "put":
                if (b.fire === O && _.fire === O) break;
                return f._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "delete":
                if (v.fire === O) break;
                return f._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "deleteRange":
                if (v.fire === O) break;
                return f._promise("readwrite", function() {
                  return function g(I, w, x) {
                    return o.query({ trans: I, values: !1, query: { index: a, range: w }, limit: x }).then(function(T) {
                      var C = T.result;
                      return R({ type: "delete", keys: C, trans: I }).then(function(A) {
                        return 0 < A.numFailures ? Promise.reject(A.failures[0]) : C.length < x ? { failures: [], numFailures: 0, lastResult: void 0 } : g(I, s(s({}, w), { lower: C[C.length - 1], lowerOpen: !0 }), x);
                      });
                    });
                  }(l.trans, l.range, 1e4);
                }, !0);
            }
            return o.mutate(l);
            function R(g) {
              var I, w, x, T = ce.trans, C = g.keys || ho(a, g);
              if (!C) throw new Error("Keys missing");
              return (g = g.type === "add" || g.type === "put" ? s(s({}, g), { keys: C }) : s({}, g)).type !== "delete" && (g.values = c([], g.values)), g.keys && (g.keys = c([], g.keys)), I = o, x = C, ((w = g).type === "add" ? Promise.resolve([]) : I.getMany({ trans: w.trans, keys: x, cache: "immutable" })).then(function(A) {
                var k = C.map(function($, M) {
                  var G, Z, X, J = A[M], te = { onerror: null, onsuccess: null };
                  return g.type === "delete" ? v.fire.call(te, $, J, T) : g.type === "add" || J === void 0 ? (G = b.fire.call(te, $, g.values[M], T), $ == null && G != null && (g.keys[M] = $ = G, a.outbound || ve(g.values[M], a.keyPath, $))) : (G = po(J, g.values[M]), (Z = _.fire.call(te, G, $, J, T)) && (X = g.values[M], Object.keys(Z).forEach(function(ee) {
                    L(X, ee) ? X[ee] = Z[ee] : ve(X, ee, Z[ee]);
                  }))), te;
                });
                return o.mutate(g).then(function($) {
                  for (var M = $.failures, G = $.results, Z = $.numFailures, $ = $.lastResult, X = 0; X < C.length; ++X) {
                    var J = (G || C)[X], te = k[X];
                    J == null ? te.onerror && te.onerror(M[X]) : te.onsuccess && te.onsuccess(g.type === "put" && A[X] ? g.values[X] : J);
                  }
                  return { failures: M, results: G, numFailures: Z, lastResult: $ };
                }).catch(function($) {
                  return k.forEach(function(M) {
                    return M.onerror && M.onerror($);
                  }), Promise.reject($);
                });
              });
            }
          } });
        } });
      } };
      function di(e, n, o) {
        try {
          if (!n || n.keys.length < e.length) return null;
          for (var a = [], l = 0, f = 0; l < n.keys.length && f < e.length; ++l) De(n.keys[l], e[f]) === 0 && (a.push(o ? be(n.values[l]) : n.values[l]), ++f);
          return a.length === e.length ? a : null;
        } catch {
          return null;
        }
      }
      var Za = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(n) {
          var o = e.table(n);
          return s(s({}, o), { getMany: function(a) {
            if (!a.cache) return o.getMany(a);
            var l = di(a.keys, a.trans._cache, a.cache === "clone");
            return l ? ne.resolve(l) : o.getMany(a).then(function(f) {
              return a.trans._cache = { keys: a.keys, values: a.cache === "clone" ? be(f) : f }, f;
            });
          }, mutate: function(a) {
            return a.type !== "add" && (a.trans._cache = null), o.mutate(a);
          } });
        } };
      } };
      function pi(e, n) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound;
      }
      function hi(e, n) {
        switch (e) {
          case "query":
            return n.values && !n.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var es = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var n = e.schema.name, o = new ct(e.MIN_KEY, e.MAX_KEY);
        return s(s({}, e), { transaction: function(a, l, f) {
          if (ce.subscr && l !== "readonly") throw new U.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ce.querier));
          return e.transaction(a, l, f);
        }, table: function(a) {
          var l = e.table(a), f = l.schema, h = f.primaryKey, g = f.indexes, v = h.extractKey, b = h.outbound, _ = h.autoIncrement && g.filter(function(w) {
            return w.compound && w.keyPath.includes(h.keyPath);
          }), R = s(s({}, l), { mutate: function(w) {
            function x(ee) {
              return ee = "idb://".concat(n, "/").concat(a, "/").concat(ee), $[ee] || ($[ee] = new ct());
            }
            var T, C, A, k = w.trans, $ = w.mutatedParts || (w.mutatedParts = {}), M = x(""), G = x(":dels"), Z = w.type, te = w.type === "deleteRange" ? [w.range] : w.type === "delete" ? [w.keys] : w.values.length < 50 ? [ho(h, w).filter(function(ee) {
              return ee;
            }), w.values] : [], X = te[0], J = te[1], te = w.trans._cache;
            return p(X) ? (M.addKeys(X), (te = Z === "delete" || X.length === J.length ? di(X, te) : null) || G.addKeys(X), (te || J) && (T = x, C = te, A = J, f.indexes.forEach(function(ee) {
              var re = T(ee.name || "");
              function Ce(Ne) {
                return Ne != null ? ee.extractKey(Ne) : null;
              }
              function Pe(Ne) {
                return ee.multiEntry && p(Ne) ? Ne.forEach(function(Ze) {
                  return re.addKey(Ze);
                }) : re.addKey(Ne);
              }
              (C || A).forEach(function(Ne, ft) {
                var xe = C && Ce(C[ft]), ft = A && Ce(A[ft]);
                De(xe, ft) !== 0 && (xe != null && Pe(xe), ft != null && Pe(ft));
              });
            }))) : X ? (J = { from: (J = X.lower) !== null && J !== void 0 ? J : e.MIN_KEY, to: (J = X.upper) !== null && J !== void 0 ? J : e.MAX_KEY }, G.add(J), M.add(J)) : (M.add(o), G.add(o), f.indexes.forEach(function(ee) {
              return x(ee.name).add(o);
            })), l.mutate(w).then(function(ee) {
              return !X || w.type !== "add" && w.type !== "put" || (M.addKeys(ee.results), _ && _.forEach(function(re) {
                for (var Ce = w.values.map(function(xe) {
                  return re.extractKey(xe);
                }), Pe = re.keyPath.findIndex(function(xe) {
                  return xe === h.keyPath;
                }), Ne = 0, Ze = ee.results.length; Ne < Ze; ++Ne) Ce[Ne][Pe] = ee.results[Ne];
                x(re.name).addKeys(Ce);
              })), k.mutatedParts = vr(k.mutatedParts || {}, $), ee;
            });
          } }), g = function(x) {
            var T = x.query, x = T.index, T = T.range;
            return [x, new ct((x = T.lower) !== null && x !== void 0 ? x : e.MIN_KEY, (T = T.upper) !== null && T !== void 0 ? T : e.MAX_KEY)];
          }, I = { get: function(w) {
            return [h, new ct(w.key)];
          }, getMany: function(w) {
            return [h, new ct().addKeys(w.keys)];
          }, count: g, query: g, openCursor: g };
          return u(I).forEach(function(w) {
            R[w] = function(x) {
              var T = ce.subscr, C = !!T, A = pi(ce, l) && hi(w, x) ? x.obsSet = {} : T;
              if (C) {
                var k = function(J) {
                  return J = "idb://".concat(n, "/").concat(a, "/").concat(J), A[J] || (A[J] = new ct());
                }, $ = k(""), M = k(":dels"), T = I[w](x), C = T[0], T = T[1];
                if ((w === "query" && C.isPrimaryKey && !x.values ? M : k(C.name || "")).add(T), !C.isPrimaryKey) {
                  if (w !== "count") {
                    var G = w === "query" && b && x.values && l.query(s(s({}, x), { values: !1 }));
                    return l[w].apply(this, arguments).then(function(J) {
                      if (w === "query") {
                        if (b && x.values) return G.then(function(Ce) {
                          return Ce = Ce.result, $.addKeys(Ce), J;
                        });
                        var te = x.values ? J.result.map(v) : J.result;
                        (x.values ? $ : M).addKeys(te);
                      } else if (w === "openCursor") {
                        var ee = J, re = x.values;
                        return ee && Object.create(ee, { key: { get: function() {
                          return M.addKey(ee.primaryKey), ee.key;
                        } }, primaryKey: { get: function() {
                          var Ce = ee.primaryKey;
                          return M.addKey(Ce), Ce;
                        } }, value: { get: function() {
                          return re && $.addKey(ee.primaryKey), ee.value;
                        } } });
                      }
                      return J;
                    });
                  }
                  M.add(o);
                }
              }
              return l[w].apply(this, arguments);
            };
          }), R;
        } });
      } };
      function mi(e, n, o) {
        if (o.numFailures === 0) return n;
        if (n.type === "deleteRange") return null;
        var a = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
        return o.numFailures === a ? null : (n = s({}, n), p(n.keys) && (n.keys = n.keys.filter(function(l, f) {
          return !(f in o.failures);
        })), "values" in n && p(n.values) && (n.values = n.values.filter(function(l, f) {
          return !(f in o.failures);
        })), n);
      }
      function mo(e, n) {
        return o = e, ((a = n).lower === void 0 || (a.lowerOpen ? 0 < De(o, a.lower) : 0 <= De(o, a.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? De(e, n.upper) < 0 : De(e, n.upper) <= 0));
        var o, a;
      }
      function vi(e, n, I, a, l, f) {
        if (!I || I.length === 0) return e;
        var h = n.query.index, v = h.multiEntry, b = n.query.range, _ = a.schema.primaryKey.extractKey, R = h.extractKey, g = (h.lowLevelIndex || h).extractKey, I = I.reduce(function(w, x) {
          var T = w, C = [];
          if (x.type === "add" || x.type === "put") for (var A = new ct(), k = x.values.length - 1; 0 <= k; --k) {
            var $, M = x.values[k], G = _(M);
            A.hasKey(G) || ($ = R(M), (v && p($) ? $.some(function(ee) {
              return mo(ee, b);
            }) : mo($, b)) && (A.addKey(G), C.push(M)));
          }
          switch (x.type) {
            case "add":
              var Z = new ct().addKeys(n.values ? w.map(function(re) {
                return _(re);
              }) : w), T = w.concat(n.values ? C.filter(function(re) {
                return re = _(re), !Z.hasKey(re) && (Z.addKey(re), !0);
              }) : C.map(function(re) {
                return _(re);
              }).filter(function(re) {
                return !Z.hasKey(re) && (Z.addKey(re), !0);
              }));
              break;
            case "put":
              var X = new ct().addKeys(x.values.map(function(re) {
                return _(re);
              }));
              T = w.filter(function(re) {
                return !X.hasKey(n.values ? _(re) : re);
              }).concat(n.values ? C : C.map(function(re) {
                return _(re);
              }));
              break;
            case "delete":
              var J = new ct().addKeys(x.keys);
              T = w.filter(function(re) {
                return !J.hasKey(n.values ? _(re) : re);
              });
              break;
            case "deleteRange":
              var te = x.range;
              T = w.filter(function(re) {
                return !mo(_(re), te);
              });
          }
          return T;
        }, e);
        return I === e ? e : (I.sort(function(w, x) {
          return De(g(w), g(x)) || De(_(w), _(x));
        }), n.limit && n.limit < 1 / 0 && (I.length > n.limit ? I.length = n.limit : e.length === n.limit && I.length < n.limit && (l.dirty = !0)), f ? Object.freeze(I) : I);
      }
      function yi(e, n) {
        return De(e.lower, n.lower) === 0 && De(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen;
      }
      function ts(e, n) {
        return function(o, a, l, f) {
          if (o === void 0) return a !== void 0 ? -1 : 0;
          if (a === void 0) return 1;
          if ((a = De(o, a)) === 0) {
            if (l && f) return 0;
            if (l) return 1;
            if (f) return -1;
          }
          return a;
        }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(o, a, l, f) {
          if (o === void 0) return a !== void 0 ? 1 : 0;
          if (a === void 0) return -1;
          if ((a = De(o, a)) === 0) {
            if (l && f) return 0;
            if (l) return -1;
            if (f) return 1;
          }
          return a;
        }(e.upper, n.upper, e.upperOpen, n.upperOpen);
      }
      function ns(e, n, o, a) {
        e.subscribers.add(o), a.addEventListener("abort", function() {
          var l, f;
          e.subscribers.delete(o), e.subscribers.size === 0 && (l = e, f = n, setTimeout(function() {
            l.subscribers.size === 0 && Se(f, l);
          }, 3e3));
        });
      }
      var rs = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var n = e.schema.name;
        return s(s({}, e), { transaction: function(o, a, l) {
          var f, h, v = e.transaction(o, a, l);
          return a === "readwrite" && (h = (f = new AbortController()).signal, l = function(b) {
            return function() {
              if (f.abort(), a === "readwrite") {
                for (var _ = /* @__PURE__ */ new Set(), R = 0, g = o; R < g.length; R++) {
                  var I = g[R], w = fn["idb://".concat(n, "/").concat(I)];
                  if (w) {
                    var x = e.table(I), T = w.optimisticOps.filter(function(re) {
                      return re.trans === v;
                    });
                    if (v._explicit && b && v.mutatedParts) for (var C = 0, A = Object.values(w.queries.query); C < A.length; C++) for (var k = 0, $ = (Z = A[C]).slice(); k < $.length; k++) so((X = $[k]).obsSet, v.mutatedParts) && (Se(Z, X), X.subscribers.forEach(function(re) {
                      return _.add(re);
                    }));
                    else if (0 < T.length) {
                      w.optimisticOps = w.optimisticOps.filter(function(re) {
                        return re.trans !== v;
                      });
                      for (var M = 0, G = Object.values(w.queries.query); M < G.length; M++) for (var Z, X, J, te = 0, ee = (Z = G[M]).slice(); te < ee.length; te++) (X = ee[te]).res != null && v.mutatedParts && (b && !X.dirty ? (J = Object.isFrozen(X.res), J = vi(X.res, X.req, T, x, X, J), X.dirty ? (Se(Z, X), X.subscribers.forEach(function(re) {
                        return _.add(re);
                      })) : J !== X.res && (X.res = J, X.promise = ne.resolve({ result: J }))) : (X.dirty && Se(Z, X), X.subscribers.forEach(function(re) {
                        return _.add(re);
                      })));
                    }
                  }
                }
                _.forEach(function(re) {
                  return re();
                });
              }
            };
          }, v.addEventListener("abort", l(!1), { signal: h }), v.addEventListener("error", l(!1), { signal: h }), v.addEventListener("complete", l(!0), { signal: h })), v;
        }, table: function(o) {
          var a = e.table(o), l = a.schema.primaryKey;
          return s(s({}, a), { mutate: function(f) {
            var h = ce.trans;
            if (l.outbound || h.db._options.cache === "disabled" || h.explicit || h.idbtrans.mode !== "readwrite") return a.mutate(f);
            var v = fn["idb://".concat(n, "/").concat(o)];
            return v ? (h = a.mutate(f), f.type !== "add" && f.type !== "put" || !(50 <= f.values.length || ho(l, f).some(function(b) {
              return b == null;
            })) ? (v.optimisticOps.push(f), f.mutatedParts && yr(f.mutatedParts), h.then(function(b) {
              0 < b.numFailures && (Se(v.optimisticOps, f), (b = mi(0, f, b)) && v.optimisticOps.push(b), f.mutatedParts && yr(f.mutatedParts));
            }), h.catch(function() {
              Se(v.optimisticOps, f), f.mutatedParts && yr(f.mutatedParts);
            })) : h.then(function(b) {
              var _ = mi(0, s(s({}, f), { values: f.values.map(function(R, g) {
                var I;
                return b.failures[g] || (R = (I = l.keyPath) !== null && I !== void 0 && I.includes(".") ? be(R) : s({}, R), ve(R, l.keyPath, b.results[g])), R;
              }) }), b);
              v.optimisticOps.push(_), queueMicrotask(function() {
                return f.mutatedParts && yr(f.mutatedParts);
              });
            }), h) : a.mutate(f);
          }, query: function(f) {
            if (!pi(ce, a) || !hi("query", f)) return a.query(f);
            var h = ((_ = ce.trans) === null || _ === void 0 ? void 0 : _.db._options.cache) === "immutable", g = ce, v = g.requery, b = g.signal, _ = function(x, T, C, A) {
              var k = fn["idb://".concat(x, "/").concat(T)];
              if (!k) return [];
              if (!(T = k.queries[C])) return [null, !1, k, null];
              var $ = T[(A.query ? A.query.index.name : null) || ""];
              if (!$) return [null, !1, k, null];
              switch (C) {
                case "query":
                  var M = $.find(function(G) {
                    return G.req.limit === A.limit && G.req.values === A.values && yi(G.req.query.range, A.query.range);
                  });
                  return M ? [M, !0, k, $] : [$.find(function(G) {
                    return ("limit" in G.req ? G.req.limit : 1 / 0) >= A.limit && (!A.values || G.req.values) && ts(G.req.query.range, A.query.range);
                  }), !1, k, $];
                case "count":
                  return M = $.find(function(G) {
                    return yi(G.req.query.range, A.query.range);
                  }), [M, !!M, k, $];
              }
            }(n, o, "query", f), R = _[0], g = _[1], I = _[2], w = _[3];
            return R && g ? R.obsSet = f.obsSet : (g = a.query(f).then(function(x) {
              var T = x.result;
              if (R && (R.res = T), h) {
                for (var C = 0, A = T.length; C < A; ++C) Object.freeze(T[C]);
                Object.freeze(T);
              } else x.result = be(T);
              return x;
            }).catch(function(x) {
              return w && R && Se(w, R), Promise.reject(x);
            }), R = { obsSet: f.obsSet, promise: g, subscribers: /* @__PURE__ */ new Set(), type: "query", req: f, dirty: !1 }, w ? w.push(R) : (w = [R], (I = I || (fn["idb://".concat(n, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[f.query.index.name || ""] = w)), ns(R, w, v, b), R.promise.then(function(x) {
              return { result: vi(x.result, f, I?.optimisticOps, a, R, h) };
            });
          } });
        } });
      } };
      function br(e, n) {
        return new Proxy(e, { get: function(o, a, l) {
          return a === "db" ? n : Reflect.get(o, a, l);
        } });
      }
      var Bt = (nt.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new U.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new U.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var n = this._versions, o = n.filter(function(a) {
          return a._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), n.push(o), n.sort(Ga), o.stores({}), this._state.autoSchema = !1, o);
      }, nt.prototype._whenReady = function(e) {
        var n = this;
        return this.idbdb && (this._state.openComplete || ce.letThrough || this._vip) ? e() : new ne(function(o, a) {
          if (n._state.openComplete) return a(new U.DatabaseClosed(n._state.dbOpenError));
          if (!n._state.isBeingOpened) {
            if (!n._state.autoOpen) return void a(new U.DatabaseClosed());
            n.open().catch(O);
          }
          n._state.dbReadyPromise.then(o, a);
        }).then(e);
      }, nt.prototype.use = function(e) {
        var n = e.stack, o = e.create, a = e.level, l = e.name;
        return l && this.unuse({ stack: n, name: l }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({ stack: n, create: o, level: a ?? 10, name: l }), e.sort(function(f, h) {
          return f.level - h.level;
        }), this;
      }, nt.prototype.unuse = function(e) {
        var n = e.stack, o = e.name, a = e.create;
        return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(l) {
          return a ? l.create !== a : !!o && l.name !== o;
        })), this;
      }, nt.prototype.open = function() {
        var e = this;
        return ln(mt, function() {
          return Qa(e);
        });
      }, nt.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, n = Nn.indexOf(this);
        if (0 <= n && Nn.splice(n, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new ne(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new ne(function(o, a) {
          e.cancelOpen = a;
        }));
      }, nt.prototype.close = function(o) {
        var n = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        n ? (o.isBeingOpened && o.cancelOpen(new U.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new U.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, nt.prototype.delete = function(e) {
        var n = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", a = this._state;
        return new ne(function(l, f) {
          function h() {
            n.close(e);
            var v = n._deps.indexedDB.deleteDatabase(n.name);
            v.onsuccess = Ye(function() {
              var b, _, R;
              b = n._deps, _ = n.name, R = b.indexedDB, b = b.IDBKeyRange, oo(R) || _ === or || ro(R, b).delete(_).catch(O), l();
            }), v.onerror = kt(f), v.onblocked = n._fireOnBlocked;
          }
          if (o) throw new U.InvalidArgument("Invalid closeOptions argument to db.delete()");
          a.isBeingOpened ? a.dbReadyPromise.then(h) : h();
        });
      }, nt.prototype.backendDB = function() {
        return this.idbdb;
      }, nt.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, nt.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, nt.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, nt.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(nt.prototype, "tables", { get: function() {
        var e = this;
        return u(this._allTables).map(function(n) {
          return e._allTables[n];
        });
      }, enumerable: !1, configurable: !0 }), nt.prototype.transaction = function() {
        var e = (function(n, o, a) {
          var l = arguments.length;
          if (l < 2) throw new U.InvalidArgument("Too few arguments");
          for (var f = new Array(l - 1); --l; ) f[l - 1] = arguments[l];
          return a = f.pop(), [n, we(f), a];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, nt.prototype._transaction = function(e, n, o) {
        var a = this, l = ce.trans;
        l && l.db === this && e.indexOf("!") === -1 || (l = null);
        var f, h, v = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (h = n.map(function(_) {
            if (_ = _ instanceof a.Table ? _.name : _, typeof _ != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return _;
          }), e == "r" || e === Gr) f = Gr;
          else {
            if (e != "rw" && e != Hr) throw new U.InvalidArgument("Invalid transaction mode: " + e);
            f = Hr;
          }
          if (l) {
            if (l.mode === Gr && f === Hr) {
              if (!v) throw new U.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              l = null;
            }
            l && h.forEach(function(_) {
              if (l && l.storeNames.indexOf(_) === -1) {
                if (!v) throw new U.SubTransaction("Table " + _ + " not included in parent transaction.");
                l = null;
              }
            }), v && l && !l.active && (l = null);
          }
        } catch (_) {
          return l ? l._promise(null, function(R, g) {
            g(_);
          }) : tt(_);
        }
        var b = (function _(R, g, I, w, x) {
          return ne.resolve().then(function() {
            var T = ce.transless || ce, C = R._createTransaction(g, I, R._dbSchema, w);
            if (C.explicit = !0, T = { trans: C, transless: T }, w) C.idbtrans = w.idbtrans;
            else try {
              C.create(), C.idbtrans._explicit = !0, R._state.PR1398_maxLoop = 3;
            } catch ($) {
              return $.name === D.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                return _(R, g, I, null, x);
              })) : tt($);
            }
            var A, k = Je(x);
            return k && xn(), T = ne.follow(function() {
              var $;
              (A = x.call(C, C)) && (k ? ($ = Gt.bind(null, null), A.then($, $)) : typeof A.next == "function" && typeof A.throw == "function" && (A = fo(A)));
            }, T), (A && typeof A.then == "function" ? ne.resolve(A).then(function($) {
              return C.active ? $ : tt(new U.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : T.then(function() {
              return A;
            })).then(function($) {
              return w && C._resolve(), C._completion.then(function() {
                return $;
              });
            }).catch(function($) {
              return C._reject($), tt($);
            });
          });
        }).bind(null, this, f, h, l, o);
        return l ? l._promise(f, b, "lock") : ce.trans ? ln(ce.transless, function() {
          return a._whenReady(b);
        }) : this._whenReady(b);
      }, nt.prototype.table = function(e) {
        if (!L(this._allTables, e)) throw new U.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, nt);
      function nt(e, n) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var a = nt.dependencies;
        this._options = n = s({ addons: nt.addons, autoOpen: !0, indexedDB: a.indexedDB, IDBKeyRange: a.IDBKeyRange, cache: "cloned" }, n), this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange }, a = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var l, f, h, v, b, _ = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: O, dbReadyPromise: null, cancelOpen: O, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: n.autoOpen };
        _.dbReadyPromise = new ne(function(g) {
          _.dbReadyResolve = g;
        }), _.openCanceller = new ne(function(g, I) {
          _.cancelOpen = I;
        }), this._state = _, this.name = e, this.on = Pn(this, "populate", "blocked", "versionchange", "close", { ready: [_e, O] }), this.once = function(g, I) {
          var w = function() {
            for (var x = [], T = 0; T < arguments.length; T++) x[T] = arguments[T];
            o.on(g).unsubscribe(w), I.apply(o, x);
          };
          return o.on(g, w);
        }, this.on.ready.subscribe = F(this.on.ready.subscribe, function(g) {
          return function(I, w) {
            nt.vip(function() {
              var x, T = o._state;
              T.openComplete ? (T.dbOpenError || ne.resolve().then(I), w && g(I)) : T.onReadyBeingFired ? (T.onReadyBeingFired.push(I), w && g(I)) : (g(I), x = o, w || g(function C() {
                x.on.ready.unsubscribe(I), x.on.ready.unsubscribe(C);
              }));
            });
          };
        }), this.Collection = (l = this, Ln(Ma.prototype, function(A, C) {
          this.db = l;
          var w = Ho, x = null;
          if (C) try {
            w = C();
          } catch (k) {
            x = k;
          }
          var T = A._ctx, C = T.table, A = C.hook.reading.fire;
          this._ctx = { table: C, index: T.index, isPrimKey: !T.index || C.schema.primKey.keyPath && T.index === C.schema.primKey.name, range: w, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: x, or: T.or, valueMapper: A !== V ? A : null };
        })), this.Table = (f = this, Ln(zo.prototype, function(g, I, w) {
          this.db = f, this._tx = w, this.name = g, this.schema = I, this.hook = f._allTables[g] ? f._allTables[g].hook : Pn(null, { creating: [ge, O], reading: [oe, V], updating: [Re, O], deleting: [he, O] });
        })), this.Transaction = (h = this, Ln(qa.prototype, function(g, I, w, x, T) {
          var C = this;
          g !== "readonly" && I.forEach(function(A) {
            A = (A = w[A]) === null || A === void 0 ? void 0 : A.yProps, A && (I = I.concat(A.map(function(k) {
              return k.updatesTable;
            })));
          }), this.db = h, this.mode = g, this.storeNames = I, this.schema = w, this.chromeTransactionDurability = x, this.idbtrans = null, this.on = Pn(this, "complete", "error", "abort"), this.parent = T || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new ne(function(A, k) {
            C._resolve = A, C._reject = k;
          }), this._completion.then(function() {
            C.active = !1, C.on.complete.fire();
          }, function(A) {
            var k = C.active;
            return C.active = !1, C.on.error.fire(A), C.parent ? C.parent._reject(A) : k && C.idbtrans && C.idbtrans.abort(), tt(A);
          });
        })), this.Version = (v = this, Ln(Xa.prototype, function(g) {
          this.db = v, this._cfg = { version: g, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (b = this, Ln(ri.prototype, function(g, I, w) {
          if (this.db = b, this._ctx = { table: g, index: I === ":id" ? null : I, or: w }, this._cmp = this._ascending = De, this._descending = function(x, T) {
            return De(T, x);
          }, this._max = function(x, T) {
            return 0 < De(x, T) ? x : T;
          }, this._min = function(x, T) {
            return De(x, T) < 0 ? x : T;
          }, this._IDBKeyRange = b._deps.IDBKeyRange, !this._IDBKeyRange) throw new U.MissingAPI();
        })), this.on("versionchange", function(g) {
          0 < g.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(g) {
          !g.newVersion || g.newVersion < g.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(g.oldVersion / 10));
        }), this._maxKey = $n(n.IDBKeyRange), this._createTransaction = function(g, I, w, x) {
          return new o.Transaction(g, I, w, o._options.chromeTransactionDurability, x);
        }, this._fireOnBlocked = function(g) {
          o.on("blocked").fire(g), Nn.filter(function(I) {
            return I.name === o.name && I !== o && !I._state.vcFired;
          }).map(function(I) {
            return I.on("versionchange").fire(g);
          });
        }, this.use(Za), this.use(rs), this.use(es), this.use(za), this.use(Ja);
        var R = new Proxy(this, { get: function(g, I, w) {
          if (I === "_vip") return !0;
          if (I === "table") return function(T) {
            return br(o.table(T), R);
          };
          var x = Reflect.get(g, I, w);
          return x instanceof zo ? br(x, R) : I === "tables" ? x.map(function(T) {
            return br(T, R);
          }) : I === "_createTransaction" ? function() {
            return br(x.apply(this, arguments), R);
          } : x;
        } });
        this.vip = R, a.forEach(function(g) {
          return g(o);
        });
      }
      var wr, Et = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", os = (vo.prototype.subscribe = function(e, n, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: o });
      }, vo.prototype[Et] = function() {
        return this;
      }, vo);
      function vo(e) {
        this._subscribe = e;
      }
      try {
        wr = { indexedDB: d.indexedDB || d.mozIndexedDB || d.webkitIndexedDB || d.msIndexedDB, IDBKeyRange: d.IDBKeyRange || d.webkitIDBKeyRange };
      } catch {
        wr = { indexedDB: null, IDBKeyRange: null };
      }
      function gi(e) {
        var n, o = !1, a = new os(function(l) {
          var f = Je(e), h, v = !1, b = {}, _ = {}, R = { get closed() {
            return v;
          }, unsubscribe: function() {
            v || (v = !0, h && h.abort(), g && Xt.storagemutated.unsubscribe(w));
          } };
          l.start && l.start(R);
          var g = !1, I = function() {
            return Wr(x);
          }, w = function(T) {
            vr(b, T), so(_, b) && I();
          }, x = function() {
            var T, C, A;
            !v && wr.indexedDB && (b = {}, T = {}, h && h.abort(), h = new AbortController(), A = function(k) {
              var $ = wn();
              try {
                f && xn();
                var M = Wt(e, k);
                return M = f ? M.finally(Gt) : M;
              } finally {
                $ && _n();
              }
            }(C = { subscr: T, signal: h.signal, requery: I, querier: e, trans: null }), Promise.resolve(A).then(function(k) {
              o = !0, n = k, v || C.signal.aborted || (b = {}, function($) {
                for (var M in $) if (L($, M)) return;
                return 1;
              }(_ = T) || g || (Xt(Fn, w), g = !0), Wr(function() {
                return !v && l.next && l.next(k);
              }));
            }, function(k) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(k?.name) || v || Wr(function() {
                v || l.error && l.error(k);
              });
            }));
          };
          return setTimeout(I, 0), R;
        });
        return a.hasValue = function() {
          return o;
        }, a.getValue = function() {
          return n;
        }, a;
      }
      var dn = Bt;
      function yo(e) {
        var n = Qt;
        try {
          Qt = !0, Xt.storagemutated.fire(e), co(e, !0);
        } finally {
          Qt = n;
        }
      }
      j(dn, s(s({}, it), { delete: function(e) {
        return new dn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new dn(e, { addons: [] }).open().then(function(n) {
          return n.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return n = dn.dependencies, o = n.indexedDB, n = n.IDBKeyRange, (oo(o) ? Promise.resolve(o.databases()).then(function(a) {
            return a.map(function(l) {
              return l.name;
            }).filter(function(l) {
              return l !== or;
            });
          }) : ro(o, n).toCollection().primaryKeys()).then(e);
        } catch {
          return tt(new U.MissingAPI());
        }
        var n, o;
      }, defineClass: function() {
        return function(e) {
          m(this, e);
        };
      }, ignoreTransaction: function(e) {
        return ce.trans ? ln(ce.transless, e) : e();
      }, vip: io, async: function(e) {
        return function() {
          try {
            var n = fo(e.apply(this, arguments));
            return n && typeof n.then == "function" ? n : ne.resolve(n);
          } catch (o) {
            return tt(o);
          }
        };
      }, spawn: function(e, n, o) {
        try {
          var a = fo(e.apply(o, n || []));
          return a && typeof a.then == "function" ? a : ne.resolve(a);
        } catch (l) {
          return tt(l);
        }
      }, currentTransaction: { get: function() {
        return ce.trans || null;
      } }, waitFor: function(e, n) {
        return n = ne.resolve(typeof e == "function" ? dn.ignoreTransaction(e) : e).timeout(n || 6e4), ce.trans ? ce.trans.waitFor(n) : n;
      }, Promise: ne, debug: { get: function() {
        return me;
      }, set: function(e) {
        $e(e);
      } }, derive: H, extend: m, props: j, override: F, Events: Pn, on: Xt, liveQuery: gi, extendObservabilitySet: vr, getByKeyPath: pe, setByKeyPath: ve, delByKeyPath: function(e, n) {
        typeof n == "string" ? ve(e, n, void 0) : "length" in n && [].map.call(n, function(o) {
          ve(e, o, void 0);
        });
      }, shallowClone: se, deepClone: be, getObjectDiff: po, cmp: De, asap: Te, minKey: -1 / 0, addons: [], connections: Nn, errnames: D, dependencies: wr, cache: fn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, n, o) {
        return e + n / Math.pow(10, 2 * o);
      }) })), dn.maxKey = $n(dn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Xt(Fn, function(e) {
        Qt || (e = new CustomEvent(Qr, { detail: e }), Qt = !0, dispatchEvent(e), Qt = !1);
      }), addEventListener(Qr, function(e) {
        e = e.detail, Qt || yo(e);
      }));
      var In, Qt = !1, bi = function() {
      };
      return typeof BroadcastChannel < "u" && ((bi = function() {
        (In = new BroadcastChannel(Qr)).onmessage = function(e) {
          return e.data && yo(e.data);
        };
      })(), typeof In.unref == "function" && In.unref(), Xt(Fn, function(e) {
        Qt || In.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Bt.disableBfCache && e.persisted) {
          me && console.debug("Dexie: handling persisted pagehide"), In?.close();
          for (var n = 0, o = Nn; n < o.length; n++) o[n].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Bt.disableBfCache && e.persisted && (me && console.debug("Dexie: handling persisted pageshow"), bi(), yo({ all: new ct(-1 / 0, [[]]) }));
      })), ne.rejectionMapper = function(e, n) {
        return !e || e instanceof qt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Q[e.name] ? e : (n = new Q[e.name](n || e.message, e), "stack" in e && z(n, "stack", { get: function() {
          return this.inner.stack;
        } }), n);
      }, $e(me), s(Bt, Object.freeze({ __proto__: null, Dexie: Bt, liveQuery: gi, Entity: Yo, cmp: De, PropModification: kn, replacePrefix: function(e, n) {
        return new kn({ replacePrefix: [e, n] });
      }, add: function(e) {
        return new kn({ add: e });
      }, remove: function(e) {
        return new kn({ remove: e });
      }, default: Bt, RangeSet: ct, mergeRanges: Kn, rangesOverlap: li }), { default: Bt }), Bt;
    });
  }(Ps)), Ps.exports;
}
var Np = xp();
const Ls = /* @__PURE__ */ vp(Np), nu = Symbol.for("Dexie"), ks = globalThis[nu] || (globalThis[nu] = Ls);
if (Ls.semVer !== ks.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${Ls.semVer} and ${ks.semVer}`);
const {
  liveQuery: Fg,
  mergeRanges: $g,
  rangesOverlap: Mg,
  RangeSet: Bg,
  cmp: Kg,
  Entity: qg,
  PropModification: Ug,
  replacePrefix: Vg,
  add: Wg,
  remove: Gg,
  DexieYProvider: Hg
} = ks;
function Ae(t, r) {
  if (t) return;
  const i = "Invariant failed", s = r ? `${i}: ${r}` : i;
  throw console.error(s), new Error("Unexpected Error!");
}
function Rp(t) {
  const r = {}, i = Object.keys(t).sort((s, c) => s.localeCompare(c));
  for (const s of i)
    r[s] = t[s];
  return r;
}
function il(t) {
  return {
    addRecord: r,
    updateRecord: i,
    findChildRecords: d,
    findChildRecordsByTagName: u,
    findChildRecordsWithinDepthAndGivenTagName: p,
    ensureRelationship: s,
    removeRelationship: c,
    findParentRecordsWithinDepthAndGivenTagName: m,
    findRecord: P,
    db: t
  };
  async function r(L) {
    const j = { ...L, id: crypto.randomUUID() };
    try {
      return await t.table(je).add(j), j;
    } catch (Y) {
      const z = {
        msg: "could not add record",
        db: t.name,
        newRecord: j,
        err: Y
      };
      throw console.error(z), new Error(JSON.stringify(z));
    }
  }
  async function i(L) {
    try {
      if (await t.table(je).update(L.id, L) < 1) {
        const Y = { msg: "nothing has been updated", record: L };
        throw console.error(Y), new Error(JSON.stringify(Y));
      }
    } catch (j) {
      console.error(j);
    }
  }
  async function s(L, j) {
    const Y = L.children?.some((H) => H.id === j.id), z = j.parent?.id === L.id;
    if (Y || (L.children.push({ id: j.id, tagName: j.tagName }), await i(L)), !z) {
      const H = {
        id: L.id,
        tagName: L.tagName
      };
      j.parent = H, await i(j);
    }
  }
  async function c(L, j) {
    j.parent = null, await i(j), L.children && (L.children = L.children.filter((Y) => Y.id !== j.id), await i(L));
  }
  async function d(L, j) {
    if (!L.children?.length)
      return [];
    let Y = (await t.table(je).bulkGet(L.children.map((z) => z.id))).filter(Boolean);
    return j?.tagNames && j.tagNames.length > 0 && (Y = Y.filter((z) => j?.tagNames?.includes(z.tagName))), j?.attrs && j.attrs.length > 0 && (Y = Y.filter(
      (z) => j.attrs.every(
        (H) => z.attributes.some(
          (ie) => ie.name === H.name && ie.value === H.value
        )
      )
    )), Y;
  }
  async function u(L, j) {
    return (await d(L)).filter((z) => j.includes(z.tagName));
  }
  async function p(L, j, Y) {
    const z = [];
    let H = [L];
    for (let ie = 0; ie < j; ie++) {
      const W = [];
      if (H.length === 0)
        break;
      for (const B of H) {
        const F = await d(B);
        F.length !== 0 && (W.push(...F), z.push(...F.filter((q) => Y.includes(q.tagName))));
      }
      H = [...W];
    }
    return z;
  }
  async function m(L, j, Y = []) {
    const z = [];
    let H = L;
    for (let ie = 0; ie < j; ie++) {
      if (!H.parent)
        return z;
      const W = await t.table(je).get(H.parent.id);
      if (!W)
        break;
      (Y.length == 0 || Y.length > 0 && Y.includes(W.tagName)) && z.push(W), H = W;
    }
    return z;
  }
  async function P(L) {
    const [j] = await E(L);
    return j;
  }
  async function E(L) {
    try {
      const j = t.table(je);
      let Y = L.tagNames && L.tagNames.length > 0 ? j.where("tagName").anyOf(L.tagNames) : j.toCollection();
      return L.parent && (Y = Y.filter((H) => H.parent?.id === L.parent?.id)), L.attr && (Y = Y.filter((H) => H.attributes?.some(
        (W) => W.name === L.attr.name && W.value === L.attr.value
      ))), await Y.toArray();
    } catch (j) {
      return console.error({ msg: "could not find records by options", options: L, err: j }), [];
    }
  }
}
function K(t, r) {
  return t?.attributes?.find((i) => i.name === r)?.value;
}
function va(t, r) {
  const i = t.attributes.find((s) => s.name === r)?.value;
  return Ae(i, `Attribute ${r} not found on record ${t.id}`), i;
}
const tn = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
}, xc = { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" };
function Cp(t) {
  const r = il(t), i = Pt();
  return {
    createControlledConnection: c,
    createConnection: s,
    createSourcePlaceholder: u,
    createDestinationPlaceholder: d,
    calculateNextInputInstance: p,
    calculateNextOutputInstance: m,
    findExistingInputs: P,
    findExistingOutputs: E,
    findMatchingExtRef: L,
    implementDataflow: j,
    findExtRefByUuid: Y,
    findControlBlock: z,
    findDataSet: H,
    findFcdasForDataSet: ie,
    findPathToLnode: B,
    findPathToExtRef: W,
    findGseControlBlockDetails: F,
    findSmvControlBlockDetails: q,
    findReportControlBlockDetails: Te,
    findLnodeFunction: pe,
    findProcessResourcesForLnode: ve
  };
  async function s(se, S, we, ue) {
    const ye = await Xi(r, we), be = await Bp(
      r,
      S,
      ye,
      se
    );
    await Kp(r, S, se), ue && (await ou(
      r,
      we,
      be
    ), await Qi(
      r,
      S,
      we,
      se.type,
      se.signal,
      se.attribute
    ), se.includeQuality && await Qi(
      r,
      S,
      we,
      se.type,
      se.signal,
      "q"
    ), se.includeTimestamp && await Qi(
      r,
      S,
      we,
      se.type,
      se.signal,
      "t"
    )), await i.refreshConnections(), await i.refreshLNode(S.id), await i.refreshPlaceholders();
  }
  async function c(se, S, we, ue) {
    const ye = await ms(r, S), be = Jp(
      se,
      we
    ), ke = await qp(r, be);
    if (await r.ensureRelationship(ye, ke), !we.dataObjectSpecifications?.find(
      (He) => He.name === se.controlledSignal
    )) {
      const Se = Pt().lnodeTypes.find(
        (It) => It.lnClass === we.lnClass
      )?.dataObjects.find(
        (It) => It.name === se.controlledSignal
      );
      let Qe = await $i(
        r,
        we,
        tn.prefix
      );
      const ht = {
        name: se.controlledSignal,
        desc: Se?.desc || ""
      }, Je = await js(r, ht);
      await r.ensureRelationship(Qe, Je);
    }
    ue && (await Wp(r, S, ke), await Qi(
      r,
      S,
      we,
      se.type,
      se.controlledSignal
    )), await i.refreshConnections(), await i.refreshLNode(we.id);
  }
  async function d(se, S, we) {
    const ue = await Xi(r, S);
    let ye;
    se.processResourceId && (ye = await r.db.table(je).get(se.processResourceId), Ae(ye, "ProcessResource record not found"));
    const be = await oa(
      r,
      Zp(
        se,
        ye
      )
    );
    await r.ensureRelationship(ue, be), we && await ou(r, S, [
      be
    ]), await i.refreshConnections();
  }
  async function u(se, S, we) {
    let ue = [{ name: "inputName", value: S.inputName }];
    if (S.preferredLNode && ue.push({ name: "pLN", value: S.preferredLNode }), S.dataflowType && ue.push({ name: "service", value: S.dataflowType }), S.processResourceId) {
      const Je = await r.db.table(je).get(S.processResourceId);
      Ae(Je, "ProcessResource record not found"), ue.push({
        name: "resourceName",
        value: va(Je, "name")
      }), ue.push({
        name: "resourceUuid",
        value: va(Je, "uuid")
      });
    }
    const ye = se.dataObjectSpecifications?.find(
      (Je) => Je.name === S.dataObject
    ), be = ye?.dataAttributeSpecifications.find(
      (Je) => Je.name === S.dataAttribute
    ), ke = Pt(), He = ke.lnodeTypes.find((Je) => Je.lnClass === se.lnClass)?.dataObjects.find((Je) => Je.name === S.dataObject), Oe = He?.dataAttributes.find((Je) => Je.name === S.dataAttribute);
    let Se, Qe;
    if (ye)
      Se = await r.db.table(je).get(ye.id);
    else {
      const Je = await $i(
        r,
        se,
        tn.prefix
      ), It = {
        name: S.dataObject,
        desc: He?.desc || ""
      };
      Se = await js(r, It), await r.ensureRelationship(Je, Se);
    }
    if (!Se) {
      const Je = "DOS element could not be found or created for source placeholder";
      throw new Error(JSON.stringify(Je));
    }
    if (be)
      Qe = await r.db.table(je).get(be.id);
    else {
      const Je = {
        name: S.dataAttribute,
        desc: Oe?.desc || ""
      };
      Qe = await Ec(
        r,
        Je
      ), await r.ensureRelationship(Se, Qe);
    }
    if (!Qe) {
      const Je = "DAS element could not be found or created for source placeholder";
      throw new Error(JSON.stringify(Je));
    }
    const ht = await r.addRecord({
      tagName: "SubscriberLNode",
      attributes: ue,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(Qe, ht), we && await Gp(
      r,
      se,
      S.dataObject,
      S.dataAttribute,
      S.dataflowType || void 0
    ), await ke.refreshLNode(se.id), await ke.refreshPlaceholders();
  }
  async function p(se, S, we) {
    const ue = await Xi(r, we), ke = (await r.findChildRecordsByTagName(ue, [
      "SourceRef"
    ])).map((Be) => ({
      input: K(Be, "input"),
      pDA: K(Be, "pDA")
    })).filter(
      (Be) => Be.input === se && Be.pDA === S
    );
    return ke.length === 0 ? 1 : ke.length + 1;
  }
  async function m(se, S) {
    const we = await ms(r, S), be = (await r.findChildRecordsByTagName(we, [
      "ControlRef"
    ])).map((ke) => K(ke, "output")).filter((ke) => !!ke).filter(
      (ke) => ke === se
    );
    return be.length === 0 ? 1 : be.length + 1;
  }
  async function P(se) {
    const S = await Xi(r, se), ue = (await r.findChildRecordsByTagName(S, [
      "SourceRef"
    ])).map((be) => K(be, "input")).filter((be) => !!be);
    return Array.from(new Set(ue));
  }
  async function E(se) {
    const S = await ms(r, se), ue = (await r.findChildRecordsByTagName(S, [
      "ControlRef"
    ])).map((be) => K(be, "output")).filter((be) => !!be);
    return Array.from(new Set(ue));
  }
  async function L(se) {
    const S = await r.db.table(je).get(se.id);
    Ae(S, "SourceRef record not found");
    const we = K(S, "extRefUuid");
    let ue;
    if (we) {
      if (ue = await r.db.table(je).where({ tagName: "ExtRef" }).and((ye) => K(ye, "uuid") === we).first(), !ue)
        throw new Error(`ExtRef with uuid ${we} not found`);
    } else {
      const ye = await $p(r, se);
      if (!ye)
        return null;
      ue = ye;
    }
    return iu(ue);
  }
  async function j(se, S) {
    if (Ae(
      se.sourceLNodeId && se.destinationLNodeId,
      "Connection must have both source and destination LNode IDs to implement"
    ), Ae(se.dataflowType, "Connection must have a dataflow type to implement"), S.srcCbName)
      throw new Error("Dataflow is already implemented (srcCBName exists in ExtRef)");
    if (![ot.GOOSE, ot.REPORT, ot.SMV].includes(se.dataflowType))
      throw new Error(
        `Dataflow type ${se.dataflowType} is not supported for automatic implementation`
      );
    const ue = await r.db.table(je).get(se.sourceLNodeId);
    Ae(ue, "Sending LNode record not found");
    const ye = await r.db.table(je).get(se.destinationLNodeId);
    Ae(ye, "Receiving LNode record not found");
    const be = await ll(
      r,
      se.sourceLNodeId
    );
    Ae(be, "LDevice of sending LNode not found");
    const ke = (await r.findChildRecords(be, { tagNames: ["LN0"] }))[0];
    Ae(ke, "LN0 record not found for LDevice");
    const Be = await Dp(
      r,
      se,
      ue,
      ye,
      be,
      ke
    ), He = await Op(
      r,
      se.dataflowType,
      K(Be, "name") || "",
      ke
    );
    vn(
      Be,
      "datSet",
      K(He, "name") || ""
    ), await r.updateRecord(Be), await Ap(
      r,
      se,
      ue,
      He
    ), await Tp(
      r,
      se.dataflowType,
      be,
      Be
    ), await jp(
      r,
      se,
      S,
      K(Be, "name") || ""
    ), await Fp(
      r,
      se,
      ye,
      S
    ), await i.refreshConnections();
  }
  async function Y(se) {
    const S = await r.findRecord({
      tagNames: ["ExtRef"],
      attr: { name: "uuid", value: se }
    });
    return Ae(S, `ExtRef record not found for uuid: ${se}`), iu(S);
  }
  async function z(se, S, we) {
    const ue = await r.findRecord({
      tagNames: ["IED"],
      attr: { name: "name", value: se }
    });
    Ae(ue, "IED record not found");
    const ye = await r.findChildRecordsWithinDepthAndGivenTagName(ue, 3, ["LDevice"]).then((Be) => Be.find((He) => K(He, "inst") === S));
    Ae(ye, "LDevice record not found");
    const [be] = await r.findChildRecordsByTagName(ye, ["LN0"]);
    Ae(be, "LN0 record not found for LDevice");
    const [ke] = await r.findChildRecords(be, {
      tagNames: ["GSEControl", "SampledValueControl", "ReportControl"],
      attrs: [{ name: "name", value: we }]
    });
    return Ae(ke, "Control Block record not found"), Xp(ke);
  }
  async function H(se, S, we) {
    const ue = await r.findRecord({
      tagNames: ["IED"],
      attr: { name: "name", value: se }
    });
    Ae(ue, "IED record not found");
    const ye = await r.findChildRecordsWithinDepthAndGivenTagName(ue, 3, ["LDevice"]).then((Be) => Be.find((He) => K(He, "inst") === S));
    Ae(ye, "LDevice record not found");
    const [be] = await r.findChildRecordsByTagName(ye, ["LN0"]);
    Ae(be, "LN0 record not found for LDevice");
    const [ke] = await r.findChildRecords(be, {
      tagNames: ["DataSet"],
      attrs: [{ name: "name", value: we }]
    });
    return Ae(ke, "DataSet record not found"), Qp(ke);
  }
  async function ie(se) {
    const S = await r.db.table(je).get(se);
    return Ae(S, "DataSet record not found"), (await r.findChildRecordsByTagName(S, ["FCDA"])).map(zp);
  }
  async function W(se) {
    const S = await r.db.table(je).get(se);
    Ae(S, "ExtRef record not found");
    let we = K(S, "intAddr") || "";
    const ue = ["LN", "LDevice", "IED"];
    let ye = S;
    for (; ye.parent; ) {
      const be = await r.db.table(je).get(ye.parent.id);
      if (Ae(be, "Parent record not found"), ue.includes(be.tagName)) {
        let ke = "";
        be.tagName === "LN" ? ke = `${K(be, "prefix") ?? ""}${K(be, "lnClass")}${K(be, "inst") ?? ""}` : be.tagName === "LDevice" ? ke = K(be, "inst") || "" : ke = K(be, "name") || "", we = `${ke}/${we}`;
      }
      ye = be;
    }
    return we;
  }
  async function B(se) {
    const S = await r.db.table(je).get(se);
    Ae(S, "LNode record not found");
    let ue = `${K(S, "prefix") ?? ""}${K(S, "lnClass")}${K(S, "lnInst") ?? ""}`;
    const ye = ["SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
    let be = S;
    for (; be.parent; ) {
      const ke = await r.db.table(je).get(be.parent.id);
      Ae(ke, "Parent record not found"), ye.includes(ke.tagName) && (ue = `${K(ke, "name")}/${ue}`), be = ke;
    }
    return ue;
  }
  async function F(se, S) {
    const we = await r.db.table(je).get(se);
    Ae(we, "Control Block record not found");
    const ue = await r.db.table(je).where({ tagName: "GSE" }).and(
      (Qe) => K(Qe, "cbName") === K(we, "name") && K(Qe, "ldInst") === S
    ).first();
    Ae(ue, "GSE Communication record not found for Control Block");
    const [ye] = await r.findChildRecordsByTagName(ue, [
      "MinTime"
    ]), [be] = await r.findChildRecordsByTagName(ue, [
      "MaxTime"
    ]), ke = await r.findChildRecordsWithinDepthAndGivenTagName(
      ue,
      2,
      ["P"]
    ), Be = ke.find(
      (Qe) => K(Qe, "type") === "VLAN-ID" || K(Qe, "type") === "tP_VLAN-ID"
    ), He = ke.find(
      (Qe) => K(Qe, "type") === "VLAN-PRIORITY" || K(Qe, "type") === "tP_VLAN-PRIORITY"
    ), Oe = ke.find(
      (Qe) => K(Qe, "type") === "MAC-Address" || K(Qe, "type") === "tP_MAC-Address"
    ), Se = ke.find(
      (Qe) => K(Qe, "type") === "APPID" || K(Qe, "type") === "tP_APPID"
    );
    return {
      appId: K(we, "appID") || "",
      communicationDetails: {
        macAddress: Oe?.value || "",
        appId: Se?.value || "",
        vlanId: Be?.value || "",
        vlanPriority: He?.value || "",
        minTime: ye?.value || "",
        maxTime: be?.value || ""
      }
    };
  }
  async function q(se, S) {
    const we = await r.db.table(je).get(se);
    Ae(we, "Control Block record not found");
    const [ue] = await r.findChildRecordsByTagName(we, [
      "SmvOpts"
    ]);
    Ae(ue, "SmvOpts record not found for Control Block");
    const ye = await r.db.table(je).where({ tagName: "SMV" }).and(
      (Se) => K(Se, "cbName") === K(we, "name") && K(Se, "ldInst") === S
    ).first();
    Ae(ye, "SMV Communication record not found for Control Block");
    const be = await r.findChildRecordsWithinDepthAndGivenTagName(
      ye,
      2,
      ["P"]
    ), ke = be.find(
      (Se) => K(Se, "type") === "VLAN-ID" || K(Se, "type") === "tP_VLAN-ID"
    ), Be = be.find(
      (Se) => K(Se, "type") === "VLAN-PRIORITY" || K(Se, "type") === "tP_VLAN-PRIORITY"
    ), He = be.find(
      (Se) => K(Se, "type") === "MAC-Address" || K(Se, "type") === "tP_MAC-Address"
    ), Oe = be.find(
      (Se) => K(Se, "type") === "APPID" || K(Se, "type") === "tP_APPID"
    );
    return {
      smvId: K(we, "smvID") || "",
      multicast: K(we, "multicast") || "",
      nofAsdu: K(we, "nofASDU") || "",
      smpMod: K(we, "smpMod") || "",
      smpRate: K(we, "smpRate") || "",
      communicationDetails: {
        macAddress: He?.value || "",
        appId: Oe?.value || "",
        vlanId: ke?.value || "",
        vlanPriority: Be?.value || ""
      },
      smvOpts: {
        refreshTime: K(ue, "refreshTime") || "",
        sampleSynchronized: K(ue, "sampleSynchronized") || "",
        sampleRate: K(ue, "sampleRate") || "",
        dataSet: K(ue, "dataSet") || "",
        security: K(ue, "security") || "",
        synchSourceId: K(ue, "synchSourceId") || ""
      }
    };
  }
  async function Te(se) {
    const S = await r.db.table(je).get(se);
    Ae(S, "Control Block record not found");
    const [we] = await r.findChildRecordsByTagName(S, [
      "TrgOps"
    ]);
    Ae(we, "TrgOps record not found for Control Block");
    const [ue] = await r.findChildRecordsByTagName(S, [
      "OptFields"
    ]);
    return Ae(ue, "OptFields record not found for Control Block"), {
      rptId: K(S, "rptID") || "",
      buffered: K(S, "buffered") || "",
      trgOps: {
        dchg: K(we, "dchg") || "",
        dupd: K(we, "dupd") || "",
        gi: K(we, "gi") || "",
        period: K(we, "period") || "",
        qchg: K(we, "qchg") || ""
      },
      optFields: {
        bufOvfl: K(ue, "bufOvfl") || "",
        configRef: K(ue, "configRef") || "",
        dataRef: K(ue, "dataRef") || "",
        dataSet: K(ue, "dataSet") || "",
        entryId: K(ue, "entryID") || "",
        reasonCode: K(ue, "reasonCode") || "",
        seqNum: K(ue, "seqNum") || "",
        timeStamp: K(ue, "timeStamp") || ""
      }
    };
  }
  async function pe(se) {
    const S = await r.db.table(je).get(se);
    Ae(S, "LNode record not found"), Ae(S.parent, "LNode has no parent");
    const we = await r.db.table(je).get(S.parent.id);
    return Ae(we, "Function record not found for LNode"), K(we, "name") ?? "";
  }
  async function ve(se) {
    const S = await r.db.table(je).get(se);
    Ae(S, "LNode record not found");
    const we = [];
    let ue = S;
    for (; ue.parent && (ue.parent.tagName == "Function" || ue.parent.tagName == "SubFunction"); ) {
      const ye = await r.db.table(je).get(ue.parent.id);
      Ae(ye, "Parent record not found");
      const be = await r.findChildRecordsWithinDepthAndGivenTagName(
        ye,
        3,
        // Expected hierarchy: Private, ProcessResources, ProcessResource
        ["ProcessResource"]
      );
      we.push(...be), ue = ye;
    }
    return we;
  }
}
async function Tp(t, r, i, s) {
  const c = await t.db.table(je).where({ tagName: "Communication" }).first();
  Ae(c, "Communication record not found in SCL");
  const d = await t.findChildRecordsWithinDepthAndGivenTagName(
    c,
    2,
    ["ConnectedAP"]
  ), [u] = await t.findParentRecordsWithinDepthAndGivenTagName(
    s,
    4,
    ["AccessPoint"]
  );
  Ae(u, "AccessPoint record not found"), Ae(u.parent, "AccessPoint has no parent");
  const p = await t.db.table(je).get(u.parent.id);
  Ae(p, "IED record not found");
  const m = d.find(
    (E) => K(E, "iedName") === K(p, "name") && K(E, "apName") === K(u, "name")
  );
  Ae(m, "ConnectedAP record for sending IED not found");
  const P = K(s, "name") || "";
  r === ot.GOOSE && await Ip(
    t,
    i,
    P,
    m
  ), r === ot.SMV && await Ep(
    t,
    i,
    P,
    m
  );
}
async function Ep(t, r, i, s) {
  if ((await t.findChildRecords(s, {
    tagNames: ["SMV"],
    attrs: [
      { name: "cbName", value: i },
      {
        name: "ldInst",
        value: K(r, "inst") || ""
      }
    ]
  }))[0])
    return;
  const d = await t.db.table(je).where({ tagName: "SMV" }).toArray(), u = await t.addRecord({
    tagName: "SMV",
    attributes: [
      { name: "cbName", value: i },
      { name: "ldInst", value: K(r, "inst") || "" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(s, u);
  const p = await t.addRecord({
    tagName: "Address",
    attributes: [],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(u, p);
  const m = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-ID",
        namespace: xc
      },
      { name: "type", value: "VLAN-ID" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "000",
    children: []
  });
  await t.ensureRelationship(p, m);
  const P = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-PRIORITY",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "VLAN-PRIORITY" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "7",
    children: []
  });
  await t.ensureRelationship(p, P);
  const E = [], L = [];
  for (const ie of d) {
    const W = await t.findChildRecords(ie, {
      tagNames: ["Address"]
    });
    Ae(W[0], "Address record not found in SMV communication");
    const B = await t.findChildRecords(W[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "MAC-Address" }]
    });
    if (B[0]) {
      const q = B[0].value;
      E.push(q);
    }
    const F = await t.findChildRecords(W[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "APPID" }]
    });
    if (F[0]) {
      const q = F[0].value;
      L.push(q);
    }
  }
  const j = Nc(
    262144,
    262655,
    E
  ), Y = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_MAC-Address",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "MAC-Address" }
    ],
    parent: null,
    namespace: Ct.default,
    value: j,
    children: []
  });
  await t.ensureRelationship(p, Y);
  const z = Rc(16384, 32767, L), H = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_APPID",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "APPID" }
    ],
    parent: null,
    namespace: Ct.default,
    value: z,
    children: []
  });
  await t.ensureRelationship(p, H);
}
async function Ip(t, r, i, s) {
  if ((await t.findChildRecords(s, {
    tagNames: ["GSE"],
    attrs: [
      { name: "cbName", value: i },
      {
        name: "ldInst",
        value: K(r, "inst") || ""
      }
    ]
  }))[0])
    return;
  const d = await t.db.table(je).where({ tagName: "GSE" }).toArray(), u = await t.addRecord({
    tagName: "GSE",
    attributes: [
      { name: "cbName", value: i },
      { name: "ldInst", value: K(r, "inst") || "" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(s, u);
  const p = await t.addRecord({
    tagName: "Address",
    attributes: [],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(u, p);
  const m = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-ID",
        namespace: xc
      },
      { name: "type", value: "VLAN-ID" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "000",
    children: []
  });
  await t.ensureRelationship(p, m);
  const P = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-PRIORITY",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "VLAN-PRIORITY" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "4",
    children: []
  });
  await t.ensureRelationship(p, P);
  const E = [], L = [];
  for (const B of d) {
    const F = await t.findChildRecords(B, {
      tagNames: ["Address"]
    });
    Ae(F[0], "Address record not found in SMV communication");
    const q = await t.findChildRecords(F[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "MAC-Address" }]
    });
    if (q[0]) {
      const pe = q[0].value;
      E.push(pe);
    }
    const Te = await t.findChildRecords(F[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "APPID" }]
    });
    if (Te[0]) {
      const pe = Te[0].value;
      L.push(pe);
    }
  }
  const j = Nc(
    65536,
    66047,
    E
  ), Y = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_MAC-Address",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "MAC-Address" }
    ],
    parent: null,
    namespace: Ct.default,
    value: j,
    children: []
  });
  await t.ensureRelationship(p, Y);
  const z = Rc(1, 16383, L), H = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_APPID",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "APPID" }
    ],
    parent: null,
    namespace: Ct.default,
    value: z,
    children: []
  });
  await t.ensureRelationship(p, H);
  const ie = await t.addRecord({
    tagName: "MinTime",
    attributes: [
      { name: "multiplier", value: "m" },
      { name: "unit", value: "s" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "5",
    children: []
  });
  await t.ensureRelationship(u, ie);
  const W = await t.addRecord({
    tagName: "MaxTime",
    attributes: [
      { name: "multiplier", value: "m" },
      { name: "unit", value: "s" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "10000",
    children: []
  });
  await t.ensureRelationship(u, W);
}
function Nc(t, r, i) {
  const s = "01-0C-CD";
  for (let c = t; c <= r; c++) {
    const d = c.toString(16).toUpperCase().padStart(6, "0"), u = `${d.slice(0, 2)}-${d.slice(2, 4)}-${d.slice(4, 6)}`, p = s + "-" + u;
    if (!i.includes(p))
      return p;
  }
  throw new Error("No available MAC Address found in the specified range");
}
function Rc(t, r, i) {
  for (let s = t; s <= r; s++) {
    const c = s.toString(16).toUpperCase().padStart(4, "0");
    if (!i.includes(c))
      return c;
  }
  throw new Error("No available APPID found in the specified range");
}
async function Ap(t, r, i, s) {
  const p = Pt().lnodeTypes.find(
    (E) => E.typeId === K(i, "lnType") && E.lnClass === K(i, "lnClass")
  )?.dataObjects.find((E) => E.name === r.sourceDataObject)?.dataAttributes?.find((E) => E.name === r.sourceDataAttribute), m = (await t.findChildRecords(s, {
    tagNames: ["FCDA"],
    attrs: [
      { name: "daName", value: r.sourceDataAttribute },
      { name: "doName", value: r.sourceDataObject },
      { name: "fc", value: p?.fc || "" },
      { name: "ldInst", value: K(i, "ldInst") || "" },
      { name: "lnClass", value: K(i, "lnClass") || "" },
      { name: "lnInst", value: K(i, "lnInst") || "" },
      { name: "prefix", value: K(i, "prefix") || "" }
    ]
  }))[0];
  if (m)
    return m;
  const P = await t.addRecord({
    tagName: "FCDA",
    attributes: [
      { name: "daName", value: r.sourceDataAttribute },
      { name: "doName", value: r.sourceDataObject },
      { name: "fc", value: p?.fc || "" },
      { name: "ldInst", value: K(i, "ldInst") || "" },
      { name: "lnClass", value: K(i, "lnClass") || "" },
      { name: "lnInst", value: K(i, "lnInst") || "" },
      { name: "prefix", value: K(i, "prefix") || "" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(s, P), P;
}
async function Op(t, r, i, s) {
  let c;
  if (r === ot.SMV) {
    const p = i.slice(i.length - 2);
    c = "PhsMeas" + parseInt(p, 10);
  } else
    c = i + "_DS";
  const d = (await t.findChildRecords(s, {
    tagNames: ["DataSet"],
    attrs: [{ name: "name", value: c }]
  }))[0];
  if (d)
    return d;
  const u = await t.addRecord({
    tagName: "DataSet",
    attributes: [{ name: "name", value: c }],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(s, u), u;
}
async function Dp(t, r, i, s, c, d) {
  const u = (await t.findParentRecordsWithinDepthAndGivenTagName(i, 1 / 0, [
    "Function"
  ]))[0];
  Ae(u, "Parent Function of sending LNode not found when implementing dataflow");
  let p;
  if (r.dataflowType === ot.GOOSE && (p = await kp(
    t,
    i,
    s,
    u,
    c,
    d
  )), r.dataflowType === ot.SMV && (p = await Pp(
    t,
    i,
    s,
    c,
    d
  )), r.dataflowType === ot.REPORT) {
    const P = K(i, "lnClass") === "MMXU";
    p = await Sp(
      t,
      i,
      s,
      u,
      c,
      d,
      P
    );
  }
  return Ae(p, "Control Block record could not be created"), p;
}
async function Sp(t, r, i, s, c, d, u) {
  const p = (K(s, "name") + "_RPT").replace(" ", "_"), m = K(i, "iedName");
  Ae(m, "iedName of receiving LNode not found");
  const P = await t.findChildRecordsByTagName(d, [
    "ReportControl"
  ]);
  for (const q of P) {
    const pe = K(q, "name")?.startsWith(p), ve = (await t.findChildRecordsWithinDepthAndGivenTagName(q, 2, [
      "ClientLN"
    ]))[0];
    Ae(ve, "ClientLN record inside ReportControl not found");
    const se = K(ve, "iedName") === m;
    if (pe && se)
      return al(t, q), q;
  }
  const L = P.filter(
    (q) => K(q, "name")?.startsWith(p) ?? !1
  ).length + 1, j = p + L, Y = sl(
    r,
    c,
    j
  ), z = {
    tagName: "ReportControl",
    attributes: [
      { name: "name", value: j },
      { name: "confRev", value: "1" },
      { name: "rptID", value: Y }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  };
  u ? z.attributes.push({ name: "buffered", value: "false" }) : (z.attributes.push({ name: "buffered", value: "true" }), z.attributes.push({ name: "bufTime", value: "100" }));
  const H = await t.addRecord(z);
  await t.ensureRelationship(d, H);
  const ie = {
    tagName: "TrgOps",
    attributes: [
      { name: "dchg", value: "true" },
      { name: "dupd", value: "false" },
      { name: "gi", value: "true" },
      { name: "period", value: "false" },
      { name: "qchg", value: "true" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  };
  u ? ie.attributes.push({ name: "dupd", value: "true" }) : ie.attributes.push({ name: "dupd", value: "false" });
  const W = await t.addRecord(ie);
  await t.ensureRelationship(H, W);
  const B = await t.addRecord({
    tagName: "OptFields",
    attributes: [
      { name: "bufOvfl", value: "false" },
      { name: "configRef", value: "true" },
      { name: "dataRef", value: "true" },
      { name: "dataSet", value: "true" },
      { name: "entryID", value: "true" },
      { name: "reasonCode", value: "true" },
      { name: "seqNum", value: "true" },
      { name: "timeStamp", value: "true" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(H, B);
  const F = await t.addRecord({
    tagName: "RptEnabled",
    attributes: [{ name: "max", value: "5" }],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(H, F), await Lp(t, F, i), H;
}
async function al(t, r) {
  const i = K(r, "confRev"), s = i ? parseInt(i, 10) + 1 : 1;
  vn(r, "confRev", s.toString()), await t.updateRecord(r);
}
async function Pp(t, r, i, s, c) {
  const d = K(i, "iedName");
  Ae(d, "iedName of receiving LNode not found");
  const u = await t.findChildRecordsByTagName(c, [
    "SampledValueControl"
  ]);
  for (const Y of u) {
    const z = (await t.findChildRecordsByTagName(Y, ["IEDName"]))[0];
    if (Ae(z, "IEDName record inside SampledValueControl not found"), z.value === d)
      return al(t, Y), Y;
  }
  const p = "MSVCB", m = u.length + 1;
  if (m > 99)
    throw new Error("Maximum number of SampledValueControl elements (99) exceeded");
  const P = p + m.toString().padStart(2, "0"), E = sl(
    r,
    s,
    P
  ), L = await t.addRecord({
    tagName: "SampledValueControl",
    attributes: [
      { name: "name", value: P },
      { name: "confRev", value: "1" },
      { name: "smvID", value: E },
      { name: "multicast", value: "true" },
      { name: "nofASDU", value: "2" },
      { name: "smpMod", value: "SmpPerSec" },
      { name: "smpRate", value: "80" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(c, L), await Cc(t, L, d);
  const j = await t.addRecord({
    tagName: "SmvOpts",
    attributes: [
      { name: "refreshTime", value: "false" },
      { name: "sampleSynchronized", value: "true" },
      { name: "sampleRate", value: "false" },
      { name: "dataSet", value: "false" },
      { name: "security", value: "false" },
      { name: "synchSourceId", value: "true" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(L, j), L;
}
async function Cc(t, r, i) {
  const s = await t.db.table(je).where({ tagName: "IED" }).and((u) => K(u, "name") === i).first();
  Ae(s, "IED record of receiving LNode not found");
  const c = (await t.findChildRecordsByTagName(s, ["AccessPoint"]))[0];
  Ae(c, "AccessPoint record of receiving IED not found");
  const d = await t.addRecord({
    tagName: "IEDName",
    attributes: [
      {
        name: "apRef",
        value: K(c, "name") || ""
      }
    ],
    parent: null,
    namespace: Ct.default,
    value: i || "",
    children: []
  });
  await t.ensureRelationship(r, d);
}
async function Lp(t, r, i) {
  const s = K(i, "iedName"), c = await t.db.table(je).where({ tagName: "IED" }).and((p) => K(p, "name") === s).first();
  Ae(c, "IED record of receiving LNode not found");
  const d = (await t.findChildRecordsByTagName(c, ["AccessPoint"]))[0];
  Ae(d, "AccessPoint record of receiving IED not found");
  const u = await t.addRecord({
    tagName: "ClientLN",
    attributes: [
      {
        name: "apRef",
        value: K(d, "name") || ""
      },
      { name: "iedName", value: s || "" },
      { name: "ldInst", value: K(i, "ldInst") || "" },
      { name: "prefix", value: K(i, "prefix") || "" },
      { name: "lnClass", value: K(i, "lnClass") || "" },
      { name: "lnInst", value: K(i, "lnInst") || "" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(r, u);
}
function sl(t, r, i) {
  const s = K(t, "iedName"), c = K(r, "inst");
  return `${s}${c}/LN0.${i}`;
}
async function kp(t, r, i, s, c, d) {
  const u = (K(s, "name") + "_GSE").replace(" ", "_"), p = K(i, "iedName");
  Ae(p, "iedName of receiving LNode not found");
  const m = await t.findChildRecordsByTagName(d, [
    "GSEControl"
  ]);
  for (const z of m) {
    const ie = K(z, "name")?.startsWith(u), W = (await t.findChildRecordsByTagName(z, ["IEDName"]))[0];
    Ae(W, "IEDName record inside GSEControl not found");
    const B = W.value === p;
    if (ie && B)
      return al(t, z), z;
  }
  const E = m.filter(
    (z) => K(z, "name")?.startsWith(u) ?? !1
  ).length + 1, L = u + E, j = sl(
    r,
    c,
    L
  ), Y = await t.addRecord({
    tagName: "GSEControl",
    attributes: [
      { name: "name", value: L },
      { name: "confRev", value: "1" },
      { name: "appID", value: j },
      { name: "type", value: "GOOSE" }
    ],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(d, Y), await Cc(t, Y, p), Y;
}
async function jp(t, r, i, s) {
  Ae(
    r.sourceLNodeId,
    "Source LNode ID not set for dataflow connection to implement"
  ), Ae(r.dataflowType, "Dataflow type not set for dataflow connection to implement");
  const c = await t.db.table(je).get(i.id);
  Ae(c, "ExtRef record not found"), vn(c, "doName", r.sourceDataObject), vn(c, "daName", r.sourceDataAttribute), vn(c, "serviceType", r.dataflowType);
  const d = await t.db.table(je).get(r.sourceLNodeId);
  Ae(d, "Sending LNode record not found"), vn(
    c,
    "iedName",
    K(d, "iedName") || ""
  ), vn(
    c,
    "ldInst",
    K(d, "ldInst") || ""
  ), vn(
    c,
    "lnClass",
    K(d, "lnClass") || ""
  ), vn(
    c,
    "lnInst",
    K(d, "lnInst") || ""
  ), vn(
    c,
    "prefix",
    K(d, "prefix") || ""
  ), vn(c, "srcCBName", s);
  const u = await ll(t, r.sourceLNodeId);
  Ae(u, "LDevice for sending LNode not found");
  const p = (await t.findChildRecords(u, { tagNames: ["LN0"] }))[0];
  Ae(p, "LN0 record not found"), vn(
    c,
    "srcLDInst",
    K(u, "inst") || ""
  ), vn(
    c,
    "srcLNClass",
    K(p, "lnClass") || ""
  ), await t.updateRecord(c);
}
async function Fp(t, r, i, s) {
  Ae(
    r.destinationLNodeId,
    "Destination LNode ID not set for dataflow connection to implement"
  );
  const c = await t.db.table(je).get(r.id);
  Ae(c, "SourceRef record not found");
  const d = K(i, "iedName"), u = K(i, "ldInst");
  Ae(d, "iedName of receiving LNode not found"), Ae(u, "ldInst of receiving LNode not found");
  const p = await Tc(t, r.destinationLNodeId);
  Ae(p, "LN record for receiving LNode not found");
  const m = K(p, "prefix"), P = K(p, "lnClass");
  Ae(P, "lnClass of receiving LN record not found");
  const E = K(p, "inst");
  if (s.intAddr) {
    const L = `${d}${u}/${m ?? ""}${P}${E ?? ""}.${s.intAddr}`;
    vn(c, "extRefAddr", L);
  }
  Ae(s.uuid, "ExtRef UUID not found when updating SourceRef"), vn(c, "extRefUuid", s.uuid), await t.updateRecord(c);
}
function vn(t, r, i) {
  const s = t.attributes.find((c) => c.name === r);
  s ? s.value = i : t.attributes.push({ name: r, value: i });
}
async function ll(t, r) {
  const i = await t.db.table(je).get(r), s = await t.db.table(je).where({ tagName: "IED" }).and(
    (u) => K(u, "name") === K(i, "iedName")
  ).first();
  Ae(s, "IED record not found for receiving LNode");
  const d = (await t.findChildRecordsWithinDepthAndGivenTagName(
    s,
    3,
    ["LDevice"]
  )).find((u) => K(u, "inst") === K(i, "ldInst"));
  return Ae(d, "LDevice record not found for receiving LNode"), d;
}
async function Tc(t, r) {
  const i = await t.db.table(je).get(r), s = await ll(t, r);
  if (!s)
    return;
  const d = (await t.findChildRecordsWithinDepthAndGivenTagName(s, 1, [
    "LN"
  ])).find((u) => K(u, "inst") === K(i, "lnInst") && K(u, "lnClass") === K(i, "lnClass") && K(u, "prefix") === K(i, "prefix"));
  return Ae(d, "LN record not found for receiving LNode"), d;
}
async function $p(t, r) {
  if (!Mp(r))
    return;
  const i = await Tc(t, r.destinationLNodeId);
  if (!i)
    return;
  const c = (await t.findChildRecordsWithinDepthAndGivenTagName(i, 2, [
    "ExtRef"
  ])).filter((u) => {
    const p = K(u, "pLN") === r.preferredLNode && K(u, "pDO") === r.preferredDataObject && K(u, "pDA") === r.preferredDataAttribute;
    Ae(r.dataflowType, "Dataflow type not set for dataflow connection to implement");
    const m = K(u, "pServT"), P = m === void 0 || m === r.dataflowType, E = K(u, "srcCBName");
    return p && P && !(E !== void 0 && E !== "");
  }), d = [];
  for (const u of c) {
    if (!K(u, "uuid")) {
      d.push(u);
      continue;
    }
    await t.db.table(je).where({ tagName: "SourceRef" }).and(
      (m) => (!!K(m, "extRefUuid") && K(m, "extRefUuid")) === K(u, "uuid")
    ).first() || d.push(u);
  }
  return d[0];
}
function Mp(t) {
  return t.preferredLNode.trim() !== "" && t.preferredDataObject.trim() !== "" && t.preferredDataAttribute.trim() !== "";
}
async function Xi(t, r) {
  const i = await $i(
    t,
    r,
    tn.prefix
  ), s = await t.findChildRecordsByTagName(i, [
    "LNodeInputs"
  ]);
  if (s.length == 1)
    return s[0];
  if (s.length == 0) {
    const d = await t.addRecord({
      tagName: "LNodeInputs",
      attributes: [],
      parent: null,
      namespace: tn,
      value: "",
      children: []
    });
    return await t.ensureRelationship(i, d), d;
  }
  const c = {
    msg: `More than one LNodeInputs element found in LNode with uuid ${r.uuid}`
  };
  throw new Error(JSON.stringify(c));
}
async function ms(t, r) {
  const i = await $i(
    t,
    r,
    tn.prefix
  ), s = await t.findChildRecordsByTagName(i, [
    "LNodeOutputs"
  ]);
  if (s.length == 1)
    return s[0];
  if (s.length == 0) {
    const d = await t.addRecord({
      tagName: "LNodeOutputs",
      attributes: [],
      parent: null,
      namespace: tn,
      value: "",
      children: []
    });
    return await t.ensureRelationship(i, d), d;
  }
  const c = {
    msg: `More than one LNodeOutputs element found in LNode with uuid ${r.uuid}`
  };
  throw new Error(JSON.stringify(c));
}
async function Bp(t, r, i, s) {
  const c = [], d = await oa(
    t,
    ys(s, r)
  );
  if (c.push(d), await t.ensureRelationship(i, d), s.includeQuality) {
    const u = {
      ...s,
      attribute: "q"
      // Set to 'q' for Quality
    }, p = await oa(
      t,
      ys(u, r)
    );
    c.push(p), await t.ensureRelationship(i, p);
  }
  if (s.includeTimestamp) {
    const u = {
      ...s,
      attribute: "t"
      // Set to 't' for Timestamp
    }, p = await oa(
      t,
      ys(u, r)
    );
    c.push(p), await t.ensureRelationship(i, p);
  }
  return c;
}
async function $i(t, r, i) {
  const s = await t.db.table(je).where({ "parent.id": r.id, tagName: "Private" }).and((u) => K(u, "type") === i).first();
  if (s)
    return s;
  const c = await t.db.table(je).get(r.id);
  if (!c) {
    const u = {
      msg: `LNode element with uuid ${r.uuid} not found`
    };
    throw new Error(JSON.stringify(u));
  }
  const d = await t.addRecord({
    tagName: "Private",
    attributes: [{ name: "type", value: i }],
    parent: null,
    namespace: Ct.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(c, d), d;
}
async function oa(t, r) {
  const i = {
    tagName: "SourceRef",
    namespace: tn,
    attributes: [
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pDA",
        value: r.pDA
      },
      {
        name: "input",
        value: r.inputName
      },
      {
        name: "inputInst",
        value: r.inputInstance
      },
      {
        name: "service",
        value: r.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: r.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: r.sourceDoName
      },
      {
        name: "sourceDaName",
        value: r.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "source",
        value: await Eo(
          t.db,
          r.sourceLNodeUuid,
          r.sourceDoName,
          r.sourceDaName
        )
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return r.resourceName && r.resourceUuid && (i.attributes.push({ name: "resourceName", value: r.resourceName }), i.attributes.push({ name: "resourceUuid", value: r.resourceUuid })), await t.addRecord(i);
}
async function Kp(t, r, i) {
  const s = r.dataObjectSpecifications?.find(
    (E) => E.name === i.signal
  ), c = s?.dataAttributeSpecifications.find(
    (E) => E.name === i.attribute
  ), u = Pt().lnodeTypes.find((E) => E.lnClass === r.lnClass), p = u?.dataObjects.find((E) => E.name === i.signal), m = p?.dataAttributes.find((E) => E.name === i.attribute);
  if (!u || !p || !m) {
    const E = `LNodeType, DO type or DA type not found for LNode class ${r.lnClass}, DO ${i.signal}, DA ${i.attribute}`;
    throw console.error(E), new Error(E);
  }
  let P;
  if (!s) {
    const E = await $i(
      t,
      r,
      tn.prefix
    ), L = {
      name: i.signal,
      desc: p.desc
    };
    P = await js(t, L), await t.ensureRelationship(E, P);
  }
  if (!P && (P = await t.db.table(je).get(s.id), !P))
    throw new Error(`DOS element with id ${s.id} not found`);
  if (c || await vs(t, P, i.attribute, m.desc), i.includeQuality) {
    const E = p?.dataAttributes.find((j) => j.name === "q");
    if (!E)
      throw new Error(`DA type 'q' not allowed for DO ${i.signal}`);
    s?.dataAttributeSpecifications.find(
      (j) => j.name === E.name
    ) || await vs(t, P, E.name, E.desc);
  }
  if (i.includeTimestamp) {
    const E = p?.dataAttributes.find((j) => j.name === "t");
    if (!E)
      throw new Error(`DA type 't' not allowed for DO ${i.signal}`);
    s?.dataAttributeSpecifications.find(
      (j) => j.name === E.name
    ) || await vs(t, P, E.name, E.desc);
  }
}
async function vs(t, r, i, s) {
  const d = await Ec(
    t,
    {
      name: i,
      desc: s
    }
  );
  await t.ensureRelationship(r, d);
}
async function qp(t, r) {
  const i = {
    tagName: "ControlRef",
    namespace: tn,
    attributes: [
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "controlled",
        value: await Eo(
          t.db,
          r.controlledLNodeUuid,
          r.controlledDoName
        )
      },
      {
        name: "output",
        value: r.output
      },
      {
        name: "outputInst",
        value: r.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: r.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: r.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(i);
}
async function Eo(t, r, i, s) {
  if (!r) return "";
  const c = await t.table(je).where({ tagName: "LNode" }).and((E) => K(E, "uuid") === r).first();
  if (!c) return "";
  const d = [];
  let u = c;
  const p = ["LNode", "SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
  for (; u && u.parent; ) {
    if (p.includes(u.tagName)) {
      const E = K(u, "name");
      E && d.unshift(E);
    }
    u = await t.table(je).get(u.parent.id);
  }
  const m = (() => {
    const E = c.attributes?.find((Y) => Y.name === "prefix")?.value || "", L = c.attributes?.find((Y) => Y.name === "lnClass")?.value || "", j = c.attributes?.find((Y) => Y.name === "lnInst")?.value || "";
    return `${E}${L}${j}`;
  })();
  d.push(m);
  let P = d.join("/");
  return i && (P += `.${i}`, s && (P += "." + s)), P;
}
async function Up(t, r, i) {
  const s = await Eo(t, r), c = K(i, "input"), d = K(i, "inputInst"), u = K(i, "pDA");
  let p = `${s}.${c}`;
  return d && (p += `(${d})`), u && (p += `.${u}`), p;
}
async function Vp(t, r, i) {
  const s = await Eo(t, r), c = K(i, "output"), d = K(i, "outputInst");
  let u = `${s}.${c}`;
  return d && (u += `(${d})`), u;
}
async function Mi(t, r) {
  const i = await t.db.table(je).get(r);
  if (!i || !i?.parent)
    return [];
  const s = await t.db.table(je).get(i.parent.id);
  return s?.tagName === "Function" || s?.tagName === "SubFunction" ? await t.db.table(je).where({ tagName: "FunctionRef" }).and(
    (u) => K(u, "functionUuid") === K(s, "uuid")
  ).toArray() : [];
}
async function ul(t, r) {
  const i = [];
  for (const s of r)
    (await t.findParentRecordsWithinDepthAndGivenTagName(
      s,
      3,
      ["Application"]
    )).length === 1 && i.push(s);
  return i;
}
async function ru(t, r) {
  const i = /* @__PURE__ */ new Map();
  for (const s of r) {
    const c = await t.findParentRecordsWithinDepthAndGivenTagName(
      s,
      3,
      ["Application"]
    );
    c.length === 1 && i.set(s.id, c[0].id);
  }
  return i;
}
async function ou(t, r, i) {
  const s = await Mi(t, r.id);
  if (s.length === 0)
    return;
  const c = await ul(
    t,
    s
  );
  for (const d of c) {
    let u = (await t.findChildRecords(d, {
      tagNames: ["SignalRole"],
      attrs: [{ name: "name", value: "Input" }]
    }))[0];
    u || (u = await t.addRecord({
      tagName: "SignalRole",
      attributes: [
        { name: "name", value: "Input" },
        { name: "uuid", value: crypto.randomUUID() }
      ],
      parent: null,
      namespace: tn,
      value: "",
      children: []
    }), await t.ensureRelationship(d, u));
    for (const p of i) {
      const m = await t.addRecord({
        tagName: "LNodeInputRef",
        attributes: [
          {
            name: "sourceRef",
            value: await Up(t.db, r.uuid, p)
          },
          { name: "sourceRefUuid", value: K(p, "uuid") || "" }
        ],
        parent: null,
        namespace: tn,
        value: "",
        children: []
      });
      await t.ensureRelationship(u, m);
    }
  }
}
async function Wp(t, r, i) {
  const s = await Mi(t, r.id);
  if (s.length === 0)
    return;
  const c = await ul(
    t,
    s
  );
  for (const d of c) {
    let u = (await t.findChildRecords(d, {
      tagNames: ["SignalRole"],
      attrs: [{ name: "name", value: "Output" }]
    }))[0];
    u || (u = await t.addRecord({
      tagName: "SignalRole",
      attributes: [
        { name: "name", value: "Output" },
        { name: "uuid", value: crypto.randomUUID() }
      ],
      parent: null,
      namespace: tn,
      value: "",
      children: []
    }), await t.ensureRelationship(d, u));
    const p = await t.addRecord({
      tagName: "LNodeOutputRef",
      attributes: [
        {
          name: "controlRef",
          value: await Vp(
            t.db,
            r.uuid,
            i
          )
        },
        { name: "controlRefUuid", value: K(i, "uuid") || "" }
      ],
      parent: null,
      namespace: tn,
      value: "",
      children: []
    });
    await t.ensureRelationship(u, p);
  }
}
async function Gp(t, r, i, s, c) {
  const d = await Mi(t, r.id);
  if (d.length === 0)
    return;
  const u = await ul(
    t,
    d
  ), p = await Eo(t.db, r.uuid, i, s);
  for (const m of u)
    await kr(
      t,
      m,
      "Process",
      p,
      r.uuid,
      i,
      s
    ), c === ot.REPORT && await kr(
      t,
      m,
      "Signalisation",
      p,
      r.uuid,
      i,
      s
    );
}
async function Qi(t, r, i, s, c, d) {
  const u = await Mi(
    t,
    r.id
  ), p = await ru(
    t,
    u
  ), m = await Mi(
    t,
    i.id
  ), P = await ru(
    t,
    m
  );
  let E = "", L, j;
  if (s === ot.CONTROL ? (E = await Eo(t.db, i.uuid, c), L = i, j = m.filter(
    (F) => Array.from(P.keys()).includes(F.id)
  )) : (E = await Eo(t.db, r.uuid, c, d), L = r, j = u.filter(
    (F) => Array.from(p.keys()).includes(F.id)
  )), j.length === 0)
    return;
  for (const F of j)
    s === ot.REPORT && await kr(
      t,
      F,
      "Signalisation",
      E,
      L.uuid,
      c,
      d
    ), s === ot.CONTROL && await kr(
      t,
      F,
      "Control",
      E,
      L.uuid,
      c
    );
  const H = Pt().lnodeTypes.find((F) => F.lnClass === L.lnClass)?.dataObjects.find((F) => F.name === c);
  if (H) {
    const F = await t.db.table(je).where({ tagName: "DOType" }).and((Te) => K(Te, "id") === H.type).first(), q = K(F, "cdc");
    if (q === "DPL" || q === "LPL" || q === "VSD")
      for (const Te of j)
        await kr(
          t,
          Te,
          "Information",
          E,
          L.uuid,
          c,
          d
        );
    else {
      const Te = L.dataObjectSpecifications?.find((ve) => ve.name === c)?.dataAttributeSpecifications.find((ve) => ve.name === d);
      if (await t.db.table(je).where({ tagName: "Val", "parent.id": Te?.id }).first())
        for (const ve of j)
          await kr(
            t,
            ve,
            "Setting",
            E,
            L.uuid,
            c,
            d
          );
    }
  }
  let ie = /* @__PURE__ */ new Set(), W = /* @__PURE__ */ new Set();
  function B(F, q) {
    const Te = F.find((pe) => pe.id === q);
    if (!Te)
      throw new Error(`FunctionRef with id ${q} not found`);
    return Te;
  }
  if (p.size === 0)
    W = new Set(
      m.filter(
        (F) => Array.from(P.keys()).includes(F.id)
      )
    );
  else if (P.size === 0)
    W = new Set(
      u.filter(
        (F) => Array.from(p.keys()).includes(F.id)
      )
    );
  else
    for (const [
      F,
      q
    ] of p)
      for (const [
        Te,
        pe
      ] of P) {
        const ve = B(
          u,
          F
        ), se = B(
          m,
          Te
        );
        q === pe ? (ie.add(ve), ie.add(se)) : (W.add(ve), W.add(se));
      }
  for (const F of j)
    W.has(F) && await kr(
      t,
      F,
      "Process",
      E,
      L.uuid,
      c,
      d
    ), ie.has(F) && await kr(
      t,
      F,
      "Internal",
      E,
      L.uuid,
      c,
      d
    );
}
async function kr(t, r, i, s, c, d, u) {
  const p = await Hp(
    t,
    r,
    i
  );
  await Yp(
    t,
    p,
    s,
    c,
    d,
    u
  );
}
async function Hp(t, r, i) {
  let s = (await t.findChildRecords(r, {
    tagNames: ["SignalRole"],
    attrs: [{ name: "name", value: i }]
  }))[0];
  return s || (s = await t.addRecord({
    tagName: "SignalRole",
    attributes: [
      { name: "name", value: i },
      { name: "uuid", value: crypto.randomUUID() }
    ],
    parent: null,
    namespace: tn,
    value: "",
    children: []
  }), await t.ensureRelationship(r, s), s);
}
async function Yp(t, r, i, s, c, d) {
  const u = [
    { name: "data", value: i },
    { name: "lnodeUuid", value: s },
    { name: "doName", value: c }
  ];
  if (d && u.push({ name: "daName", value: d }), !(await t.findChildRecords(r, {
    tagNames: ["LNodeDataRef"],
    attrs: u
  }))[0]) {
    const m = await t.addRecord({
      tagName: "LNodeDataRef",
      attributes: u,
      parent: null,
      namespace: tn,
      value: "",
      children: []
    });
    await t.ensureRelationship(r, m);
  }
}
function iu(t) {
  return {
    id: t.id,
    uuid: K(t, "uuid") || "",
    desc: K(t, "desc") || "",
    intAddr: K(t, "intAddr") || "",
    pServT: K(t, "pServT") ?? void 0,
    pLN: K(t, "pLN") || "",
    pDo: K(t, "pDO") || "",
    pDa: K(t, "pDA") || "",
    daName: K(t, "daName") || "",
    doName: K(t, "doName") || "",
    ldInst: K(t, "ldInst") || "",
    lnClass: K(t, "lnClass") || "",
    lnInst: K(t, "lnInst") || "",
    prefix: K(t, "prefix") || "",
    serviceType: K(t, "serviceType") ?? void 0,
    srcCbName: K(t, "srcCBName") || "",
    srcLdInst: K(t, "srcLDInst") || "",
    srcPrefix: K(t, "srcPrefix") || "",
    srcLnClass: K(t, "srcLNClass") || "",
    srcLnInst: K(t, "srcLNInst") || "",
    iedName: K(t, "iedName") || ""
  };
}
function Xp(t) {
  return {
    id: t.id,
    name: K(t, "name") || "",
    confRev: K(t, "confRev") || "",
    datSet: K(t, "datSet") || ""
  };
}
function Qp(t) {
  return {
    id: t.id,
    name: K(t, "name") || ""
  };
}
function zp(t) {
  return {
    id: t.id,
    doName: K(t, "doName") || "",
    daName: K(t, "daName") || "",
    fc: K(t, "fc") || ""
  };
}
function ys(t, r) {
  return {
    dataflowType: t.type,
    inputName: t.inputName,
    inputInstance: t.inputInstance,
    sourceLNodeUuid: r.uuid,
    resourceName: "",
    resourceUuid: "",
    sourceDoName: t.signal,
    sourceDaName: t.attribute,
    pLN: r.lnClass,
    // SETRULE: set lnClass of source LNode also as preferred LN
    pDO: t.signal,
    // SETRULE: set signal/data object also as preferred DO
    pDA: t.attribute
    // SETRULE: set data attribute also as preferred DA
  };
}
function Jp(t, r) {
  return {
    pDO: "",
    // TODO
    pLN: "",
    // TODO
    output: t.outputName,
    outputInst: t.outputInstance,
    controlledLNodeUuid: r.uuid,
    controlledDoName: t.controlledSignal
  };
}
function Zp(t, r) {
  return {
    dataflowType: t.dataflowType,
    inputName: t.inputName,
    inputInstance: t.inputInstance,
    sourceLNodeUuid: "",
    resourceName: K(r, "name") || "",
    resourceUuid: K(r, "uuid") || "",
    sourceDoName: "",
    sourceDaName: "",
    pLN: t.preferredLNode,
    pDO: t.preferredDataObject,
    pDA: t.preferredDataAttribute
  };
}
async function js(t, r) {
  const i = {
    tagName: "DOS",
    namespace: tn,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(i);
}
async function Ec(t, r) {
  const i = {
    tagName: "DAS",
    namespace: tn,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(i);
}
function Ic(t) {
  return {
    findAllEnrichedLNodes: r,
    findAllLNodeTypes: i,
    enrichWithDataObjectSpecifications: d
  };
  async function r() {
    const p = await u();
    return p.length ? await d(p) : [];
  }
  async function i() {
    const p = await t.table(je).where({ tagName: "LNodeType" }).toArray(), m = [];
    for (const P of p)
      m.push({
        id: P.id,
        typeId: K(P, "id") ?? "",
        lnClass: K(P, "lnClass") ?? "",
        dataObjects: await s(P)
      });
    return m;
  }
  async function s(p) {
    if (!p.children) return [];
    const m = [];
    for (const P of p.children) {
      if (P.tagName !== "DO") continue;
      const E = await t.table(je).get(P.id);
      E && m.push({
        id: E.id,
        name: K(E, "name") ?? "",
        type: K(E, "type") ?? "",
        desc: K(E, "desc") ?? "",
        dataAttributes: await c(E)
      });
    }
    return m;
  }
  async function c(p) {
    const m = K(p, "type");
    if (!m) return [];
    const P = (await t.table(je).where({ tagName: "DOType" }).toArray()).find((L) => L.attributes?.find((j) => j.name === "id" && j.value === m));
    if (!P || !P.children) return [];
    const E = [];
    for (const L of P.children) {
      if (L.tagName !== "DA") continue;
      const j = await t.table(je).get(L.id);
      j && E.push({
        id: j.id,
        name: K(j, "name") ?? "",
        type: K(j, "type") ?? "",
        desc: K(j, "desc") ?? "",
        bType: K(j, "bType") ?? "",
        fc: K(j, "fc") ?? ""
      });
    }
    return E;
  }
  async function d(p) {
    const m = await t.table(je).where({ tagName: "Private" }).toArray(), P = await t.table(je).where({ tagName: "DOS" }).toArray(), E = await t.table(je).where({ tagName: "DAS" }).toArray(), L = await t.table(je).where({ tagName: "SubscriberLNode" }).toArray();
    return Promise.all(
      p.map(async (j) => {
        const Y = m.find(
          (H) => H.parent?.id === j.id && H.parent?.tagName === "LNode" && K(H, "type") === "eIEC61850-6-100"
        );
        if (!Y || !Y.children)
          return { ...j, dataObjectSpecifications: [] };
        const z = [];
        for (const H of Y.children) {
          if (H.tagName !== "DOS") continue;
          const ie = P.find((B) => B.id === H.id);
          if (!ie) continue;
          const W = [];
          if (ie.children)
            for (const B of ie.children) {
              if (B.tagName !== "DAS") continue;
              const F = E.find((Te) => Te.id === B.id);
              if (!F) continue;
              let q = [];
              if (F.children) {
                const Te = F.children.filter((ve) => ve.tagName === "SubscriberLNode"), pe = L.filter(
                  (ve) => Te.some((se) => se.id === ve.id)
                );
                for (const ve of pe)
                  q.push({
                    id: ve.id,
                    inputName: K(ve, "inputName") ?? "",
                    service: cl(ve, "service"),
                    pLN: K(ve, "pLN") ?? "",
                    resourceName: K(ve, "resourceName") ?? ""
                  });
              }
              W.push({
                id: F.id,
                name: K(F, "name") ?? "",
                desc: K(F, "desc") ?? "",
                subscriberLNodes: q
              });
            }
          z.push({
            id: ie.id,
            name: K(ie, "name") ?? "",
            desc: K(ie, "desc") ?? "",
            dataAttributeSpecifications: W
          });
        }
        return { ...j, dataObjectSpecifications: z };
      })
    );
  }
  async function u() {
    return (await t.table(je).where({ tagName: "LNode" }).toArray()).map((m) => ({
      id: m.id,
      uuid: K(m, "uuid") ?? "",
      iedName: K(m, "iedName") ?? "",
      prefix: K(m, "prefix") ?? "",
      lnClass: K(m, "lnClass") ?? "",
      lnInst: K(m, "lnInst") ?? "",
      lnType: K(m, "lnType") ?? "",
      ldInst: K(m, "ldInst") ?? "",
      dataObjects: []
    }));
  }
}
function cl(t, r) {
  const i = t?.attributes?.find((c) => c.name === r)?.value;
  if (!i) return;
  switch (i.toUpperCase()) {
    case "GOOSE":
      return ot.GOOSE;
    case "SMV":
      return ot.SMV;
    case "REPORT":
      return ot.REPORT;
    case "WIRED":
      return ot.WIRED;
    case "CONTROL":
      return ot.CONTROL;
    case "INTERNAL":
      return ot.INTERNAL;
    default:
      return;
  }
}
function eh(t) {
  const r = il(t);
  return {
    findAllExistingConnections: i,
    findAllExistingControlledConnections: s
  };
  async function i() {
    const c = await t.table(je).where({ tagName: "SourceRef" }).toArray();
    if (!c.length) return [];
    const d = [];
    for (const u of c) {
      if (!u.attributes) continue;
      const p = K(u, "sourceLNodeUuid"), m = await t.table(je).where({ tagName: "LNode" }).toArray().then(
        (F) => F.find(
          (q) => q.attributes?.some(
            (Te) => Te.name === "uuid" && Te.value === p
          )
        )
      ), P = await r.findParentRecordsWithinDepthAndGivenTagName(
        u,
        3,
        ["LNode"]
      );
      if (P.length != 1) {
        const F = {
          msg: "Destination LNode record not found for SourceRef id",
          id: u.id
        };
        throw console.error(F), new Error(JSON.stringify(F));
      }
      const E = await t.table(je).where({ tagName: "IED" }).toArray();
      let L = !1;
      const j = K(m, "iedName");
      if (j) {
        const F = E.find(
          (q) => K(q, "name") === j
        );
        Ae(F, `IED record not found for iedName: ${j}`), L = K(F, "manufacturer") !== "S_IED";
      }
      let Y = !1;
      const z = K(P[0], "iedName");
      if (z) {
        const F = E.find(
          (q) => K(q, "name") === z
        );
        Ae(
          F,
          `IED record not found for iedName: ${z}`
        ), Y = K(F, "manufacturer") !== "S_IED";
      }
      const H = !L || !Y;
      let ie = !1;
      const W = K(u, "extRefUuid");
      if (W) {
        const F = await r.findRecord({
          tagNames: ["ExtRef"],
          attr: { name: "uuid", value: W }
        });
        Ae(F, `ExtRef record not found for uuid: ${W}`), ie = !!K(F, "srcCBName");
      }
      const B = th(
        u,
        m?.id ?? null,
        P[0].id,
        ie,
        H,
        W
      );
      d.push(B);
    }
    return d;
  }
  async function s() {
    const c = await t.table(je).where({ tagName: "ControlRef" }).toArray();
    if (!c.length) return [];
    const d = [];
    for (const u of c) {
      if (!u.attributes) continue;
      const p = K(u, "controlledLNodeUuid"), m = K(u, "controlledDoName"), P = await t.table(je).where({ tagName: "LNode" }).toArray().then(
        (j) => j.find(
          (Y) => Y.attributes?.some(
            (z) => z.name === "uuid" && z.value === p
          )
        )?.id
      ) || null, E = await r.findParentRecordsWithinDepthAndGivenTagName(
        u,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (E.length != 1) {
        const j = {
          msg: "LNode record not found for ControlRef id",
          id: u.id
        };
        throw console.error(j), new Error(JSON.stringify(j));
      }
      const L = {
        controllerLNodeId: E[0].id,
        controlledLNodeId: P,
        controlledDataObject: m || "",
        dataflowType: ot.CONTROL,
        outputInstance: K(u, "outputInst") || "",
        outputName: K(u, "output") || "",
        id: u.id
      };
      d.push(L);
    }
    return d;
  }
}
function th(t, r, i, s, c, d) {
  return {
    id: t.id,
    sourceLNodeId: r,
    destinationLNodeId: i,
    sourceDataObject: K(t, "sourceDoName") || "",
    sourceDataAttribute: K(t, "sourceDaName") || "",
    dataflowType: cl(t, "service"),
    inputInstance: K(t, "inputInst") || "",
    input: K(t, "input") || "",
    preferredLNode: K(t, "pLN") || "",
    preferredDataObject: K(t, "pDO") || "",
    preferredDataAttribute: K(t, "pDA") || "",
    processResource: K(t, "resourceName") || "",
    isImplemented: s,
    notPossibleToImplement: c,
    extRefUuid: d
  };
}
function nh(t) {
  const r = il(t), i = Ic(t);
  return {
    findAllSourcePlaceholders: s
  };
  async function s() {
    let p = [];
    const m = await i.findAllEnrichedLNodes();
    if (!m.length) return p;
    for (const E of m) {
      const L = E.dataObjectSpecifications ?? [];
      for (const j of L) {
        const Y = j.dataAttributeSpecifications ?? [];
        for (const z of Y) {
          const H = z.subscriberLNodes ?? [];
          for (const ie of H)
            p.push({
              lNodeId: E.id,
              id: ie.id,
              dataObject: j.name,
              dataAttribute: z.name,
              dataflowType: ie.service,
              preferredLNode: ie.pLN,
              input: ie.inputName,
              processResource: ie.resourceName,
              isFulfilled: void 0
            });
        }
      }
    }
    return await u(p);
  }
  async function c() {
    const m = (await t.table(je).where({ tagName: "SourceRef" }).toArray()).map(async (E) => ({
      id: E.id,
      uuid: K(E, "uuid") ?? "",
      pDO: K(E, "pDO") ?? "",
      pDA: K(E, "pDA") ?? "",
      pLN: K(E, "pLN") ?? "",
      input: K(E, "input") ?? "",
      inputInst: K(E, "inputInst") ?? "",
      source: K(E, "source") ?? "",
      sourceLNodeUuid: K(E, "sourceLNodeUuid") ?? "",
      dataflowType: cl(E, "service"),
      sourceDoName: K(E, "sourceDoName") ?? "",
      sourceDaName: K(E, "sourceDaName") ?? "",
      // Add the lnClass for finding fulfilled placeholders
      lnClassOfParentLNode: await d(E.id, 3)
    }));
    return await Promise.all(m);
  }
  async function d(p, m) {
    const P = await r.db.table(je).get(p);
    if (P) {
      const E = await r.findParentRecordsWithinDepthAndGivenTagName(
        P,
        m,
        ["LNode"]
      );
      return K(E[0], "lnClass");
    } else return "";
  }
  async function u(p) {
    const m = await c(), P = [];
    for (const E of p) {
      const L = m.some((j) => !(E.preferredLNode && E.preferredLNode !== j.lnClassOfParentLNode || E.dataflowType && E.dataflowType !== j.dataflowType || E.dataObject && E.dataObject !== j.sourceDoName || E.dataAttribute && E.dataAttribute !== j.sourceDaName));
      P.push({
        ...E,
        isFulfilled: L
      });
    }
    return P;
  }
}
const Pt = /* @__PURE__ */ ol("dataflow/app", () => {
  let t = null;
  const r = Ue(""), i = Ue([]), s = Ue([]), c = Ue([]), d = Ue([]), u = Ue([]), p = An(), m = An(), P = An(), E = An();
  async function L(ie) {
    j(), t = new ma(ie), await t.open(), P.value = Ic(t), m.value = eh(t), E.value = nh(t), r.value = ie, p.value = Cp(t), i.value = await P.value.findAllEnrichedLNodes(), s.value = await P.value.findAllLNodeTypes(), c.value = await m.value.findAllExistingConnections(), d.value = await m.value.findAllExistingControlledConnections(), u.value = await E.value.findAllSourcePlaceholders();
  }
  function j() {
    t && (t.close(), t = null);
  }
  async function Y() {
    c.value = await m.value.findAllExistingConnections(), d.value = await m.value.findAllExistingControlledConnections();
  }
  async function z(ie) {
    const B = (await P.value.findAllEnrichedLNodes()).find((F) => F.id === ie);
    if (B) {
      const F = i.value.findIndex((q) => q.id === ie);
      F !== -1 && (i.value[F] = B);
    }
  }
  async function H() {
    u.value = await E.value.findAllSourcePlaceholders();
  }
  return {
    // states
    activeFilename: r,
    lnodes: i,
    lnodeTypes: s,
    connections: c,
    controlledConnections: d,
    sourcePlaceholders: u,
    // getters
    dataflowSdk: p,
    // actions
    initApp: L,
    closeDatabase: j,
    refreshConnections: Y,
    refreshLNode: z,
    refreshPlaceholders: H
  };
}), rh = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, oh = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, ih = { class: "mt-4" }, ah = { key: 0 }, sh = { key: 1 }, lh = { class: "mt-4" }, uh = /* @__PURE__ */ Ot({
  __name: "connection-details",
  props: {
    connection: {}
  },
  setup(t) {
    const r = t, i = Pt(), { lnodes: s } = $t(i), c = ze(() => s.value.find((p) => p.id === r.connection.sourceLNodeId)?.dataObjectSpecifications?.find(
      (p) => p.name === r.connection.sourceDataObject
    )), d = ze(() => c?.value?.dataAttributeSpecifications?.find(
      (u) => u.name === r.connection.sourceDataAttribute
    ));
    return (u, p) => (ae(), de(qe, null, [
      p[10] || (p[10] = y("h2", { class: "text-lg font-bold mb-2" }, "Specified Dataflow", -1)),
      u.connection.dataflowType ? (ae(), de("span", rh, le(u.connection.dataflowType), 1)) : Xe("", !0),
      y("dl", oh, [
        y("div", null, [
          p[0] || (p[0] = y("dt", null, "Input:", -1)),
          y("dd", null, le(u.connection.input), 1)
        ]),
        y("div", null, [
          p[1] || (p[1] = y("dt", null, "Input Instance:", -1)),
          y("dd", null, le(u.connection.inputInstance || "-"), 1)
        ]),
        y("div", ih, [
          p[2] || (p[2] = y("dt", null, "DO:", -1)),
          y("dd", null, le(u.connection.sourceDataObject || "-"), 1)
        ]),
        c.value?.desc ? (ae(), de("div", ah, [
          p[3] || (p[3] = y("dt", null, "DO Desc:", -1)),
          y("dd", null, le(c.value.desc), 1)
        ])) : Xe("", !0),
        y("div", null, [
          p[4] || (p[4] = y("dt", null, "DA:", -1)),
          y("dd", null, le(u.connection.sourceDataAttribute || "-"), 1)
        ]),
        d.value?.desc ? (ae(), de("div", sh, [
          p[5] || (p[5] = y("dt", null, "DA Desc:", -1)),
          y("dd", null, le(d.value.desc), 1)
        ])) : Xe("", !0),
        y("div", lh, [
          p[6] || (p[6] = y("dt", null, "Preferred LN:", -1)),
          y("dd", null, le(u.connection.preferredLNode || "-"), 1)
        ]),
        y("div", null, [
          p[7] || (p[7] = y("dt", null, "Preferred DO:", -1)),
          y("dd", null, le(u.connection.preferredDataObject || "-"), 1)
        ]),
        y("div", null, [
          p[8] || (p[8] = y("dt", null, "Preferred DA:", -1)),
          y("dd", null, le(u.connection.preferredDataAttribute || "-"), 1)
        ]),
        y("div", null, [
          p[9] || (p[9] = y("dt", null, "Process Resource:", -1)),
          y("dd", null, le(u.connection.processResource || "-"), 1)
        ])
      ])
    ], 64));
  }
}), ch = { key: 0 }, fh = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, dh = { class: "flex flex-col gap-4" }, ph = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, hh = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, mh = /* @__PURE__ */ Ot({
  __name: "implemented-dataflow-details",
  props: {
    connection: {}
  },
  setup(t) {
    const r = t, i = Pt(), { dataflowSdk: s } = $t(i), c = Ue(null), d = Ue(null), u = Ue(null), p = Ue("");
    Ia(async () => {
      !r.connection.extRefUuid || !r.connection.isImplemented || (c.value = await s.value.findExtRefByUuid(r.connection.extRefUuid), c.value.srcCbName && (d.value = await s.value.findControlBlock(
        c.value.iedName,
        c.value.ldInst,
        c.value.srcCbName
      ), u.value = await s.value.findDataSet(
        c.value.iedName,
        c.value.ldInst,
        d.value.datSet
      ), p.value = await s.value.findPathToExtRef(c.value.id)));
    });
    const m = ze(() => `${c.value?.iedName}/${c.value?.ldInst}/${c.value?.prefix}${c.value?.lnClass}${c.value?.lnInst}`), P = ze(() => p.value.split("/").slice(0, -1).join("/")), E = ze(() => `${c.value?.iedName}/${c.value?.srcLdInst}/${c.value?.srcPrefix}${c.value?.srcLnClass}${c.value?.srcLnInst}`);
    return (L, j) => (ae(), de(qe, null, [
      j[9] || (j[9] = y("h2", { class: "text-lg font-bold mb-2" }, "Implemented Dataflow", -1)),
      L.connection.isImplemented ? Xe("", !0) : (ae(), de("p", ch, "Not implemented yet")),
      c.value ? (ae(), de(qe, { key: 1 }, [
        L.connection.dataflowType ? (ae(), de("span", fh, le(c.value.serviceType), 1)) : Xe("", !0),
        y("div", dh, [
          y("dl", ph, [
            y("div", null, [
              j[0] || (j[0] = y("dt", null, "DO:", -1)),
              y("dd", null, le(c.value.doName), 1)
            ]),
            y("div", null, [
              j[1] || (j[1] = y("dt", null, "DA:", -1)),
              y("dd", null, le(c.value.daName), 1)
            ])
          ]),
          y("div", null, [
            j[2] || (j[2] = y("h3", { class: "font-semibold" }, "Sending IED/LD/LN", -1)),
            y("div", null, le(m.value), 1)
          ]),
          y("div", null, [
            j[3] || (j[3] = y("h3", { class: "font-semibold" }, "Receiving IED/LD/LN", -1)),
            y("div", null, le(P.value), 1)
          ]),
          y("div", null, [
            j[8] || (j[8] = y("h3", { class: "font-semibold" }, "Control Block and Data Set", -1)),
            y("dl", hh, [
              y("div", null, [
                j[4] || (j[4] = y("dt", null, "Location:", -1)),
                y("dd", null, le(E.value), 1)
              ]),
              y("div", null, [
                j[5] || (j[5] = y("dt", null, "Control Block:", -1)),
                y("dd", null, le(d.value?.name), 1)
              ]),
              y("div", null, [
                j[6] || (j[6] = y("dt", null, "ConfRev:", -1)),
                y("dd", null, le(d.value?.confRev), 1)
              ]),
              y("div", null, [
                j[7] || (j[7] = y("dt", null, "DataSet:", -1)),
                y("dd", null, le(u.value?.name), 1)
              ])
            ])
          ])
        ])
      ], 64)) : Xe("", !0)
    ], 64));
  }
}), vh = { class: "grid grid-cols-2 gap-4 mt-4" }, yh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, gh = ["value"], bh = { class: "grid grid-cols-2 gap-4 mt-4" }, wh = ["value", "title"], _h = { class: "grid grid-cols-2 gap-4 mt-4" }, xh = ["value", "title"], Nh = { class: "grid grid-cols-2 gap-4 mt-4" }, Rh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Ch = ["value"], Th = { class: "grid grid-cols-2 gap-4 mt-4" }, Eh = { class: "flex items-center" }, Ih = { class: "flex items-center" }, Ah = ["value"], Oh = { class: "grid grid-cols-2 gap-4 mt-4" }, Dh = { class: "mt-4" }, Sh = { class: "mt-4" }, Ph = { class: "mt-4 flex items-center" }, Lh = /* @__PURE__ */ Ot({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {},
    sourcePlaceholder: {}
  },
  setup(t) {
    const r = t, i = zn(), s = Pt(), { lnodeTypes: c, dataflowSdk: d } = $t(s), u = Ue(j()), p = Ue(!1), m = Ue([]), P = Ue(!0);
    Ko(async () => {
      m.value = await d.value.findExistingInputs(r.destinationLNode);
    }), Ut(p, (W) => {
      W ? u.value.inputName = "" : u.value.inputName = u.value.signal;
    }), Ut(
      [
        () => u.value.inputName,
        () => u.value.attribute
      ],
      async ([W, B]) => {
        const F = await d.value.calculateNextInputInstance(
          W,
          B,
          r.destinationLNode
        );
        u.value.inputInstance = F.toString();
      }
    ), Ut(
      () => u.value.signal,
      (W, B) => {
        const F = u.value.inputName !== B && u.value.inputName !== "";
        !p.value && !F && (u.value.inputName = W);
      }
    ), Ia(() => {
      switch (ie(), u.value.type = r.dataflowType, r.dataflowType) {
        case ot.GOOSE:
        case ot.SMV:
          u.value.includeQuality = !0, u.value.includeTimestamp = !1;
          break;
        case ot.REPORT:
          u.value.includeQuality = !0, u.value.includeTimestamp = !0;
          break;
        default:
          u.value.includeQuality = !1, u.value.includeTimestamp = !1;
      }
    });
    const E = ze(() => !r.dataflowType || !r.sourceLNode ? [] : c.value.find((W) => W.typeId === r.sourceLNode.lnType)?.dataObjects.filter(
      (W) => W.dataAttributes.some(
        (B) => Mo[r.dataflowType]?.includes(B.fc)
      )
    ).sort((W, B) => W.name.localeCompare(B.name)) ?? []), L = ze(() => !r.dataflowType || !r.sourceLNode ? [] : c.value.find((W) => W.typeId === r.sourceLNode.lnType)?.dataObjects.find((W) => W.name === u.value.signal)?.dataAttributes.filter(
      (W) => Mo[r.dataflowType].includes(W.fc)
    ).filter((W) => !Fi.includes(W.name)).sort((W, B) => W.name.localeCompare(B.name)) ?? []);
    Ut(
      [() => E.value, () => r.sourcePlaceholder],
      ([W, B]) => {
        if (B && W.length > 0) {
          const F = W.find((q) => q.name === B.dataObject);
          u.value.signal = F ? F.name : "";
        }
      },
      { immediate: !0 }
    ), Ut(
      [
        () => L.value,
        () => r.sourcePlaceholder,
        () => u.value.signal
      ],
      ([W, B, F]) => {
        if (B && W.length > 0) {
          const q = W.find((Te) => Te.name === B.dataAttribute);
          q && F === B.dataObject && (u.value.attribute = q.name);
        }
      },
      { immediate: !0 }
    ), Ut(
      [
        () => u.value.signal,
        () => u.value.attribute,
        () => p.value,
        () => r.sourcePlaceholder
      ],
      ([W, B, F, q]) => {
        q && q.input && W !== "" && B !== "" && F === !1 && (u.value.inputName = q.input);
      },
      { immediate: !0 }
    );
    function j() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function Y(W) {
      for (const B of W)
        u.value[B] = "";
    }
    async function z() {
      try {
        if (!H(u.value))
          return;
        await d.value.createConnection(
          u.value,
          r.sourceLNode,
          r.destinationLNode,
          P.value
        ), i.handleClose();
      } catch (W) {
        console.error("Error creating dataflow:", W), alert(`Error creating dataflow: ${W instanceof Error ? W.message : "Unknown error"}`);
      }
    }
    function H(W) {
      return W.type ? W.signal ? W.attribute ? W.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function ie() {
      u.value = j(), p.value = !1, P.value = !0;
    }
    return (W, B) => (ae(), de(qe, null, [
      B[27] || (B[27] = y("hr", { class: "solid mt-4" }, null, -1)),
      y("form", {
        method: "dialog",
        onSubmit: z
      }, [
        y("div", vh, [
          B[11] || (B[11] = y("label", {
            for: "source-select",
            class: "col-start-1 self-center"
          }, "Source", -1)),
          y("select", yh, [
            y("option", {
              value: r.sourceLNode.id
            }, le(Le(ha)(W.sourceLNode)), 9, gh)
          ])
        ]),
        y("div", bh, [
          B[13] || (B[13] = y("label", {
            for: "data-object-select",
            class: "col-start-1 self-center"
          }, "Signal (DO)", -1)),
          at(y("select", {
            id: "data-object-select",
            required: "",
            class: "select col-start-2",
            "onUpdate:modelValue": B[0] || (B[0] = (F) => u.value.signal = F),
            onChange: B[1] || (B[1] = (F) => Y(["attribute"]))
          }, [
            B[12] || (B[12] = y("option", {
              key: "empty",
              value: ""
            }, "-", -1)),
            (ae(!0), de(qe, null, bt(E.value, (F) => (ae(), de("option", {
              key: F.name,
              value: F.name,
              title: F.desc ? `Desc: ${F.desc}` : ""
            }, le(F.desc ? F.name + " ⓘ" : F.name), 9, wh))), 128))
          ], 544), [
            [Jt, u.value.signal]
          ])
        ]),
        y("div", _h, [
          B[15] || (B[15] = y("label", {
            for: "data-attribute-select",
            class: "col-start-1 self-center"
          }, "Attribute (DA)", -1)),
          at(y("select", {
            id: "data-attribute-select",
            required: "",
            class: "select col-start-2",
            "onUpdate:modelValue": B[2] || (B[2] = (F) => u.value.attribute = F)
          }, [
            B[14] || (B[14] = y("option", {
              key: "empty",
              value: ""
            }, "-", -1)),
            (ae(!0), de(qe, null, bt(L.value, (F) => (ae(), de("option", {
              key: F.name,
              value: F.name,
              title: F.desc ? `Desc: ${F.desc}` : ""
            }, le(F.desc ? F.name + " ⓘ" : F.name), 9, xh))), 128))
          ], 512), [
            [Jt, u.value.attribute]
          ])
        ]),
        B[24] || (B[24] = y("hr", { class: "solid mt-4" }, null, -1)),
        y("div", Nh, [
          B[16] || (B[16] = y("label", {
            for: "destination-select",
            class: "col-start-1 self-center"
          }, "Destination", -1)),
          y("select", Rh, [
            y("option", {
              value: r.destinationLNode.id
            }, le(Le(ha)(W.destinationLNode)), 9, Ch)
          ])
        ]),
        y("div", Th, [
          y("fieldset", null, [
            B[19] || (B[19] = y("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
            y("div", Eh, [
              at(y("input", {
                type: "radio",
                id: "dataflow-new-input",
                name: "input",
                "onUpdate:modelValue": B[3] || (B[3] = (F) => p.value = F),
                value: !1,
                class: "radio radio-sm mr-2"
              }, null, 512), [
                [Mr, p.value]
              ]),
              B[17] || (B[17] = y("label", { for: "dataflow-new-input" }, "New Input", -1))
            ]),
            y("div", Ih, [
              at(y("input", {
                type: "radio",
                id: "dataflow-existing-input",
                name: "input",
                "onUpdate:modelValue": B[4] || (B[4] = (F) => p.value = F),
                value: !0,
                class: "radio radio-sm mr-2"
              }, null, 512), [
                [Mr, p.value]
              ]),
              B[18] || (B[18] = y("label", { for: "dataflow-existing-input" }, "Existing Input", -1))
            ])
          ]),
          p.value ? Xe("", !0) : at((ae(), de("input", {
            key: 0,
            "aria-label": "New Input Name",
            required: "",
            type: "text",
            placeholder: "Input Name",
            class: "input col-start-2",
            "onUpdate:modelValue": B[5] || (B[5] = (F) => u.value.inputName = F)
          }, null, 512)), [
            [To, u.value.inputName]
          ]),
          p.value ? at((ae(), de("select", {
            key: 1,
            "aria-label": "Existing Input Name Select",
            required: "",
            class: "select col-start-2",
            "onUpdate:modelValue": B[6] || (B[6] = (F) => u.value.inputName = F)
          }, [
            (ae(!0), de(qe, null, bt(m.value, (F) => (ae(), de("option", {
              key: F,
              value: F
            }, le(F), 9, Ah))), 128))
          ], 512)), [
            [Jt, u.value.inputName]
          ]) : Xe("", !0)
        ]),
        y("div", Oh, [
          B[20] || (B[20] = y("label", {
            for: "input-instance-input",
            class: "col-start-1 self-center"
          }, "Input Instance", -1)),
          at(y("input", {
            id: "input-instance-input",
            required: "",
            disabled: "",
            type: "text",
            class: "input col-start-2",
            "onUpdate:modelValue": B[7] || (B[7] = (F) => u.value.inputInstance = F)
          }, null, 512), [
            [To, u.value.inputInstance]
          ])
        ]),
        B[25] || (B[25] = y("hr", { class: "solid mt-4" }, null, -1)),
        y("div", Dh, [
          at(y("input", {
            type: "checkbox",
            "onUpdate:modelValue": B[8] || (B[8] = (F) => u.value.includeQuality = F),
            class: "checkbox mr-2",
            id: "checkbox-include-quality"
          }, null, 512), [
            [Ro, u.value.includeQuality]
          ]),
          B[21] || (B[21] = y("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
        ]),
        y("div", Sh, [
          at(y("input", {
            type: "checkbox",
            "onUpdate:modelValue": B[9] || (B[9] = (F) => u.value.includeTimestamp = F),
            class: "checkbox mr-2",
            id: "checkbox-include-timestamp"
          }, null, 512), [
            [Ro, u.value.includeTimestamp]
          ]),
          B[22] || (B[22] = y("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
        ]),
        y("div", Ph, [
          at(y("input", {
            type: "checkbox",
            "onUpdate:modelValue": B[10] || (B[10] = (F) => P.value = F),
            class: "checkbox mr-2",
            id: "dataflow-checkbox-add-references"
          }, null, 512), [
            [Ro, P.value]
          ]),
          B[23] || (B[23] = y("label", { for: "dataflow-checkbox-add-references" }, "Add References to Application", -1))
        ]),
        B[26] || (B[26] = y("div", { class: "modal-action" }, [
          y("button", {
            class: "btn bg-(--color-primary) border-none text-white",
            type: "submit",
            "data-testId": "save-dataflow-connection"
          }, " Save ")
        ], -1))
      ], 32)
    ], 64));
  }
}), kh = { class: "grid grid-cols-2 gap-4 mt-4" }, jh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Fh = ["value"], $h = { class: "grid grid-cols-2 gap-4 mt-4" }, Mh = ["value", "title"], Bh = { class: "grid grid-cols-2 gap-4 mt-4" }, Kh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, qh = ["value"], Uh = { class: "grid grid-cols-2 gap-4 mt-4" }, Vh = { class: "flex items-center" }, Wh = { class: "flex items-center" }, Gh = ["value"], Hh = { class: "grid grid-cols-2 gap-4 mt-4" }, Yh = { class: "mt-4 flex items-center" }, Xh = /* @__PURE__ */ Ot({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {}
  },
  setup(t) {
    const r = t, i = zn(), s = Pt(), { lnodeTypes: c, dataflowSdk: d } = $t(s), u = Ue(
      L()
    ), p = Ue(!1), m = Ue([]), P = Ue(!0);
    Ko(async () => {
      m.value = await d.value.findExistingOutputs(r.sourceLNode);
    }), Ut(p, (z) => {
      z ? u.value.outputName = "" : u.value.outputName = u.value.controlledSignal;
    }), Ut(
      () => u.value.outputName,
      async (z) => {
        const H = await d.value.calculateNextOutputInstance(
          z,
          r.sourceLNode
        );
        u.value.outputInstance = H.toString();
      }
    ), Ut(
      () => u.value.controlledSignal,
      (z, H) => {
        const ie = u.value.outputName !== H && u.value.outputName !== "";
        !p.value && !ie && (u.value.outputName = z);
      }
    );
    const E = ze(() => r.destinationLNode ? c.value.find((H) => H.typeId === r.destinationLNode.lnType)?.dataObjects.map((H) => ({
      name: H.name,
      desc: H.desc
    })).sort((H, ie) => H.name.localeCompare(ie.name)) ?? [] : []);
    function L() {
      return {
        type: ot.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function j() {
      try {
        if (!Y(u.value))
          return;
        await d.value.createControlledConnection(
          u.value,
          r.sourceLNode,
          r.destinationLNode,
          P.value
        ), i.handleClose();
      } catch (z) {
        console.error("Error creating controlled dataflow:", z), alert(`Error creating controlled dataflow: ${z instanceof Error ? z.message : "Unknown error"}`);
      }
    }
    function Y(z) {
      return z.type ? z.outputName ? z.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    return (z, H) => (ae(), de(qe, null, [
      H[16] || (H[16] = y("hr", { class: "solid mt-4" }, null, -1)),
      y("div", kh, [
        H[7] || (H[7] = y("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        y("select", jh, [
          y("option", {
            value: r.destinationLNode.id
          }, le(Le(ha)(z.destinationLNode)), 9, Fh)
        ])
      ]),
      y("div", $h, [
        H[9] || (H[9] = y("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        at(y("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": H[0] || (H[0] = (ie) => u.value.controlledSignal = ie)
        }, [
          H[8] || (H[8] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(E.value, (ie) => (ae(), de("option", {
            key: ie.name,
            value: ie.name,
            title: ie.desc ? `Desc: ${ie.desc}` : ""
          }, le(ie.desc ? ie.name + " ⓘ" : ie.name), 9, Mh))), 128))
        ], 512), [
          [Jt, u.value.controlledSignal]
        ])
      ]),
      H[17] || (H[17] = y("hr", { class: "solid mt-4" }, null, -1)),
      y("div", Bh, [
        H[10] || (H[10] = y("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        y("select", Kh, [
          y("option", {
            value: r.sourceLNode.id
          }, le(Le(ha)(z.sourceLNode)), 9, qh)
        ])
      ]),
      y("div", Uh, [
        y("fieldset", null, [
          H[13] || (H[13] = y("legend", { class: "col-start-1 self-start" }, "Controller Output Name", -1)),
          y("div", Vh, [
            at(y("input", {
              type: "radio",
              id: "dataflow-control-new-output",
              name: "output",
              "onUpdate:modelValue": H[1] || (H[1] = (ie) => p.value = ie),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Mr, p.value]
            ]),
            H[11] || (H[11] = y("label", { for: "dataflow-control-new-output" }, "New Output", -1))
          ]),
          y("div", Wh, [
            at(y("input", {
              type: "radio",
              id: "dataflow-control-existing-output",
              name: "output",
              "onUpdate:modelValue": H[2] || (H[2] = (ie) => p.value = ie),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Mr, p.value]
            ]),
            H[12] || (H[12] = y("label", { for: "dataflow-control-existing-output" }, "Existing Output", -1))
          ])
        ]),
        p.value ? Xe("", !0) : at((ae(), de("input", {
          key: 0,
          "aria-label": "New Output Name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": H[3] || (H[3] = (ie) => u.value.outputName = ie)
        }, null, 512)), [
          [To, u.value.outputName]
        ]),
        p.value ? at((ae(), de("select", {
          key: 1,
          "aria-label": "Existing Output Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": H[4] || (H[4] = (ie) => u.value.outputName = ie)
        }, [
          (ae(!0), de(qe, null, bt(m.value, (ie) => (ae(), de("option", {
            key: ie,
            value: ie
          }, le(ie), 9, Gh))), 128))
        ], 512)), [
          [Jt, u.value.outputName]
        ]) : Xe("", !0)
      ]),
      y("div", Hh, [
        H[14] || (H[14] = y("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Output Instance", -1)),
        at(y("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": H[5] || (H[5] = (ie) => u.value.outputInstance = ie)
        }, null, 512), [
          [To, u.value.outputInstance]
        ])
      ]),
      y("div", Yh, [
        at(y("input", {
          type: "checkbox",
          "onUpdate:modelValue": H[6] || (H[6] = (ie) => P.value = ie),
          class: "checkbox mr-2",
          id: "dataflow-control-checkbox-add-references"
        }, null, 512), [
          [Ro, P.value]
        ]),
        H[15] || (H[15] = y("label", { for: "dataflow-control-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      H[18] || (H[18] = y("hr", { class: "solid mt-4" }, null, -1)),
      y("div", { class: "modal-action" }, [
        y("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: j,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), Qh = { class: "grid grid-cols-2 gap-4 mt-4" }, zh = ["value", "disabled"], Jh = /* @__PURE__ */ Ot({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    sourcePlaceholder: {}
  },
  setup(t) {
    const r = t, i = Ue(
      r.sourcePlaceholder && r.sourcePlaceholder.dataflowType ? r.sourcePlaceholder.dataflowType : null
    ), s = ze(
      () => Object.values(ot).filter((u) => u !== ot.INTERNAL)
    ), c = ze(
      () => r.sourceLNode?.lnClass === "IHMI" || r.sourceLNode?.lnClass === "ITCI"
    );
    function d(u) {
      const p = u.target.value;
      i.value = p;
    }
    return (u, p) => (ae(), de(qe, null, [
      p[3] || (p[3] = y("h3", { class: "font-bold text-lg" }, "Create Dataflow", -1)),
      y("div", Qh, [
        p[2] || (p[2] = y("label", {
          for: "dataflow-type-select",
          class: "col-start-1 self-center"
        }, "Dataflow Type", -1)),
        at(y("select", {
          id: "dataflow-type-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": p[0] || (p[0] = (m) => i.value = m),
          onChange: d
        }, [
          p[1] || (p[1] = y("option", {
            key: "empty",
            value: null
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(s.value, (m) => (ae(), de("option", {
            key: m,
            value: m,
            disabled: m === Le(ot).CONTROL && !c.value
          }, le(m), 9, zh))), 128))
        ], 544), [
          [Jt, i.value]
        ])
      ]),
      i.value !== Le(ot).CONTROL ? (ae(), en(Lh, {
        key: 0,
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        dataflowType: i.value,
        sourcePlaceholder: u.sourcePlaceholder
      }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType", "sourcePlaceholder"])) : (ae(), en(Xh, {
        key: 1,
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        dataflowType: i.value
      }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType"]))
    ], 64));
  }
});
function Zh(t) {
  return qs() ? (hu(t), !0) : !1;
}
const em = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const tm = () => {
};
function nm(t, r, i = {}) {
  const {
    immediate: s = !0,
    immediateCallback: c = !1
  } = i, d = An(!1);
  let u;
  function p() {
    u && (clearTimeout(u), u = void 0);
  }
  function m() {
    d.value = !1, p();
  }
  function P(...E) {
    c && t(), p(), d.value = !0, u = setTimeout(() => {
      d.value = !1, u = void 0, t(...E);
    }, ff(r));
  }
  return s && (d.value = !0, em && P()), Zh(m), {
    isPending: uf(d),
    start: P,
    stop: m
  };
}
function fl(t, r, i) {
  let s;
  At(i) ? s = {
    evaluating: i
  } : s = {};
  const {
    lazy: c = !1,
    flush: d = "pre",
    evaluating: u = void 0,
    shallow: p = !0,
    onError: m = tm
  } = s, P = An(!c), E = p ? An(r) : Ue(r);
  let L = 0;
  return Ia(async (j) => {
    if (!P.value)
      return;
    L++;
    const Y = L;
    let z = !1;
    u && Promise.resolve().then(() => {
      u.value = !0;
    });
    try {
      const H = await t((ie) => {
        j(() => {
          u && (u.value = !1), z || ie();
        });
      });
      Y === L && (E.value = H);
    } catch (H) {
      m(H);
    } finally {
      u && Y === L && (u.value = !1), z = !0;
    }
  }, { flush: d }), c ? ze(() => (P.value = !0, E.value)) : E;
}
const rm = { class: "grid grid-cols-2 gap-4 items-center" }, om = { class: "grid grid-cols-2 gap-4 items-center" }, im = ["value", "disabled"], am = { class: "grid grid-cols-2 gap-4 items-center" }, sm = ["value", "title"], lm = { class: "grid grid-cols-2 gap-4 items-center" }, um = ["value", "title"], cm = { class: "grid grid-cols-2 gap-4 items-center" }, fm = ["value"], dm = { class: "grid grid-cols-2 gap-4 items-center" }, pm = ["value"], hm = { class: "flex items-center" }, mm = /* @__PURE__ */ Ot({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {}
  },
  setup(t) {
    const r = t, i = zn(), s = Pt(), { lnodeTypes: c, dataflowSdk: d } = $t(s), u = Ue(
      z()
    ), p = Ue(!0);
    async function m(ie) {
      try {
        await d.value.createSourcePlaceholder(
          r.sourceLNode,
          u.value,
          p.value
        ), i.handleClose();
      } catch (W) {
        console.error("Error creating source placeholder port:", W), alert(`Error creating placeholder: ${W instanceof Error ? W.message : "Unknown error"}`);
      }
    }
    const P = fl(async () => d.value ? (await d.value.findProcessResourcesForLnode(
      r.sourceLNode.id
    )).map((W) => ({
      name: va(W, "name"),
      id: W.id
    })).sort((W, B) => W.name.localeCompare(B.name)) : []), E = ze(
      () => [...c.value].sort((ie, W) => ie.lnClass.localeCompare(W.lnClass))
    ), L = ze(
      () => Object.values(ot).filter((ie) => ie !== ot.INTERNAL)
    ), j = ze(() => {
      const ie = c.value.find((W) => W.typeId === r.sourceLNode.lnType);
      return ie ? u.value.dataflowType ? ie.dataObjects.filter(
        (W) => W.dataAttributes.some(
          (B) => Mo[u.value.dataflowType].includes(
            B.fc
          )
        )
      ).sort((W, B) => W.name.localeCompare(B.name)) : ie.dataObjects.sort((W, B) => W.name.localeCompare(B.name)) : [];
    }), Y = ze(() => {
      const ie = c.value.find((W) => W.typeId === r.sourceLNode.lnType)?.dataObjects.find((W) => W.name === u.value.dataObject);
      return ie ? u.value.dataflowType ? ie.dataAttributes.filter(
        (W) => Mo[u.value.dataflowType].includes(
          W.fc
        )
      ).filter((W) => !Fi.includes(W.name)).sort((W, B) => W.name.localeCompare(B.name)) : ie.dataAttributes.filter((W) => !Fi.includes(W.name)).sort((W, B) => W.name.localeCompare(B.name)) : [];
    });
    function z() {
      return {
        dataObject: "",
        dataAttribute: "",
        inputName: "",
        dataflowType: "",
        processResourceId: "",
        preferredLNode: ""
      };
    }
    function H(ie) {
      for (const W of ie)
        u.value[W] = "";
    }
    return (ie, W) => (ae(), de("form", {
      onSubmit: m,
      method: "dialog",
      class: "flex flex-col gap-4 mt-4"
    }, [
      W[21] || (W[21] = y("h3", { class: "font-bold text-lg" }, "Create Placeholder - Provide data", -1)),
      y("div", rm, [
        W[9] || (W[9] = y("label", { for: "input-name" }, "Input Name", -1)),
        at(y("input", {
          required: "",
          id: "input-name",
          name: "inputName",
          "onUpdate:modelValue": W[0] || (W[0] = (B) => u.value.inputName = B),
          placeholder: "Input Name",
          class: "input col-start-2"
        }, null, 512), [
          [To, u.value.inputName]
        ])
      ]),
      y("div", om, [
        W[11] || (W[11] = y("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
        at(y("select", {
          id: "dataflow-type-select",
          name: "dataflowType",
          class: "select col-start-2",
          "onUpdate:modelValue": W[1] || (W[1] = (B) => u.value.dataflowType = B),
          onChange: W[2] || (W[2] = (B) => H(["dataObject", "dataAttribute"]))
        }, [
          W[10] || (W[10] = y("option", { value: "" }, "-", -1)),
          (ae(!0), de(qe, null, bt(L.value, (B) => (ae(), de("option", {
            key: B,
            value: B,
            disabled: B === Le(ot).CONTROL
          }, le(B), 9, im))), 128))
        ], 544), [
          [Jt, u.value.dataflowType]
        ])
      ]),
      y("div", am, [
        W[13] || (W[13] = y("label", { for: "data-object-select" }, "Data Object", -1)),
        at(y("select", {
          required: "",
          id: "data-object-select",
          name: "data object",
          class: "select col-start-2",
          "onUpdate:modelValue": W[3] || (W[3] = (B) => u.value.dataObject = B),
          onChange: W[4] || (W[4] = (B) => H(["dataAttribute"]))
        }, [
          W[12] || (W[12] = y("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(j.value, (B) => (ae(), de("option", {
            key: B.id,
            value: B.name,
            title: B.desc ? `Desc: ${B.desc}` : ""
          }, le(B.desc ? B.name + " ⓘ" : B.name), 9, sm))), 128))
        ], 544), [
          [Jt, u.value.dataObject]
        ])
      ]),
      y("div", lm, [
        W[15] || (W[15] = y("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
        at(y("select", {
          required: "",
          id: "data-attribute-select",
          name: "data attribute",
          "onUpdate:modelValue": W[5] || (W[5] = (B) => u.value.dataAttribute = B),
          class: "select col-start-2"
        }, [
          W[14] || (W[14] = y("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(Y.value, (B) => (ae(), de("option", {
            key: B.id,
            value: B.name,
            title: B.desc ? `Desc: ${B.desc}` : ""
          }, le(B.desc ? B.name + " ⓘ" : B.name), 9, um))), 128))
        ], 512), [
          [Jt, u.value.dataAttribute]
        ])
      ]),
      y("div", cm, [
        W[17] || (W[17] = y("label", {
          for: "process-resource-select",
          class: "col-start-1"
        }, "Process Resource", -1)),
        at(y("select", {
          id: "process-resource-select",
          name: "processResource",
          class: "select col-start-2",
          "onUpdate:modelValue": W[6] || (W[6] = (B) => u.value.processResourceId = B)
        }, [
          W[16] || (W[16] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(Le(P), (B) => (ae(), de("option", {
            key: B.id,
            value: B.id
          }, le(B.name), 9, fm))), 128))
        ], 512), [
          [Jt, u.value.processResourceId]
        ])
      ]),
      y("div", dm, [
        W[19] || (W[19] = y("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
        at(y("select", {
          id: "preferred-lnode-select",
          name: "preferredLNode",
          class: "select col-start-2",
          "onUpdate:modelValue": W[7] || (W[7] = (B) => u.value.preferredLNode = B)
        }, [
          W[18] || (W[18] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(E.value, (B) => (ae(), de("option", {
            key: B.lnClass,
            value: B.lnClass
          }, le(B.lnClass), 9, pm))), 128))
        ], 512), [
          [Jt, u.value.preferredLNode]
        ])
      ]),
      y("div", hm, [
        at(y("input", {
          type: "checkbox",
          "onUpdate:modelValue": W[8] || (W[8] = (B) => p.value = B),
          class: "checkbox mr-2",
          id: "source-placeholder-checkbox-add-references"
        }, null, 512), [
          [Ro, p.value]
        ]),
        W[20] || (W[20] = y("label", { for: "source-placeholder-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      W[22] || (W[22] = y("div", { class: "modal-action" }, [
        y("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
      ], -1))
    ], 32));
  }
}), vm = { class: "grid grid-cols-2 gap-4 mt-4" }, ym = { class: "flex items-center" }, gm = { class: "flex items-center" }, bm = ["value"], wm = { class: "grid grid-cols-2 gap-4 mt-4" }, _m = { class: "grid grid-cols-2 gap-4 mt-4" }, xm = ["value", "disabled"], Nm = { class: "grid grid-cols-2 gap-4 mt-4" }, Rm = ["value"], Cm = { class: "grid grid-cols-2 gap-4 mt-4" }, Tm = ["value", "title"], Em = { class: "grid grid-cols-2 gap-4 mt-4" }, Im = ["value", "title"], Am = { class: "grid grid-cols-2 gap-4 mt-4" }, Om = ["value"], Dm = { class: "mt-4 flex items-center" }, Sm = /* @__PURE__ */ Ot({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {}
  },
  setup(t) {
    const r = t, i = zn(), s = Pt(), { lnodeTypes: c, dataflowSdk: d } = $t(s), u = Ue(
      H()
    ), p = Ue(!0), m = Ue(!1), P = Ue([]);
    Ko(async () => {
      P.value = await d.value.findExistingInputs(r.destinationLNode);
    }), Ut(m, () => {
      u.value.inputName = "";
    }), Ut(
      [
        () => u.value.inputName,
        () => u.value.preferredDataAttribute
      ],
      async ([B, F]) => {
        if (!B) {
          u.value.inputInstance = "";
          return;
        }
        const q = await d.value.calculateNextInputInstance(
          B,
          F,
          r.destinationLNode
        );
        u.value.inputInstance = q.toString();
      }
    );
    const E = fl(async () => d.value ? (await d.value.findProcessResourcesForLnode(
      r.destinationLNode.id
    )).map((F) => ({
      name: va(F, "name"),
      id: F.id
    })).sort((F, q) => F.name.localeCompare(q.name)) : []), L = ze(
      () => Object.values(ot).filter((B) => B !== ot.INTERNAL)
    ), j = ze(
      () => [...c.value].sort((B, F) => B.lnClass.localeCompare(F.lnClass))
    ), Y = ze(() => {
      const B = c.value.find(
        (F) => F.lnClass === u.value.preferredLNode
      );
      return B ? u.value.dataflowType ? B.dataObjects.filter(
        (F) => F.dataAttributes.some(
          (q) => Mo[u.value.dataflowType].includes(q.fc)
        )
      ).map((F) => ({
        name: F.name,
        desc: F.desc
      })).sort((F, q) => F.name.localeCompare(q.name)) : B.dataObjects.map((F) => ({
        name: F.name,
        desc: F.desc
      })).sort((F, q) => F.name.localeCompare(q.name)) : [];
    }), z = ze(() => {
      const B = c.value.find(
        (q) => q.lnClass === u.value.preferredLNode
      );
      if (!B) return [];
      const F = B.dataObjects.find(
        (q) => q.name === u.value.preferredDataObject
      );
      return F ? u.value.dataflowType ? F.dataAttributes.filter(
        (q) => Mo[u.value.dataflowType].includes(q.fc)
      ).filter((q) => !Fi.includes(q.name)).sort((q, Te) => q.name.localeCompare(Te.name)) : F.dataAttributes.filter((q) => !Fi.includes(q.name)).sort((q, Te) => q.name.localeCompare(Te.name)) : [];
    });
    function H() {
      return {
        dataflowType: null,
        inputName: "",
        inputInstance: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResourceId: ""
      };
    }
    async function ie() {
      try {
        await d.value.createDestinationPlaceholder(
          u.value,
          r.destinationLNode,
          p.value
        ), i.handleClose();
      } catch (B) {
        console.error("Error creating destination placeholder port:", B), alert(`Error creating placeholder: ${B instanceof Error ? B.message : "Unknown error"}`);
      }
    }
    function W(B) {
      for (const F of B)
        u.value[F] = "";
    }
    return (B, F) => (ae(), de("form", {
      method: "dialog",
      onSubmit: ie
    }, [
      F[29] || (F[29] = y("h3", { class: "font-bold text-lg" }, "Create Placeholder - Receive data from", -1)),
      y("div", vm, [
        y("fieldset", null, [
          F[16] || (F[16] = y("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
          y("div", ym, [
            at(y("input", {
              type: "radio",
              id: "destination-placeholder-new-input",
              name: "input",
              "onUpdate:modelValue": F[0] || (F[0] = (q) => m.value = q),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Mr, m.value]
            ]),
            F[14] || (F[14] = y("label", { for: "destination-placeholder-new-input" }, "New Input", -1))
          ]),
          y("div", gm, [
            at(y("input", {
              type: "radio",
              id: "destination-placeholder-existing-input",
              name: "input",
              "onUpdate:modelValue": F[1] || (F[1] = (q) => m.value = q),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Mr, m.value]
            ]),
            F[15] || (F[15] = y("label", { for: "destination-placeholder-existing-input" }, "Existing Input", -1))
          ])
        ]),
        m.value ? Xe("", !0) : at((ae(), de("input", {
          key: 0,
          "aria-label": "New Input Name",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": F[2] || (F[2] = (q) => u.value.inputName = q)
        }, null, 512)), [
          [To, u.value.inputName]
        ]),
        m.value ? at((ae(), de("select", {
          key: 1,
          "aria-label": "Existing Input Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": F[3] || (F[3] = (q) => u.value.inputName = q)
        }, [
          (ae(!0), de(qe, null, bt(P.value, (q) => (ae(), de("option", {
            key: q,
            value: q
          }, le(q), 9, bm))), 128))
        ], 512)), [
          [Jt, u.value.inputName]
        ]) : Xe("", !0)
      ]),
      y("div", wm, [
        F[17] || (F[17] = y("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        at(y("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": F[4] || (F[4] = (q) => u.value.inputInstance = q)
        }, null, 512), [
          [To, u.value.inputInstance]
        ])
      ]),
      y("div", _m, [
        F[19] || (F[19] = y("label", {
          for: "dataflow-type-select",
          class: "col-start-1 self-center"
        }, "Dataflow Type", -1)),
        at(y("select", {
          id: "dataflow-type-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[5] || (F[5] = (q) => u.value.dataflowType = q),
          onChange: F[6] || (F[6] = (q) => W(["preferredDataObject"]))
        }, [
          F[18] || (F[18] = y("option", {
            key: "empty",
            value: null
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(L.value, (q) => (ae(), de("option", {
            key: q,
            value: q,
            disabled: q === Le(ot).CONTROL
          }, le(q), 9, xm))), 128))
        ], 544), [
          [Jt, u.value.dataflowType]
        ])
      ]),
      y("div", Nm, [
        F[21] || (F[21] = y("label", {
          for: "preferred-lnode-select",
          class: "col-start-1 self-center"
        }, "Preferred LNode", -1)),
        at(y("select", {
          id: "preferred-lnode-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[7] || (F[7] = (q) => u.value.preferredLNode = q),
          onChange: F[8] || (F[8] = (q) => W(["preferredDataObject"]))
        }, [
          F[20] || (F[20] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(j.value, (q) => (ae(), de("option", {
            key: q.id,
            value: q.lnClass
          }, le(q.lnClass), 9, Rm))), 128))
        ], 544), [
          [Jt, u.value.preferredLNode]
        ])
      ]),
      y("div", Cm, [
        F[23] || (F[23] = y("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Preferred Data Object", -1)),
        at(y("select", {
          id: "data-object-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[9] || (F[9] = (q) => u.value.preferredDataObject = q),
          onChange: F[10] || (F[10] = (q) => W(["preferredDataAttribute"]))
        }, [
          F[22] || (F[22] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(Y.value, (q) => (ae(), de("option", {
            key: q.name,
            value: q.name,
            title: q.desc ? `Desc: ${q.desc}` : ""
          }, le(q.desc ? q.name + " ⓘ" : q.name), 9, Tm))), 128))
        ], 544), [
          [Jt, u.value.preferredDataObject]
        ])
      ]),
      y("div", Em, [
        F[25] || (F[25] = y("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Preferred Data Attribute", -1)),
        at(y("select", {
          id: "data-attribute-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[11] || (F[11] = (q) => u.value.preferredDataAttribute = q)
        }, [
          F[24] || (F[24] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(z.value, (q) => (ae(), de("option", {
            key: q.name,
            value: q.name,
            title: q.desc ? `Desc: ${q.desc}` : ""
          }, le(q.desc ? q.name + " ⓘ" : q.name), 9, Im))), 128))
        ], 512), [
          [Jt, u.value.preferredDataAttribute]
        ])
      ]),
      y("div", Am, [
        F[27] || (F[27] = y("label", {
          for: "process-resource-select",
          class: "col-start-1"
        }, "Process Resource", -1)),
        at(y("select", {
          id: "process-resource-select",
          name: "processResource",
          class: "select col-start-2",
          "onUpdate:modelValue": F[12] || (F[12] = (q) => u.value.processResourceId = q)
        }, [
          F[26] || (F[26] = y("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ae(!0), de(qe, null, bt(Le(E), (q) => (ae(), de("option", {
            key: q.id,
            value: q.id
          }, le(q.name), 9, Om))), 128))
        ], 512), [
          [Jt, u.value.processResourceId]
        ])
      ]),
      y("div", Dm, [
        at(y("input", {
          type: "checkbox",
          "onUpdate:modelValue": F[13] || (F[13] = (q) => p.value = q),
          class: "checkbox mr-2",
          id: "destination-placeholder-checkbox-add-references"
        }, null, 512), [
          [Ro, p.value]
        ]),
        F[28] || (F[28] = y("label", { for: "destination-placeholder-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      F[30] || (F[30] = y("div", { class: "modal-action" }, [
        y("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          type: "submit"
        }, "Save")
      ], -1))
    ], 32));
  }
}), Pm = { class: "grid grid-cols-[1fr_20px_0.5fr_20px_1fr] w-full mb-8 grid-rows-[50px_50px_80px]" }, Lm = { class: "col-start-1 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, km = { class: "col-start-1 col-span-2 self-center justify-self-center row-start-2 text-center" }, jm = { class: "col-start-4 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, Fm = { class: "col-start-4 col-span-2 self-center justify-self-center row-start-2 text-center" }, $m = { class: "col-span-full row-start-3" }, Mm = { class: "grid grid-cols-[1fr_20px_0.5fr_20px_1fr] h-[50px]" }, Bm = { class: "col-start-1 col-span-1 self-center justify-self-end" }, Km = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, qm = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 p-1 rounded-sm text-sm row-start-1" }, Um = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Vm = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, zi = /* @__PURE__ */ Ot({
  __name: "single-dataflow",
  props: {
    sendingSecondaryLabel: {},
    receivingSecondaryLabel: {},
    sendingPrimaryLabel: {},
    receivingPrimaryLabel: {},
    dataflowType: {},
    sendingPortLabels: {},
    receivingPortLabels: {}
  },
  setup(t) {
    return (r, i) => (ae(), de("div", Pm, [
      i[2] || (i[2] = y("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2" }, null, -1)),
      y("div", Lm, le(r.sendingSecondaryLabel), 1),
      y("div", km, le(r.sendingPrimaryLabel), 1),
      i[3] || (i[3] = y("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2" }, null, -1)),
      y("div", jm, le(r.receivingSecondaryLabel), 1),
      y("div", Fm, le(r.receivingPrimaryLabel), 1),
      y("div", $m, [
        y("div", Mm, [
          y("div", Bm, [
            (ae(!0), de(qe, null, bt(r.sendingPortLabels, (s) => (ae(), de("span", Km, le(s), 1))), 256))
          ]),
          i[0] || (i[0] = dc('<div class="rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] bg-(--color-ocean-gray-100)"></div><div class="col-start-3 col-span-1 row-start-1 flex items-center"><div class="border h-[2px] w-full border-(--color-ocean-gray-100) border-solid"></div></div><svg height="12" width="8" class="col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1" xmlns="http://www.w3.org/2000/svg"><polygon points="0,0 8,6 0,12" style="fill:var(--color-ocean-gray-100);"></polygon></svg>', 3)),
          y("div", qm, le(r.dataflowType), 1),
          i[1] || (i[1] = y("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] bg-(--color-ocean-gray-100)" }, null, -1)),
          y("div", Um, [
            (ae(!0), de(qe, null, bt(r.receivingPortLabels, (s) => (ae(), de("span", Vm, le(s), 1))), 256))
          ])
        ])
      ])
    ]));
  }
}), Wm = { class: "bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2 p-3" }, Gm = { class: "text-center text-xs mb-4" }, Hm = { class: "flex flex-col justify-between gap-4" }, Ym = { class: "flex-1 bg-(--color-ocean-gray-50) rounded-xl border-(--color-ocean-gray-100) border-2 p-3" }, Xm = { class: "text-center mb-4" }, Qm = { key: 0 }, zm = { class: "grid grid-cols-[max-content_auto] gap-x-2" }, Jm = { class: "collapse collapse-arrow mt-2" }, Zm = { class: "collapse-content text-sm px-5 pt-1" }, ev = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, tv = { key: 1 }, nv = { class: "grid grid-cols-[max-content_auto] gap-x-2" }, rv = { class: "collapse collapse-arrow mt-2" }, ov = { class: "collapse-content text-sm px-5 pt-1" }, iv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, av = { class: "collapse collapse-arrow mt-2" }, sv = { class: "collapse-content text-sm px-5 pt-1" }, lv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, uv = { key: 2 }, cv = { class: "grid grid-cols-[max-content_auto] gap-x-2" }, fv = { class: "collapse collapse-arrow mt-2" }, dv = { class: "collapse-content text-sm px-5 pt-1" }, pv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, hv = { class: "collapse collapse-arrow mt-2" }, mv = { class: "collapse-content text-sm px-5 pt-1" }, vv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, yv = { class: "flex-1 bg-(--color-ocean-gray-50) rounded-xl border-(--color-ocean-gray-100) border-2 p-3" }, gv = { class: "text-center mb-4" }, bv = { class: "list-disc pl-5" }, wv = /* @__PURE__ */ Ot({
  __name: "dataflow-implementation-details",
  props: {
    dataflowType: {},
    ldInst: {},
    controlBlock: {},
    dataSet: {},
    fcdas: {},
    ln0Path: {}
  },
  setup(t) {
    const r = t, i = Pt(), { dataflowSdk: s } = $t(i), c = Ue(), d = Ue(), u = Ue();
    return Ia(async () => {
      r.dataflowType === ot.GOOSE ? c.value = await s.value.findGseControlBlockDetails(
        r.controlBlock.id,
        r.ldInst
      ) : r.dataflowType === ot.SMV ? d.value = await s.value.findSmvControlBlockDetails(
        r.controlBlock.id,
        r.ldInst
      ) : r.dataflowType === ot.REPORT && (u.value = await s.value.findReportControlBlockDetails(
        r.controlBlock.id
      ));
    }), (p, m) => (ae(), de("div", Wm, [
      y("div", Gm, le(p.ln0Path), 1),
      y("div", Hm, [
        y("div", Ym, [
          y("div", Xm, le(p.controlBlock.name), 1),
          c.value ? (ae(), de("div", Qm, [
            y("dl", zm, [
              m[0] || (m[0] = y("dt", null, "App ID:", -1)),
              y("dd", null, le(c.value.appId), 1),
              m[1] || (m[1] = y("dt", null, "ConfRev:", -1)),
              y("dd", null, le(p.controlBlock.confRev), 1)
            ]),
            y("details", Jm, [
              m[6] || (m[6] = y("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, " Communication ", -1)),
              y("div", Zm, [
                y("dl", ev, [
                  m[2] || (m[2] = y("dt", null, "MAC Address:", -1)),
                  y("dd", null, le(c.value.communicationDetails.macAddress), 1),
                  m[3] || (m[3] = y("dt", null, "App ID:", -1)),
                  y("dd", null, le(c.value.communicationDetails.appId), 1),
                  m[4] || (m[4] = y("dt", null, "VLAN ID:", -1)),
                  y("dd", null, le(c.value.communicationDetails.vlanId), 1),
                  m[5] || (m[5] = y("dt", null, "VLAN Priority:", -1)),
                  y("dd", null, le(c.value.communicationDetails.vlanPriority), 1)
                ])
              ])
            ])
          ])) : Xe("", !0),
          d.value ? (ae(), de("div", tv, [
            y("dl", nv, [
              m[7] || (m[7] = y("dt", null, "SMV ID:", -1)),
              y("dd", null, le(d.value.smvId), 1),
              m[8] || (m[8] = y("dt", null, "ConfRev:", -1)),
              y("dd", null, le(p.controlBlock.confRev), 1),
              m[9] || (m[9] = y("dt", null, "Multicast:", -1)),
              y("dd", null, le(d.value.multicast), 1),
              m[10] || (m[10] = y("dt", null, "NofASDU:", -1)),
              y("dd", null, le(d.value.nofAsdu), 1),
              m[11] || (m[11] = y("dt", null, "SmpMod:", -1)),
              y("dd", null, le(d.value.smpMod), 1),
              m[12] || (m[12] = y("dt", null, "SmpRate:", -1)),
              y("dd", null, le(d.value.smpRate), 1)
            ]),
            y("details", rv, [
              m[19] || (m[19] = y("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, "SmvOpts", -1)),
              y("div", ov, [
                y("dl", iv, [
                  m[13] || (m[13] = y("dt", null, "RefreshTime:", -1)),
                  y("dd", null, le(d.value.smvOpts.refreshTime), 1),
                  m[14] || (m[14] = y("dt", null, "SampleSynchronized:", -1)),
                  y("dd", null, le(d.value.smvOpts.sampleSynchronized), 1),
                  m[15] || (m[15] = y("dt", null, "SampleRate:", -1)),
                  y("dd", null, le(d.value.smvOpts.sampleRate), 1),
                  m[16] || (m[16] = y("dt", null, "DataSet:", -1)),
                  y("dd", null, le(d.value.smvOpts.dataSet), 1),
                  m[17] || (m[17] = y("dt", null, "Security:", -1)),
                  y("dd", null, le(d.value.smvOpts.security), 1),
                  m[18] || (m[18] = y("dt", null, "SynchSourceId:", -1)),
                  y("dd", null, le(d.value.smvOpts.synchSourceId), 1)
                ])
              ])
            ]),
            y("details", av, [
              m[24] || (m[24] = y("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, " Communication ", -1)),
              y("div", sv, [
                y("dl", lv, [
                  m[20] || (m[20] = y("dt", null, "MAC Address:", -1)),
                  y("dd", null, le(d.value.communicationDetails.macAddress), 1),
                  m[21] || (m[21] = y("dt", null, "App ID:", -1)),
                  y("dd", null, le(d.value.communicationDetails.appId), 1),
                  m[22] || (m[22] = y("dt", null, "VLAN ID:", -1)),
                  y("dd", null, le(d.value.communicationDetails.vlanId), 1),
                  m[23] || (m[23] = y("dt", null, "VLAN Priority:", -1)),
                  y("dd", null, le(d.value.communicationDetails.vlanPriority), 1)
                ])
              ])
            ])
          ])) : Xe("", !0),
          u.value ? (ae(), de("div", uv, [
            y("dl", cv, [
              m[25] || (m[25] = y("dt", null, "RPT ID:", -1)),
              y("dd", null, le(u.value.rptId), 1),
              m[26] || (m[26] = y("dt", null, "ConfRev:", -1)),
              y("dd", null, le(p.controlBlock.confRev), 1),
              m[27] || (m[27] = y("dt", null, "Buffered:", -1)),
              y("dd", null, le(u.value.buffered), 1)
            ]),
            y("details", fv, [
              m[33] || (m[33] = y("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, "TrgOps", -1)),
              y("div", dv, [
                y("dl", pv, [
                  m[28] || (m[28] = y("dt", null, "Dchg:", -1)),
                  y("dd", null, le(u.value.trgOps.dchg), 1),
                  m[29] || (m[29] = y("dt", null, "Dupd:", -1)),
                  y("dd", null, le(u.value.trgOps.dupd), 1),
                  m[30] || (m[30] = y("dt", null, "Gi:", -1)),
                  y("dd", null, le(u.value.trgOps.gi), 1),
                  m[31] || (m[31] = y("dt", null, "Period:", -1)),
                  y("dd", null, le(u.value.trgOps.period), 1),
                  m[32] || (m[32] = y("dt", null, "Qchg:", -1)),
                  y("dd", null, le(u.value.trgOps.qchg), 1)
                ])
              ])
            ]),
            y("details", hv, [
              m[42] || (m[42] = y("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, "OptFields", -1)),
              y("div", mv, [
                y("dl", vv, [
                  m[34] || (m[34] = y("dt", null, "BufOvfl:", -1)),
                  y("dd", null, le(u.value.optFields.bufOvfl), 1),
                  m[35] || (m[35] = y("dt", null, "ConfigRef:", -1)),
                  y("dd", null, le(u.value.optFields.configRef), 1),
                  m[36] || (m[36] = y("dt", null, "DataRef:", -1)),
                  y("dd", null, le(u.value.optFields.dataRef), 1),
                  m[37] || (m[37] = y("dt", null, "DataSet:", -1)),
                  y("dd", null, le(u.value.optFields.dataSet), 1),
                  m[38] || (m[38] = y("dt", null, "EntryID:", -1)),
                  y("dd", null, le(u.value.optFields.entryId), 1),
                  m[39] || (m[39] = y("dt", null, "ReasonCode:", -1)),
                  y("dd", null, le(u.value.optFields.reasonCode), 1),
                  m[40] || (m[40] = y("dt", null, "SeqNum:", -1)),
                  y("dd", null, le(u.value.optFields.seqNum), 1),
                  m[41] || (m[41] = y("dt", null, "TimeStamp:", -1)),
                  y("dd", null, le(u.value.optFields.timeStamp), 1)
                ])
              ])
            ])
          ])) : Xe("", !0)
        ]),
        y("div", yv, [
          y("div", gv, le(p.dataSet.name), 1),
          y("ul", bv, [
            (ae(!0), de(qe, null, bt(p.fcdas, (P) => (ae(), de("li", null, le(`${P.doName}.${P.daName} (fc: ${P.fc || "-"})`), 1))), 256))
          ])
        ])
      ])
    ]));
  }
}), _v = { class: "font-bold text-lg mb-4" }, xv = { key: 0 }, Nv = { key: 1 }, Rv = {
  key: 4,
  class: "modal-action"
}, Cv = /* @__PURE__ */ Ot({
  __name: "dataflow-implementation",
  props: {
    connection: {},
    extRef: {}
  },
  setup(t) {
    const r = t, i = zn(), s = Pt(), { dataflowSdk: c, lnodes: d } = $t(s), u = Ue(""), p = Ue(""), m = Ue(""), P = Ue(), E = Ue(), L = Ue([]);
    Ut(
      () => r.extRef,
      async function(ve) {
        ve && (m.value = await c.value.findPathToExtRef(ve.id), ve.srcCbName && (P.value = await c.value.findControlBlock(
          ve.iedName,
          ve.ldInst,
          ve.srcCbName
        ), E.value = await c.value.findDataSet(
          ve.iedName,
          ve.ldInst,
          P.value.datSet
        ), L.value = await c.value.findFcdasForDataSet(E.value.id)));
      },
      { immediate: !0 }
    ), Ut(
      () => r.connection,
      async function(ve) {
        Ae(ve.sourceLNodeId, "Source LNodeId is undefined"), u.value = await c.value.findPathToLnode(ve.sourceLNodeId), p.value = await c.value.findPathToLnode(
          ve.destinationLNodeId
        );
      },
      { immediate: !0 }
    );
    const j = ze(() => u.value.split("/").slice(-1).join("")), Y = ze(() => u.value.split("/").slice(0, -1).join("/")), z = ze(() => p.value.split("/").slice(-1).join("")), H = ze(() => p.value.split("/").slice(0, -1).join("/")), ie = ze(() => {
      if (!r.connection.isImplemented) {
        const pe = d.value.find((ve) => ve.id === r.connection.sourceLNodeId);
        return Ae(pe, "Sending LNode not found"), `${pe.prefix}${pe.lnClass}${pe.lnInst}`;
      }
      return `${r.extRef?.prefix ?? ""}${r.extRef?.lnClass}${r.extRef?.lnInst ?? ""}`;
    }), W = ze(() => {
      if (!r.connection.isImplemented) {
        const pe = d.value.find((ve) => ve.id === r.connection.sourceLNodeId);
        return Ae(pe, "Sending LNode not found"), `${pe.iedName}/${pe.ldInst}`;
      }
      return `${r.extRef?.iedName}/${r.extRef?.ldInst}`;
    }), B = ze(() => m.value.split("/").slice(-2, -1).join("")), F = ze(() => m.value.split("/").slice(0, -2).join("/")), q = ze(() => `${r.extRef?.iedName}/${r.extRef?.srcLdInst}/${r.extRef?.srcPrefix}${r.extRef?.srcLnClass}${r.extRef?.srcLnInst}`);
    async function Te() {
      try {
        if (!r.extRef)
          throw new Error("No matching ExtRef found for dataflow implementation");
        await c.value.implementDataflow(r.connection, r.extRef), i.handleClose();
      } catch (pe) {
        console.error("Error implementing dataflow:", pe), alert(`Error implementing dataflow: ${pe instanceof Error ? pe.message : "Unknown error"}`);
      }
    }
    return (pe, ve) => (ae(), de(qe, null, [
      y("h3", _v, le(pe.connection.isImplemented ? "Implemented Dataflow Details" : "Implement Dataflow"), 1),
      pe.extRef ? Xe("", !0) : (ae(), de("p", xv, "No matching ExtRef found for dataflow implementation.")),
      pe.connection.notPossibleToImplement ? (ae(), de("p", Nv, "Sending or receiving LNode is not mapped to a real IED.")) : Xe("", !0),
      pe.extRef && pe.connection.isImplemented ? (ae(), de(qe, { key: 2 }, [
        ve[0] || (ve[0] = y("h3", { class: "mb-4" }, "Specification:", -1)),
        yt(zi, {
          sendingSecondaryLabel: Y.value,
          sendingPrimaryLabel: j.value,
          receivingSecondaryLabel: H.value,
          receivingPrimaryLabel: z.value,
          dataflowType: pe.connection.dataflowType,
          sendingPortLabels: [pe.connection.sourceDataObject, pe.connection.sourceDataAttribute],
          receivingPortLabels: [pe.connection.input, pe.connection.inputInstance]
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"]),
        ve[1] || (ve[1] = y("h3", { class: "mb-4" }, "Implementation:", -1)),
        yt(zi, {
          sendingSecondaryLabel: W.value,
          sendingPrimaryLabel: ie.value,
          receivingSecondaryLabel: F.value,
          receivingPrimaryLabel: B.value,
          dataflowType: pe.extRef.serviceType,
          sendingPortLabels: [pe.extRef.doName, pe.extRef.daName],
          receivingPortLabels: [pe.extRef.intAddr, pe.extRef.desc].filter(Boolean)
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"]),
        P.value && E.value ? (ae(), en(wv, {
          key: 0,
          controlBlock: P.value,
          dataSet: E.value,
          fcdas: L.value,
          ln0Path: q.value,
          dataflowType: pe.extRef.serviceType,
          ldInst: pe.extRef.srcLdInst
        }, null, 8, ["controlBlock", "dataSet", "fcdas", "ln0Path", "dataflowType", "ldInst"])) : Xe("", !0)
      ], 64)) : Xe("", !0),
      pe.extRef && !pe.connection.notPossibleToImplement && !pe.connection.isImplemented ? (ae(), de(qe, { key: 3 }, [
        ve[2] || (ve[2] = y("h3", { class: "mb-4" }, "Specification:", -1)),
        yt(zi, {
          sendingSecondaryLabel: Y.value,
          sendingPrimaryLabel: j.value,
          receivingSecondaryLabel: H.value,
          receivingPrimaryLabel: z.value,
          dataflowType: pe.connection.dataflowType,
          sendingPortLabels: [pe.connection.sourceDataObject, pe.connection.sourceDataAttribute],
          receivingPortLabels: [pe.connection.input, pe.connection.inputInstance]
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"]),
        ve[3] || (ve[3] = y("h3", { class: "mb-4" }, "Matching ExtRef to implement:", -1)),
        yt(zi, {
          sendingSecondaryLabel: W.value,
          sendingPrimaryLabel: ie.value,
          receivingSecondaryLabel: F.value,
          receivingPrimaryLabel: B.value,
          dataflowType: pe.extRef.serviceType || pe.extRef.pServT || pe.connection.dataflowType,
          sendingPortLabels: [
            pe.extRef.pDo || pe.connection.sourceDataObject,
            pe.extRef.pDa || pe.connection.sourceDataAttribute
          ],
          receivingPortLabels: [pe.extRef.intAddr, pe.extRef.desc].filter(Boolean)
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"])
      ], 64)) : Xe("", !0),
      !pe.connection.isImplemented && !pe.connection.notPossibleToImplement ? (ae(), de("div", Rv, [
        y("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: Te
        }, " Implement ")
      ])) : Xe("", !0)
    ], 64));
  }
}), zn = /* @__PURE__ */ ol("dataflow/dialog-store", () => {
  const t = {
    component: void 0,
    props: void 0
  }, r = Ue(), i = Ue(t), s = Ue(), c = Ki({
    DataflowCreation: An(Jh),
    SourcePlaceholderCreation: An(mm),
    DestinationPlaceholderCreation: An(Sm),
    DataflowImplementation: An(Cv)
  });
  function d() {
    i.value = {
      component: void 0,
      props: void 0
    };
  }
  function u() {
    r.value?.close(), nm(() => {
      d();
    }, 300);
  }
  function p(m, P, E) {
    i.value.component = Ca(c[m]), i.value.props = P, E && (s.value = E), r.value?.showModal();
  }
  return {
    // states
    dialogRef: r,
    currentDialogContent: i,
    availableDialogContent: c,
    dialogAttributes: s,
    // getters
    // actions
    hardReset: d,
    handleClose: u,
    openDialogWithContent: p
  };
}), Tv = ["onClick"], Ev = /* @__PURE__ */ Ot({
  __name: "context-menu",
  props: {
    x: {},
    y: {},
    isVisible: { type: Boolean },
    items: {}
  },
  emits: ["close"],
  setup(t, { emit: r }) {
    const i = t, s = r, c = ze(() => ({
      left: `${i.x}px`,
      top: `${i.y}px`,
      display: i.isVisible ? "flex" : "none"
    }));
    function d(u) {
      u.action(), s("close");
    }
    return (u, p) => (ae(), de(qe, null, [
      u.isVisible ? (ae(), de("div", {
        key: 0,
        class: "menu bg-base-100 rounded-box fixed z-10",
        style: Br(c.value)
      }, [
        y("ul", null, [
          (ae(!0), de(qe, null, bt(u.items, (m) => (ae(), de("li", null, [
            y("a", {
              onClick: (P) => d(m)
            }, le(m.label), 9, Tv)
          ]))), 256))
        ])
      ], 4)) : Xe("", !0),
      (ae(), en(jo, { to: "body" }, [
        i.isVisible ? (ae(), de("div", {
          key: 0,
          class: "backdrop",
          onClick: p[0] || (p[0] = pa((m) => u.$emit("close"), ["prevent"])),
          onContextmenu: p[1] || (p[1] = pa((m) => u.$emit("close"), ["prevent"]))
        }, null, 32)) : Xe("", !0)
      ]))
    ], 64));
  }
}), Vi = (t, r) => {
  const i = t.__vccOpts || t;
  for (const [s, c] of r)
    i[s] = c;
  return i;
}, Iv = /* @__PURE__ */ Vi(Ev, [["__scopeId", "data-v-9cc5b747"]]), Av = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Ov = ["onClick"], Dv = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Sv = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Pv = ["onClick"], Lv = ["onClick", "onContextmenu"], kv = ["data-testid"], jv = ["onClick"], Fv = ["onClick", "onContextmenu"], $v = ["onClick"], Mv = ["onClick"], Bv = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Kv = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, qv = /* @__PURE__ */ Ot({
  __name: "dataflow-connections",
  props: {
    connections: {},
    isDataflowImplementationEnabled: { type: Boolean }
  },
  setup(t) {
    const r = t, i = Pa(), { activeElement: s } = $t(i), c = Pt(), { dataflowSdk: d } = $t(c), u = zn(), p = Ue(!1), m = Ue(0), P = Ue(0), E = Ue([]), L = [
      ot.GOOSE,
      ot.REPORT,
      ot.SMV
    ], j = ze(() => [...r.connections].sort((B, F) => B.dataflowType < F.dataflowType ? -1 : B.dataflowType > F.dataflowType ? 1 : 0));
    async function Y(B) {
      const F = await d.value.findMatchingExtRef(B);
      u.openDialogWithContent(
        "DataflowImplementation",
        {
          extRef: F,
          connection: B
        },
        { class: "w-1/2 max-w-none" }
      );
    }
    function z(B) {
      return B ? L.includes(B) : !1;
    }
    function H(B, F) {
      !z(F.dataflowType) || !r.isDataflowImplementationEnabled || (B.preventDefault(), ie(B), E.value = W(F), p.value = !0);
    }
    function ie(B) {
      m.value = B.clientX, P.value = B.clientY;
    }
    function W(B) {
      return [
        {
          label: B.isImplemented ? "Show Implementation" : "Implement",
          action: () => Y(B)
        }
      ];
    }
    return (B, F) => (ae(), de(qe, null, [
      (ae(!0), de(qe, null, bt(j.value, (q, Te) => (ae(), de("div", Av, [
        y("div", {
          class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer",
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id)
        }, [
          y("span", Dv, le(q.sourceDataObject), 1),
          y("span", Sv, le(q.sourceDataAttribute), 1)
        ], 8, Ov),
        y("div", {
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id),
          class: Zt(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
            "bg-(--color-primary)": Le(s) === q.id,
            "bg-(--color-ocean-gray-100)": Le(s) !== q.id
          }])
        }, null, 10, Pv),
        y("div", {
          class: "col-start-3 col-span-1 row-start-1 hover:cursor-pointer flex items-center",
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id),
          onContextmenu: pa((pe) => H(pe, q), ["right"])
        }, [
          y("div", {
            class: Zt(["border h-[2px] w-full", {
              "border-(--color-primary)": Le(s) === q.id,
              "border-(--color-ocean-gray-100)": Le(s) !== q.id,
              "border-solid": !B.isDataflowImplementationEnabled || q.isImplemented,
              "border-dashed": B.isDataflowImplementationEnabled && !q.isImplemented,
              "border-dotted": B.isDataflowImplementationEnabled && q.notPossibleToImplement
            }]),
            "data-testid": `dataflow-line-${Te}`
          }, null, 10, kv)
        ], 40, Lv),
        (ae(), de("svg", {
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id),
          height: "12",
          width: "8",
          class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          y("polygon", {
            points: "0,0 8,6 0,12",
            style: Br({
              fill: Le(s) === q.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
            })
          }, null, 4)
        ], 8, jv)),
        y("div", {
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id),
          onContextmenu: pa((pe) => H(pe, q), ["right"]),
          class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
        }, le(q.dataflowType), 41, Fv),
        y("div", {
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id),
          class: Zt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
            "bg-(--color-primary)": Le(s) === q.id,
            "bg-(--color-ocean-gray-100)": Le(s) !== q.id
          }])
        }, null, 10, $v),
        y("div", {
          onClick: (pe) => Le(i).setOrResetActiveElement(q.id),
          class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
        }, [
          y("span", Bv, le(q.input), 1),
          y("span", Kv, le(q.inputInstance), 1)
        ], 8, Mv),
        Le(s) == q.id && !B.isDataflowImplementationEnabled ? (ae(), en(jo, {
          key: 0,
          to: "#sidebar-details"
        }, [
          yt(uh, { connection: q }, null, 8, ["connection"])
        ])) : Xe("", !0),
        Le(s) == q.id && B.isDataflowImplementationEnabled ? (ae(), en(jo, {
          key: 1,
          to: "#sidebar-details"
        }, [
          yt(mh, { connection: q }, null, 8, ["connection"])
        ])) : Xe("", !0)
      ]))), 256)),
      yt(Iv, {
        x: m.value,
        y: P.value,
        isVisible: p.value,
        items: E.value,
        onClose: F[0] || (F[0] = (q) => p.value = !1)
      }, null, 8, ["x", "y", "isVisible", "items"])
    ], 64));
  }
}), Uv = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, Vv = {
  class: "[&_dt,dd]:inline [&_dt]:mr-1",
  "data-testid": "destination-placeholder-details"
}, Wv = { class: "mt-4" }, Gv = { key: 0 }, Hv = { key: 1 }, Yv = /* @__PURE__ */ Ot({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(t) {
    const r = t, i = Pt(), { lnodeTypes: s } = $t(i), c = ze(() => s.value.find((p) => p.lnClass === r.placeholder.preferredLNode)?.dataObjects.find(
      (p) => p.name === r.placeholder.preferredDataObject
    )), d = ze(() => c?.value?.dataAttributes?.find(
      (u) => u.name === r.placeholder.preferredDataAttribute
    ));
    return (u, p) => (ae(), de(qe, null, [
      p[8] || (p[8] = y("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder", -1)),
      u.placeholder.dataflowType ? (ae(), de("span", Uv, le(u.placeholder.dataflowType), 1)) : Xe("", !0),
      y("dl", Vv, [
        y("div", null, [
          p[0] || (p[0] = y("dt", null, "Input:", -1)),
          y("dd", null, le(u.placeholder.input), 1)
        ]),
        y("div", null, [
          p[1] || (p[1] = y("dt", null, "Input Instance:", -1)),
          y("dd", null, le(u.placeholder.inputInstance || "-"), 1)
        ]),
        y("div", Wv, [
          p[2] || (p[2] = y("dt", null, "Preferred LN:", -1)),
          y("dd", null, le(u.placeholder.preferredLNode || "-"), 1)
        ]),
        y("div", null, [
          p[3] || (p[3] = y("dt", null, "Preferred DO:", -1)),
          y("dd", null, le(u.placeholder.preferredDataObject || "-"), 1)
        ]),
        c.value?.desc ? (ae(), de("div", Gv, [
          p[4] || (p[4] = y("dt", null, "Preferred DO Desc:", -1)),
          y("dd", null, le(c.value.desc), 1)
        ])) : Xe("", !0),
        y("div", null, [
          p[5] || (p[5] = y("dt", null, "Preferred DA:", -1)),
          y("dd", null, le(u.placeholder.preferredDataAttribute || "-"), 1)
        ]),
        d.value?.desc ? (ae(), de("div", Hv, [
          p[6] || (p[6] = y("dt", null, "Preferred DA Desc:", -1)),
          y("dd", null, le(d.value.desc), 1)
        ])) : Xe("", !0),
        y("div", null, [
          p[7] || (p[7] = y("dt", null, "Process Resource:", -1)),
          y("dd", null, le(u.placeholder.processResource || "-"), 1)
        ])
      ])
    ], 64));
  }
}), Xv = ["y1", "x2", "y2"], Qv = ["points"], zv = /* @__PURE__ */ Ot({
  __name: "arrow",
  props: {
    height: {},
    length: {}
  },
  setup(t) {
    return (r, i) => (ae(), de(qe, null, [
      y("line", {
        x1: 0,
        y1: r.height / 2,
        x2: r.length - r.height / 2,
        y2: r.height / 2,
        stroke: "currentColor",
        "stroke-width": "2"
      }, null, 8, Xv),
      y("polygon", {
        points: `${r.length - r.height * 0.7}, 0 ${r.length}, ${r.height / 2} ${r.length - r.height * 0.7}, ${r.height}`,
        fill: "currentColor"
      }, null, 8, Qv)
    ], 64));
  }
}), Jv = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, Zv = ["onClick"], ey = {
  height: "12",
  width: "35",
  class: "mr-[9px] text-(--color-ocean-gray-100)"
}, ty = ["data-testid"], ny = ["onClick"], ry = { class: "col-start-5 col-span-1 self-center justify-self-start" }, oy = ["onClick"], iy = ["onClick"], ay = /* @__PURE__ */ Ot({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(t) {
    const r = Pa(), { activeElement: i } = $t(r);
    return (s, c) => (ae(!0), de(qe, null, bt(s.destinationPlaceHolderPorts, (d, u) => (ae(), de("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
      key: `destination-placeholder-port-${u}`
    }, [
      y("div", Jv, [
        y("div", {
          class: "flex items-center justify-self-end h-full max-w-max hover:cursor-pointer",
          onClick: (p) => Le(r).setOrResetActiveElement(d.id)
        }, [
          (ae(), de("svg", ey, [
            y("g", {
              "data-testid": `placeholder-line-${u}`,
              class: Zt({
                "text-(--color-primary)": Le(i) === d.id
              })
            }, [
              yt(zv, {
                height: 12,
                length: 35
              })
            ], 10, ty)
          ]))
        ], 8, Zv)
      ]),
      y("div", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        class: Zt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Le(i) === d.id
        }])
      }, null, 10, ny),
      y("div", ry, [
        y("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
          onClick: (p) => Le(r).setOrResetActiveElement(d.id)
        }, le(d.input), 9, oy),
        y("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm hover:cursor-pointer",
          onClick: (p) => Le(r).setOrResetActiveElement(d.id)
        }, le(d.inputInstance), 9, iy)
      ]),
      Le(i) == d.id ? (ae(), en(jo, {
        key: 0,
        to: "#sidebar-details"
      }, [
        yt(Yv, { placeholder: d }, null, 8, ["placeholder"])
      ])) : Xe("", !0)
    ]))), 128));
  }
}), sy = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, ly = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, uy = { class: "mt-4" }, cy = { key: 0 }, fy = { key: 1 }, dy = { class: "mt-4" }, py = {
  key: 2,
  class: "mt-4"
}, hy = /* @__PURE__ */ Ot({
  __name: "source-placeholder-details",
  props: {
    placeholder: {},
    sourceLNodeId: {}
  },
  setup(t) {
    const r = t, i = Pt(), { lnodes: s } = $t(i), c = ze(() => s.value.find((p) => p.id === r.sourceLNodeId)?.dataObjectSpecifications?.find(
      (p) => p.name === r.placeholder.dataObject
    )), d = ze(() => c?.value?.dataAttributeSpecifications?.find(
      (u) => u.name === r.placeholder.dataAttribute
    ));
    return (u, p) => (ae(), de(qe, null, [
      p[8] || (p[8] = y("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder", -1)),
      u.placeholder.dataflowType ? (ae(), de("span", sy, le(u.placeholder.dataflowType), 1)) : Xe("", !0),
      y("dl", ly, [
        y("div", null, [
          p[0] || (p[0] = y("dt", null, "Input:", -1)),
          y("dd", null, le(u.placeholder.input), 1)
        ]),
        y("div", uy, [
          p[1] || (p[1] = y("dt", null, "DO:", -1)),
          y("dd", null, le(u.placeholder.dataObject || "-"), 1)
        ]),
        c.value?.desc ? (ae(), de("div", cy, [
          p[2] || (p[2] = y("dt", null, "DO Desc:", -1)),
          y("dd", null, le(c.value?.desc), 1)
        ])) : Xe("", !0),
        y("div", null, [
          p[3] || (p[3] = y("dt", null, "DA:", -1)),
          y("dd", null, le(u.placeholder.dataAttribute || "-"), 1)
        ]),
        d.value?.desc ? (ae(), de("div", fy, [
          p[4] || (p[4] = y("dt", null, "DA Desc:", -1)),
          y("dd", null, le(d.value?.desc), 1)
        ])) : Xe("", !0),
        y("div", dy, [
          p[5] || (p[5] = y("dt", null, "Preferred LN:", -1)),
          y("dd", null, le(u.placeholder.preferredLNode || "-"), 1)
        ]),
        y("div", null, [
          p[6] || (p[6] = y("dt", null, "Process Resource:", -1)),
          y("dd", null, le(u.placeholder.processResource || "-"), 1)
        ]),
        u.placeholder.isFulfilled != null ? (ae(), de("div", py, [
          p[7] || (p[7] = y("dt", null, "Placeholder is fulfilled:", -1)),
          y("dd", null, le(u.placeholder.isFulfilled), 1)
        ])) : Xe("", !0)
      ])
    ], 64));
  }
}), my = {}, vy = {
  width: "16",
  height: "16",
  viewBox: "0 0 20 20",
  fill: "currentColor"
};
function yy(t, r) {
  return ae(), de("svg", vy, r[0] || (r[0] = [
    y("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }, null, -1),
    y("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" }, null, -1)
  ]));
}
const ya = /* @__PURE__ */ Vi(my, [["render", yy]]), gy = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12" }, by = ["onClick"], wy = ["onClick"], _y = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, xy = ["onClick"], Ny = ["onClick"], Ry = ["onClick"], Cy = ["onClick"], Ty = ["disabled", "onClick"], Ey = /* @__PURE__ */ Ot({
  __name: "source-placeholder-ports",
  props: {
    sourceLNode: {},
    destinationLNode: {}
  },
  setup(t) {
    const r = t, i = Pa(), { activeElement: s } = $t(i), c = Pt(), { sourcePlaceholders: d } = $t(c), u = zn(), p = ze(() => r.sourceLNode.id ? d.value.filter((E) => E.lNodeId === r.sourceLNode.id) : []), m = (E) => {
      if (r.destinationLNode)
        return E.preferredLNode ? r.destinationLNode.lnClass === E.preferredLNode ? r.destinationLNode : void 0 : r.destinationLNode;
    };
    function P(E) {
      Ae(r.destinationLNode, "Destination LNode is undefined"), u.openDialogWithContent("DataflowCreation", {
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        sourcePlaceholder: E
      });
    }
    return (E, L) => (ae(!0), de(qe, null, bt(p.value, (j) => (ae(), de("div", gy, [
      y("div", {
        onClick: (Y) => Le(i).setOrResetActiveElement(j.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        y("span", {
          class: Zt([j.isFulfilled ? "border-solid" : "border-dashed", "relative inline-block border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm"])
        }, [
          fc(le(j.dataObject) + "." + le(j.dataAttribute) + " ", 1),
          y("span", {
            class: Zt([{
              "bg-(--color-primary)": Le(s) === j.id
            }, "absolute -top-3 -right-3 bg-(--color-ocean-gray-100) text-white text-xs font-semibold rounded-full w-5 h-5 flex items-center justify-center"])
          }, " 1+ ", 2)
        ], 2)
      ], 8, by),
      y("div", {
        onClick: (Y) => Le(i).setOrResetActiveElement(j.id),
        class: Zt([{
          "bg-(--color-primary)": Le(s) === j.id
        }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
      }, null, 10, wy),
      y("div", _y, [
        y("div", {
          class: "flex items-center h-full w-3/4 hover:cursor-pointer",
          onClick: (Y) => Le(i).setOrResetActiveElement(j.id)
        }, [
          y("div", {
            class: Zt(["h-[2px] w-full border border-dashed", {
              "border-[var(--color-primary)]": Le(s) === j.id,
              "border-[var(--color-gray-200)]": Le(s) !== j.id
            }]),
            onClick: (Y) => Le(i).setOrResetActiveElement(j.id)
          }, null, 10, Ny)
        ], 8, xy)
      ]),
      y("div", {
        onClick: (Y) => Le(i).setOrResetActiveElement(j.id),
        class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-start z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer left-[10%] truncate max-w-[8ch]"
      }, le(j.input), 9, Ry),
      j.preferredLNode ? (ae(), de("div", {
        key: 0,
        onClick: (Y) => Le(i).setOrResetActiveElement(j.id),
        class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-start z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer left-[70%]"
      }, le(j.preferredLNode), 9, Cy)) : Xe("", !0),
      y("button", {
        class: "col-start-3 self-center justify-self-center p-4 rounded-sm text-sm row-start-1 btn bg-(--color-primary) border-1 text-white relative z-2",
        disabled: !r.sourceLNode || !r.destinationLNode || !m(j),
        style: Br(
          !r.sourceLNode || !r.destinationLNode || !m(j) ? {
            border: "1",
            backgroundColor: "var(--color-ocean-gray-75)",
            color: "var(--color-ocean-gray-200)",
            borderColor: "var(--color-ocean-gray-200)"
          } : { borderColor: "var(--color-primary)" }
        ),
        "aria-label": "Fulfill placeholder",
        onClick: (Y) => P(j)
      }, [
        yt(ya)
      ], 12, Ty),
      Le(s) == j.id ? (ae(), en(jo, {
        key: 1,
        to: "#sidebar-details"
      }, [
        yt(hy, {
          placeholder: j,
          sourceLNodeId: r.sourceLNode.id
        }, null, 8, ["placeholder", "sourceLNodeId"])
      ])) : Xe("", !0)
    ]))), 256));
  }
}), Iy = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, Ay = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, Oy = { class: "mt-4" }, Dy = { key: 0 }, Sy = /* @__PURE__ */ Ot({
  __name: "controlled-connection-details",
  props: {
    controlledConnection: {}
  },
  setup(t) {
    const r = t, i = Pt(), { lnodes: s } = $t(i), c = ze(() => s.value.find(
      (u) => u.id === r.controlledConnection.controlledLNodeId
    )?.dataObjectSpecifications?.find(
      (u) => u.name === r.controlledConnection.controlledDataObject
    ));
    return (d, u) => (ae(), de(qe, null, [
      u[4] || (u[4] = y("h2", { class: "text-lg font-bold mb-2" }, "Specified Controlled Dataflow", -1)),
      d.controlledConnection.dataflowType ? (ae(), de("span", Iy, le(d.controlledConnection.dataflowType), 1)) : Xe("", !0),
      y("dl", Ay, [
        y("div", null, [
          u[0] || (u[0] = y("dt", null, "Output:", -1)),
          y("dd", null, le(d.controlledConnection.outputName), 1)
        ]),
        y("div", null, [
          u[1] || (u[1] = y("dt", null, "Output Instance:", -1)),
          y("dd", null, le(d.controlledConnection.outputInstance || "-"), 1)
        ]),
        y("div", Oy, [
          u[2] || (u[2] = y("dt", null, "Controlled DO:", -1)),
          y("dd", null, le(d.controlledConnection.controlledDataObject || "-"), 1)
        ]),
        c.value?.desc ? (ae(), de("div", Dy, [
          u[3] || (u[3] = y("dt", null, "Controlled DO Desc:", -1)),
          y("dd", null, le(c.value.desc), 1)
        ])) : Xe("", !0)
      ])
    ], 64));
  }
}), Py = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Ly = ["onClick"], ky = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, jy = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Fy = ["onClick"], $y = ["onClick"], My = ["data-testid"], By = ["onClick"], Ky = ["onClick"], qy = ["onClick"], Uy = ["onClick"], Vy = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Wy = /* @__PURE__ */ Ot({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(t) {
    const r = Pa(), { activeElement: i } = $t(r);
    return (s, c) => (ae(!0), de(qe, null, bt(s.controlledConnections, (d, u) => (ae(), de("div", Py, [
      y("div", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        y("span", ky, le(d.outputName), 1),
        y("span", jy, le(d.outputInstance), 1)
      ], 8, Ly),
      y("div", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        class: Zt(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Le(i) === d.id,
          "bg-(--color-ocean-gray-100)": Le(i) !== d.id
        }])
      }, null, 10, Fy),
      y("div", {
        class: "col-start-3 col-span-1 row-start-1 hover:cursor-pointer flex items-center",
        onClick: (p) => Le(r).setOrResetActiveElement(d.id)
      }, [
        y("div", {
          class: Zt(["h-[2px] w-full", {
            "bg-(--color-primary)": Le(i) === d.id,
            "bg-(--color-ocean-gray-100)": Le(i) !== d.id
          }]),
          "data-testid": `dataflow-controlled-connection-line-${u}`
        }, null, 10, My)
      ], 8, $y),
      (ae(), de("svg", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        y("polygon", {
          points: "0,0 8,6 0,12",
          style: Br({
            fill: Le(i) === d.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ], 8, By)),
      y("div", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
      }, le(d.dataflowType), 9, Ky),
      y("div", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        class: Zt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Le(i) === d.id,
          "bg-(--color-ocean-gray-100)": Le(i) !== d.id
        }])
      }, null, 10, qy),
      y("div", {
        onClick: (p) => Le(r).setOrResetActiveElement(d.id),
        class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
      }, [
        y("span", Vy, le(d.controlledDataObject), 1)
      ], 8, Uy),
      Le(i) == d.id ? (ae(), en(jo, {
        key: 0,
        to: "#sidebar-details"
      }, [
        yt(Sy, { "controlled-connection": d }, null, 8, ["controlled-connection"])
      ])) : Xe("", !0)
    ]))), 256));
  }
}), Gy = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[50px_50px_1fr_80px]" }, Hy = { class: "col-start-1 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, Yy = ["value"], Xy = ["label"], Qy = ["value"], zy = { class: "col-start-4 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, Jy = ["value"], Zy = ["label"], eg = ["value"], tg = { class: "col-span-full row-start-3" }, ng = /* @__PURE__ */ Ot({
  __name: "dataflow-visualisation",
  props: {
    isDataflowImplementationEnabled: { type: Boolean }
  },
  emits: ["sourceLNodeChange", "destinationLNodeChange"],
  setup(t, { emit: r }) {
    const i = r, s = zn(), c = Pt(), { lnodes: d, connections: u, controlledConnections: p, dataflowSdk: m } = $t(c), P = Ue(), E = Ue(), L = Ue(), j = Ue();
    Ut(
      () => d.value,
      () => {
        P.value = void 0, E.value = void 0;
      }
    );
    const Y = fl(
      async () => await Promise.all(
        d.value.map(async (ue) => {
          const be = (await m.value.findPathToLnode(ue.id))?.split("/");
          Ae(be.length > 0, "LNode path is invalid");
          const ke = be[be.length - 1], Be = be.slice(0, -1).join("/");
          return {
            lnodeId: ue.id,
            path: Be,
            label: ke
          };
        })
      )
    ), z = ze(() => {
      if (!Y.value)
        return {};
      const ue = Y.value.filter(
        (ye) => ye.lnodeId !== E.value
      );
      return we(ue);
    }), H = ze(() => {
      if (!Y.value)
        return {};
      const ue = Y.value.filter(
        (ye) => ye.lnodeId !== P.value
      );
      return we(ue);
    }), ie = ze(() => !P.value || !E.value ? [] : u.value.filter(
      (ue) => ue.sourceLNodeId === P.value && ue.destinationLNodeId === E.value
    )), W = ze(() => !P.value || !E.value ? [] : p.value.filter(
      (ue) => ue.controllerLNodeId === P.value && ue.controlledLNodeId === E.value
    )), B = ze(() => E.value ? u.value.filter(
      (ue) => ue.destinationLNodeId === E.value && !ue.sourceLNodeId
    ) : []), F = ze(
      () => Y.value?.find((ue) => ue.lnodeId === P.value)?.path || ""
    ), q = ze(
      () => Y.value?.find((ue) => ue.lnodeId === E.value)?.path || ""
    );
    function Te(ue) {
      return d.value.find((ye) => ye.id === ue) ?? void 0;
    }
    async function pe(ue) {
      P.value = ue, L.value = Te(ue), i("sourceLNodeChange", ue);
    }
    async function ve(ue) {
      E.value = ue, j.value = Te(ue), i("destinationLNodeChange", ue);
    }
    function se() {
      if (!L.value)
        throw new Error("Source LNode is undefined");
      s.openDialogWithContent("SourcePlaceholderCreation", {
        sourceLNode: L.value
      });
    }
    function S() {
      if (!j.value)
        throw new Error("Destination LNode is undefined");
      s.openDialogWithContent("DestinationPlaceholderCreation", {
        destinationLNode: j.value
      });
    }
    function we(ue) {
      const ye = ue.sort((ke, Be) => ke.label.localeCompare(Be.label));
      let be = {};
      for (const ke of ye) {
        const Be = ke.path;
        be[Be] || (be[Be] = []), be[Be].push({
          lnodeId: ke.lnodeId,
          label: ke.label
        });
      }
      return Rp(be);
    }
    return (ue, ye) => (ae(), de("div", Gy, [
      ye[4] || (ye[4] = y("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2 min-h-[450px]" }, null, -1)),
      y("div", Hy, le(F.value), 1),
      y("select", {
        value: P.value ?? "",
        onChange: ye[0] || (ye[0] = (be) => pe(be.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-2 text-lg text-center font-medium"
      }, [
        ye[2] || (ye[2] = y("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ae(!0), de(qe, null, bt(z.value, (be, ke) => (ae(), de("optgroup", { label: ke }, [
          (ae(!0), de(qe, null, bt(be, (Be) => (ae(), de("option", {
            key: Be.lnodeId,
            value: Be.lnodeId
          }, le(Be.label), 9, Qy))), 128))
        ], 8, Xy))), 256))
      ], 40, Yy),
      ye[5] || (ye[5] = y("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2 min-h-[450px]" }, null, -1)),
      y("div", zy, le(q.value), 1),
      y("select", {
        value: E.value ?? "",
        onChange: ye[1] || (ye[1] = (be) => ve(be.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-2 text-lg text-center font-medium"
      }, [
        ye[3] || (ye[3] = y("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ae(!0), de(qe, null, bt(H.value, (be, ke) => (ae(), de("optgroup", { label: ke }, [
          (ae(!0), de(qe, null, bt(be, (Be) => (ae(), de("option", {
            key: Be.lnodeId,
            value: Be.lnodeId
          }, le(Be.label), 9, eg))), 128))
        ], 8, Zy))), 256))
      ], 40, Jy),
      y("div", tg, [
        ie.value.length > 0 ? (ae(), en(qv, {
          key: 0,
          connections: ie.value,
          isDataflowImplementationEnabled: ue.isDataflowImplementationEnabled
        }, null, 8, ["connections", "isDataflowImplementationEnabled"])) : Xe("", !0),
        W.value.length > 0 ? (ae(), en(Wy, {
          key: 1,
          controlledConnections: W.value
        }, null, 8, ["controlledConnections"])) : Xe("", !0),
        L.value && !ue.isDataflowImplementationEnabled ? (ae(), en(Ey, {
          key: 2,
          sourceLNode: L.value,
          destinationLNode: j.value
        }, null, 8, ["sourceLNode", "destinationLNode"])) : Xe("", !0),
        ue.isDataflowImplementationEnabled ? Xe("", !0) : (ae(), en(ay, {
          key: 3,
          destinationPlaceHolderPorts: B.value
        }, null, 8, ["destinationPlaceHolderPorts"]))
      ]),
      L.value && !ue.isDataflowImplementationEnabled ? (ae(), de("button", {
        key: 0,
        "aria-label": "Add source placeholder",
        class: "custom-plus-btn-left",
        onClick: se
      }, [
        yt(ya)
      ])) : Xe("", !0),
      j.value && !ue.isDataflowImplementationEnabled ? (ae(), de("button", {
        key: 1,
        class: "custom-plus-btn-right",
        "aria-label": "Add destination placeholder",
        onClick: S
      }, [
        yt(ya)
      ])) : Xe("", !0)
    ]));
  }
}), rg = /* @__PURE__ */ Vi(ng, [["__scopeId", "data-v-350ad1a1"]]), og = { class: "flex justify-between mb-6 w-full h-18" }, ig = { key: 0 }, ag = { class: "flex flex-col items-center justify-center w-full" }, sg = ["disabled"], lg = /* @__PURE__ */ Ot({
  __name: "dataflow-view",
  setup(t) {
    const r = Ue(), i = Ue(), s = Ue(!1), c = zn(), d = Pt(), { lnodes: u } = $t(d), p = ze(() => L(r.value)), m = ze(() => L(i.value));
    function P(Y) {
      r.value = Y;
    }
    function E(Y) {
      i.value = Y;
    }
    function L(Y) {
      return u.value.find((z) => z.id === Y) ?? void 0;
    }
    function j() {
      if (!p.value || !m.value)
        throw new Error("Source or Destination LNode is undefined");
      c.openDialogWithContent("DataflowCreation", {
        sourceLNode: p.value,
        destinationLNode: m.value
      });
    }
    return (Y, z) => (ae(), de(qe, null, [
      y("div", og, [
        y("div", null, [
          z[1] || (z[1] = y("span", { class: "mr-3" }, "Specification", -1)),
          at(y("input", {
            type: "checkbox",
            "onUpdate:modelValue": z[0] || (z[0] = (H) => s.value = H),
            class: "toggle"
          }, null, 512), [
            [Ro, s.value]
          ]),
          z[2] || (z[2] = y("span", { class: "ml-3" }, "Implementation", -1))
        ]),
        s.value ? (ae(), de("div", ig, z[3] || (z[3] = [
          dc('<div class="flex items-center"><div class="border w-[50px] h-[2px] mr-2"></div><span>Implemented</span></div><div class="flex items-center"><div class="border border-dashed w-[50px] h-[2px] mr-2"></div><span>Not implemented</span></div><div class="flex items-center"><div class="border border-dotted w-[50px] h-[2px] mr-2"></div><span>Not possible to implement</span></div>', 3)
        ]))) : Xe("", !0)
      ]),
      y("div", ag, [
        yt(rg, {
          onSourceLNodeChange: P,
          onDestinationLNodeChange: E,
          isDataflowImplementationEnabled: s.value
        }, null, 8, ["isDataflowImplementationEnabled"]),
        s.value ? Xe("", !0) : (ae(), de("button", {
          key: 0,
          class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
          onClick: j,
          disabled: !p.value || !m.value,
          "aria-label": "Add connection"
        }, [
          yt(ya)
        ], 8, sg))
      ])
    ], 64));
  }
}), ug = {}, cg = { class: "layout" }, fg = { class: "main" }, dg = { class: "sidebar" };
function pg(t, r) {
  return ae(), de("div", cg, [
    y("div", fg, [
      _l(t.$slots, "main", {}, void 0)
    ]),
    y("div", dg, [
      _l(t.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const hg = /* @__PURE__ */ Vi(ug, [["render", pg], ["__scopeId", "data-v-5f95d421"]]), mg = {
  name: "sidebar",
  class: "root"
}, vg = { class: "tabs tabs-box" }, yg = { key: 0 }, gg = { key: 1 }, bg = /* @__PURE__ */ Ot({
  __name: "sidebar",
  setup(t) {
    const r = Ue("details");
    return (i, s) => (ae(), de("div", mg, [
      y("div", vg, [
        at(y("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": s[0] || (s[0] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [Mr, r.value]
        ]),
        at(y("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": s[1] || (s[1] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [Mr, r.value]
        ])
      ]),
      y("div", null, [
        r.value === "details" ? (ae(), de("div", yg, s[2] || (s[2] = [
          y("div", { id: "sidebar-details" }, null, -1)
        ]))) : Xe("", !0),
        r.value === "advanced" ? (ae(), de("div", gg)) : Xe("", !0)
      ])
    ]));
  }
}), wg = /* @__PURE__ */ Vi(bg, [["__scopeId", "data-v-ec5c053a"]]), _g = {
  class: "modal",
  ref: "dialogRef"
}, xg = /* @__PURE__ */ Ot({
  __name: "dialog-container",
  setup(t) {
    const r = zn(), { currentDialogContent: i } = $t(r), s = Tf("dialogRef");
    return Ko(() => {
      s.value && (r.dialogRef = s.value);
    }), (c, d) => (ae(), de("dialog", _g, [
      y("div", {
        class: Zt(["modal-box max-h-[85vh]", Le(r).dialogAttributes?.class])
      }, [
        y("button", {
          class: "btn btn-sm btn-circle btn-ghost absolute right-2 top-2",
          "aria-label": "Close dialog",
          onClick: d[0] || (d[0] = //@ts-ignore
          (...u) => Le(r).handleClose && Le(r).handleClose(...u))
        }, " ✕ "),
        Le(i).component ? (ae(), en(Mf(Le(i).component), $c(pc({ key: 0 }, Le(i).props)), null, 16)) : Xe("", !0)
      ], 2),
      d[1] || (d[1] = y("form", {
        method: "dialog",
        class: "modal-backdrop"
      }, [
        y("button", null, "close")
      ], -1))
    ], 512));
  }
}), Ng = ["id"], Rg = { class: "px-5" }, Cg = /* @__PURE__ */ Ot({
  __name: "app",
  props: {
    api: {}
  },
  setup(t) {
    const r = "dataflow", i = t, s = Pt();
    let c = () => {
    };
    return Ko(() => {
      c = i.api.activeFileName.subscribe((d) => {
        s.initApp(d);
      }), s.initApp(i.api.activeFileName.value);
    }), zs(() => {
      s.closeDatabase(), c();
    }), (d, u) => (ae(), de("article", {
      id: Le(r),
      style: { height: "100%" }
    }, [
      yt(hg, null, {
        main: xs(() => [
          y("div", Rg, [
            yt(lg),
            yt(xg)
          ])
        ]),
        sidebar: xs(() => [
          yt(wg)
        ]),
        _: 1
      })
    ], 8, Ng));
  }
});
function Yg(t, r) {
  if (!document.getElementById(t)) {
    console.error({ msg: "could not found root element", rootId: t });
    return;
  }
  const s = tp(Cg, { api: r });
  return s.use(op()), s.mount(`#${t}`), s.unmount;
}
export {
  Yg as default
};
