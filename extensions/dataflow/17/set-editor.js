(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999;transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.pointer-events-none{pointer-events:none}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-\\[1\\.5rem\\]{top:1.5rem}.right-\\[1\\.5rem\\]{right:1.5rem}.-z-1{z-index:-1}.z-1{z-index:1}.z-10{z-index:10}.-order-1{order:-1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-2{margin-left:calc(var(--spacing)*2)}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.min-h-\\[450px\\]{min-height:450px}.w-\\[20px\\]{width:20px}.w-full{width:100%}.max-w-max{max-width:max-content}.cursor-pointer{cursor:pointer}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-1{grid-template-rows:repeat(1,minmax(0,1fr))}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.self-start{align-self:flex-start}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.radio-sm{padding:.1875rem}.radio-sm[type=radio]{--size:calc(var(--size-selector,.25rem)*5)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function _a(n) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const s of n.split(",")) r[s] = 1;
  return (s) => s in r;
}
const ft = {}, Eo = [], Hn = () => {
}, tc = () => !1, is = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), xa = (n) => n.startsWith("onUpdate:"), zt = Object.assign, Oa = (n, r) => {
  const s = n.indexOf(r);
  s > -1 && n.splice(s, 1);
}, nc = Object.prototype.hasOwnProperty, at = (n, r) => nc.call(n, r), ke = Array.isArray, No = (n) => ki(n) === "[object Map]", Io = (n) => ki(n) === "[object Set]", Va = (n) => ki(n) === "[object Date]", qe = (n) => typeof n == "function", At = (n) => typeof n == "string", Fn = (n) => typeof n == "symbol", gt = (n) => n !== null && typeof n == "object", Lu = (n) => (gt(n) || qe(n)) && qe(n.then) && qe(n.catch), Ku = Object.prototype.toString, ki = (n) => Ku.call(n), rc = (n) => ki(n).slice(8, -1), Fu = (n) => ki(n) === "[object Object]", Ta = (n) => At(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, yi = /* @__PURE__ */ _a(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), ss = (n) => {
  const r = /* @__PURE__ */ Object.create(null);
  return (s) => r[s] || (r[s] = n(s));
}, oc = /-(\w)/g, Rr = ss(
  (n) => n.replace(oc, (r, s) => s ? s.toUpperCase() : "")
), ic = /\B([A-Z])/g, _o = ss(
  (n) => n.replace(ic, "-$1").toLowerCase()
), Mu = ss((n) => n.charAt(0).toUpperCase() + n.slice(1)), Us = ss(
  (n) => n ? `on${Mu(n)}` : ""
), Dr = (n, r) => !Object.is(n, r), Ui = (n, ...r) => {
  for (let s = 0; s < n.length; s++)
    n[s](...r);
}, na = (n, r, s, u = !1) => {
  Object.defineProperty(n, r, {
    configurable: !0,
    enumerable: !1,
    writable: u,
    value: s
  });
}, zi = (n) => {
  const r = parseFloat(n);
  return isNaN(r) ? n : r;
};
let Ha;
const as = () => Ha || (Ha = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ji(n) {
  if (ke(n)) {
    const r = {};
    for (let s = 0; s < n.length; s++) {
      const u = n[s], c = At(u) ? lc(u) : ji(u);
      if (c)
        for (const f in c)
          r[f] = c[f];
    }
    return r;
  } else if (At(n) || gt(n))
    return n;
}
const sc = /;(?![^(]*\))/g, ac = /:([^]+)/, uc = /\/\*[^]*?\*\//g;
function lc(n) {
  const r = {};
  return n.replace(uc, "").split(sc).forEach((s) => {
    if (s) {
      const u = s.split(ac);
      u.length > 1 && (r[u[0].trim()] = u[1].trim());
    }
  }), r;
}
function On(n) {
  let r = "";
  if (At(n))
    r = n;
  else if (ke(n))
    for (let s = 0; s < n.length; s++) {
      const u = On(n[s]);
      u && (r += u + " ");
    }
  else if (gt(n))
    for (const s in n)
      n[s] && (r += s + " ");
  return r.trim();
}
const cc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", fc = /* @__PURE__ */ _a(cc);
function Bu(n) {
  return !!n || n === "";
}
function dc(n, r) {
  if (n.length !== r.length) return !1;
  let s = !0;
  for (let u = 0; s && u < n.length; u++)
    s = bo(n[u], r[u]);
  return s;
}
function bo(n, r) {
  if (n === r) return !0;
  let s = Va(n), u = Va(r);
  if (s || u)
    return s && u ? n.getTime() === r.getTime() : !1;
  if (s = Fn(n), u = Fn(r), s || u)
    return n === r;
  if (s = ke(n), u = ke(r), s || u)
    return s && u ? dc(n, r) : !1;
  if (s = gt(n), u = gt(r), s || u) {
    if (!s || !u)
      return !1;
    const c = Object.keys(n).length, f = Object.keys(r).length;
    if (c !== f)
      return !1;
    for (const p in n) {
      const h = n.hasOwnProperty(p), g = r.hasOwnProperty(p);
      if (h && !g || !h && g || !bo(n[p], r[p]))
        return !1;
    }
  }
  return String(n) === String(r);
}
function Ea(n, r) {
  return n.findIndex((s) => bo(s, r));
}
const $u = (n) => !!(n && n.__v_isRef === !0), Ee = (n) => At(n) ? n : n == null ? "" : ke(n) || gt(n) && (n.toString === Ku || !qe(n.toString)) ? $u(n) ? Ee(n.value) : JSON.stringify(n, qu, 2) : String(n), qu = (n, r) => $u(r) ? qu(n, r.value) : No(r) ? {
  [`Map(${r.size})`]: [...r.entries()].reduce(
    (s, [u, c], f) => (s[Vs(u, f) + " =>"] = c, s),
    {}
  )
} : Io(r) ? {
  [`Set(${r.size})`]: [...r.values()].map((s) => Vs(s))
} : Fn(r) ? Vs(r) : gt(r) && !ke(r) && !Fu(r) ? String(r) : r, Vs = (n, r = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Fn(n) ? `Symbol(${(s = n.description) != null ? s : r})` : n
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Yt;
class Uu {
  constructor(r = !1) {
    this.detached = r, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Yt, !r && Yt && (this.index = (Yt.scopes || (Yt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let r, s;
      if (this.scopes)
        for (r = 0, s = this.scopes.length; r < s; r++)
          this.scopes[r].pause();
      for (r = 0, s = this.effects.length; r < s; r++)
        this.effects[r].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let r, s;
      if (this.scopes)
        for (r = 0, s = this.scopes.length; r < s; r++)
          this.scopes[r].resume();
      for (r = 0, s = this.effects.length; r < s; r++)
        this.effects[r].resume();
    }
  }
  run(r) {
    if (this._active) {
      const s = Yt;
      try {
        return Yt = this, r();
      } finally {
        Yt = s;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Yt, Yt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Yt = this.prevScope, this.prevScope = void 0);
  }
  stop(r) {
    if (this._active) {
      this._active = !1;
      let s, u;
      for (s = 0, u = this.effects.length; s < u; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, u = this.cleanups.length; s < u; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, u = this.scopes.length; s < u; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !r) {
        const c = this.parent.scopes.pop();
        c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Vu(n) {
  return new Uu(n);
}
function Hu() {
  return Yt;
}
function pc(n, r = !1) {
  Yt && Yt.cleanups.push(n);
}
let yt;
const Hs = /* @__PURE__ */ new WeakSet();
class Wu {
  constructor(r) {
    this.fn = r, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Yt && Yt.active && Yt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Hs.has(this) && (Hs.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Yu(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Wa(this), Xu(this);
    const r = yt, s = Kn;
    yt = this, Kn = !0;
    try {
      return this.fn();
    } finally {
      zu(this), yt = r, Kn = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let r = this.deps; r; r = r.nextDep)
        Sa(r);
      this.deps = this.depsTail = void 0, Wa(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Hs.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    ra(this) && this.run();
  }
  get dirty() {
    return ra(this);
  }
}
let Gu = 0, vi, gi;
function Yu(n, r = !1) {
  if (n.flags |= 8, r) {
    n.next = gi, gi = n;
    return;
  }
  n.next = vi, vi = n;
}
function Na() {
  Gu++;
}
function Ca() {
  if (--Gu > 0)
    return;
  if (gi) {
    let r = gi;
    for (gi = void 0; r; ) {
      const s = r.next;
      r.next = void 0, r.flags &= -9, r = s;
    }
  }
  let n;
  for (; vi; ) {
    let r = vi;
    for (vi = void 0; r; ) {
      const s = r.next;
      if (r.next = void 0, r.flags &= -9, r.flags & 1)
        try {
          r.trigger();
        } catch (u) {
          n || (n = u);
        }
      r = s;
    }
  }
  if (n) throw n;
}
function Xu(n) {
  for (let r = n.deps; r; r = r.nextDep)
    r.version = -1, r.prevActiveLink = r.dep.activeLink, r.dep.activeLink = r;
}
function zu(n) {
  let r, s = n.depsTail, u = s;
  for (; u; ) {
    const c = u.prevDep;
    u.version === -1 ? (u === s && (s = c), Sa(u), hc(u)) : r = u, u.dep.activeLink = u.prevActiveLink, u.prevActiveLink = void 0, u = c;
  }
  n.deps = r, n.depsTail = s;
}
function ra(n) {
  for (let r = n.deps; r; r = r.nextDep)
    if (r.dep.version !== r.version || r.dep.computed && (Qu(r.dep.computed) || r.dep.version !== r.version))
      return !0;
  return !!n._dirty;
}
function Qu(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === Ei) || (n.globalVersion = Ei, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !ra(n))))
    return;
  n.flags |= 2;
  const r = n.dep, s = yt, u = Kn;
  yt = n, Kn = !0;
  try {
    Xu(n);
    const c = n.fn(n._value);
    (r.version === 0 || Dr(c, n._value)) && (n.flags |= 128, n._value = c, r.version++);
  } catch (c) {
    throw r.version++, c;
  } finally {
    yt = s, Kn = u, zu(n), n.flags &= -3;
  }
}
function Sa(n, r = !1) {
  const { dep: s, prevSub: u, nextSub: c } = n;
  if (u && (u.nextSub = c, n.prevSub = void 0), c && (c.prevSub = u, n.nextSub = void 0), s.subs === n && (s.subs = u, !u && s.computed)) {
    s.computed.flags &= -5;
    for (let f = s.computed.deps; f; f = f.nextDep)
      Sa(f, !0);
  }
  !r && !--s.sc && s.map && s.map.delete(s.key);
}
function hc(n) {
  const { prevDep: r, nextDep: s } = n;
  r && (r.nextDep = s, n.prevDep = void 0), s && (s.prevDep = r, n.nextDep = void 0);
}
let Kn = !0;
const Ju = [];
function Tr() {
  Ju.push(Kn), Kn = !1;
}
function Er() {
  const n = Ju.pop();
  Kn = n === void 0 ? !0 : n;
}
function Wa(n) {
  const { cleanup: r } = n;
  if (n.cleanup = void 0, r) {
    const s = yt;
    yt = void 0;
    try {
      r();
    } finally {
      yt = s;
    }
  }
}
let Ei = 0;
class mc {
  constructor(r, s) {
    this.sub = r, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Aa {
  // TODO isolatedDeclarations "__v_skip"
  constructor(r) {
    this.computed = r, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(r) {
    if (!yt || !Kn || yt === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== yt)
      s = this.activeLink = new mc(yt, this), yt.deps ? (s.prevDep = yt.depsTail, yt.depsTail.nextDep = s, yt.depsTail = s) : yt.deps = yt.depsTail = s, Zu(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const u = s.nextDep;
      u.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = u), s.prevDep = yt.depsTail, s.nextDep = void 0, yt.depsTail.nextDep = s, yt.depsTail = s, yt.deps === s && (yt.deps = u);
    }
    return s;
  }
  trigger(r) {
    this.version++, Ei++, this.notify(r);
  }
  notify(r) {
    Na();
    try {
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Ca();
    }
  }
}
function Zu(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const r = n.dep.computed;
    if (r && !n.dep.subs) {
      r.flags |= 20;
      for (let u = r.deps; u; u = u.nextDep)
        Zu(u);
    }
    const s = n.dep.subs;
    s !== n && (n.prevSub = s, s && (s.nextSub = n)), n.dep.subs = n;
  }
}
const Qi = /* @__PURE__ */ new WeakMap(), vo = Symbol(
  ""
), oa = Symbol(
  ""
), Ni = Symbol(
  ""
);
function Xt(n, r, s) {
  if (Kn && yt) {
    let u = Qi.get(n);
    u || Qi.set(n, u = /* @__PURE__ */ new Map());
    let c = u.get(s);
    c || (u.set(s, c = new Aa()), c.map = u, c.key = s), c.track();
  }
}
function br(n, r, s, u, c, f) {
  const p = Qi.get(n);
  if (!p) {
    Ei++;
    return;
  }
  const h = (g) => {
    g && g.trigger();
  };
  if (Na(), r === "clear")
    p.forEach(h);
  else {
    const g = ke(n), R = g && Ta(s);
    if (g && s === "length") {
      const D = Number(u);
      p.forEach((L, B) => {
        (B === "length" || B === Ni || !Fn(B) && B >= D) && h(L);
      });
    } else
      switch ((s !== void 0 || p.has(void 0)) && h(p.get(s)), R && h(p.get(Ni)), r) {
        case "add":
          g ? R && h(p.get("length")) : (h(p.get(vo)), No(n) && h(p.get(oa)));
          break;
        case "delete":
          g || (h(p.get(vo)), No(n) && h(p.get(oa)));
          break;
        case "set":
          No(n) && h(p.get(vo));
          break;
      }
  }
  Ca();
}
function yc(n, r) {
  const s = Qi.get(n);
  return s && s.get(r);
}
function xo(n) {
  const r = et(n);
  return r === n ? r : (Xt(r, "iterate", Ni), Nn(n) ? r : r.map(Vt));
}
function us(n) {
  return Xt(n = et(n), "iterate", Ni), n;
}
const vc = {
  __proto__: null,
  [Symbol.iterator]() {
    return Ws(this, Symbol.iterator, Vt);
  },
  concat(...n) {
    return xo(this).concat(
      ...n.map((r) => ke(r) ? xo(r) : r)
    );
  },
  entries() {
    return Ws(this, "entries", (n) => (n[1] = Vt(n[1]), n));
  },
  every(n, r) {
    return vr(this, "every", n, r, void 0, arguments);
  },
  filter(n, r) {
    return vr(this, "filter", n, r, (s) => s.map(Vt), arguments);
  },
  find(n, r) {
    return vr(this, "find", n, r, Vt, arguments);
  },
  findIndex(n, r) {
    return vr(this, "findIndex", n, r, void 0, arguments);
  },
  findLast(n, r) {
    return vr(this, "findLast", n, r, Vt, arguments);
  },
  findLastIndex(n, r) {
    return vr(this, "findLastIndex", n, r, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, r) {
    return vr(this, "forEach", n, r, void 0, arguments);
  },
  includes(...n) {
    return Gs(this, "includes", n);
  },
  indexOf(...n) {
    return Gs(this, "indexOf", n);
  },
  join(n) {
    return xo(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return Gs(this, "lastIndexOf", n);
  },
  map(n, r) {
    return vr(this, "map", n, r, void 0, arguments);
  },
  pop() {
    return di(this, "pop");
  },
  push(...n) {
    return di(this, "push", n);
  },
  reduce(n, ...r) {
    return Ga(this, "reduce", n, r);
  },
  reduceRight(n, ...r) {
    return Ga(this, "reduceRight", n, r);
  },
  shift() {
    return di(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, r) {
    return vr(this, "some", n, r, void 0, arguments);
  },
  splice(...n) {
    return di(this, "splice", n);
  },
  toReversed() {
    return xo(this).toReversed();
  },
  toSorted(n) {
    return xo(this).toSorted(n);
  },
  toSpliced(...n) {
    return xo(this).toSpliced(...n);
  },
  unshift(...n) {
    return di(this, "unshift", n);
  },
  values() {
    return Ws(this, "values", Vt);
  }
};
function Ws(n, r, s) {
  const u = us(n), c = u[r]();
  return u !== n && !Nn(n) && (c._next = c.next, c.next = () => {
    const f = c._next();
    return f.value && (f.value = s(f.value)), f;
  }), c;
}
const gc = Array.prototype;
function vr(n, r, s, u, c, f) {
  const p = us(n), h = p !== n && !Nn(n), g = p[r];
  if (g !== gc[r]) {
    const L = g.apply(n, f);
    return h ? Vt(L) : L;
  }
  let R = s;
  p !== n && (h ? R = function(L, B) {
    return s.call(this, Vt(L), B, n);
  } : s.length > 2 && (R = function(L, B) {
    return s.call(this, L, B, n);
  }));
  const D = g.call(p, R, u);
  return h && c ? c(D) : D;
}
function Ga(n, r, s, u) {
  const c = us(n);
  let f = s;
  return c !== n && (Nn(n) ? s.length > 3 && (f = function(p, h, g) {
    return s.call(this, p, h, g, n);
  }) : f = function(p, h, g) {
    return s.call(this, p, Vt(h), g, n);
  }), c[r](f, ...u);
}
function Gs(n, r, s) {
  const u = et(n);
  Xt(u, "iterate", Ni);
  const c = u[r](...s);
  return (c === -1 || c === !1) && Ra(s[0]) ? (s[0] = et(s[0]), u[r](...s)) : c;
}
function di(n, r, s = []) {
  Tr(), Na();
  const u = et(n)[r].apply(n, s);
  return Ca(), Er(), u;
}
const bc = /* @__PURE__ */ _a("__proto__,__v_isRef,__isVue"), el = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(Fn)
);
function wc(n) {
  Fn(n) || (n = String(n));
  const r = et(this);
  return Xt(r, "has", n), r.hasOwnProperty(n);
}
class tl {
  constructor(r = !1, s = !1) {
    this._isReadonly = r, this._isShallow = s;
  }
  get(r, s, u) {
    if (s === "__v_skip") return r.__v_skip;
    const c = this._isReadonly, f = this._isShallow;
    if (s === "__v_isReactive")
      return !c;
    if (s === "__v_isReadonly")
      return c;
    if (s === "__v_isShallow")
      return f;
    if (s === "__v_raw")
      return u === (c ? f ? Pc : il : f ? ol : rl).get(r) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(r) === Object.getPrototypeOf(u) ? r : void 0;
    const p = ke(r);
    if (!c) {
      let g;
      if (p && (g = vc[s]))
        return g;
      if (s === "hasOwnProperty")
        return wc;
    }
    const h = Reflect.get(
      r,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      xt(r) ? r : u
    );
    return (Fn(s) ? el.has(s) : bc(s)) || (c || Xt(r, "get", s), f) ? h : xt(h) ? p && Ta(s) ? h : h.value : gt(h) ? c ? sl(h) : ls(h) : h;
  }
}
class nl extends tl {
  constructor(r = !1) {
    super(!1, r);
  }
  set(r, s, u, c) {
    let f = r[s];
    if (!this._isShallow) {
      const g = Ir(f);
      if (!Nn(u) && !Ir(u) && (f = et(f), u = et(u)), !ke(r) && xt(f) && !xt(u))
        return g ? !1 : (f.value = u, !0);
    }
    const p = ke(r) && Ta(s) ? Number(s) < r.length : at(r, s), h = Reflect.set(
      r,
      s,
      u,
      xt(r) ? r : c
    );
    return r === et(c) && (p ? Dr(u, f) && br(r, "set", s, u) : br(r, "add", s, u)), h;
  }
  deleteProperty(r, s) {
    const u = at(r, s);
    r[s];
    const c = Reflect.deleteProperty(r, s);
    return c && u && br(r, "delete", s, void 0), c;
  }
  has(r, s) {
    const u = Reflect.has(r, s);
    return (!Fn(s) || !el.has(s)) && Xt(r, "has", s), u;
  }
  ownKeys(r) {
    return Xt(
      r,
      "iterate",
      ke(r) ? "length" : vo
    ), Reflect.ownKeys(r);
  }
}
class _c extends tl {
  constructor(r = !1) {
    super(!0, r);
  }
  set(r, s) {
    return !0;
  }
  deleteProperty(r, s) {
    return !0;
  }
}
const xc = /* @__PURE__ */ new nl(), Oc = /* @__PURE__ */ new _c(), Tc = /* @__PURE__ */ new nl(!0);
const ia = (n) => n, Fi = (n) => Reflect.getPrototypeOf(n);
function Ec(n, r, s) {
  return function(...u) {
    const c = this.__v_raw, f = et(c), p = No(f), h = n === "entries" || n === Symbol.iterator && p, g = n === "keys" && p, R = c[n](...u), D = s ? ia : r ? Ji : Vt;
    return !r && Xt(
      f,
      "iterate",
      g ? oa : vo
    ), {
      // iterator protocol
      next() {
        const { value: L, done: B } = R.next();
        return B ? { value: L, done: B } : {
          value: h ? [D(L[0]), D(L[1])] : D(L),
          done: B
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Mi(n) {
  return function(...r) {
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function Nc(n, r) {
  const s = {
    get(c) {
      const f = this.__v_raw, p = et(f), h = et(c);
      n || (Dr(c, h) && Xt(p, "get", c), Xt(p, "get", h));
      const { has: g } = Fi(p), R = r ? ia : n ? Ji : Vt;
      if (g.call(p, c))
        return R(f.get(c));
      if (g.call(p, h))
        return R(f.get(h));
      f !== p && f.get(c);
    },
    get size() {
      const c = this.__v_raw;
      return !n && Xt(et(c), "iterate", vo), Reflect.get(c, "size", c);
    },
    has(c) {
      const f = this.__v_raw, p = et(f), h = et(c);
      return n || (Dr(c, h) && Xt(p, "has", c), Xt(p, "has", h)), c === h ? f.has(c) : f.has(c) || f.has(h);
    },
    forEach(c, f) {
      const p = this, h = p.__v_raw, g = et(h), R = r ? ia : n ? Ji : Vt;
      return !n && Xt(g, "iterate", vo), h.forEach((D, L) => c.call(f, R(D), R(L), p));
    }
  };
  return zt(
    s,
    n ? {
      add: Mi("add"),
      set: Mi("set"),
      delete: Mi("delete"),
      clear: Mi("clear")
    } : {
      add(c) {
        !r && !Nn(c) && !Ir(c) && (c = et(c));
        const f = et(this);
        return Fi(f).has.call(f, c) || (f.add(c), br(f, "add", c, c)), this;
      },
      set(c, f) {
        !r && !Nn(f) && !Ir(f) && (f = et(f));
        const p = et(this), { has: h, get: g } = Fi(p);
        let R = h.call(p, c);
        R || (c = et(c), R = h.call(p, c));
        const D = g.call(p, c);
        return p.set(c, f), R ? Dr(f, D) && br(p, "set", c, f) : br(p, "add", c, f), this;
      },
      delete(c) {
        const f = et(this), { has: p, get: h } = Fi(f);
        let g = p.call(f, c);
        g || (c = et(c), g = p.call(f, c)), h && h.call(f, c);
        const R = f.delete(c);
        return g && br(f, "delete", c, void 0), R;
      },
      clear() {
        const c = et(this), f = c.size !== 0, p = c.clear();
        return f && br(
          c,
          "clear",
          void 0,
          void 0
        ), p;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((c) => {
    s[c] = Ec(c, n, r);
  }), s;
}
function Pa(n, r) {
  const s = Nc(n, r);
  return (u, c, f) => c === "__v_isReactive" ? !n : c === "__v_isReadonly" ? n : c === "__v_raw" ? u : Reflect.get(
    at(s, c) && c in u ? s : u,
    c,
    f
  );
}
const Cc = {
  get: /* @__PURE__ */ Pa(!1, !1)
}, Sc = {
  get: /* @__PURE__ */ Pa(!1, !0)
}, Ac = {
  get: /* @__PURE__ */ Pa(!0, !1)
};
const rl = /* @__PURE__ */ new WeakMap(), ol = /* @__PURE__ */ new WeakMap(), il = /* @__PURE__ */ new WeakMap(), Pc = /* @__PURE__ */ new WeakMap();
function Dc(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Rc(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : Dc(rc(n));
}
function ls(n) {
  return Ir(n) ? n : Da(
    n,
    !1,
    xc,
    Cc,
    rl
  );
}
function Ic(n) {
  return Da(
    n,
    !1,
    Tc,
    Sc,
    ol
  );
}
function sl(n) {
  return Da(
    n,
    !0,
    Oc,
    Ac,
    il
  );
}
function Da(n, r, s, u, c) {
  if (!gt(n) || n.__v_raw && !(r && n.__v_isReactive))
    return n;
  const f = Rc(n);
  if (f === 0)
    return n;
  const p = c.get(n);
  if (p)
    return p;
  const h = new Proxy(
    n,
    f === 2 ? u : s
  );
  return c.set(n, h), h;
}
function xr(n) {
  return Ir(n) ? xr(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Ir(n) {
  return !!(n && n.__v_isReadonly);
}
function Nn(n) {
  return !!(n && n.__v_isShallow);
}
function Ra(n) {
  return n ? !!n.__v_raw : !1;
}
function et(n) {
  const r = n && n.__v_raw;
  return r ? et(r) : n;
}
function Ia(n) {
  return !at(n, "__v_skip") && Object.isExtensible(n) && na(n, "__v_skip", !0), n;
}
const Vt = (n) => gt(n) ? ls(n) : n, Ji = (n) => gt(n) ? sl(n) : n;
function xt(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function rt(n) {
  return al(n, !1);
}
function Vi(n) {
  return al(n, !0);
}
function al(n, r) {
  return xt(n) ? n : new kc(n, r);
}
class kc {
  constructor(r, s) {
    this.dep = new Aa(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? r : et(r), this._value = s ? r : Vt(r), this.__v_isShallow = s;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(r) {
    const s = this._rawValue, u = this.__v_isShallow || Nn(r) || Ir(r);
    r = u ? r : et(r), Dr(r, s) && (this._rawValue = r, this._value = u ? r : Vt(r), this.dep.trigger());
  }
}
function De(n) {
  return xt(n) ? n.value : n;
}
const jc = {
  get: (n, r, s) => r === "__v_raw" ? n : De(Reflect.get(n, r, s)),
  set: (n, r, s, u) => {
    const c = n[r];
    return xt(c) && !xt(s) ? (c.value = s, !0) : Reflect.set(n, r, s, u);
  }
};
function ul(n) {
  return xr(n) ? n : new Proxy(n, jc);
}
function Lc(n) {
  const r = ke(n) ? new Array(n.length) : {};
  for (const s in n)
    r[s] = ll(n, s);
  return r;
}
class Kc {
  constructor(r, s, u) {
    this._object = r, this._key = s, this._defaultValue = u, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const r = this._object[this._key];
    return this._value = r === void 0 ? this._defaultValue : r;
  }
  set value(r) {
    this._object[this._key] = r;
  }
  get dep() {
    return yc(et(this._object), this._key);
  }
}
class Fc {
  constructor(r) {
    this._getter = r, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Mc(n, r, s) {
  return xt(n) ? n : qe(n) ? new Fc(n) : gt(n) && arguments.length > 1 ? ll(n, r, s) : rt(n);
}
function ll(n, r, s) {
  const u = n[r];
  return xt(u) ? u : new Kc(n, r, s);
}
class Bc {
  constructor(r, s, u) {
    this.fn = r, this.setter = s, this._value = void 0, this.dep = new Aa(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Ei - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = u;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    yt !== this)
      return Yu(this, !0), !0;
  }
  get value() {
    const r = this.dep.track();
    return Qu(this), r && (r.version = this.dep.version), this._value;
  }
  set value(r) {
    this.setter && this.setter(r);
  }
}
function $c(n, r, s = !1) {
  let u, c;
  return qe(n) ? u = n : (u = n.get, c = n.set), new Bc(u, c, s);
}
const Bi = {}, Zi = /* @__PURE__ */ new WeakMap();
let yo;
function qc(n, r = !1, s = yo) {
  if (s) {
    let u = Zi.get(s);
    u || Zi.set(s, u = []), u.push(n);
  }
}
function Uc(n, r, s = ft) {
  const { immediate: u, deep: c, once: f, scheduler: p, augmentJob: h, call: g } = s, R = (q) => c ? q : Nn(q) || c === !1 || c === 0 ? wr(q, 1) : wr(q);
  let D, L, B, ee, ie = !1, ce = !1;
  if (xt(n) ? (L = () => n.value, ie = Nn(n)) : xr(n) ? (L = () => R(n), ie = !0) : ke(n) ? (ce = !0, ie = n.some((q) => xr(q) || Nn(q)), L = () => n.map((q) => {
    if (xt(q))
      return q.value;
    if (xr(q))
      return R(q);
    if (qe(q))
      return g ? g(q, 2) : q();
  })) : qe(n) ? r ? L = g ? () => g(n, 2) : n : L = () => {
    if (B) {
      Tr();
      try {
        B();
      } finally {
        Er();
      }
    }
    const q = yo;
    yo = D;
    try {
      return g ? g(n, 3, [ee]) : n(ee);
    } finally {
      yo = q;
    }
  } : L = Hn, r && c) {
    const q = L, M = c === !0 ? 1 / 0 : c;
    L = () => wr(q(), M);
  }
  const xe = Hu(), le = () => {
    D.stop(), xe && xe.active && Oa(xe.effects, D);
  };
  if (f && r) {
    const q = r;
    r = (...M) => {
      q(...M), le();
    };
  }
  let U = ce ? new Array(n.length).fill(Bi) : Bi;
  const Y = (q) => {
    if (!(!(D.flags & 1) || !D.dirty && !q))
      if (r) {
        const M = D.run();
        if (c || ie || (ce ? M.some((ne, we) => Dr(ne, U[we])) : Dr(M, U))) {
          B && B();
          const ne = yo;
          yo = D;
          try {
            const we = [
              M,
              // pass undefined as the old value when it's changed for the first time
              U === Bi ? void 0 : ce && U[0] === Bi ? [] : U,
              ee
            ];
            U = M, g ? g(r, 3, we) : (
              // @ts-expect-error
              r(...we)
            );
          } finally {
            yo = ne;
          }
        }
      } else
        D.run();
  };
  return h && h(Y), D = new Wu(L), D.scheduler = p ? () => p(Y, !1) : Y, ee = (q) => qc(q, !1, D), B = D.onStop = () => {
    const q = Zi.get(D);
    if (q) {
      if (g)
        g(q, 4);
      else
        for (const M of q) M();
      Zi.delete(D);
    }
  }, r ? u ? Y(!0) : U = D.run() : p ? p(Y.bind(null, !0), !0) : D.run(), le.pause = D.pause.bind(D), le.resume = D.resume.bind(D), le.stop = le, le;
}
function wr(n, r = 1 / 0, s) {
  if (r <= 0 || !gt(n) || n.__v_skip || (s = s || /* @__PURE__ */ new Set(), s.has(n)))
    return n;
  if (s.add(n), r--, xt(n))
    wr(n.value, r, s);
  else if (ke(n))
    for (let u = 0; u < n.length; u++)
      wr(n[u], r, s);
  else if (Io(n) || No(n))
    n.forEach((u) => {
      wr(u, r, s);
    });
  else if (Fu(n)) {
    for (const u in n)
      wr(n[u], r, s);
    for (const u of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, u) && wr(n[u], r, s);
  }
  return n;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Li(n, r, s, u) {
  try {
    return u ? n(...u) : n();
  } catch (c) {
    cs(c, r, s);
  }
}
function Wn(n, r, s, u) {
  if (qe(n)) {
    const c = Li(n, r, s, u);
    return c && Lu(c) && c.catch((f) => {
      cs(f, r, s);
    }), c;
  }
  if (ke(n)) {
    const c = [];
    for (let f = 0; f < n.length; f++)
      c.push(Wn(n[f], r, s, u));
    return c;
  }
}
function cs(n, r, s, u = !0) {
  const c = r ? r.vnode : null, { errorHandler: f, throwUnhandledErrorInProduction: p } = r && r.appContext.config || ft;
  if (r) {
    let h = r.parent;
    const g = r.proxy, R = `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; h; ) {
      const D = h.ec;
      if (D) {
        for (let L = 0; L < D.length; L++)
          if (D[L](n, g, R) === !1)
            return;
      }
      h = h.parent;
    }
    if (f) {
      Tr(), Li(f, null, 10, [
        n,
        g,
        R
      ]), Er();
      return;
    }
  }
  Vc(n, s, c, u, p);
}
function Vc(n, r, s, u = !0, c = !1) {
  if (c)
    throw n;
  console.error(n);
}
const un = [];
let qn = -1;
const Co = [];
let Ar = null, To = 0;
const cl = /* @__PURE__ */ Promise.resolve();
let es = null;
function ka(n) {
  const r = es || cl;
  return n ? r.then(this ? n.bind(this) : n) : r;
}
function Hc(n) {
  let r = qn + 1, s = un.length;
  for (; r < s; ) {
    const u = r + s >>> 1, c = un[u], f = Ci(c);
    f < n || f === n && c.flags & 2 ? r = u + 1 : s = u;
  }
  return r;
}
function ja(n) {
  if (!(n.flags & 1)) {
    const r = Ci(n), s = un[un.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(n.flags & 2) && r >= Ci(s) ? un.push(n) : un.splice(Hc(r), 0, n), n.flags |= 1, fl();
  }
}
function fl() {
  es || (es = cl.then(pl));
}
function Wc(n) {
  ke(n) ? Co.push(...n) : Ar && n.id === -1 ? Ar.splice(To + 1, 0, n) : n.flags & 1 || (Co.push(n), n.flags |= 1), fl();
}
function Ya(n, r, s = qn + 1) {
  for (; s < un.length; s++) {
    const u = un[s];
    if (u && u.flags & 2) {
      if (n && u.id !== n.uid)
        continue;
      un.splice(s, 1), s--, u.flags & 4 && (u.flags &= -2), u(), u.flags & 4 || (u.flags &= -2);
    }
  }
}
function dl(n) {
  if (Co.length) {
    const r = [...new Set(Co)].sort(
      (s, u) => Ci(s) - Ci(u)
    );
    if (Co.length = 0, Ar) {
      Ar.push(...r);
      return;
    }
    for (Ar = r, To = 0; To < Ar.length; To++) {
      const s = Ar[To];
      s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2;
    }
    Ar = null, To = 0;
  }
}
const Ci = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function pl(n) {
  try {
    for (qn = 0; qn < un.length; qn++) {
      const r = un[qn];
      r && !(r.flags & 8) && (r.flags & 4 && (r.flags &= -2), Li(
        r,
        r.i,
        r.i ? 15 : 14
      ), r.flags & 4 || (r.flags &= -2));
    }
  } finally {
    for (; qn < un.length; qn++) {
      const r = un[qn];
      r && (r.flags &= -2);
    }
    qn = -1, un.length = 0, dl(), es = null, (un.length || Co.length) && pl();
  }
}
let Lt = null, hl = null;
function ts(n) {
  const r = Lt;
  return Lt = n, hl = n && n.type.__scopeId || null, r;
}
function sa(n, r = Lt, s) {
  if (!r || n._n)
    return n;
  const u = (...c) => {
    u._d && au(-1);
    const f = ts(r);
    let p;
    try {
      p = n(...c);
    } finally {
      ts(f), u._d && au(1);
    }
    return p;
  };
  return u._n = !0, u._c = !0, u._d = !0, u;
}
function He(n, r) {
  if (Lt === null)
    return n;
  const s = ms(Lt), u = n.dirs || (n.dirs = []);
  for (let c = 0; c < r.length; c++) {
    let [f, p, h, g = ft] = r[c];
    f && (qe(f) && (f = {
      mounted: f,
      updated: f
    }), f.deep && wr(p), u.push({
      dir: f,
      instance: s,
      value: p,
      oldValue: void 0,
      arg: h,
      modifiers: g
    }));
  }
  return n;
}
function ho(n, r, s, u) {
  const c = n.dirs, f = r && r.dirs;
  for (let p = 0; p < c.length; p++) {
    const h = c[p];
    f && (h.oldValue = f[p].value);
    let g = h.dir[u];
    g && (Tr(), Wn(g, s, 8, [
      n.el,
      h,
      n,
      r
    ]), Er());
  }
}
const ml = Symbol("_vte"), Gc = (n) => n.__isTeleport, bi = (n) => n && (n.disabled || n.disabled === ""), Xa = (n) => n && (n.defer || n.defer === ""), za = (n) => typeof SVGElement < "u" && n instanceof SVGElement, Qa = (n) => typeof MathMLElement == "function" && n instanceof MathMLElement, aa = (n, r) => {
  const s = n && n.to;
  return At(s) ? r ? r(s) : null : s;
}, yl = {
  name: "Teleport",
  __isTeleport: !0,
  process(n, r, s, u, c, f, p, h, g, R) {
    const {
      mc: D,
      pc: L,
      pbc: B,
      o: { insert: ee, querySelector: ie, createText: ce, createComment: xe }
    } = R, le = bi(r.props);
    let { shapeFlag: U, children: Y, dynamicChildren: q } = r;
    if (n == null) {
      const M = r.el = ce(""), ne = r.anchor = ce("");
      ee(M, s, u), ee(ne, s, u);
      const we = ($, ze) => {
        U & 16 && (c && c.isCE && (c.ce._teleportTarget = $), D(
          Y,
          $,
          ze,
          c,
          f,
          p,
          h,
          g
        ));
      }, _e = () => {
        const $ = r.target = aa(r.props, ie), ze = vl($, r, ce, ee);
        $ && (p !== "svg" && za($) ? p = "svg" : p !== "mathml" && Qa($) && (p = "mathml"), le || (we($, ze), Hi(r, !1)));
      };
      le && (we(s, ne), Hi(r, !0)), Xa(r.props) ? (r.el.__isMounted = !1, an(() => {
        _e(), delete r.el.__isMounted;
      }, f)) : _e();
    } else {
      if (Xa(r.props) && n.el.__isMounted === !1) {
        an(() => {
          yl.process(
            n,
            r,
            s,
            u,
            c,
            f,
            p,
            h,
            g,
            R
          );
        }, f);
        return;
      }
      r.el = n.el, r.targetStart = n.targetStart;
      const M = r.anchor = n.anchor, ne = r.target = n.target, we = r.targetAnchor = n.targetAnchor, _e = bi(n.props), $ = _e ? s : ne, ze = _e ? M : we;
      if (p === "svg" || za(ne) ? p = "svg" : (p === "mathml" || Qa(ne)) && (p = "mathml"), q ? (B(
        n.dynamicChildren,
        q,
        $,
        c,
        f,
        p,
        h
      ), Ba(n, r, !0)) : g || L(
        n,
        r,
        $,
        ze,
        c,
        f,
        p,
        h,
        !1
      ), le)
        _e ? r.props && n.props && r.props.to !== n.props.to && (r.props.to = n.props.to) : $i(
          r,
          s,
          M,
          R,
          1
        );
      else if ((r.props && r.props.to) !== (n.props && n.props.to)) {
        const dt = r.target = aa(
          r.props,
          ie
        );
        dt && $i(
          r,
          dt,
          null,
          R,
          0
        );
      } else _e && $i(
        r,
        ne,
        we,
        R,
        1
      );
      Hi(r, le);
    }
  },
  remove(n, r, s, { um: u, o: { remove: c } }, f) {
    const {
      shapeFlag: p,
      children: h,
      anchor: g,
      targetStart: R,
      targetAnchor: D,
      target: L,
      props: B
    } = n;
    if (L && (c(R), c(D)), f && c(g), p & 16) {
      const ee = f || !bi(B);
      for (let ie = 0; ie < h.length; ie++) {
        const ce = h[ie];
        u(
          ce,
          r,
          s,
          ee,
          !!ce.dynamicChildren
        );
      }
    }
  },
  move: $i,
  hydrate: Yc
};
function $i(n, r, s, { o: { insert: u }, m: c }, f = 2) {
  f === 0 && u(n.targetAnchor, r, s);
  const { el: p, anchor: h, shapeFlag: g, children: R, props: D } = n, L = f === 2;
  if (L && u(p, r, s), (!L || bi(D)) && g & 16)
    for (let B = 0; B < R.length; B++)
      c(
        R[B],
        r,
        s,
        2
      );
  L && u(h, r, s);
}
function Yc(n, r, s, u, c, f, {
  o: { nextSibling: p, parentNode: h, querySelector: g, insert: R, createText: D }
}, L) {
  const B = r.target = aa(
    r.props,
    g
  );
  if (B) {
    const ee = bi(r.props), ie = B._lpa || B.firstChild;
    if (r.shapeFlag & 16)
      if (ee)
        r.anchor = L(
          p(n),
          r,
          h(n),
          s,
          u,
          c,
          f
        ), r.targetStart = ie, r.targetAnchor = ie && p(ie);
      else {
        r.anchor = p(n);
        let ce = ie;
        for (; ce; ) {
          if (ce && ce.nodeType === 8) {
            if (ce.data === "teleport start anchor")
              r.targetStart = ce;
            else if (ce.data === "teleport anchor") {
              r.targetAnchor = ce, B._lpa = r.targetAnchor && p(r.targetAnchor);
              break;
            }
          }
          ce = p(ce);
        }
        r.targetAnchor || vl(B, r, D, R), L(
          ie && p(ie),
          r,
          B,
          s,
          u,
          c,
          f
        );
      }
    Hi(r, ee);
  }
  return r.anchor && p(r.anchor);
}
const fs = yl;
function Hi(n, r) {
  const s = n.ctx;
  if (s && s.ut) {
    let u, c;
    for (r ? (u = n.el, c = n.anchor) : (u = n.targetStart, c = n.targetAnchor); u && u !== c; )
      u.nodeType === 1 && u.setAttribute("data-v-owner", s.uid), u = u.nextSibling;
    s.ut();
  }
}
function vl(n, r, s, u) {
  const c = r.targetStart = s(""), f = r.targetAnchor = s("");
  return c[ml] = f, n && (u(c, n), u(f, n)), f;
}
function La(n, r) {
  n.shapeFlag & 6 && n.component ? (n.transition = r, La(n.component.subTree, r)) : n.shapeFlag & 128 ? (n.ssContent.transition = r.clone(n.ssContent), n.ssFallback.transition = r.clone(n.ssFallback)) : n.transition = r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Kt(n, r) {
  return qe(n) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    zt({ name: n.name }, r, { setup: n })
  ) : n;
}
function gl(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0];
}
function bl(n) {
  const r = Wf(), s = Vi(null);
  if (r) {
    const c = r.refs === ft ? r.refs = {} : r.refs;
    Object.defineProperty(c, n, {
      enumerable: !0,
      get: () => s.value,
      set: (f) => s.value = f
    });
  }
  return s;
}
function wi(n, r, s, u, c = !1) {
  if (ke(n)) {
    n.forEach(
      (ie, ce) => wi(
        ie,
        r && (ke(r) ? r[ce] : r),
        s,
        u,
        c
      )
    );
    return;
  }
  if (So(u) && !c) {
    u.shapeFlag & 512 && u.type.__asyncResolved && u.component.subTree.component && wi(n, r, s, u.component.subTree);
    return;
  }
  const f = u.shapeFlag & 4 ? ms(u.component) : u.el, p = c ? null : f, { i: h, r: g } = n, R = r && r.r, D = h.refs === ft ? h.refs = {} : h.refs, L = h.setupState, B = et(L), ee = L === ft ? () => !1 : (ie) => at(B, ie);
  if (R != null && R !== g && (At(R) ? (D[R] = null, ee(R) && (L[R] = null)) : xt(R) && (R.value = null)), qe(g))
    Li(g, h, 12, [p, D]);
  else {
    const ie = At(g), ce = xt(g);
    if (ie || ce) {
      const xe = () => {
        if (n.f) {
          const le = ie ? ee(g) ? L[g] : D[g] : g.value;
          c ? ke(le) && Oa(le, f) : ke(le) ? le.includes(f) || le.push(f) : ie ? (D[g] = [f], ee(g) && (L[g] = D[g])) : (g.value = [f], n.k && (D[n.k] = g.value));
        } else ie ? (D[g] = p, ee(g) && (L[g] = p)) : ce && (g.value = p, n.k && (D[n.k] = p));
      };
      p ? (xe.id = -1, an(xe, s)) : xe();
    }
  }
}
as().requestIdleCallback;
as().cancelIdleCallback;
const So = (n) => !!n.type.__asyncLoader, wl = (n) => n.type.__isKeepAlive;
function Xc(n, r) {
  _l(n, "a", r);
}
function zc(n, r) {
  _l(n, "da", r);
}
function _l(n, r, s = Wt) {
  const u = n.__wdc || (n.__wdc = () => {
    let c = s;
    for (; c; ) {
      if (c.isDeactivated)
        return;
      c = c.parent;
    }
    return n();
  });
  if (ds(r, u, s), s) {
    let c = s.parent;
    for (; c && c.parent; )
      wl(c.parent.vnode) && Qc(u, r, s, c), c = c.parent;
  }
}
function Qc(n, r, s, u) {
  const c = ds(
    r,
    n,
    u,
    !0
    /* prepend */
  );
  Ka(() => {
    Oa(u[r], c);
  }, s);
}
function ds(n, r, s = Wt, u = !1) {
  if (s) {
    const c = s[n] || (s[n] = []), f = r.__weh || (r.__weh = (...p) => {
      Tr();
      const h = Ki(s), g = Wn(r, s, n, p);
      return h(), Er(), g;
    });
    return u ? c.unshift(f) : c.push(f), f;
  }
}
const Cr = (n) => (r, s = Wt) => {
  (!Ai || n === "sp") && ds(n, (...u) => r(...u), s);
}, Jc = Cr("bm"), xl = Cr("m"), Zc = Cr(
  "bu"
), ef = Cr("u"), tf = Cr(
  "bum"
), Ka = Cr("um"), nf = Cr(
  "sp"
), rf = Cr("rtg"), of = Cr("rtc");
function sf(n, r = Wt) {
  ds("ec", n, r);
}
const af = Symbol.for("v-ndc");
function Ct(n, r, s, u) {
  let c;
  const f = s, p = ke(n);
  if (p || At(n)) {
    const h = p && xr(n);
    let g = !1, R = !1;
    h && (g = !Nn(n), R = Ir(n), n = us(n)), c = new Array(n.length);
    for (let D = 0, L = n.length; D < L; D++)
      c[D] = r(
        g ? R ? Ji(Vt(n[D])) : Vt(n[D]) : n[D],
        D,
        void 0,
        f
      );
  } else if (typeof n == "number") {
    c = new Array(n);
    for (let h = 0; h < n; h++)
      c[h] = r(h + 1, h, void 0, f);
  } else if (gt(n))
    if (n[Symbol.iterator])
      c = Array.from(
        n,
        (h, g) => r(h, g, void 0, f)
      );
    else {
      const h = Object.keys(n);
      c = new Array(h.length);
      for (let g = 0, R = h.length; g < R; g++) {
        const D = h[g];
        c[g] = r(n[D], D, g, f);
      }
    }
  else
    c = [];
  return c;
}
function Ja(n, r, s = {}, u, c) {
  if (Lt.ce || Lt.parent && So(Lt.parent) && Lt.parent.ce)
    return r !== "default" && (s.name = r), fe(), pn(
      Xe,
      null,
      [St("slot", s, u)],
      64
    );
  let f = n[r];
  f && f._c && (f._d = !1), fe();
  const p = f && Ol(f(s)), h = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  p && p.key, g = pn(
    Xe,
    {
      key: (h && !Fn(h) ? h : `_${r}`) + // #7256 force differentiate fallback content from actual content
      (!p && u ? "_fb" : "")
    },
    p || [],
    p && n._ === 1 ? 64 : -2
  );
  return f && f._c && (f._d = !0), g;
}
function Ol(n) {
  return n.some((r) => qa(r) ? !(r.type === Nr || r.type === Xe && !Ol(r.children)) : !0) ? n : null;
}
const ua = (n) => n ? ql(n) ? ms(n) : ua(n.parent) : null, _i = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ zt(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => ua(n.parent),
    $root: (n) => ua(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => El(n),
    $forceUpdate: (n) => n.f || (n.f = () => {
      ja(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = ka.bind(n.proxy)),
    $watch: (n) => Df.bind(n)
  })
), Ys = (n, r) => n !== ft && !n.__isScriptSetup && at(n, r), uf = {
  get({ _: n }, r) {
    if (r === "__v_skip")
      return !0;
    const { ctx: s, setupState: u, data: c, props: f, accessCache: p, type: h, appContext: g } = n;
    let R;
    if (r[0] !== "$") {
      const ee = p[r];
      if (ee !== void 0)
        switch (ee) {
          case 1:
            return u[r];
          case 2:
            return c[r];
          case 4:
            return s[r];
          case 3:
            return f[r];
        }
      else {
        if (Ys(u, r))
          return p[r] = 1, u[r];
        if (c !== ft && at(c, r))
          return p[r] = 2, c[r];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (R = n.propsOptions[0]) && at(R, r)
        )
          return p[r] = 3, f[r];
        if (s !== ft && at(s, r))
          return p[r] = 4, s[r];
        la && (p[r] = 0);
      }
    }
    const D = _i[r];
    let L, B;
    if (D)
      return r === "$attrs" && Xt(n.attrs, "get", ""), D(n);
    if (
      // css module (injected by vue-loader)
      (L = h.__cssModules) && (L = L[r])
    )
      return L;
    if (s !== ft && at(s, r))
      return p[r] = 4, s[r];
    if (
      // global properties
      B = g.config.globalProperties, at(B, r)
    )
      return B[r];
  },
  set({ _: n }, r, s) {
    const { data: u, setupState: c, ctx: f } = n;
    return Ys(c, r) ? (c[r] = s, !0) : u !== ft && at(u, r) ? (u[r] = s, !0) : at(n.props, r) || r[0] === "$" && r.slice(1) in n ? !1 : (f[r] = s, !0);
  },
  has({
    _: { data: n, setupState: r, accessCache: s, ctx: u, appContext: c, propsOptions: f }
  }, p) {
    let h;
    return !!s[p] || n !== ft && at(n, p) || Ys(r, p) || (h = f[0]) && at(h, p) || at(u, p) || at(_i, p) || at(c.config.globalProperties, p);
  },
  defineProperty(n, r, s) {
    return s.get != null ? n._.accessCache[r] = 0 : at(s, "value") && this.set(n, r, s.value, null), Reflect.defineProperty(n, r, s);
  }
};
function Za(n) {
  return ke(n) ? n.reduce(
    (r, s) => (r[s] = null, r),
    {}
  ) : n;
}
let la = !0;
function lf(n) {
  const r = El(n), s = n.proxy, u = n.ctx;
  la = !1, r.beforeCreate && eu(r.beforeCreate, n, "bc");
  const {
    // state
    data: c,
    computed: f,
    methods: p,
    watch: h,
    provide: g,
    inject: R,
    // lifecycle
    created: D,
    beforeMount: L,
    mounted: B,
    beforeUpdate: ee,
    updated: ie,
    activated: ce,
    deactivated: xe,
    beforeDestroy: le,
    beforeUnmount: U,
    destroyed: Y,
    unmounted: q,
    render: M,
    renderTracked: ne,
    renderTriggered: we,
    errorCaptured: _e,
    serverPrefetch: $,
    // public API
    expose: ze,
    inheritAttrs: dt,
    // assets
    components: Me,
    directives: st,
    filters: Tn
  } = r;
  if (R && cf(R, u, null), p)
    for (const Ne in p) {
      const Fe = p[Ne];
      qe(Fe) && (u[Ne] = Fe.bind(s));
    }
  if (c) {
    const Ne = c.call(s, s);
    gt(Ne) && (n.data = ls(Ne));
  }
  if (la = !0, f)
    for (const Ne in f) {
      const Fe = f[Ne], bt = qe(Fe) ? Fe.bind(s, s) : qe(Fe.get) ? Fe.get.bind(s, s) : Hn, ct = !qe(Fe) && qe(Fe.set) ? Fe.set.bind(s) : Hn, _t = tt({
        get: bt,
        set: ct
      });
      Object.defineProperty(u, Ne, {
        enumerable: !0,
        configurable: !0,
        get: () => _t.value,
        set: (kt) => _t.value = kt
      });
    }
  if (h)
    for (const Ne in h)
      Tl(h[Ne], u, s, Ne);
  if (g) {
    const Ne = qe(g) ? g.call(s) : g;
    Reflect.ownKeys(Ne).forEach((Fe) => {
      yf(Fe, Ne[Fe]);
    });
  }
  D && eu(D, n, "c");
  function nt(Ne, Fe) {
    ke(Fe) ? Fe.forEach((bt) => Ne(bt.bind(s))) : Fe && Ne(Fe.bind(s));
  }
  if (nt(Jc, L), nt(xl, B), nt(Zc, ee), nt(ef, ie), nt(Xc, ce), nt(zc, xe), nt(sf, _e), nt(of, ne), nt(rf, we), nt(tf, U), nt(Ka, q), nt(nf, $), ke(ze))
    if (ze.length) {
      const Ne = n.exposed || (n.exposed = {});
      ze.forEach((Fe) => {
        Object.defineProperty(Ne, Fe, {
          get: () => s[Fe],
          set: (bt) => s[Fe] = bt
        });
      });
    } else n.exposed || (n.exposed = {});
  M && n.render === Hn && (n.render = M), dt != null && (n.inheritAttrs = dt), Me && (n.components = Me), st && (n.directives = st), $ && gl(n);
}
function cf(n, r, s = Hn) {
  ke(n) && (n = ca(n));
  for (const u in n) {
    const c = n[u];
    let f;
    gt(c) ? "default" in c ? f = xi(
      c.from || u,
      c.default,
      !0
    ) : f = xi(c.from || u) : f = xi(c), xt(f) ? Object.defineProperty(r, u, {
      enumerable: !0,
      configurable: !0,
      get: () => f.value,
      set: (p) => f.value = p
    }) : r[u] = f;
  }
}
function eu(n, r, s) {
  Wn(
    ke(n) ? n.map((u) => u.bind(r.proxy)) : n.bind(r.proxy),
    r,
    s
  );
}
function Tl(n, r, s, u) {
  let c = u.includes(".") ? Ll(s, u) : () => s[u];
  if (At(n)) {
    const f = r[n];
    qe(f) && Ht(c, f);
  } else if (qe(n))
    Ht(c, n.bind(s));
  else if (gt(n))
    if (ke(n))
      n.forEach((f) => Tl(f, r, s, u));
    else {
      const f = qe(n.handler) ? n.handler.bind(s) : r[n.handler];
      qe(f) && Ht(c, f, n);
    }
}
function El(n) {
  const r = n.type, { mixins: s, extends: u } = r, {
    mixins: c,
    optionsCache: f,
    config: { optionMergeStrategies: p }
  } = n.appContext, h = f.get(r);
  let g;
  return h ? g = h : !c.length && !s && !u ? g = r : (g = {}, c.length && c.forEach(
    (R) => ns(g, R, p, !0)
  ), ns(g, r, p)), gt(r) && f.set(r, g), g;
}
function ns(n, r, s, u = !1) {
  const { mixins: c, extends: f } = r;
  f && ns(n, f, s, !0), c && c.forEach(
    (p) => ns(n, p, s, !0)
  );
  for (const p in r)
    if (!(u && p === "expose")) {
      const h = ff[p] || s && s[p];
      n[p] = h ? h(n[p], r[p]) : r[p];
    }
  return n;
}
const ff = {
  data: tu,
  props: nu,
  emits: nu,
  // objects
  methods: hi,
  computed: hi,
  // lifecycle
  beforeCreate: sn,
  created: sn,
  beforeMount: sn,
  mounted: sn,
  beforeUpdate: sn,
  updated: sn,
  beforeDestroy: sn,
  beforeUnmount: sn,
  destroyed: sn,
  unmounted: sn,
  activated: sn,
  deactivated: sn,
  errorCaptured: sn,
  serverPrefetch: sn,
  // assets
  components: hi,
  directives: hi,
  // watch
  watch: pf,
  // provide / inject
  provide: tu,
  inject: df
};
function tu(n, r) {
  return r ? n ? function() {
    return zt(
      qe(n) ? n.call(this, this) : n,
      qe(r) ? r.call(this, this) : r
    );
  } : r : n;
}
function df(n, r) {
  return hi(ca(n), ca(r));
}
function ca(n) {
  if (ke(n)) {
    const r = {};
    for (let s = 0; s < n.length; s++)
      r[n[s]] = n[s];
    return r;
  }
  return n;
}
function sn(n, r) {
  return n ? [...new Set([].concat(n, r))] : r;
}
function hi(n, r) {
  return n ? zt(/* @__PURE__ */ Object.create(null), n, r) : r;
}
function nu(n, r) {
  return n ? ke(n) && ke(r) ? [.../* @__PURE__ */ new Set([...n, ...r])] : zt(
    /* @__PURE__ */ Object.create(null),
    Za(n),
    Za(r ?? {})
  ) : r;
}
function pf(n, r) {
  if (!n) return r;
  if (!r) return n;
  const s = zt(/* @__PURE__ */ Object.create(null), n);
  for (const u in r)
    s[u] = sn(n[u], r[u]);
  return s;
}
function Nl() {
  return {
    app: null,
    config: {
      isNativeTag: tc,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let hf = 0;
function mf(n, r) {
  return function(u, c = null) {
    qe(u) || (u = zt({}, u)), c != null && !gt(c) && (c = null);
    const f = Nl(), p = /* @__PURE__ */ new WeakSet(), h = [];
    let g = !1;
    const R = f.app = {
      _uid: hf++,
      _component: u,
      _props: c,
      _container: null,
      _context: f,
      _instance: null,
      version: Jf,
      get config() {
        return f.config;
      },
      set config(D) {
      },
      use(D, ...L) {
        return p.has(D) || (D && qe(D.install) ? (p.add(D), D.install(R, ...L)) : qe(D) && (p.add(D), D(R, ...L))), R;
      },
      mixin(D) {
        return f.mixins.includes(D) || f.mixins.push(D), R;
      },
      component(D, L) {
        return L ? (f.components[D] = L, R) : f.components[D];
      },
      directive(D, L) {
        return L ? (f.directives[D] = L, R) : f.directives[D];
      },
      mount(D, L, B) {
        if (!g) {
          const ee = R._ceVNode || St(u, c);
          return ee.appContext = f, B === !0 ? B = "svg" : B === !1 && (B = void 0), n(ee, D, B), g = !0, R._container = D, D.__vue_app__ = R, ms(ee.component);
        }
      },
      onUnmount(D) {
        h.push(D);
      },
      unmount() {
        g && (Wn(
          h,
          R._instance,
          16
        ), n(null, R._container), delete R._container.__vue_app__);
      },
      provide(D, L) {
        return f.provides[D] = L, R;
      },
      runWithContext(D) {
        const L = go;
        go = R;
        try {
          return D();
        } finally {
          go = L;
        }
      }
    };
    return R;
  };
}
let go = null;
function yf(n, r) {
  if (Wt) {
    let s = Wt.provides;
    const u = Wt.parent && Wt.parent.provides;
    u === s && (s = Wt.provides = Object.create(u)), s[n] = r;
  }
}
function xi(n, r, s = !1) {
  const u = Wt || Lt;
  if (u || go) {
    let c = go ? go._context.provides : u ? u.parent == null || u.ce ? u.vnode.appContext && u.vnode.appContext.provides : u.parent.provides : void 0;
    if (c && n in c)
      return c[n];
    if (arguments.length > 1)
      return s && qe(r) ? r.call(u && u.proxy) : r;
  }
}
function vf() {
  return !!(Wt || Lt || go);
}
const Cl = {}, Sl = () => Object.create(Cl), Al = (n) => Object.getPrototypeOf(n) === Cl;
function gf(n, r, s, u = !1) {
  const c = {}, f = Sl();
  n.propsDefaults = /* @__PURE__ */ Object.create(null), Pl(n, r, c, f);
  for (const p in n.propsOptions[0])
    p in c || (c[p] = void 0);
  s ? n.props = u ? c : Ic(c) : n.type.props ? n.props = c : n.props = f, n.attrs = f;
}
function bf(n, r, s, u) {
  const {
    props: c,
    attrs: f,
    vnode: { patchFlag: p }
  } = n, h = et(c), [g] = n.propsOptions;
  let R = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (u || p > 0) && !(p & 16)
  ) {
    if (p & 8) {
      const D = n.vnode.dynamicProps;
      for (let L = 0; L < D.length; L++) {
        let B = D[L];
        if (ps(n.emitsOptions, B))
          continue;
        const ee = r[B];
        if (g)
          if (at(f, B))
            ee !== f[B] && (f[B] = ee, R = !0);
          else {
            const ie = Rr(B);
            c[ie] = fa(
              g,
              h,
              ie,
              ee,
              n,
              !1
            );
          }
        else
          ee !== f[B] && (f[B] = ee, R = !0);
      }
    }
  } else {
    Pl(n, r, c, f) && (R = !0);
    let D;
    for (const L in h)
      (!r || // for camelCase
      !at(r, L) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((D = _o(L)) === L || !at(r, D))) && (g ? s && // for camelCase
      (s[L] !== void 0 || // for kebab-case
      s[D] !== void 0) && (c[L] = fa(
        g,
        h,
        L,
        void 0,
        n,
        !0
      )) : delete c[L]);
    if (f !== h)
      for (const L in f)
        (!r || !at(r, L)) && (delete f[L], R = !0);
  }
  R && br(n.attrs, "set", "");
}
function Pl(n, r, s, u) {
  const [c, f] = n.propsOptions;
  let p = !1, h;
  if (r)
    for (let g in r) {
      if (yi(g))
        continue;
      const R = r[g];
      let D;
      c && at(c, D = Rr(g)) ? !f || !f.includes(D) ? s[D] = R : (h || (h = {}))[D] = R : ps(n.emitsOptions, g) || (!(g in u) || R !== u[g]) && (u[g] = R, p = !0);
    }
  if (f) {
    const g = et(s), R = h || ft;
    for (let D = 0; D < f.length; D++) {
      const L = f[D];
      s[L] = fa(
        c,
        g,
        L,
        R[L],
        n,
        !at(R, L)
      );
    }
  }
  return p;
}
function fa(n, r, s, u, c, f) {
  const p = n[s];
  if (p != null) {
    const h = at(p, "default");
    if (h && u === void 0) {
      const g = p.default;
      if (p.type !== Function && !p.skipFactory && qe(g)) {
        const { propsDefaults: R } = c;
        if (s in R)
          u = R[s];
        else {
          const D = Ki(c);
          u = R[s] = g.call(
            null,
            r
          ), D();
        }
      } else
        u = g;
      c.ce && c.ce._setProp(s, u);
    }
    p[
      0
      /* shouldCast */
    ] && (f && !h ? u = !1 : p[
      1
      /* shouldCastTrue */
    ] && (u === "" || u === _o(s)) && (u = !0));
  }
  return u;
}
const wf = /* @__PURE__ */ new WeakMap();
function Dl(n, r, s = !1) {
  const u = s ? wf : r.propsCache, c = u.get(n);
  if (c)
    return c;
  const f = n.props, p = {}, h = [];
  let g = !1;
  if (!qe(n)) {
    const D = (L) => {
      g = !0;
      const [B, ee] = Dl(L, r, !0);
      zt(p, B), ee && h.push(...ee);
    };
    !s && r.mixins.length && r.mixins.forEach(D), n.extends && D(n.extends), n.mixins && n.mixins.forEach(D);
  }
  if (!f && !g)
    return gt(n) && u.set(n, Eo), Eo;
  if (ke(f))
    for (let D = 0; D < f.length; D++) {
      const L = Rr(f[D]);
      ru(L) && (p[L] = ft);
    }
  else if (f)
    for (const D in f) {
      const L = Rr(D);
      if (ru(L)) {
        const B = f[D], ee = p[L] = ke(B) || qe(B) ? { type: B } : zt({}, B), ie = ee.type;
        let ce = !1, xe = !0;
        if (ke(ie))
          for (let le = 0; le < ie.length; ++le) {
            const U = ie[le], Y = qe(U) && U.name;
            if (Y === "Boolean") {
              ce = !0;
              break;
            } else Y === "String" && (xe = !1);
          }
        else
          ce = qe(ie) && ie.name === "Boolean";
        ee[
          0
          /* shouldCast */
        ] = ce, ee[
          1
          /* shouldCastTrue */
        ] = xe, (ce || at(ee, "default")) && h.push(L);
      }
    }
  const R = [p, h];
  return gt(n) && u.set(n, R), R;
}
function ru(n) {
  return n[0] !== "$" && !yi(n);
}
const Fa = (n) => n[0] === "_" || n === "$stable", Ma = (n) => ke(n) ? n.map(Un) : [Un(n)], _f = (n, r, s) => {
  if (r._n)
    return r;
  const u = sa((...c) => Ma(r(...c)), s);
  return u._c = !1, u;
}, Rl = (n, r, s) => {
  const u = n._ctx;
  for (const c in n) {
    if (Fa(c)) continue;
    const f = n[c];
    if (qe(f))
      r[c] = _f(c, f, u);
    else if (f != null) {
      const p = Ma(f);
      r[c] = () => p;
    }
  }
}, Il = (n, r) => {
  const s = Ma(r);
  n.slots.default = () => s;
}, kl = (n, r, s) => {
  for (const u in r)
    (s || !Fa(u)) && (n[u] = r[u]);
}, xf = (n, r, s) => {
  const u = n.slots = Sl();
  if (n.vnode.shapeFlag & 32) {
    const c = r.__;
    c && na(u, "__", c, !0);
    const f = r._;
    f ? (kl(u, r, s), s && na(u, "_", f, !0)) : Rl(r, u);
  } else r && Il(n, r);
}, Of = (n, r, s) => {
  const { vnode: u, slots: c } = n;
  let f = !0, p = ft;
  if (u.shapeFlag & 32) {
    const h = r._;
    h ? s && h === 1 ? f = !1 : kl(c, r, s) : (f = !r.$stable, Rl(r, c)), p = r;
  } else r && (Il(n, r), p = { default: 1 });
  if (f)
    for (const h in c)
      !Fa(h) && p[h] == null && delete c[h];
}, an = Ff;
function Tf(n) {
  return Ef(n);
}
function Ef(n, r) {
  const s = as();
  s.__VUE__ = !0;
  const {
    insert: u,
    remove: c,
    patchProp: f,
    createElement: p,
    createText: h,
    createComment: g,
    setText: R,
    setElementText: D,
    parentNode: L,
    nextSibling: B,
    setScopeId: ee = Hn,
    insertStaticContent: ie
  } = n, ce = (S, F, te, oe = null, ue = null, se = null, me = void 0, ge = null, de = !!F.dynamicChildren) => {
    if (S === F)
      return;
    S && !pi(S, F) && (oe = A(S), kt(S, ue, se, !0), S = null), F.patchFlag === -2 && (de = !1, F.dynamicChildren = null);
    const { type: ae, ref: Se, shapeFlag: be } = F;
    switch (ae) {
      case hs:
        xe(S, F, te, oe);
        break;
      case Nr:
        le(S, F, te, oe);
        break;
      case zs:
        S == null && U(F, te, oe, me);
        break;
      case Xe:
        Me(
          S,
          F,
          te,
          oe,
          ue,
          se,
          me,
          ge,
          de
        );
        break;
      default:
        be & 1 ? M(
          S,
          F,
          te,
          oe,
          ue,
          se,
          me,
          ge,
          de
        ) : be & 6 ? st(
          S,
          F,
          te,
          oe,
          ue,
          se,
          me,
          ge,
          de
        ) : (be & 64 || be & 128) && ae.process(
          S,
          F,
          te,
          oe,
          ue,
          se,
          me,
          ge,
          de,
          W
        );
    }
    Se != null && ue ? wi(Se, S && S.ref, se, F || S, !F) : Se == null && S && S.ref != null && wi(S.ref, null, se, S, !0);
  }, xe = (S, F, te, oe) => {
    if (S == null)
      u(
        F.el = h(F.children),
        te,
        oe
      );
    else {
      const ue = F.el = S.el;
      F.children !== S.children && R(ue, F.children);
    }
  }, le = (S, F, te, oe) => {
    S == null ? u(
      F.el = g(F.children || ""),
      te,
      oe
    ) : F.el = S.el;
  }, U = (S, F, te, oe) => {
    [S.el, S.anchor] = ie(
      S.children,
      F,
      te,
      oe,
      S.el,
      S.anchor
    );
  }, Y = ({ el: S, anchor: F }, te, oe) => {
    let ue;
    for (; S && S !== F; )
      ue = B(S), u(S, te, oe), S = ue;
    u(F, te, oe);
  }, q = ({ el: S, anchor: F }) => {
    let te;
    for (; S && S !== F; )
      te = B(S), c(S), S = te;
    c(F);
  }, M = (S, F, te, oe, ue, se, me, ge, de) => {
    F.type === "svg" ? me = "svg" : F.type === "math" && (me = "mathml"), S == null ? ne(
      F,
      te,
      oe,
      ue,
      se,
      me,
      ge,
      de
    ) : $(
      S,
      F,
      ue,
      se,
      me,
      ge,
      de
    );
  }, ne = (S, F, te, oe, ue, se, me, ge) => {
    let de, ae;
    const { props: Se, shapeFlag: be, transition: Ae, dirs: Pe } = S;
    if (de = S.el = p(
      S.type,
      se,
      Se && Se.is,
      Se
    ), be & 8 ? D(de, S.children) : be & 16 && _e(
      S.children,
      de,
      null,
      oe,
      ue,
      Xs(S, se),
      me,
      ge
    ), Pe && ho(S, null, oe, "created"), we(de, S, S.scopeId, me, oe), Se) {
      for (const Ue in Se)
        Ue !== "value" && !yi(Ue) && f(de, Ue, null, Se[Ue], se, oe);
      "value" in Se && f(de, "value", null, Se.value, se), (ae = Se.onVnodeBeforeMount) && $n(ae, oe, S);
    }
    Pe && ho(S, null, oe, "beforeMount");
    const je = Nf(ue, Ae);
    je && Ae.beforeEnter(de), u(de, F, te), ((ae = Se && Se.onVnodeMounted) || je || Pe) && an(() => {
      ae && $n(ae, oe, S), je && Ae.enter(de), Pe && ho(S, null, oe, "mounted");
    }, ue);
  }, we = (S, F, te, oe, ue) => {
    if (te && ee(S, te), oe)
      for (let se = 0; se < oe.length; se++)
        ee(S, oe[se]);
    if (ue) {
      let se = ue.subTree;
      if (F === se || Fl(se.type) && (se.ssContent === F || se.ssFallback === F)) {
        const me = ue.vnode;
        we(
          S,
          me,
          me.scopeId,
          me.slotScopeIds,
          ue.parent
        );
      }
    }
  }, _e = (S, F, te, oe, ue, se, me, ge, de = 0) => {
    for (let ae = de; ae < S.length; ae++) {
      const Se = S[ae] = ge ? Pr(S[ae]) : Un(S[ae]);
      ce(
        null,
        Se,
        F,
        te,
        oe,
        ue,
        se,
        me,
        ge
      );
    }
  }, $ = (S, F, te, oe, ue, se, me) => {
    const ge = F.el = S.el;
    let { patchFlag: de, dynamicChildren: ae, dirs: Se } = F;
    de |= S.patchFlag & 16;
    const be = S.props || ft, Ae = F.props || ft;
    let Pe;
    if (te && mo(te, !1), (Pe = Ae.onVnodeBeforeUpdate) && $n(Pe, te, F, S), Se && ho(F, S, te, "beforeUpdate"), te && mo(te, !0), (be.innerHTML && Ae.innerHTML == null || be.textContent && Ae.textContent == null) && D(ge, ""), ae ? ze(
      S.dynamicChildren,
      ae,
      ge,
      te,
      oe,
      Xs(F, ue),
      se
    ) : me || Fe(
      S,
      F,
      ge,
      null,
      te,
      oe,
      Xs(F, ue),
      se,
      !1
    ), de > 0) {
      if (de & 16)
        dt(ge, be, Ae, te, ue);
      else if (de & 2 && be.class !== Ae.class && f(ge, "class", null, Ae.class, ue), de & 4 && f(ge, "style", be.style, Ae.style, ue), de & 8) {
        const je = F.dynamicProps;
        for (let Ue = 0; Ue < je.length; Ue++) {
          const We = je[Ue], ht = be[We], Ot = Ae[We];
          (Ot !== ht || We === "value") && f(ge, We, ht, Ot, ue, te);
        }
      }
      de & 1 && S.children !== F.children && D(ge, F.children);
    } else !me && ae == null && dt(ge, be, Ae, te, ue);
    ((Pe = Ae.onVnodeUpdated) || Se) && an(() => {
      Pe && $n(Pe, te, F, S), Se && ho(F, S, te, "updated");
    }, oe);
  }, ze = (S, F, te, oe, ue, se, me) => {
    for (let ge = 0; ge < F.length; ge++) {
      const de = S[ge], ae = F[ge], Se = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        de.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (de.type === Xe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !pi(de, ae) || // - In the case of a component, it could contain anything.
        de.shapeFlag & 198) ? L(de.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          te
        )
      );
      ce(
        de,
        ae,
        Se,
        null,
        oe,
        ue,
        se,
        me,
        !0
      );
    }
  }, dt = (S, F, te, oe, ue) => {
    if (F !== te) {
      if (F !== ft)
        for (const se in F)
          !yi(se) && !(se in te) && f(
            S,
            se,
            F[se],
            null,
            ue,
            oe
          );
      for (const se in te) {
        if (yi(se)) continue;
        const me = te[se], ge = F[se];
        me !== ge && se !== "value" && f(S, se, ge, me, ue, oe);
      }
      "value" in te && f(S, "value", F.value, te.value, ue);
    }
  }, Me = (S, F, te, oe, ue, se, me, ge, de) => {
    const ae = F.el = S ? S.el : h(""), Se = F.anchor = S ? S.anchor : h("");
    let { patchFlag: be, dynamicChildren: Ae, slotScopeIds: Pe } = F;
    Pe && (ge = ge ? ge.concat(Pe) : Pe), S == null ? (u(ae, te, oe), u(Se, te, oe), _e(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      F.children || [],
      te,
      Se,
      ue,
      se,
      me,
      ge,
      de
    )) : be > 0 && be & 64 && Ae && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    S.dynamicChildren ? (ze(
      S.dynamicChildren,
      Ae,
      te,
      ue,
      se,
      me,
      ge
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (F.key != null || ue && F === ue.subTree) && Ba(
      S,
      F,
      !0
      /* shallow */
    )) : Fe(
      S,
      F,
      te,
      Se,
      ue,
      se,
      me,
      ge,
      de
    );
  }, st = (S, F, te, oe, ue, se, me, ge, de) => {
    F.slotScopeIds = ge, S == null ? F.shapeFlag & 512 ? ue.ctx.activate(
      F,
      te,
      oe,
      me,
      de
    ) : Tn(
      F,
      te,
      oe,
      ue,
      se,
      me,
      de
    ) : It(S, F, de);
  }, Tn = (S, F, te, oe, ue, se, me) => {
    const ge = S.component = Hf(
      S,
      oe,
      ue
    );
    if (wl(S) && (ge.ctx.renderer = W), Gf(ge, !1, me), ge.asyncDep) {
      if (ue && ue.registerDep(ge, nt, me), !S.el) {
        const de = ge.subTree = St(Nr);
        le(null, de, F, te);
      }
    } else
      nt(
        ge,
        S,
        F,
        te,
        ue,
        se,
        me
      );
  }, It = (S, F, te) => {
    const oe = F.component = S.component;
    if (Lf(S, F, te))
      if (oe.asyncDep && !oe.asyncResolved) {
        Ne(oe, F, te);
        return;
      } else
        oe.next = F, oe.update();
    else
      F.el = S.el, oe.vnode = F;
  }, nt = (S, F, te, oe, ue, se, me) => {
    const ge = () => {
      if (S.isMounted) {
        let { next: be, bu: Ae, u: Pe, parent: je, vnode: Ue } = S;
        {
          const mt = jl(S);
          if (mt) {
            be && (be.el = Ue.el, Ne(S, be, me)), mt.asyncDep.then(() => {
              S.isUnmounted || ge();
            });
            return;
          }
        }
        let We = be, ht;
        mo(S, !1), be ? (be.el = Ue.el, Ne(S, be, me)) : be = Ue, Ae && Ui(Ae), (ht = be.props && be.props.onVnodeBeforeUpdate) && $n(ht, je, be, Ue), mo(S, !0);
        const Ot = iu(S), Pt = S.subTree;
        S.subTree = Ot, ce(
          Pt,
          Ot,
          // parent may have changed if it's in a teleport
          L(Pt.el),
          // anchor may have changed if it's in a fragment
          A(Pt),
          S,
          ue,
          se
        ), be.el = Ot.el, We === null && Kf(S, Ot.el), Pe && an(Pe, ue), (ht = be.props && be.props.onVnodeUpdated) && an(
          () => $n(ht, je, be, Ue),
          ue
        );
      } else {
        let be;
        const { el: Ae, props: Pe } = F, { bm: je, m: Ue, parent: We, root: ht, type: Ot } = S, Pt = So(F);
        mo(S, !1), je && Ui(je), !Pt && (be = Pe && Pe.onVnodeBeforeMount) && $n(be, We, F), mo(S, !0);
        {
          ht.ce && // @ts-expect-error _def is private
          ht.ce._def.shadowRoot !== !1 && ht.ce._injectChildStyle(Ot);
          const mt = S.subTree = iu(S);
          ce(
            null,
            mt,
            te,
            oe,
            S,
            ue,
            se
          ), F.el = mt.el;
        }
        if (Ue && an(Ue, ue), !Pt && (be = Pe && Pe.onVnodeMounted)) {
          const mt = F;
          an(
            () => $n(be, We, mt),
            ue
          );
        }
        (F.shapeFlag & 256 || We && So(We.vnode) && We.vnode.shapeFlag & 256) && S.a && an(S.a, ue), S.isMounted = !0, F = te = oe = null;
      }
    };
    S.scope.on();
    const de = S.effect = new Wu(ge);
    S.scope.off();
    const ae = S.update = de.run.bind(de), Se = S.job = de.runIfDirty.bind(de);
    Se.i = S, Se.id = S.uid, de.scheduler = () => ja(Se), mo(S, !0), ae();
  }, Ne = (S, F, te) => {
    F.component = S;
    const oe = S.vnode.props;
    S.vnode = F, S.next = null, bf(S, F.props, oe, te), Of(S, F.children, te), Tr(), Ya(S), Er();
  }, Fe = (S, F, te, oe, ue, se, me, ge, de = !1) => {
    const ae = S && S.children, Se = S ? S.shapeFlag : 0, be = F.children, { patchFlag: Ae, shapeFlag: Pe } = F;
    if (Ae > 0) {
      if (Ae & 128) {
        ct(
          ae,
          be,
          te,
          oe,
          ue,
          se,
          me,
          ge,
          de
        );
        return;
      } else if (Ae & 256) {
        bt(
          ae,
          be,
          te,
          oe,
          ue,
          se,
          me,
          ge,
          de
        );
        return;
      }
    }
    Pe & 8 ? (Se & 16 && Tt(ae, ue, se), be !== ae && D(te, be)) : Se & 16 ? Pe & 16 ? ct(
      ae,
      be,
      te,
      oe,
      ue,
      se,
      me,
      ge,
      de
    ) : Tt(ae, ue, se, !0) : (Se & 8 && D(te, ""), Pe & 16 && _e(
      be,
      te,
      oe,
      ue,
      se,
      me,
      ge,
      de
    ));
  }, bt = (S, F, te, oe, ue, se, me, ge, de) => {
    S = S || Eo, F = F || Eo;
    const ae = S.length, Se = F.length, be = Math.min(ae, Se);
    let Ae;
    for (Ae = 0; Ae < be; Ae++) {
      const Pe = F[Ae] = de ? Pr(F[Ae]) : Un(F[Ae]);
      ce(
        S[Ae],
        Pe,
        te,
        null,
        ue,
        se,
        me,
        ge,
        de
      );
    }
    ae > Se ? Tt(
      S,
      ue,
      se,
      !0,
      !1,
      be
    ) : _e(
      F,
      te,
      oe,
      ue,
      se,
      me,
      ge,
      de,
      be
    );
  }, ct = (S, F, te, oe, ue, se, me, ge, de) => {
    let ae = 0;
    const Se = F.length;
    let be = S.length - 1, Ae = Se - 1;
    for (; ae <= be && ae <= Ae; ) {
      const Pe = S[ae], je = F[ae] = de ? Pr(F[ae]) : Un(F[ae]);
      if (pi(Pe, je))
        ce(
          Pe,
          je,
          te,
          null,
          ue,
          se,
          me,
          ge,
          de
        );
      else
        break;
      ae++;
    }
    for (; ae <= be && ae <= Ae; ) {
      const Pe = S[be], je = F[Ae] = de ? Pr(F[Ae]) : Un(F[Ae]);
      if (pi(Pe, je))
        ce(
          Pe,
          je,
          te,
          null,
          ue,
          se,
          me,
          ge,
          de
        );
      else
        break;
      be--, Ae--;
    }
    if (ae > be) {
      if (ae <= Ae) {
        const Pe = Ae + 1, je = Pe < Se ? F[Pe].el : oe;
        for (; ae <= Ae; )
          ce(
            null,
            F[ae] = de ? Pr(F[ae]) : Un(F[ae]),
            te,
            je,
            ue,
            se,
            me,
            ge,
            de
          ), ae++;
      }
    } else if (ae > Ae)
      for (; ae <= be; )
        kt(S[ae], ue, se, !0), ae++;
    else {
      const Pe = ae, je = ae, Ue = /* @__PURE__ */ new Map();
      for (ae = je; ae <= Ae; ae++) {
        const ot = F[ae] = de ? Pr(F[ae]) : Un(F[ae]);
        ot.key != null && Ue.set(ot.key, ae);
      }
      let We, ht = 0;
      const Ot = Ae - je + 1;
      let Pt = !1, mt = 0;
      const Qt = new Array(Ot);
      for (ae = 0; ae < Ot; ae++) Qt[ae] = 0;
      for (ae = Pe; ae <= be; ae++) {
        const ot = S[ae];
        if (ht >= Ot) {
          kt(ot, ue, se, !0);
          continue;
        }
        let re;
        if (ot.key != null)
          re = Ue.get(ot.key);
        else
          for (We = je; We <= Ae; We++)
            if (Qt[We - je] === 0 && pi(ot, F[We])) {
              re = We;
              break;
            }
        re === void 0 ? kt(ot, ue, se, !0) : (Qt[re - je] = ae + 1, re >= mt ? mt = re : Pt = !0, ce(
          ot,
          F[re],
          te,
          null,
          ue,
          se,
          me,
          ge,
          de
        ), ht++);
      }
      const Bn = Pt ? Cf(Qt) : Eo;
      for (We = Bn.length - 1, ae = Ot - 1; ae >= 0; ae--) {
        const ot = je + ae, re = F[ot], dn = ot + 1 < Se ? F[ot + 1].el : oe;
        Qt[ae] === 0 ? ce(
          null,
          re,
          te,
          dn,
          ue,
          se,
          me,
          ge,
          de
        ) : Pt && (We < 0 || ae !== Bn[We] ? _t(re, te, dn, 2) : We--);
      }
    }
  }, _t = (S, F, te, oe, ue = null) => {
    const { el: se, type: me, transition: ge, children: de, shapeFlag: ae } = S;
    if (ae & 6) {
      _t(S.component.subTree, F, te, oe);
      return;
    }
    if (ae & 128) {
      S.suspense.move(F, te, oe);
      return;
    }
    if (ae & 64) {
      me.move(S, F, te, W);
      return;
    }
    if (me === Xe) {
      u(se, F, te);
      for (let be = 0; be < de.length; be++)
        _t(de[be], F, te, oe);
      u(S.anchor, F, te);
      return;
    }
    if (me === zs) {
      Y(S, F, te);
      return;
    }
    if (oe !== 2 && ae & 1 && ge)
      if (oe === 0)
        ge.beforeEnter(se), u(se, F, te), an(() => ge.enter(se), ue);
      else {
        const { leave: be, delayLeave: Ae, afterLeave: Pe } = ge, je = () => {
          S.ctx.isUnmounted ? c(se) : u(se, F, te);
        }, Ue = () => {
          be(se, () => {
            je(), Pe && Pe();
          });
        };
        Ae ? Ae(se, je, Ue) : Ue();
      }
    else
      u(se, F, te);
  }, kt = (S, F, te, oe = !1, ue = !1) => {
    const {
      type: se,
      props: me,
      ref: ge,
      children: de,
      dynamicChildren: ae,
      shapeFlag: Se,
      patchFlag: be,
      dirs: Ae,
      cacheIndex: Pe
    } = S;
    if (be === -2 && (ue = !1), ge != null && (Tr(), wi(ge, null, te, S, !0), Er()), Pe != null && (F.renderCache[Pe] = void 0), Se & 256) {
      F.ctx.deactivate(S);
      return;
    }
    const je = Se & 1 && Ae, Ue = !So(S);
    let We;
    if (Ue && (We = me && me.onVnodeBeforeUnmount) && $n(We, F, S), Se & 6)
      fn(S.component, te, oe);
    else {
      if (Se & 128) {
        S.suspense.unmount(te, oe);
        return;
      }
      je && ho(S, null, F, "beforeUnmount"), Se & 64 ? S.type.remove(
        S,
        F,
        te,
        W,
        oe
      ) : ae && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ae.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (se !== Xe || be > 0 && be & 64) ? Tt(
        ae,
        F,
        te,
        !1,
        !0
      ) : (se === Xe && be & 384 || !ue && Se & 16) && Tt(de, F, te), oe && jt(S);
    }
    (Ue && (We = me && me.onVnodeUnmounted) || je) && an(() => {
      We && $n(We, F, S), je && ho(S, null, F, "unmounted");
    }, te);
  }, jt = (S) => {
    const { type: F, el: te, anchor: oe, transition: ue } = S;
    if (F === Xe) {
      Mn(te, oe);
      return;
    }
    if (F === zs) {
      q(S);
      return;
    }
    const se = () => {
      c(te), ue && !ue.persisted && ue.afterLeave && ue.afterLeave();
    };
    if (S.shapeFlag & 1 && ue && !ue.persisted) {
      const { leave: me, delayLeave: ge } = ue, de = () => me(te, se);
      ge ? ge(S.el, se, de) : de();
    } else
      se();
  }, Mn = (S, F) => {
    let te;
    for (; S !== F; )
      te = B(S), c(S), S = te;
    c(F);
  }, fn = (S, F, te) => {
    const {
      bum: oe,
      scope: ue,
      job: se,
      subTree: me,
      um: ge,
      m: de,
      a: ae,
      parent: Se,
      slots: { __: be }
    } = S;
    ou(de), ou(ae), oe && Ui(oe), Se && ke(be) && be.forEach((Ae) => {
      Se.renderCache[Ae] = void 0;
    }), ue.stop(), se && (se.flags |= 8, kt(me, S, F, te)), ge && an(ge, F), an(() => {
      S.isUnmounted = !0;
    }, F), F && F.pendingBranch && !F.isUnmounted && S.asyncDep && !S.asyncResolved && S.suspenseId === F.pendingId && (F.deps--, F.deps === 0 && F.resolve());
  }, Tt = (S, F, te, oe = !1, ue = !1, se = 0) => {
    for (let me = se; me < S.length; me++)
      kt(S[me], F, te, oe, ue);
  }, A = (S) => {
    if (S.shapeFlag & 6)
      return A(S.component.subTree);
    if (S.shapeFlag & 128)
      return S.suspense.next();
    const F = B(S.anchor || S.el), te = F && F[ml];
    return te ? B(te) : F;
  };
  let x = !1;
  const K = (S, F, te) => {
    S == null ? F._vnode && kt(F._vnode, null, null, !0) : ce(
      F._vnode || null,
      S,
      F,
      null,
      null,
      null,
      te
    ), F._vnode = S, x || (x = !0, Ya(), dl(), x = !1);
  }, W = {
    p: ce,
    um: kt,
    m: _t,
    r: jt,
    mt: Tn,
    mc: _e,
    pc: Fe,
    pbc: ze,
    n: A,
    o: n
  };
  return {
    render: K,
    hydrate: void 0,
    createApp: mf(K)
  };
}
function Xs({ type: n, props: r }, s) {
  return s === "svg" && n === "foreignObject" || s === "mathml" && n === "annotation-xml" && r && r.encoding && r.encoding.includes("html") ? void 0 : s;
}
function mo({ effect: n, job: r }, s) {
  s ? (n.flags |= 32, r.flags |= 4) : (n.flags &= -33, r.flags &= -5);
}
function Nf(n, r) {
  return (!n || n && !n.pendingBranch) && r && !r.persisted;
}
function Ba(n, r, s = !1) {
  const u = n.children, c = r.children;
  if (ke(u) && ke(c))
    for (let f = 0; f < u.length; f++) {
      const p = u[f];
      let h = c[f];
      h.shapeFlag & 1 && !h.dynamicChildren && ((h.patchFlag <= 0 || h.patchFlag === 32) && (h = c[f] = Pr(c[f]), h.el = p.el), !s && h.patchFlag !== -2 && Ba(p, h)), h.type === hs && (h.el = p.el), h.type === Nr && !h.el && (h.el = p.el);
    }
}
function Cf(n) {
  const r = n.slice(), s = [0];
  let u, c, f, p, h;
  const g = n.length;
  for (u = 0; u < g; u++) {
    const R = n[u];
    if (R !== 0) {
      if (c = s[s.length - 1], n[c] < R) {
        r[u] = c, s.push(u);
        continue;
      }
      for (f = 0, p = s.length - 1; f < p; )
        h = f + p >> 1, n[s[h]] < R ? f = h + 1 : p = h;
      R < n[s[f]] && (f > 0 && (r[u] = s[f - 1]), s[f] = u);
    }
  }
  for (f = s.length, p = s[f - 1]; f-- > 0; )
    s[f] = p, p = r[p];
  return s;
}
function jl(n) {
  const r = n.subTree.component;
  if (r)
    return r.asyncDep && !r.asyncResolved ? r : jl(r);
}
function ou(n) {
  if (n)
    for (let r = 0; r < n.length; r++)
      n[r].flags |= 8;
}
const Sf = Symbol.for("v-scx"), Af = () => xi(Sf);
function Pf(n, r) {
  return $a(n, null, r);
}
function Ht(n, r, s) {
  return $a(n, r, s);
}
function $a(n, r, s = ft) {
  const { immediate: u, deep: c, flush: f, once: p } = s, h = zt({}, s), g = r && u || !r && f !== "post";
  let R;
  if (Ai) {
    if (f === "sync") {
      const ee = Af();
      R = ee.__watcherHandles || (ee.__watcherHandles = []);
    } else if (!g) {
      const ee = () => {
      };
      return ee.stop = Hn, ee.resume = Hn, ee.pause = Hn, ee;
    }
  }
  const D = Wt;
  h.call = (ee, ie, ce) => Wn(ee, D, ie, ce);
  let L = !1;
  f === "post" ? h.scheduler = (ee) => {
    an(ee, D && D.suspense);
  } : f !== "sync" && (L = !0, h.scheduler = (ee, ie) => {
    ie ? ee() : ja(ee);
  }), h.augmentJob = (ee) => {
    r && (ee.flags |= 4), L && (ee.flags |= 2, D && (ee.id = D.uid, ee.i = D));
  };
  const B = Uc(n, r, h);
  return Ai && (R ? R.push(B) : g && B()), B;
}
function Df(n, r, s) {
  const u = this.proxy, c = At(n) ? n.includes(".") ? Ll(u, n) : () => u[n] : n.bind(u, u);
  let f;
  qe(r) ? f = r : (f = r.handler, s = r);
  const p = Ki(this), h = $a(c, f.bind(u), s);
  return p(), h;
}
function Ll(n, r) {
  const s = r.split(".");
  return () => {
    let u = n;
    for (let c = 0; c < s.length && u; c++)
      u = u[s[c]];
    return u;
  };
}
const Rf = (n, r) => r === "modelValue" || r === "model-value" ? n.modelModifiers : n[`${r}Modifiers`] || n[`${Rr(r)}Modifiers`] || n[`${_o(r)}Modifiers`];
function If(n, r, ...s) {
  if (n.isUnmounted) return;
  const u = n.vnode.props || ft;
  let c = s;
  const f = r.startsWith("update:"), p = f && Rf(u, r.slice(7));
  p && (p.trim && (c = s.map((D) => At(D) ? D.trim() : D)), p.number && (c = s.map(zi)));
  let h, g = u[h = Us(r)] || // also try camelCase event handler (#2249)
  u[h = Us(Rr(r))];
  !g && f && (g = u[h = Us(_o(r))]), g && Wn(
    g,
    n,
    6,
    c
  );
  const R = u[h + "Once"];
  if (R) {
    if (!n.emitted)
      n.emitted = {};
    else if (n.emitted[h])
      return;
    n.emitted[h] = !0, Wn(
      R,
      n,
      6,
      c
    );
  }
}
function Kl(n, r, s = !1) {
  const u = r.emitsCache, c = u.get(n);
  if (c !== void 0)
    return c;
  const f = n.emits;
  let p = {}, h = !1;
  if (!qe(n)) {
    const g = (R) => {
      const D = Kl(R, r, !0);
      D && (h = !0, zt(p, D));
    };
    !s && r.mixins.length && r.mixins.forEach(g), n.extends && g(n.extends), n.mixins && n.mixins.forEach(g);
  }
  return !f && !h ? (gt(n) && u.set(n, null), null) : (ke(f) ? f.forEach((g) => p[g] = null) : zt(p, f), gt(n) && u.set(n, p), p);
}
function ps(n, r) {
  return !n || !is(r) ? !1 : (r = r.slice(2).replace(/Once$/, ""), at(n, r[0].toLowerCase() + r.slice(1)) || at(n, _o(r)) || at(n, r));
}
function iu(n) {
  const {
    type: r,
    vnode: s,
    proxy: u,
    withProxy: c,
    propsOptions: [f],
    slots: p,
    attrs: h,
    emit: g,
    render: R,
    renderCache: D,
    props: L,
    data: B,
    setupState: ee,
    ctx: ie,
    inheritAttrs: ce
  } = n, xe = ts(n);
  let le, U;
  try {
    if (s.shapeFlag & 4) {
      const q = c || u, M = q;
      le = Un(
        R.call(
          M,
          q,
          D,
          L,
          ee,
          B,
          ie
        )
      ), U = h;
    } else {
      const q = r;
      le = Un(
        q.length > 1 ? q(
          L,
          { attrs: h, slots: p, emit: g }
        ) : q(
          L,
          null
        )
      ), U = r.props ? h : kf(h);
    }
  } catch (q) {
    Oi.length = 0, cs(q, n, 1), le = St(Nr);
  }
  let Y = le;
  if (U && ce !== !1) {
    const q = Object.keys(U), { shapeFlag: M } = Y;
    q.length && M & 7 && (f && q.some(xa) && (U = jf(
      U,
      f
    )), Y = Po(Y, U, !1, !0));
  }
  return s.dirs && (Y = Po(Y, null, !1, !0), Y.dirs = Y.dirs ? Y.dirs.concat(s.dirs) : s.dirs), s.transition && La(Y, s.transition), le = Y, ts(xe), le;
}
const kf = (n) => {
  let r;
  for (const s in n)
    (s === "class" || s === "style" || is(s)) && ((r || (r = {}))[s] = n[s]);
  return r;
}, jf = (n, r) => {
  const s = {};
  for (const u in n)
    (!xa(u) || !(u.slice(9) in r)) && (s[u] = n[u]);
  return s;
};
function Lf(n, r, s) {
  const { props: u, children: c, component: f } = n, { props: p, children: h, patchFlag: g } = r, R = f.emitsOptions;
  if (r.dirs || r.transition)
    return !0;
  if (s && g >= 0) {
    if (g & 1024)
      return !0;
    if (g & 16)
      return u ? su(u, p, R) : !!p;
    if (g & 8) {
      const D = r.dynamicProps;
      for (let L = 0; L < D.length; L++) {
        const B = D[L];
        if (p[B] !== u[B] && !ps(R, B))
          return !0;
      }
    }
  } else
    return (c || h) && (!h || !h.$stable) ? !0 : u === p ? !1 : u ? p ? su(u, p, R) : !0 : !!p;
  return !1;
}
function su(n, r, s) {
  const u = Object.keys(r);
  if (u.length !== Object.keys(n).length)
    return !0;
  for (let c = 0; c < u.length; c++) {
    const f = u[c];
    if (r[f] !== n[f] && !ps(s, f))
      return !0;
  }
  return !1;
}
function Kf({ vnode: n, parent: r }, s) {
  for (; r; ) {
    const u = r.subTree;
    if (u.suspense && u.suspense.activeBranch === n && (u.el = n.el), u === n)
      (n = r.vnode).el = s, r = r.parent;
    else
      break;
  }
}
const Fl = (n) => n.__isSuspense;
function Ff(n, r) {
  r && r.pendingBranch ? ke(n) ? r.effects.push(...n) : r.effects.push(n) : Wc(n);
}
const Xe = Symbol.for("v-fgt"), hs = Symbol.for("v-txt"), Nr = Symbol.for("v-cmt"), zs = Symbol.for("v-stc"), Oi = [];
let xn = null;
function fe(n = !1) {
  Oi.push(xn = n ? null : []);
}
function Mf() {
  Oi.pop(), xn = Oi[Oi.length - 1] || null;
}
let Si = 1;
function au(n, r = !1) {
  Si += n, n < 0 && xn && r && (xn.hasOnce = !0);
}
function Ml(n) {
  return n.dynamicChildren = Si > 0 ? xn || Eo : null, Mf(), Si > 0 && xn && xn.push(n), n;
}
function ve(n, r, s, u, c, f) {
  return Ml(
    j(
      n,
      r,
      s,
      u,
      c,
      f,
      !0
    )
  );
}
function pn(n, r, s, u, c) {
  return Ml(
    St(
      n,
      r,
      s,
      u,
      c,
      !0
    )
  );
}
function qa(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
function pi(n, r) {
  return n.type === r.type && n.key === r.key;
}
const Bl = ({ key: n }) => n ?? null, Wi = ({
  ref: n,
  ref_key: r,
  ref_for: s
}) => (typeof n == "number" && (n = "" + n), n != null ? At(n) || xt(n) || qe(n) ? { i: Lt, r: n, k: r, f: !!s } : n : null);
function j(n, r = null, s = null, u = 0, c = null, f = n === Xe ? 0 : 1, p = !1, h = !1) {
  const g = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: r,
    key: r && Bl(r),
    ref: r && Wi(r),
    scopeId: hl,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: f,
    patchFlag: u,
    dynamicProps: c,
    dynamicChildren: null,
    appContext: null,
    ctx: Lt
  };
  return h ? (Ua(g, s), f & 128 && n.normalize(g)) : s && (g.shapeFlag |= At(s) ? 8 : 16), Si > 0 && // avoid a block node from tracking itself
  !p && // has current parent block
  xn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (g.patchFlag > 0 || f & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  g.patchFlag !== 32 && xn.push(g), g;
}
const St = Bf;
function Bf(n, r = null, s = null, u = 0, c = null, f = !1) {
  if ((!n || n === af) && (n = Nr), qa(n)) {
    const h = Po(
      n,
      r,
      !0
      /* mergeRef: true */
    );
    return s && Ua(h, s), Si > 0 && !f && xn && (h.shapeFlag & 6 ? xn[xn.indexOf(n)] = h : xn.push(h)), h.patchFlag = -2, h;
  }
  if (Qf(n) && (n = n.__vccOpts), r) {
    r = $f(r);
    let { class: h, style: g } = r;
    h && !At(h) && (r.class = On(h)), gt(g) && (Ra(g) && !ke(g) && (g = zt({}, g)), r.style = ji(g));
  }
  const p = At(n) ? 1 : Fl(n) ? 128 : Gc(n) ? 64 : gt(n) ? 4 : qe(n) ? 2 : 0;
  return j(
    n,
    r,
    s,
    u,
    c,
    p,
    f,
    !0
  );
}
function $f(n) {
  return n ? Ra(n) || Al(n) ? zt({}, n) : n : null;
}
function Po(n, r, s = !1, u = !1) {
  const { props: c, ref: f, patchFlag: p, children: h, transition: g } = n, R = r ? qf(c || {}, r) : c, D = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: R,
    key: R && Bl(R),
    ref: r && r.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && f ? ke(f) ? f.concat(Wi(r)) : [f, Wi(r)] : Wi(r)
    ) : f,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: h,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: r && n.type !== Xe ? p === -1 ? 16 : p | 16 : p,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: g,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && Po(n.ssContent),
    ssFallback: n.ssFallback && Po(n.ssFallback),
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return g && u && La(
    D,
    g.clone(D)
  ), D;
}
function $l(n = " ", r = 0) {
  return St(hs, null, n, r);
}
function lt(n = "", r = !1) {
  return r ? (fe(), pn(Nr, null, n)) : St(Nr, null, n);
}
function Un(n) {
  return n == null || typeof n == "boolean" ? St(Nr) : ke(n) ? St(
    Xe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    n.slice()
  ) : qa(n) ? Pr(n) : St(hs, null, String(n));
}
function Pr(n) {
  return n.el === null && n.patchFlag !== -1 || n.memo ? n : Po(n);
}
function Ua(n, r) {
  let s = 0;
  const { shapeFlag: u } = n;
  if (r == null)
    r = null;
  else if (ke(r))
    s = 16;
  else if (typeof r == "object")
    if (u & 65) {
      const c = r.default;
      c && (c._c && (c._d = !1), Ua(n, c()), c._c && (c._d = !0));
      return;
    } else {
      s = 32;
      const c = r._;
      !c && !Al(r) ? r._ctx = Lt : c === 3 && Lt && (Lt.slots._ === 1 ? r._ = 1 : (r._ = 2, n.patchFlag |= 1024));
    }
  else qe(r) ? (r = { default: r, _ctx: Lt }, s = 32) : (r = String(r), u & 64 ? (s = 16, r = [$l(r)]) : s = 8);
  n.children = r, n.shapeFlag |= s;
}
function qf(...n) {
  const r = {};
  for (let s = 0; s < n.length; s++) {
    const u = n[s];
    for (const c in u)
      if (c === "class")
        r.class !== u.class && (r.class = On([r.class, u.class]));
      else if (c === "style")
        r.style = ji([r.style, u.style]);
      else if (is(c)) {
        const f = r[c], p = u[c];
        p && f !== p && !(ke(f) && f.includes(p)) && (r[c] = f ? [].concat(f, p) : p);
      } else c !== "" && (r[c] = u[c]);
  }
  return r;
}
function $n(n, r, s, u = null) {
  Wn(n, r, 7, [
    s,
    u
  ]);
}
const Uf = Nl();
let Vf = 0;
function Hf(n, r, s) {
  const u = n.type, c = (r ? r.appContext : n.appContext) || Uf, f = {
    uid: Vf++,
    vnode: n,
    type: u,
    parent: r,
    appContext: c,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Uu(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: r ? r.provides : Object.create(c.provides),
    ids: r ? r.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Dl(u, c),
    emitsOptions: Kl(u, c),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ft,
    // inheritAttrs
    inheritAttrs: u.inheritAttrs,
    // state
    ctx: ft,
    data: ft,
    props: ft,
    attrs: ft,
    slots: ft,
    refs: ft,
    setupState: ft,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return f.ctx = { _: f }, f.root = r ? r.root : f, f.emit = If.bind(null, f), n.ce && n.ce(f), f;
}
let Wt = null;
const Wf = () => Wt || Lt;
let rs, da;
{
  const n = as(), r = (s, u) => {
    let c;
    return (c = n[s]) || (c = n[s] = []), c.push(u), (f) => {
      c.length > 1 ? c.forEach((p) => p(f)) : c[0](f);
    };
  };
  rs = r(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Wt = s
  ), da = r(
    "__VUE_SSR_SETTERS__",
    (s) => Ai = s
  );
}
const Ki = (n) => {
  const r = Wt;
  return rs(n), n.scope.on(), () => {
    n.scope.off(), rs(r);
  };
}, uu = () => {
  Wt && Wt.scope.off(), rs(null);
};
function ql(n) {
  return n.vnode.shapeFlag & 4;
}
let Ai = !1;
function Gf(n, r = !1, s = !1) {
  r && da(r);
  const { props: u, children: c } = n.vnode, f = ql(n);
  gf(n, u, f, r), xf(n, c, s || r);
  const p = f ? Yf(n, r) : void 0;
  return r && da(!1), p;
}
function Yf(n, r) {
  const s = n.type;
  n.accessCache = /* @__PURE__ */ Object.create(null), n.proxy = new Proxy(n.ctx, uf);
  const { setup: u } = s;
  if (u) {
    Tr();
    const c = n.setupContext = u.length > 1 ? zf(n) : null, f = Ki(n), p = Li(
      u,
      n,
      0,
      [
        n.props,
        c
      ]
    ), h = Lu(p);
    if (Er(), f(), (h || n.sp) && !So(n) && gl(n), h) {
      if (p.then(uu, uu), r)
        return p.then((g) => {
          lu(n, g);
        }).catch((g) => {
          cs(g, n, 0);
        });
      n.asyncDep = p;
    } else
      lu(n, p);
  } else
    Ul(n);
}
function lu(n, r, s) {
  qe(r) ? n.type.__ssrInlineRender ? n.ssrRender = r : n.render = r : gt(r) && (n.setupState = ul(r)), Ul(n);
}
function Ul(n, r, s) {
  const u = n.type;
  n.render || (n.render = u.render || Hn);
  {
    const c = Ki(n);
    Tr();
    try {
      lf(n);
    } finally {
      Er(), c();
    }
  }
}
const Xf = {
  get(n, r) {
    return Xt(n, "get", ""), n[r];
  }
};
function zf(n) {
  const r = (s) => {
    n.exposed = s || {};
  };
  return {
    attrs: new Proxy(n.attrs, Xf),
    slots: n.slots,
    emit: n.emit,
    expose: r
  };
}
function ms(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(ul(Ia(n.exposed)), {
    get(r, s) {
      if (s in r)
        return r[s];
      if (s in _i)
        return _i[s](n);
    },
    has(r, s) {
      return s in r || s in _i;
    }
  })) : n.proxy;
}
function Qf(n) {
  return qe(n) && "__vccOpts" in n;
}
const tt = (n, r) => $c(n, r, Ai), Jf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let pa;
const cu = typeof window < "u" && window.trustedTypes;
if (cu)
  try {
    pa = /* @__PURE__ */ cu.createPolicy("vue", {
      createHTML: (n) => n
    });
  } catch {
  }
const Vl = pa ? (n) => pa.createHTML(n) : (n) => n, Zf = "http://www.w3.org/2000/svg", ed = "http://www.w3.org/1998/Math/MathML", gr = typeof document < "u" ? document : null, fu = gr && /* @__PURE__ */ gr.createElement("template"), td = {
  insert: (n, r, s) => {
    r.insertBefore(n, s || null);
  },
  remove: (n) => {
    const r = n.parentNode;
    r && r.removeChild(n);
  },
  createElement: (n, r, s, u) => {
    const c = r === "svg" ? gr.createElementNS(Zf, n) : r === "mathml" ? gr.createElementNS(ed, n) : s ? gr.createElement(n, { is: s }) : gr.createElement(n);
    return n === "select" && u && u.multiple != null && c.setAttribute("multiple", u.multiple), c;
  },
  createText: (n) => gr.createTextNode(n),
  createComment: (n) => gr.createComment(n),
  setText: (n, r) => {
    n.nodeValue = r;
  },
  setElementText: (n, r) => {
    n.textContent = r;
  },
  parentNode: (n) => n.parentNode,
  nextSibling: (n) => n.nextSibling,
  querySelector: (n) => gr.querySelector(n),
  setScopeId(n, r) {
    n.setAttribute(r, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(n, r, s, u, c, f) {
    const p = s ? s.previousSibling : r.lastChild;
    if (c && (c === f || c.nextSibling))
      for (; r.insertBefore(c.cloneNode(!0), s), !(c === f || !(c = c.nextSibling)); )
        ;
    else {
      fu.innerHTML = Vl(
        u === "svg" ? `<svg>${n}</svg>` : u === "mathml" ? `<math>${n}</math>` : n
      );
      const h = fu.content;
      if (u === "svg" || u === "mathml") {
        const g = h.firstChild;
        for (; g.firstChild; )
          h.appendChild(g.firstChild);
        h.removeChild(g);
      }
      r.insertBefore(h, s);
    }
    return [
      // first
      p ? p.nextSibling : r.firstChild,
      // last
      s ? s.previousSibling : r.lastChild
    ];
  }
}, nd = Symbol("_vtc");
function rd(n, r, s) {
  const u = n[nd];
  u && (r = (r ? [r, ...u] : [...u]).join(" ")), r == null ? n.removeAttribute("class") : s ? n.setAttribute("class", r) : n.className = r;
}
const du = Symbol("_vod"), od = Symbol("_vsh"), id = Symbol(""), sd = /(^|;)\s*display\s*:/;
function ad(n, r, s) {
  const u = n.style, c = At(s);
  let f = !1;
  if (s && !c) {
    if (r)
      if (At(r))
        for (const p of r.split(";")) {
          const h = p.slice(0, p.indexOf(":")).trim();
          s[h] == null && Gi(u, h, "");
        }
      else
        for (const p in r)
          s[p] == null && Gi(u, p, "");
    for (const p in s)
      p === "display" && (f = !0), Gi(u, p, s[p]);
  } else if (c) {
    if (r !== s) {
      const p = u[id];
      p && (s += ";" + p), u.cssText = s, f = sd.test(s);
    }
  } else r && n.removeAttribute("style");
  du in n && (n[du] = f ? u.display : "", n[od] && (u.display = "none"));
}
const pu = /\s*!important$/;
function Gi(n, r, s) {
  if (ke(s))
    s.forEach((u) => Gi(n, r, u));
  else if (s == null && (s = ""), r.startsWith("--"))
    n.setProperty(r, s);
  else {
    const u = ud(n, r);
    pu.test(s) ? n.setProperty(
      _o(u),
      s.replace(pu, ""),
      "important"
    ) : n[u] = s;
  }
}
const hu = ["Webkit", "Moz", "ms"], Qs = {};
function ud(n, r) {
  const s = Qs[r];
  if (s)
    return s;
  let u = Rr(r);
  if (u !== "filter" && u in n)
    return Qs[r] = u;
  u = Mu(u);
  for (let c = 0; c < hu.length; c++) {
    const f = hu[c] + u;
    if (f in n)
      return Qs[r] = f;
  }
  return r;
}
const mu = "http://www.w3.org/1999/xlink";
function yu(n, r, s, u, c, f = fc(r)) {
  u && r.startsWith("xlink:") ? s == null ? n.removeAttributeNS(mu, r.slice(6, r.length)) : n.setAttributeNS(mu, r, s) : s == null || f && !Bu(s) ? n.removeAttribute(r) : n.setAttribute(
    r,
    f ? "" : Fn(s) ? String(s) : s
  );
}
function vu(n, r, s, u, c) {
  if (r === "innerHTML" || r === "textContent") {
    s != null && (n[r] = r === "innerHTML" ? Vl(s) : s);
    return;
  }
  const f = n.tagName;
  if (r === "value" && f !== "PROGRESS" && // custom elements may use _value internally
  !f.includes("-")) {
    const h = f === "OPTION" ? n.getAttribute("value") || "" : n.value, g = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      n.type === "checkbox" ? "on" : ""
    ) : String(s);
    (h !== g || !("_value" in n)) && (n.value = g), s == null && n.removeAttribute(r), n._value = s;
    return;
  }
  let p = !1;
  if (s === "" || s == null) {
    const h = typeof n[r];
    h === "boolean" ? s = Bu(s) : s == null && h === "string" ? (s = "", p = !0) : h === "number" && (s = 0, p = !0);
  }
  try {
    n[r] = s;
  } catch {
  }
  p && n.removeAttribute(c || r);
}
function _r(n, r, s, u) {
  n.addEventListener(r, s, u);
}
function ld(n, r, s, u) {
  n.removeEventListener(r, s, u);
}
const gu = Symbol("_vei");
function cd(n, r, s, u, c = null) {
  const f = n[gu] || (n[gu] = {}), p = f[r];
  if (u && p)
    p.value = u;
  else {
    const [h, g] = fd(r);
    if (u) {
      const R = f[r] = hd(
        u,
        c
      );
      _r(n, h, R, g);
    } else p && (ld(n, h, p, g), f[r] = void 0);
  }
}
const bu = /(?:Once|Passive|Capture)$/;
function fd(n) {
  let r;
  if (bu.test(n)) {
    r = {};
    let u;
    for (; u = n.match(bu); )
      n = n.slice(0, n.length - u[0].length), r[u[0].toLowerCase()] = !0;
  }
  return [n[2] === ":" ? n.slice(3) : _o(n.slice(2)), r];
}
let Js = 0;
const dd = /* @__PURE__ */ Promise.resolve(), pd = () => Js || (dd.then(() => Js = 0), Js = Date.now());
function hd(n, r) {
  const s = (u) => {
    if (!u._vts)
      u._vts = Date.now();
    else if (u._vts <= s.attached)
      return;
    Wn(
      md(u, s.value),
      r,
      5,
      [u]
    );
  };
  return s.value = n, s.attached = pd(), s;
}
function md(n, r) {
  if (ke(r)) {
    const s = n.stopImmediatePropagation;
    return n.stopImmediatePropagation = () => {
      s.call(n), n._stopped = !0;
    }, r.map(
      (u) => (c) => !c._stopped && u && u(c)
    );
  } else
    return r;
}
const wu = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // lowercase letter
n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, yd = (n, r, s, u, c, f) => {
  const p = c === "svg";
  r === "class" ? rd(n, u, p) : r === "style" ? ad(n, s, u) : is(r) ? xa(r) || cd(n, r, s, u, f) : (r[0] === "." ? (r = r.slice(1), !0) : r[0] === "^" ? (r = r.slice(1), !1) : vd(n, r, u, p)) ? (vu(n, r, u), !n.tagName.includes("-") && (r === "value" || r === "checked" || r === "selected") && yu(n, r, u, p, f, r !== "value")) : /* #11081 force set props for possible async custom element */ n._isVueCE && (/[A-Z]/.test(r) || !At(u)) ? vu(n, Rr(r), u, f, r) : (r === "true-value" ? n._trueValue = u : r === "false-value" && (n._falseValue = u), yu(n, r, u, p));
};
function vd(n, r, s, u) {
  if (u)
    return !!(r === "innerHTML" || r === "textContent" || r in n && wu(r) && qe(s));
  if (r === "spellcheck" || r === "draggable" || r === "translate" || r === "autocorrect" || r === "form" || r === "list" && n.tagName === "INPUT" || r === "type" && n.tagName === "TEXTAREA")
    return !1;
  if (r === "width" || r === "height") {
    const c = n.tagName;
    if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE")
      return !1;
  }
  return wu(r) && At(s) ? !1 : r in n;
}
const kr = (n) => {
  const r = n.props["onUpdate:modelValue"] || !1;
  return ke(r) ? (s) => Ui(r, s) : r;
};
function gd(n) {
  n.target.composing = !0;
}
function _u(n) {
  const r = n.target;
  r.composing && (r.composing = !1, r.dispatchEvent(new Event("input")));
}
const Cn = Symbol("_assign"), Or = {
  created(n, { modifiers: { lazy: r, trim: s, number: u } }, c) {
    n[Cn] = kr(c);
    const f = u || c.props && c.props.type === "number";
    _r(n, r ? "change" : "input", (p) => {
      if (p.target.composing) return;
      let h = n.value;
      s && (h = h.trim()), f && (h = zi(h)), n[Cn](h);
    }), s && _r(n, "change", () => {
      n.value = n.value.trim();
    }), r || (_r(n, "compositionstart", gd), _r(n, "compositionend", _u), _r(n, "change", _u));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(n, { value: r }) {
    n.value = r ?? "";
  },
  beforeUpdate(n, { value: r, oldValue: s, modifiers: { lazy: u, trim: c, number: f } }, p) {
    if (n[Cn] = kr(p), n.composing) return;
    const h = (f || n.type === "number") && !/^0\d/.test(n.value) ? zi(n.value) : n.value, g = r ?? "";
    h !== g && (document.activeElement === n && n.type !== "range" && (u && r === s || c && n.value.trim() === g) || (n.value = g));
  }
}, Ao = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(n, r, s) {
    n[Cn] = kr(s), _r(n, "change", () => {
      const u = n._modelValue, c = Do(n), f = n.checked, p = n[Cn];
      if (ke(u)) {
        const h = Ea(u, c), g = h !== -1;
        if (f && !g)
          p(u.concat(c));
        else if (!f && g) {
          const R = [...u];
          R.splice(h, 1), p(R);
        }
      } else if (Io(u)) {
        const h = new Set(u);
        f ? h.add(c) : h.delete(c), p(h);
      } else
        p(Hl(n, f));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: xu,
  beforeUpdate(n, r, s) {
    n[Cn] = kr(s), xu(n, r, s);
  }
};
function xu(n, { value: r, oldValue: s }, u) {
  n._modelValue = r;
  let c;
  if (ke(r))
    c = Ea(r, u.props.value) > -1;
  else if (Io(r))
    c = r.has(u.props.value);
  else {
    if (r === s) return;
    c = bo(r, Hl(n, !0));
  }
  n.checked !== c && (n.checked = c);
}
const jr = {
  created(n, { value: r }, s) {
    n.checked = bo(r, s.props.value), n[Cn] = kr(s), _r(n, "change", () => {
      n[Cn](Do(n));
    });
  },
  beforeUpdate(n, { value: r, oldValue: s }, u) {
    n[Cn] = kr(u), r !== s && (n.checked = bo(r, u.props.value));
  }
}, ln = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(n, { value: r, modifiers: { number: s } }, u) {
    const c = Io(r);
    _r(n, "change", () => {
      const f = Array.prototype.filter.call(n.options, (p) => p.selected).map(
        (p) => s ? zi(Do(p)) : Do(p)
      );
      n[Cn](
        n.multiple ? c ? new Set(f) : f : f[0]
      ), n._assigning = !0, ka(() => {
        n._assigning = !1;
      });
    }), n[Cn] = kr(u);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(n, { value: r }) {
    Ou(n, r);
  },
  beforeUpdate(n, r, s) {
    n[Cn] = kr(s);
  },
  updated(n, { value: r }) {
    n._assigning || Ou(n, r);
  }
};
function Ou(n, r) {
  const s = n.multiple, u = ke(r);
  if (!(s && !u && !Io(r))) {
    for (let c = 0, f = n.options.length; c < f; c++) {
      const p = n.options[c], h = Do(p);
      if (s)
        if (u) {
          const g = typeof h;
          g === "string" || g === "number" ? p.selected = r.some((R) => String(R) === String(h)) : p.selected = Ea(r, h) > -1;
        } else
          p.selected = r.has(h);
      else if (bo(Do(p), r)) {
        n.selectedIndex !== c && (n.selectedIndex = c);
        return;
      }
    }
    !s && n.selectedIndex !== -1 && (n.selectedIndex = -1);
  }
}
function Do(n) {
  return "_value" in n ? n._value : n.value;
}
function Hl(n, r) {
  const s = r ? "_trueValue" : "_falseValue";
  return s in n ? n[s] : r;
}
const bd = /* @__PURE__ */ zt({ patchProp: yd }, td);
let Tu;
function wd() {
  return Tu || (Tu = Tf(bd));
}
const _d = (...n) => {
  const r = wd().createApp(...n), { mount: s } = r;
  return r.mount = (u) => {
    const c = Od(u);
    if (!c) return;
    const f = r._component;
    !qe(f) && !f.render && !f.template && (f.template = c.innerHTML), c.nodeType === 1 && (c.textContent = "");
    const p = s(c, !1, xd(c));
    return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), p;
  }, r;
};
function xd(n) {
  if (n instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && n instanceof MathMLElement)
    return "mathml";
}
function Od(n) {
  return At(n) ? document.querySelector(n) : n;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Wl;
const ys = (n) => Wl = n, Gl = (
  /* istanbul ignore next */
  Symbol()
);
function ha(n) {
  return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function";
}
var Ti;
(function(n) {
  n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function";
})(Ti || (Ti = {}));
function Td() {
  const n = Vu(!0), r = n.run(() => rt({}));
  let s = [], u = [];
  const c = Ia({
    install(f) {
      ys(c), c._a = f, f.provide(Gl, c), f.config.globalProperties.$pinia = c, u.forEach((p) => s.push(p)), u = [];
    },
    use(f) {
      return this._a ? s.push(f) : u.push(f), this;
    },
    _p: s,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: n,
    _s: /* @__PURE__ */ new Map(),
    state: r
  });
  return c;
}
const Yl = () => {
};
function Eu(n, r, s, u = Yl) {
  n.push(r);
  const c = () => {
    const f = n.indexOf(r);
    f > -1 && (n.splice(f, 1), u());
  };
  return !s && Hu() && pc(c), c;
}
function Oo(n, ...r) {
  n.slice().forEach((s) => {
    s(...r);
  });
}
const Ed = (n) => n(), Nu = Symbol(), Zs = Symbol();
function ma(n, r) {
  n instanceof Map && r instanceof Map ? r.forEach((s, u) => n.set(u, s)) : n instanceof Set && r instanceof Set && r.forEach(n.add, n);
  for (const s in r) {
    if (!r.hasOwnProperty(s))
      continue;
    const u = r[s], c = n[s];
    ha(c) && ha(u) && n.hasOwnProperty(s) && !xt(u) && !xr(u) ? n[s] = ma(c, u) : n[s] = u;
  }
  return n;
}
const Nd = (
  /* istanbul ignore next */
  Symbol()
);
function Cd(n) {
  return !ha(n) || !Object.prototype.hasOwnProperty.call(n, Nd);
}
const { assign: Sr } = Object;
function Sd(n) {
  return !!(xt(n) && n.effect);
}
function Ad(n, r, s, u) {
  const { state: c, actions: f, getters: p } = r, h = s.state.value[n];
  let g;
  function R() {
    h || (s.state.value[n] = c ? c() : {});
    const D = Lc(s.state.value[n]);
    return Sr(D, f, Object.keys(p || {}).reduce((L, B) => (L[B] = Ia(tt(() => {
      ys(s);
      const ee = s._s.get(n);
      return p[B].call(ee, ee);
    })), L), {}));
  }
  return g = Xl(n, R, r, s, u, !0), g;
}
function Xl(n, r, s = {}, u, c, f) {
  let p;
  const h = Sr({ actions: {} }, s), g = { deep: !0 };
  let R, D, L = [], B = [], ee;
  const ie = u.state.value[n];
  !f && !ie && (u.state.value[n] = {}), rt({});
  let ce;
  function xe(_e) {
    let $;
    R = D = !1, typeof _e == "function" ? (_e(u.state.value[n]), $ = {
      type: Ti.patchFunction,
      storeId: n,
      events: ee
    }) : (ma(u.state.value[n], _e), $ = {
      type: Ti.patchObject,
      payload: _e,
      storeId: n,
      events: ee
    });
    const ze = ce = Symbol();
    ka().then(() => {
      ce === ze && (R = !0);
    }), D = !0, Oo(L, $, u.state.value[n]);
  }
  const le = f ? function() {
    const { state: $ } = s, ze = $ ? $() : {};
    this.$patch((dt) => {
      Sr(dt, ze);
    });
  } : (
    /* istanbul ignore next */
    Yl
  );
  function U() {
    p.stop(), L = [], B = [], u._s.delete(n);
  }
  const Y = (_e, $ = "") => {
    if (Nu in _e)
      return _e[Zs] = $, _e;
    const ze = function() {
      ys(u);
      const dt = Array.from(arguments), Me = [], st = [];
      function Tn(Ne) {
        Me.push(Ne);
      }
      function It(Ne) {
        st.push(Ne);
      }
      Oo(B, {
        args: dt,
        name: ze[Zs],
        store: M,
        after: Tn,
        onError: It
      });
      let nt;
      try {
        nt = _e.apply(this && this.$id === n ? this : M, dt);
      } catch (Ne) {
        throw Oo(st, Ne), Ne;
      }
      return nt instanceof Promise ? nt.then((Ne) => (Oo(Me, Ne), Ne)).catch((Ne) => (Oo(st, Ne), Promise.reject(Ne))) : (Oo(Me, nt), nt);
    };
    return ze[Nu] = !0, ze[Zs] = $, ze;
  }, q = {
    _p: u,
    // _s: scope,
    $id: n,
    $onAction: Eu.bind(null, B),
    $patch: xe,
    $reset: le,
    $subscribe(_e, $ = {}) {
      const ze = Eu(L, _e, $.detached, () => dt()), dt = p.run(() => Ht(() => u.state.value[n], (Me) => {
        ($.flush === "sync" ? D : R) && _e({
          storeId: n,
          type: Ti.direct,
          events: ee
        }, Me);
      }, Sr({}, g, $)));
      return ze;
    },
    $dispose: U
  }, M = ls(q);
  u._s.set(n, M);
  const we = (u._a && u._a.runWithContext || Ed)(() => u._e.run(() => (p = Vu()).run(() => r({ action: Y }))));
  for (const _e in we) {
    const $ = we[_e];
    if (xt($) && !Sd($) || xr($))
      f || (ie && Cd($) && (xt($) ? $.value = ie[_e] : ma($, ie[_e])), u.state.value[n][_e] = $);
    else if (typeof $ == "function") {
      const ze = Y($, _e);
      we[_e] = ze, h.actions[_e] = $;
    }
  }
  return Sr(M, we), Sr(et(M), we), Object.defineProperty(M, "$state", {
    get: () => u.state.value[n],
    set: (_e) => {
      xe(($) => {
        Sr($, _e);
      });
    }
  }), u._p.forEach((_e) => {
    Sr(M, p.run(() => _e({
      store: M,
      app: u._a,
      pinia: u,
      options: h
    })));
  }), ie && f && s.hydrate && s.hydrate(M.$state, ie), R = !0, D = !0, M;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function zl(n, r, s) {
  let u;
  const c = typeof r == "function";
  u = c ? s : r;
  function f(p, h) {
    const g = vf();
    return p = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    p || (g ? xi(Gl, null) : null), p && ys(p), p = Wl, p._s.has(n) || (c ? Xl(n, r, u, p) : Ad(n, u, p)), p._s.get(n);
  }
  return f.$id = n, f;
}
function hn(n) {
  const r = et(n), s = {};
  for (const u in r) {
    const c = r[u];
    c.effect ? s[u] = // ...
    tt({
      get: () => n[u],
      set(f) {
        n[u] = f;
      }
    }) : (xt(c) || xr(c)) && (s[u] = // ---
    Mc(n, u));
  }
  return s;
}
const Pi = ["q", "t"];
function Vn(n) {
  return `${n.prefix} ${n.lnClass} ${n.lnInst}`;
}
const vs = /* @__PURE__ */ zl("dataflow/sidebar", () => {
  const n = rt(null);
  function r(u) {
    n.value = u;
  }
  function s(u) {
    const c = u === n.value ? null : u;
    r(c);
  }
  return {
    activeElement: n,
    setActiveElement: r,
    setOrResetActiveElement: s
  };
});
var Pd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Dd(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Yi = { exports: {} }, Rd = Yi.exports, Cu;
function Id() {
  return Cu || (Cu = 1, function(n, r) {
    (function(s, u) {
      n.exports = u();
    })(Rd, function() {
      var s = function(e, t) {
        return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (o[a] = i[a]);
        })(e, t);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var t, o = 1, i = arguments.length; o < i; o++) for (var a in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, t, o) {
        for (var i, a = 0, l = t.length; a < l; a++) !i && a in t || ((i = i || Array.prototype.slice.call(t, 0, a))[a] = t[a]);
        return e.concat(i || Array.prototype.slice.call(t));
      }
      var f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Pd, p = Object.keys, h = Array.isArray;
      function g(e, t) {
        return typeof t != "object" || p(t).forEach(function(o) {
          e[o] = t[o];
        }), e;
      }
      typeof Promise > "u" || f.Promise || (f.Promise = Promise);
      var R = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function L(e, t) {
        return D.call(e, t);
      }
      function B(e, t) {
        typeof t == "function" && (t = t(R(e))), (typeof Reflect > "u" ? p : Reflect.ownKeys)(t).forEach(function(o) {
          ie(e, o, t[o]);
        });
      }
      var ee = Object.defineProperty;
      function ie(e, t, o, i) {
        ee(e, t, g(o && L(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function ce(e) {
        return { from: function(t) {
          return e.prototype = Object.create(t.prototype), ie(e.prototype, "constructor", e), { extend: B.bind(null, e.prototype) };
        } };
      }
      var xe = Object.getOwnPropertyDescriptor, le = [].slice;
      function U(e, t, o) {
        return le.call(e, t, o);
      }
      function Y(e, t) {
        return t(e);
      }
      function q(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function M(e) {
        f.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function ne(e, t) {
        if (typeof t == "string" && L(e, t)) return e[t];
        if (!t) return e;
        if (typeof t != "string") {
          for (var o = [], i = 0, a = t.length; i < a; ++i) {
            var l = ne(e, t[i]);
            o.push(l);
          }
          return o;
        }
        var d = t.indexOf(".");
        if (d !== -1) {
          var m = e[t.substr(0, d)];
          return m == null ? void 0 : ne(m, t.substr(d + 1));
        }
      }
      function we(e, t, o) {
        if (e && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) {
          q(typeof o != "string" && "length" in o);
          for (var i = 0, a = t.length; i < a; ++i) we(e, t[i], o[i]);
        } else {
          var l, d, m = t.indexOf(".");
          m !== -1 ? (l = t.substr(0, m), (d = t.substr(m + 1)) === "" ? o === void 0 ? h(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : we(m = !(m = e[l]) || !L(e, l) ? e[l] = {} : m, d, o)) : o === void 0 ? h(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = o;
        }
      }
      function _e(e) {
        var t, o = {};
        for (t in e) L(e, t) && (o[t] = e[t]);
        return o;
      }
      var $ = [].concat;
      function ze(e) {
        return $.apply([], e);
      }
      var je = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(ze([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + e + "Array";
        });
      }))).filter(function(e) {
        return f[e];
      }), dt = new Set(je.map(function(e) {
        return f[e];
      })), Me = null;
      function st(e) {
        return Me = /* @__PURE__ */ new WeakMap(), e = function t(o) {
          if (!o || typeof o != "object") return o;
          var i = Me.get(o);
          if (i) return i;
          if (h(o)) {
            i = [], Me.set(o, i);
            for (var a = 0, l = o.length; a < l; ++a) i.push(t(o[a]));
          } else if (dt.has(o.constructor)) i = o;
          else {
            var d, m = R(o);
            for (d in i = m === Object.prototype ? {} : Object.create(m), Me.set(o, i), o) L(o, d) && (i[d] = t(o[d]));
          }
          return i;
        }(e), Me = null, e;
      }
      var Tn = {}.toString;
      function It(e) {
        return Tn.call(e).slice(8, -1);
      }
      var nt = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ne = typeof nt == "symbol" ? function(e) {
        var t;
        return e != null && (t = e[nt]) && t.apply(e);
      } : function() {
        return null;
      };
      function Fe(e, t) {
        return t = e.indexOf(t), 0 <= t && e.splice(t, 1), 0 <= t;
      }
      var bt = {};
      function ct(e) {
        var t, o, i, a;
        if (arguments.length === 1) {
          if (h(e)) return e.slice();
          if (this === bt && typeof e == "string") return [e];
          if (a = Ne(e)) {
            for (o = []; !(i = a.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (t = e.length) != "number") return [e];
          for (o = new Array(t); t--; ) o[t] = e[t];
          return o;
        }
        for (t = arguments.length, o = new Array(t); t--; ) o[t] = arguments[t];
        return o;
      }
      var _t = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], wt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Pe), kt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function jt(e, t) {
        this.name = e, this.message = t;
      }
      function Mn(e, t) {
        return e + ". Errors: " + Object.keys(t).map(function(o) {
          return t[o].toString();
        }).filter(function(o, i, a) {
          return a.indexOf(o) === i;
        }).join(`
`);
      }
      function fn(e, t, o, i) {
        this.failures = t, this.failedKeys = i, this.successCount = o, this.message = Mn(e, t);
      }
      function Tt(e, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(o) {
          return t[o];
        }), this.failuresByPos = t, this.message = Mn(e, this.failures);
      }
      ce(jt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), ce(fn).from(jt), ce(Tt).from(jt);
      var A = wt.reduce(function(e, t) {
        return e[t] = t + "Error", e;
      }, {}), x = jt, K = wt.reduce(function(e, t) {
        var o = t + "Error";
        function i(a, l) {
          this.name = o, a ? typeof a == "string" ? (this.message = "".concat(a).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof a == "object" && (this.message = "".concat(a.name, " ").concat(a.message), this.inner = a) : (this.message = kt[t] || o, this.inner = null);
        }
        return ce(i).from(x), e[t] = i, e;
      }, {});
      K.Syntax = SyntaxError, K.Type = TypeError, K.Range = RangeError;
      var W = Pe.reduce(function(e, t) {
        return e[t + "Error"] = K[t], e;
      }, {}), Ve = wt.reduce(function(e, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = K[t]), e;
      }, {});
      function S() {
      }
      function F(e) {
        return e;
      }
      function te(e, t) {
        return e == null || e === F ? t : function(o) {
          return t(e(o));
        };
      }
      function oe(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function ue(e, t) {
        return e === S ? t : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, a = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = t.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? oe(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? oe(a, this.onerror) : a), l !== void 0 ? l : o;
        };
      }
      function se(e, t) {
        return e === S ? t : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? oe(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? oe(i, this.onerror) : i);
        };
      }
      function me(e, t) {
        return e === S ? t : function(o) {
          var i = e.apply(this, arguments);
          g(o, i);
          var a = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = t.apply(this, arguments), a && (this.onsuccess = this.onsuccess ? oe(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? oe(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : g(i, o);
        };
      }
      function ge(e, t) {
        return e === S ? t : function() {
          return t.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function de(e, t) {
        return e === S ? t : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, a = arguments.length, l = new Array(a); a--; ) l[a] = arguments[a];
            return o.then(function() {
              return t.apply(i, l);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Ve.ModifyError = fn, Ve.DexieError = jt, Ve.BulkError = Tt;
      var ae = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Se(e) {
        ae = e;
      }
      var be = {}, Ae = 100, je = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, R(e), e];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, R(t), e];
      }(), Pe = je[0], wt = je[1], je = je[2], wt = wt && wt.then, Ue = Pe && Pe.constructor, We = !!je, ht = function(e, t) {
        dn.push([e, t]), Pt && (queueMicrotask(bs), Pt = !1);
      }, Ot = !0, Pt = !0, mt = [], Qt = [], Bn = F, ot = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: S, pgp: !1, env: {}, finalize: S }, re = ot, dn = [], Jt = 0, Gn = [];
      function J(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof e != "function") {
          if (e !== be) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Kr(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function o(i, a) {
          try {
            a(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var d = i._lib && mn();
                l && typeof l.then == "function" ? o(i, function(m, v) {
                  l instanceof J ? l._then(m, v) : l.then(m, v);
                }) : (i._state = !0, i._value = l, jo(i)), d && yn();
              }
            }, Kr.bind(null, i));
          } catch (l) {
            Kr(i, l);
          }
        }(this, e);
      }
      var Lr = { get: function() {
        var e = re, t = Qn;
        function o(i, a) {
          var l = this, d = !e.global && (e !== re || t !== Qn), m = d && !Mt(), v = new J(function(w, O) {
            Fr(l, new ko(Ko(i, e, d, m), Ko(a, e, d, m), w, O, e));
          });
          return this._consoleTask && (v._consoleTask = this._consoleTask), v;
        }
        return o.prototype = be, o;
      }, set: function(e) {
        ie(this, "then", e && e.prototype === be ? Lr : { get: function() {
          return e;
        }, set: Lr.set });
      } };
      function ko(e, t, o, i, a) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = o, this.reject = i, this.psd = a;
      }
      function Kr(e, t) {
        var o, i;
        Qt.push(t), e._state === null && (o = e._lib && mn(), t = Bn(t), e._state = !1, e._value = t, i = e, mt.some(function(a) {
          return a._value === i._value;
        }) || mt.push(i), jo(e), o && yn());
      }
      function jo(e) {
        var t = e._listeners;
        e._listeners = [];
        for (var o = 0, i = t.length; o < i; ++o) Fr(e, t[o]);
        var a = e._PSD;
        --a.ref || a.finalize(), Jt === 0 && (++Jt, ht(function() {
          --Jt == 0 && Mr();
        }, []));
      }
      function Fr(e, t) {
        if (e._state !== null) {
          var o = e._state ? t.onFulfilled : t.onRejected;
          if (o === null) return (e._state ? t.resolve : t.reject)(e._value);
          ++t.psd.ref, ++Jt, ht(gs, [o, e, t]);
        } else e._listeners.push(t);
      }
      function gs(e, t, o) {
        try {
          var i, a = t._value;
          !t._state && Qt.length && (Qt = []), i = ae && t._consoleTask ? t._consoleTask.run(function() {
            return e(a);
          }) : e(a), t._state || Qt.indexOf(a) !== -1 || function(l) {
            for (var d = mt.length; d; ) if (mt[--d]._value === l._value) return mt.splice(d, 1);
          }(t), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Jt == 0 && Mr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function bs() {
        Zt(ot, function() {
          mn() && yn();
        });
      }
      function mn() {
        var e = Ot;
        return Pt = Ot = !1, e;
      }
      function yn() {
        var e, t, o;
        do
          for (; 0 < dn.length; ) for (e = dn, dn = [], o = e.length, t = 0; t < o; ++t) {
            var i = e[t];
            i[0].apply(null, i[1]);
          }
        while (0 < dn.length);
        Pt = Ot = !0;
      }
      function Mr() {
        var e = mt;
        mt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var t = Gn.slice(0), o = t.length; o; ) t[--o]();
      }
      function Yn(e) {
        return new J(be, !1, e);
      }
      function Le(e, t) {
        var o = re;
        return function() {
          var i = mn(), a = re;
          try {
            return Bt(o, !0), e.apply(this, arguments);
          } catch (l) {
            t && t(l);
          } finally {
            Bt(a, !1), i && yn();
          }
        };
      }
      B(J.prototype, { then: Lr, _then: function(e, t) {
        Fr(this, new ko(null, null, e, t, re));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var t = e, o = arguments[1];
        return typeof t == "function" ? this.then(null, function(i) {
          return (i instanceof t ? o : Yn)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === t ? o : Yn)(i);
        });
      }, finally: function(e) {
        return this.then(function(t) {
          return J.resolve(e()).then(function() {
            return t;
          });
        }, function(t) {
          return J.resolve(e()).then(function() {
            return Yn(t);
          });
        });
      }, timeout: function(e, t) {
        var o = this;
        return e < 1 / 0 ? new J(function(i, a) {
          var l = setTimeout(function() {
            return a(new K.Timeout(t));
          }, e);
          o.then(i, a).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && ie(J.prototype, Symbol.toStringTag, "Dexie.Promise"), ot.env = Lo(), B(J, { all: function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t, o) {
          e.length === 0 && t([]);
          var i = e.length;
          e.forEach(function(a, l) {
            return J.resolve(a).then(function(d) {
              e[l] = d, --i || t(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof J ? e : e && typeof e.then == "function" ? new J(function(t, o) {
          e.then(t, o);
        }) : new J(be, !0, e);
      }, reject: Yn, race: function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t, o) {
          e.map(function(i) {
            return J.resolve(i).then(t, o);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(e) {
        return re = e;
      } }, totalEchoes: { get: function() {
        return Qn;
      } }, newPSD: Ft, usePSD: Zt, scheduler: { get: function() {
        return ht;
      }, set: function(e) {
        ht = e;
      } }, rejectionMapper: { get: function() {
        return Bn;
      }, set: function(e) {
        Bn = e;
      } }, follow: function(e, t) {
        return new J(function(o, i) {
          return Ft(function(a, l) {
            var d = re;
            d.unhandleds = [], d.onunhandled = l, d.finalize = oe(function() {
              var m, v = this;
              m = function() {
                v.unhandleds.length === 0 ? a() : l(v.unhandleds[0]);
              }, Gn.push(function w() {
                m(), Gn.splice(Gn.indexOf(w), 1);
              }), ++Jt, ht(function() {
                --Jt == 0 && Mr();
              }, []);
            }, d.finalize), e();
          }, t, o, i);
        });
      } }), Ue && (Ue.allSettled && ie(J, "allSettled", function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t) {
          e.length === 0 && t([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(a, l) {
            return J.resolve(a).then(function(d) {
              return i[l] = { status: "fulfilled", value: d };
            }, function(d) {
              return i[l] = { status: "rejected", reason: d };
            }).then(function() {
              return --o || t(i);
            });
          });
        });
      }), Ue.any && typeof AggregateError < "u" && ie(J, "any", function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, a = new Array(i);
          e.forEach(function(l, d) {
            return J.resolve(l).then(function(m) {
              return t(m);
            }, function(m) {
              a[d] = m, --i || o(new AggregateError(a));
            });
          });
        });
      }), Ue.withResolvers && (J.withResolvers = Ue.withResolvers));
      var Ge = { awaits: 0, echoes: 0, id: 0 }, ws = 0, Xn = [], zn = 0, Qn = 0, _s = 0;
      function Ft(e, t, o, i) {
        var a = re, l = Object.create(a);
        return l.parent = a, l.ref = 0, l.global = !1, l.id = ++_s, ot.env, l.env = We ? { Promise: J, PromiseProp: { value: J, configurable: !0, writable: !0 }, all: J.all, race: J.race, allSettled: J.allSettled, any: J.any, resolve: J.resolve, reject: J.reject } : {}, t && g(l, t), ++a.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = Zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function vn() {
        return Ge.id || (Ge.id = ++ws), ++Ge.awaits, Ge.echoes += Ae, Ge.id;
      }
      function Mt() {
        return !!Ge.awaits && (--Ge.awaits == 0 && (Ge.id = 0), Ge.echoes = Ge.awaits * Ae, !0);
      }
      function Jn(e) {
        return Ge.echoes && e && e.constructor === Ue ? (vn(), e.then(function(t) {
          return Mt(), t;
        }, function(t) {
          return Mt(), Be(t);
        })) : e;
      }
      function xs() {
        var e = Xn[Xn.length - 1];
        Xn.pop(), Bt(e, !1);
      }
      function Bt(e, t) {
        var o, i = re;
        (t ? !Ge.echoes || zn++ && e === re : !zn || --zn && e === re) || queueMicrotask(t ? (function(a) {
          ++Qn, Ge.echoes && --Ge.echoes != 0 || (Ge.echoes = Ge.awaits = Ge.id = 0), Xn.push(re), Bt(a, !0);
        }).bind(null, e) : xs), e !== re && (re = e, i === ot && (ot.env = Lo()), We && (o = ot.env.Promise, t = e.env, (i.global || e.global) && (Object.defineProperty(f, "Promise", t.PromiseProp), o.all = t.all, o.race = t.race, o.resolve = t.resolve, o.reject = t.reject, t.allSettled && (o.allSettled = t.allSettled), t.any && (o.any = t.any))));
      }
      function Lo() {
        var e = f.Promise;
        return We ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function Zt(e, t, o, i, a) {
        var l = re;
        try {
          return Bt(e, !0), t(o, i, a);
        } finally {
          Bt(l, !1);
        }
      }
      function Ko(e, t, o, i) {
        return typeof e != "function" ? e : function() {
          var a = re;
          o && vn(), Bt(t, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Bt(a, !1), i && queueMicrotask(Mt);
          }
        };
      }
      function Br(e) {
        Promise === Ue && Ge.echoes === 0 ? zn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + wt).indexOf("[native code]") === -1 && (vn = Mt = S);
      var Be = J.reject, en = "￿", Dt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Fo = "String expected.", gn = [], Zn = "__dbnames", $r = "readonly", qr = "readwrite";
      function tn(e, t) {
        return e ? t ? function() {
          return e.apply(this, arguments) && t.apply(this, arguments);
        } : e : t;
      }
      var Mo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function er(e) {
        return typeof e != "string" || /\./.test(e) ? function(t) {
          return t;
        } : function(t) {
          return t[e] === void 0 && e in t && delete (t = st(t))[e], t;
        };
      }
      function Bo() {
        throw K.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Oe(e, t) {
        try {
          var o = $o(e), i = $o(t);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return t < e ? 1 : e < t ? -1 : 0;
            case "binary":
              return function(a, l) {
                for (var d = a.length, m = l.length, v = d < m ? d : m, w = 0; w < v; ++w) if (a[w] !== l[w]) return a[w] < l[w] ? -1 : 1;
                return d === m ? 0 : d < m ? -1 : 1;
              }(qo(e), qo(t));
            case "Array":
              return function(a, l) {
                for (var d = a.length, m = l.length, v = d < m ? d : m, w = 0; w < v; ++w) {
                  var O = Oe(a[w], l[w]);
                  if (O !== 0) return O;
                }
                return d === m ? 0 : d < m ? -1 : 1;
              }(e, t);
          }
        } catch {
        }
        return NaN;
      }
      function $o(e) {
        var t = typeof e;
        return t != "object" ? t : ArrayBuffer.isView(e) ? "binary" : (e = It(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function qo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function tr(e, t, o) {
        var i = e.schema.yProps;
        return i ? (t && 0 < o.numFailures && (t = t.filter(function(a, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(a) {
          return a = a.updatesTable, t ? e.db.table(a).where("k").anyOf(t).delete() : e.db.table(a).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Uo = (Ie.prototype._trans = function(e, t, o) {
        var i = this._tx || re.trans, a = this.name, l = ae && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function d(w, O, y) {
          if (!y.schema[a]) throw new K.NotFound("Table " + a + " not part of transaction");
          return t(y.idbtrans, y);
        }
        var m = mn();
        try {
          var v = i && i.db._novip === this.db._novip ? i === re.trans ? i._promise(e, d, o) : Ft(function() {
            return i._promise(e, d, o);
          }, { trans: i, transless: re.transless || re }) : function w(O, y, N, b) {
            if (O.idbdb && (O._state.openComplete || re.letThrough || O._vip)) {
              var _ = O._createTransaction(y, N, O._dbSchema);
              try {
                _.create(), O._state.PR1398_maxLoop = 3;
              } catch (E) {
                return E.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                  return w(O, y, N, b);
                })) : Be(E);
              }
              return _._promise(y, function(E, T) {
                return Ft(function() {
                  return re.trans = _, b(E, T, _);
                });
              }).then(function(E) {
                if (y === "readwrite") try {
                  _.idbtrans.commit();
                } catch {
                }
                return y === "readonly" ? E : _._completion.then(function() {
                  return E;
                });
              });
            }
            if (O._state.openComplete) return Be(new K.DatabaseClosed(O._state.dbOpenError));
            if (!O._state.isBeingOpened) {
              if (!O._state.autoOpen) return Be(new K.DatabaseClosed());
              O.open().catch(S);
            }
            return O._state.dbReadyPromise.then(function() {
              return w(O, y, N, b);
            });
          }(this.db, e, [this.name], d);
          return l && (v._consoleTask = l, v = v.catch(function(w) {
            return console.trace(w), Be(w);
          })), v;
        } finally {
          m && yn();
        }
      }, Ie.prototype.get = function(e, t) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(t) : e == null ? Be(new K.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(a) {
            return o.hook.reading.fire(a);
          });
        }).then(t);
      }, Ie.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (h(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var t = p(e);
        if (t.length === 1) return this.where(t[0]).equals(e[t[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(m) {
          if (m.compound && t.every(function(w) {
            return 0 <= m.keyPath.indexOf(w);
          })) {
            for (var v = 0; v < t.length; ++v) if (t.indexOf(m.keyPath[v]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(m, v) {
          return m.keyPath.length - v.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== en) {
          var l = o.keyPath.slice(0, t.length);
          return this.where(l).equals(l.map(function(v) {
            return e[v];
          }));
        }
        !o && ae && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var i = this.schema.idxByName;
        function a(m, v) {
          return Oe(m, v) === 0;
        }
        var d = t.reduce(function(y, v) {
          var w = y[0], O = y[1], y = i[v], N = e[v];
          return [w || y, w || !y ? tn(O, y && y.multi ? function(b) {
            return b = ne(b, v), h(b) && b.some(function(_) {
              return a(N, _);
            });
          } : function(b) {
            return a(N, ne(b, v));
          }) : O];
        }, [null, null]), l = d[0], d = d[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(d) : o ? this.filter(d) : this.where(t).equals("");
      }, Ie.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Ie.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Ie.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Ie.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Ie.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Ie.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Ie.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ie.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, h(e) ? "[".concat(e.join("+"), "]") : e));
      }, Ie.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ie.prototype.mapToClass = function(e) {
        var t, o = this.db, i = this.name;
        function a() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Bo && (function(v, w) {
          if (typeof w != "function" && w !== null) throw new TypeError("Class extends value " + String(w) + " is not a constructor or null");
          function O() {
            this.constructor = v;
          }
          s(v, w), v.prototype = w === null ? Object.create(w) : (O.prototype = w.prototype, new O());
        }(a, t = e), Object.defineProperty(a.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), a.prototype.table = function() {
          return i;
        }, e = a);
        for (var l = /* @__PURE__ */ new Set(), d = e.prototype; d; d = R(d)) Object.getOwnPropertyNames(d).forEach(function(v) {
          return l.add(v);
        });
        function m(v) {
          if (!v) return v;
          var w, O = Object.create(e.prototype);
          for (w in v) if (!l.has(w)) try {
            O[w] = v[w];
          } catch {
          }
          return O;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = m, this.hook("reading", m), e;
      }, Ie.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          g(this, e);
        });
      }, Ie.prototype.add = function(e, t) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, d = e;
        return l && a && (d = er(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "add", keys: t != null ? [t] : null, values: [d] });
        }).then(function(m) {
          return m.numFailures ? J.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            we(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.update = function(e, t) {
        return typeof e != "object" || h(e) ? this.where(":id").equals(e).modify(t) : (e = ne(e, this.schema.primKey.keyPath), e === void 0 ? Be(new K.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(t));
      }, Ie.prototype.put = function(e, t) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, d = e;
        return l && a && (d = er(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "put", values: [d], keys: t != null ? [t] : null });
        }).then(function(m) {
          return m.numFailures ? J.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            we(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.delete = function(e) {
        var t = this;
        return this._trans("readwrite", function(o) {
          return t.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return tr(t, [e], i);
          }).then(function(i) {
            return i.numFailures ? J.reject(i.failures[0]) : void 0;
          });
        });
      }, Ie.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(t) {
          return e.core.mutate({ trans: t, type: "deleteRange", range: Mo }).then(function(o) {
            return tr(e, null, o);
          });
        }).then(function(t) {
          return t.numFailures ? J.reject(t.failures[0]) : void 0;
        });
      }, Ie.prototype.bulkGet = function(e) {
        var t = this;
        return this._trans("readonly", function(o) {
          return t.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(a) {
              return t.hook.reading.fire(a);
            });
          });
        });
      }, Ie.prototype.bulkAdd = function(e, t, o) {
        var i = this, a = Array.isArray(t) ? t : void 0, l = (o = o || (a ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var w = i.schema.primKey, m = w.auto, w = w.keyPath;
          if (w && a) throw new K.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, w = w && m ? e.map(er(w)) : e;
          return i.core.mutate({ trans: d, type: "add", keys: a, values: w, wantResults: l }).then(function(_) {
            var y = _.numFailures, N = _.results, b = _.lastResult, _ = _.failures;
            if (y === 0) return l ? N : b;
            throw new Tt("".concat(i.name, ".bulkAdd(): ").concat(y, " of ").concat(v, " operations failed"), _);
          });
        });
      }, Ie.prototype.bulkPut = function(e, t, o) {
        var i = this, a = Array.isArray(t) ? t : void 0, l = (o = o || (a ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var w = i.schema.primKey, m = w.auto, w = w.keyPath;
          if (w && a) throw new K.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, w = w && m ? e.map(er(w)) : e;
          return i.core.mutate({ trans: d, type: "put", keys: a, values: w, wantResults: l }).then(function(_) {
            var y = _.numFailures, N = _.results, b = _.lastResult, _ = _.failures;
            if (y === 0) return l ? N : b;
            throw new Tt("".concat(i.name, ".bulkPut(): ").concat(y, " of ").concat(v, " operations failed"), _);
          });
        });
      }, Ie.prototype.bulkUpdate = function(e) {
        var t = this, o = this.core, i = e.map(function(d) {
          return d.key;
        }), a = e.map(function(d) {
          return d.changes;
        }), l = [];
        return this._trans("readwrite", function(d) {
          return o.getMany({ trans: d, keys: i, cache: "clone" }).then(function(m) {
            var v = [], w = [];
            e.forEach(function(y, N) {
              var b = y.key, _ = y.changes, E = m[N];
              if (E) {
                for (var T = 0, C = Object.keys(_); T < C.length; T++) {
                  var P = C[T], I = _[P];
                  if (P === t.schema.primKey.keyPath) {
                    if (Oe(I, b) !== 0) throw new K.Constraint("Cannot update primary key in bulkUpdate()");
                  } else we(E, P, I);
                }
                l.push(N), v.push(b), w.push(E);
              }
            });
            var O = v.length;
            return o.mutate({ trans: d, type: "put", keys: v, values: w, updates: { keys: i, changeSpecs: a } }).then(function(y) {
              var N = y.numFailures, b = y.failures;
              if (N === 0) return O;
              for (var _ = 0, E = Object.keys(b); _ < E.length; _++) {
                var T, C = E[_], P = l[Number(C)];
                P != null && (T = b[C], delete b[C], b[P] = T);
              }
              throw new Tt("".concat(t.name, ".bulkUpdate(): ").concat(N, " of ").concat(O, " operations failed"), b);
            });
          });
        });
      }, Ie.prototype.bulkDelete = function(e) {
        var t = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return t.core.mutate({ trans: i, type: "delete", keys: e }).then(function(a) {
            return tr(t, e, a);
          });
        }).then(function(d) {
          var a = d.numFailures, l = d.lastResult, d = d.failures;
          if (a === 0) return l;
          throw new Tt("".concat(t.name, ".bulkDelete(): ").concat(a, " of ").concat(o, " operations failed"), d);
        });
      }, Ie);
      function Ie() {
      }
      function Sn(e) {
        function t(d, m) {
          if (m) {
            for (var v = arguments.length, w = new Array(v - 1); --v; ) w[v - 1] = arguments[v];
            return o[d].subscribe.apply(null, w), e;
          }
          if (typeof d == "string") return o[d];
        }
        var o = {};
        t.addEventType = l;
        for (var i = 1, a = arguments.length; i < a; ++i) l(arguments[i]);
        return t;
        function l(d, m, v) {
          if (typeof d != "object") {
            var w;
            m = m || ge;
            var O = { subscribers: [], fire: v = v || S, subscribe: function(y) {
              O.subscribers.indexOf(y) === -1 && (O.subscribers.push(y), O.fire = m(O.fire, y));
            }, unsubscribe: function(y) {
              O.subscribers = O.subscribers.filter(function(N) {
                return N !== y;
              }), O.fire = O.subscribers.reduce(m, v);
            } };
            return o[d] = t[d] = O;
          }
          p(w = d).forEach(function(y) {
            var N = w[y];
            if (h(N)) l(y, w[y][0], w[y][1]);
            else {
              if (N !== "asap") throw new K.InvalidArgument("Invalid event config");
              var b = l(y, F, function() {
                for (var _ = arguments.length, E = new Array(_); _--; ) E[_] = arguments[_];
                b.subscribers.forEach(function(T) {
                  M(function() {
                    T.apply(null, E);
                  });
                });
              });
            }
          });
        }
      }
      function An(e, t) {
        return ce(t).from({ prototype: e }), t;
      }
      function bn(e, t) {
        return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);
      }
      function Ur(e, t) {
        e.filter = tn(e.filter, t);
      }
      function Vr(e, t, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return tn(i(), t());
        } : t, e.justLimit = o && !i;
      }
      function nr(e, t) {
        if (e.isPrimKey) return t.primaryKey;
        var o = t.getIndexByKeyPath(e.index);
        if (!o) throw new K.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return o;
      }
      function Vo(e, t, o) {
        var i = nr(e, t.schema);
        return t.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function rr(e, t, o, i) {
        var a = e.replayFilter ? tn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, d = function(m, v, w) {
            var O, y;
            a && !a(v, w, function(N) {
              return v.stop(N);
            }, function(N) {
              return v.fail(N);
            }) || ((y = "" + (O = v.primaryKey)) == "[object ArrayBuffer]" && (y = "" + new Uint8Array(O)), L(l, y) || (l[y] = !0, t(m, v, w)));
          };
          return Promise.all([e.or._iterate(d, o), Ho(Vo(e, i, o), e.algorithm, d, !e.keysOnly && e.valueMapper)]);
        }
        return Ho(Vo(e, i, o), tn(e.algorithm, a), t, !e.keysOnly && e.valueMapper);
      }
      function Ho(e, t, o, i) {
        var a = Le(i ? function(l, d, m) {
          return o(i(l), d, m);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var d = function() {
              return l.continue();
            };
            t && !t(l, function(m) {
              return d = m;
            }, function(m) {
              l.stop(m), d = S;
            }, function(m) {
              l.fail(m), d = S;
            }) || a(l.value, l, function(m) {
              return d = m;
            }), d();
          });
        });
      }
      var Pn = (Wo.prototype.execute = function(e) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var o = t.add;
          if (h(o)) return c(c([], h(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (t.remove !== void 0) {
          var i = t.remove;
          if (h(i)) return h(e) ? e.filter(function(a) {
            return !i.includes(a);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = t.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? t.replacePrefix[1] + e.substring(o.length) : e;
      }, Wo);
      function Wo(e) {
        this["@@propmod"] = e;
      }
      var Os = (Ce.prototype._read = function(e, t) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, Be.bind(null, o.error)) : o.table._trans("readonly", e).then(t);
      }, Ce.prototype._write = function(e) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, Be.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
      }, Ce.prototype._addAlgorithm = function(e) {
        var t = this._ctx;
        t.algorithm = tn(t.algorithm, e);
      }, Ce.prototype._iterate = function(e, t) {
        return rr(this._ctx, e, t, this._ctx.table.core);
      }, Ce.prototype.clone = function(e) {
        var t = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && g(o, e), t._ctx = o, t;
      }, Ce.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ce.prototype.each = function(e) {
        var t = this._ctx;
        return this._read(function(o) {
          return rr(t, e, o, t.table.core);
        });
      }, Ce.prototype.count = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx, a = i.table.core;
          if (bn(i, !0)) return a.count({ trans: o, query: { index: nr(i, a.schema), range: i.range } }).then(function(d) {
            return Math.min(d, i.limit);
          });
          var l = 0;
          return rr(i, function() {
            return ++l, !1;
          }, o, a).then(function() {
            return l;
          });
        }).then(e);
      }, Ce.prototype.sortBy = function(e, t) {
        var o = e.split(".").reverse(), i = o[0], a = o.length - 1;
        function l(v, w) {
          return w ? l(v[o[w]], w - 1) : v[i];
        }
        var d = this._ctx.dir === "next" ? 1 : -1;
        function m(v, w) {
          return Oe(l(v, a), l(w, a)) * d;
        }
        return this.toArray(function(v) {
          return v.sort(m);
        }).then(t);
      }, Ce.prototype.toArray = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx;
          if (i.dir === "next" && bn(i, !0) && 0 < i.limit) {
            var a = i.valueMapper, l = nr(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(m) {
              return m = m.result, a ? m.map(a) : m;
            });
          }
          var d = [];
          return rr(i, function(m) {
            return d.push(m);
          }, o, i.table.core).then(function() {
            return d;
          });
        }, e);
      }, Ce.prototype.offset = function(e) {
        var t = this._ctx;
        return e <= 0 || (t.offset += e, bn(t) ? Vr(t, function() {
          var o = e;
          return function(i, a) {
            return o === 0 || (o === 1 ? --o : a(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : Vr(t, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Ce.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Vr(this._ctx, function() {
          var t = e;
          return function(o, i, a) {
            return --t <= 0 && i(a), 0 <= t;
          };
        }, !0), this;
      }, Ce.prototype.until = function(e, t) {
        return Ur(this._ctx, function(o, i, a) {
          return !e(o.value) || (i(a), t);
        }), this;
      }, Ce.prototype.first = function(e) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(e);
      }, Ce.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Ce.prototype.filter = function(e) {
        var t;
        return Ur(this._ctx, function(o) {
          return e(o.value);
        }), (t = this._ctx).isMatch = tn(t.isMatch, e), this;
      }, Ce.prototype.and = function(e) {
        return this.filter(e);
      }, Ce.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Ce.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ce.prototype.desc = function() {
        return this.reverse();
      }, Ce.prototype.eachKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, Ce.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Ce.prototype.eachPrimaryKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, Ce.prototype.keys = function(e) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Ce.prototype.primaryKeys = function(e) {
        var t = this._ctx;
        if (t.dir === "next" && bn(t, !0) && 0 < t.limit) return this._read(function(i) {
          var a = nr(t, t.table.core.schema);
          return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: a, range: t.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Ce.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Ce.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(e);
      }, Ce.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Ce.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var t = {};
        return Ur(this._ctx, function(a) {
          var i = a.primaryKey.toString(), a = L(t, i);
          return t[i] = !0, !a;
        }), this;
      }, Ce.prototype.modify = function(e) {
        var t = this, o = this._ctx;
        return this._write(function(i) {
          var a, l, d;
          d = typeof e == "function" ? e : (a = p(e), l = a.length, function(C) {
            for (var P = !1, I = 0; I < l; ++I) {
              var k = a[I], V = e[k], X = ne(C, k);
              V instanceof Pn ? (we(C, k, V.execute(X)), P = !0) : X !== V && (we(C, k, V), P = !0);
            }
            return P;
          });
          var m = o.table.core, y = m.schema.primaryKey, v = y.outbound, w = y.extractKey, O = 200, y = t.db._options.modifyChunkSize;
          y && (O = typeof y == "object" ? y[m.name] || y["*"] || 200 : y);
          function N(C, k) {
            var I = k.failures, k = k.numFailures;
            _ += C - k;
            for (var V = 0, X = p(I); V < X.length; V++) {
              var H = X[V];
              b.push(I[H]);
            }
          }
          var b = [], _ = 0, E = [], T = e === Go;
          return t.clone().primaryKeys().then(function(C) {
            function P(k) {
              var V = Math.min(O, C.length - k), X = C.slice(k, k + V);
              return (T ? Promise.resolve([]) : m.getMany({ trans: i, keys: X, cache: "immutable" })).then(function(H) {
                var G = [], Q = [], z = v ? [] : null, Z = T ? X : [];
                if (!T) for (var ye = 0; ye < V; ++ye) {
                  var Te = H[ye], he = { value: st(Te), primKey: C[k + ye] };
                  d.call(he, he.value, he) !== !1 && (he.value == null ? Z.push(C[k + ye]) : v || Oe(w(Te), w(he.value)) === 0 ? (Q.push(he.value), v && z.push(C[k + ye])) : (Z.push(C[k + ye]), G.push(he.value)));
                }
                return Promise.resolve(0 < G.length && m.mutate({ trans: i, type: "add", values: G }).then(function(Ke) {
                  for (var pe in Ke.failures) Z.splice(parseInt(pe), 1);
                  N(G.length, Ke);
                })).then(function() {
                  return (0 < Q.length || I && typeof e == "object") && m.mutate({ trans: i, type: "put", keys: z, values: Q, criteria: I, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < k }).then(function(Ke) {
                    return N(Q.length, Ke);
                  });
                }).then(function() {
                  return (0 < Z.length || I && T) && m.mutate({ trans: i, type: "delete", keys: Z, criteria: I, isAdditionalChunk: 0 < k }).then(function(Ke) {
                    return tr(o.table, Z, Ke);
                  }).then(function(Ke) {
                    return N(Z.length, Ke);
                  });
                }).then(function() {
                  return C.length > k + V && P(k + O);
                });
              });
            }
            var I = bn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return P(0).then(function() {
              if (0 < b.length) throw new fn("Error modifying one or more objects", b, _, E);
              return C.length;
            });
          });
        });
      }, Ce.prototype.delete = function() {
        var e = this._ctx, t = e.range;
        return !bn(e) || e.table.schema.yProps || !e.isPrimKey && t.type !== 3 ? this.modify(Go) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, a = t;
          return e.table.core.count({ trans: o, query: { index: i, range: a } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: a }).then(function(v) {
              var m = v.failures, v = v.numFailures;
              if (v) throw new fn("Could not delete some values", Object.keys(m).map(function(w) {
                return m[w];
              }), l - v);
              return l - v;
            });
          });
        });
      }, Ce);
      function Ce() {
      }
      var Go = function(e, t) {
        return t.value = null;
      };
      function Ts(e, t) {
        return e < t ? -1 : e === t ? 0 : 1;
      }
      function Es(e, t) {
        return t < e ? -1 : e === t ? 0 : 1;
      }
      function pt(e, t, o) {
        return e = e instanceof Xo ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(t), e;
      }
      function wn(e) {
        return new e.Collection(e, function() {
          return Yo("");
        }).limit(0);
      }
      function or(e, t, o, i) {
        var a, l, d, m, v, w, O, y = o.length;
        if (!o.every(function(_) {
          return typeof _ == "string";
        })) return pt(e, Fo);
        function N(_) {
          a = _ === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = _ === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, d = _ === "next" ? Ts : Es;
          var E = o.map(function(T) {
            return { lower: l(T), upper: a(T) };
          }).sort(function(T, C) {
            return d(T.lower, C.lower);
          });
          m = E.map(function(T) {
            return T.upper;
          }), v = E.map(function(T) {
            return T.lower;
          }), O = (w = _) === "next" ? "" : i;
        }
        N("next"), e = new e.Collection(e, function() {
          return $t(m[0], v[y - 1] + i);
        }), e._ondirectionchange = function(_) {
          N(_);
        };
        var b = 0;
        return e._addAlgorithm(function(_, E, T) {
          var C = _.key;
          if (typeof C != "string") return !1;
          var P = l(C);
          if (t(P, v, b)) return !0;
          for (var I = null, k = b; k < y; ++k) {
            var V = function(X, H, G, Q, z, Z) {
              for (var ye = Math.min(X.length, Q.length), Te = -1, he = 0; he < ye; ++he) {
                var Ke = H[he];
                if (Ke !== Q[he]) return z(X[he], G[he]) < 0 ? X.substr(0, he) + G[he] + G.substr(he + 1) : z(X[he], Q[he]) < 0 ? X.substr(0, he) + Q[he] + G.substr(he + 1) : 0 <= Te ? X.substr(0, Te) + H[Te] + G.substr(Te + 1) : null;
                z(X[he], Ke) < 0 && (Te = he);
              }
              return ye < Q.length && Z === "next" ? X + G.substr(X.length) : ye < X.length && Z === "prev" ? X.substr(0, G.length) : Te < 0 ? null : X.substr(0, Te) + Q[Te] + G.substr(Te + 1);
            }(C, P, m[k], v[k], d, w);
            V === null && I === null ? b = k + 1 : (I === null || 0 < d(I, V)) && (I = V);
          }
          return E(I !== null ? function() {
            _.continue(I + O);
          } : T), !1;
        }), e;
      }
      function $t(e, t, o, i) {
        return { type: 2, lower: e, upper: t, lowerOpen: o, upperOpen: i };
      }
      function Yo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var Xo = (Object.defineProperty(Ye.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Ye.prototype.between = function(e, t, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, t) || this._cmp(e, t) === 0 && (o || i) && (!o || !i) ? wn(this) : new this.Collection(this, function() {
            return $t(e, t, !o, !i);
          });
        } catch {
          return pt(this, Dt);
        }
      }, Ye.prototype.equals = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return Yo(e);
        });
      }, Ye.prototype.above = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(e, void 0, !0);
        });
      }, Ye.prototype.aboveOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(e, void 0, !1);
        });
      }, Ye.prototype.below = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(void 0, e, !1, !0);
        });
      }, Ye.prototype.belowOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(void 0, e);
        });
      }, Ye.prototype.startsWith = function(e) {
        return typeof e != "string" ? pt(this, Fo) : this.between(e, e + en, !0, !0);
      }, Ye.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : or(this, function(t, o) {
          return t.indexOf(o[0]) === 0;
        }, [e], en);
      }, Ye.prototype.equalsIgnoreCase = function(e) {
        return or(this, function(t, o) {
          return t === o[0];
        }, [e], "");
      }, Ye.prototype.anyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? wn(this) : or(this, function(t, o) {
          return o.indexOf(t) !== -1;
        }, e, "");
      }, Ye.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? wn(this) : or(this, function(t, o) {
          return o.some(function(i) {
            return t.indexOf(i) === 0;
          });
        }, e, en);
      }, Ye.prototype.anyOf = function() {
        var e = this, t = ct.apply(bt, arguments), o = this._cmp;
        try {
          t.sort(o);
        } catch {
          return pt(this, Dt);
        }
        if (t.length === 0) return wn(this);
        var i = new this.Collection(this, function() {
          return $t(t[0], t[t.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, t.sort(o);
        };
        var a = 0;
        return i._addAlgorithm(function(l, d, m) {
          for (var v = l.key; 0 < o(v, t[a]); ) if (++a === t.length) return d(m), !1;
          return o(v, t[a]) === 0 || (d(function() {
            l.continue(t[a]);
          }), !1);
        }), i;
      }, Ye.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.noneOf = function() {
        var e = ct.apply(bt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return pt(this, Dt);
        }
        var t = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.inAnyRange = function(C, t) {
        var o = this, i = this._cmp, a = this._ascending, l = this._descending, d = this._min, m = this._max;
        if (C.length === 0) return wn(this);
        if (!C.every(function(P) {
          return P[0] !== void 0 && P[1] !== void 0 && a(P[0], P[1]) <= 0;
        })) return pt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", K.InvalidArgument);
        var v = !t || t.includeLowers !== !1, w = t && t.includeUppers === !0, O, y = a;
        function N(P, I) {
          return y(P[0], I[0]);
        }
        try {
          (O = C.reduce(function(P, I) {
            for (var k = 0, V = P.length; k < V; ++k) {
              var X = P[k];
              if (i(I[0], X[1]) < 0 && 0 < i(I[1], X[0])) {
                X[0] = d(X[0], I[0]), X[1] = m(X[1], I[1]);
                break;
              }
            }
            return k === V && P.push(I), P;
          }, [])).sort(N);
        } catch {
          return pt(this, Dt);
        }
        var b = 0, _ = w ? function(P) {
          return 0 < a(P, O[b][1]);
        } : function(P) {
          return 0 <= a(P, O[b][1]);
        }, E = v ? function(P) {
          return 0 < l(P, O[b][0]);
        } : function(P) {
          return 0 <= l(P, O[b][0]);
        }, T = _, C = new this.Collection(this, function() {
          return $t(O[0][0], O[O.length - 1][1], !v, !w);
        });
        return C._ondirectionchange = function(P) {
          y = P === "next" ? (T = _, a) : (T = E, l), O.sort(N);
        }, C._addAlgorithm(function(P, I, k) {
          for (var V, X = P.key; T(X); ) if (++b === O.length) return I(k), !1;
          return !_(V = X) && !E(V) || (o._cmp(X, O[b][1]) === 0 || o._cmp(X, O[b][0]) === 0 || I(function() {
            y === a ? P.continue(O[b][0]) : P.continue(O[b][1]);
          }), !1);
        }), C;
      }, Ye.prototype.startsWithAnyOf = function() {
        var e = ct.apply(bt, arguments);
        return e.every(function(t) {
          return typeof t == "string";
        }) ? e.length === 0 ? wn(this) : this.inAnyRange(e.map(function(t) {
          return [t, t + en];
        })) : pt(this, "startsWithAnyOf() only works with strings");
      }, Ye);
      function Ye() {
      }
      function Et(e) {
        return Le(function(t) {
          return Dn(t), e(t.target.error), !1;
        });
      }
      function Dn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Rn = "storagemutated", Hr = "x-storagemutated-1", qt = Sn(null, Rn), Ns = (Nt.prototype._lock = function() {
        return q(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, Nt.prototype._unlock = function() {
        if (q(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            Zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Nt.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, Nt.prototype.create = function(e) {
        var t = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (q(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new K.DatabaseClosed(i);
          case "MissingAPIError":
            throw new K.MissingAPI(i.message, i);
          default:
            throw new K.OpenFailed(i);
        }
        if (!this.active) throw new K.TransactionInactive();
        return q(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Le(function(a) {
          Dn(a), t._reject(e.error);
        }), e.onabort = Le(function(a) {
          Dn(a), t.active && t._reject(new K.Abort(e.error)), t.active = !1, t.on("abort").fire(a);
        }), e.oncomplete = Le(function() {
          t.active = !1, t._resolve(), "mutatedParts" in e && qt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Nt.prototype._promise = function(e, t, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return Be(new K.ReadOnly("Transaction is readonly"));
        if (!this.active) return Be(new K.TransactionInactive());
        if (this._locked()) return new J(function(l, d) {
          i._blockedFuncs.push([function() {
            i._promise(e, t, o).then(l, d);
          }, re]);
        });
        if (o) return Ft(function() {
          var l = new J(function(d, m) {
            i._lock();
            var v = t(d, m, i);
            v && v.then && v.then(d, m);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var a = new J(function(l, d) {
          var m = t(l, d, i);
          m && m.then && m.then(l, d);
        });
        return a._lib = !0, a;
      }, Nt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Nt.prototype.waitFor = function(e) {
        var t, o = this._root(), i = J.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], t = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (t.get(-1 / 0).onsuccess = l);
        }());
        var a = o._waitingFor;
        return new J(function(l, d) {
          i.then(function(m) {
            return o._waitingQueue.push(Le(l.bind(null, m)));
          }, function(m) {
            return o._waitingQueue.push(Le(d.bind(null, m)));
          }).finally(function() {
            o._waitingFor === a && (o._waitingFor = null);
          });
        });
      }, Nt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new K.Abort()));
      }, Nt.prototype.table = function(e) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (L(t, e)) return t[e];
        var o = this.schema[e];
        if (!o) throw new K.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), t[e] = o;
      }, Nt);
      function Nt() {
      }
      function Wr(e, t, o, i, a, l, d, m) {
        return { name: e, keyPath: t, unique: o, multi: i, auto: a, compound: l, src: (o && !d ? "&" : "") + (i ? "*" : "") + (a ? "++" : "") + zo(t), type: m };
      }
      function zo(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Gr(e, t, o) {
        return { name: e, primKey: t, indexes: o, mappedClass: null, idxByName: (i = function(a) {
          return [a.name, a];
        }, o.reduce(function(a, l, d) {
          return d = i(l, d), d && (a[d[0]] = d[1]), a;
        }, {})) };
        var i;
      }
      var In = function(e) {
        try {
          return e.only([[]]), In = function() {
            return [[]];
          }, [[]];
        } catch {
          return In = function() {
            return en;
          }, en;
        }
      };
      function Yr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (t = e).split(".").length === 1 ? function(o) {
          return o[t];
        } : function(o) {
          return ne(o, t);
        } : function(o) {
          return ne(o, e);
        };
        var t;
      }
      function Qo(e) {
        return [].slice.call(e);
      }
      var Cs = 0;
      function kn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Ss(e, t, v) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var b = T.lower, _ = T.upper, E = T.lowerOpen, T = T.upperOpen;
          return b === void 0 ? _ === void 0 ? null : t.upperBound(_, !!T) : _ === void 0 ? t.lowerBound(b, !!E) : t.bound(b, _, !!E, !!T);
        }
        function a(N) {
          var b, _ = N.name;
          return { name: _, schema: N, mutate: function(E) {
            var T = E.trans, C = E.type, P = E.keys, I = E.values, k = E.range;
            return new Promise(function(V, X) {
              V = Le(V);
              var H = T.objectStore(_), G = H.keyPath == null, Q = C === "put" || C === "add";
              if (!Q && C !== "delete" && C !== "deleteRange") throw new Error("Invalid operation type: " + C);
              var z, Z = (P || I || { length: 1 }).length;
              if (P && I && P.length !== I.length) throw new Error("Given keys array must have same length as given values array.");
              if (Z === 0) return V({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ye(it) {
                ++Ke, Dn(it);
              }
              var Te = [], he = [], Ke = 0;
              if (C === "deleteRange") {
                if (k.type === 4) return V({ numFailures: Ke, failures: he, results: [], lastResult: void 0 });
                k.type === 3 ? Te.push(z = H.clear()) : Te.push(z = H.delete(i(k)));
              } else {
                var G = Q ? G ? [I, P] : [I, null] : [P, null], pe = G[0], Je = G[1];
                if (Q) for (var Ze = 0; Ze < Z; ++Ze) Te.push(z = Je && Je[Ze] !== void 0 ? H[C](pe[Ze], Je[Ze]) : H[C](pe[Ze])), z.onerror = ye;
                else for (Ze = 0; Ze < Z; ++Ze) Te.push(z = H[C](pe[Ze])), z.onerror = ye;
              }
              function yr(it) {
                it = it.target.result, Te.forEach(function(on, po) {
                  return on.error != null && (he[po] = on.error);
                }), V({ numFailures: Ke, failures: he, results: C === "delete" ? P : Te.map(function(on) {
                  return on.result;
                }), lastResult: it });
              }
              z.onerror = function(it) {
                ye(it), yr(it);
              }, z.onsuccess = yr;
            });
          }, getMany: function(E) {
            var T = E.trans, C = E.keys;
            return new Promise(function(P, I) {
              P = Le(P);
              for (var k, V = T.objectStore(_), X = C.length, H = new Array(X), G = 0, Q = 0, z = function(Te) {
                Te = Te.target, H[Te._pos] = Te.result, ++Q === G && P(H);
              }, Z = Et(I), ye = 0; ye < X; ++ye) C[ye] != null && ((k = V.get(C[ye]))._pos = ye, k.onsuccess = z, k.onerror = Z, ++G);
              G === 0 && P(H);
            });
          }, get: function(E) {
            var T = E.trans, C = E.key;
            return new Promise(function(P, I) {
              P = Le(P);
              var k = T.objectStore(_).get(C);
              k.onsuccess = function(V) {
                return P(V.target.result);
              }, k.onerror = Et(I);
            });
          }, query: (b = w, function(E) {
            return new Promise(function(T, C) {
              T = Le(T);
              var P, I, k, G = E.trans, V = E.values, X = E.limit, z = E.query, H = X === 1 / 0 ? void 0 : X, Q = z.index, z = z.range, G = G.objectStore(_), Q = Q.isPrimaryKey ? G : G.index(Q.name), z = i(z);
              if (X === 0) return T({ result: [] });
              b ? ((H = V ? Q.getAll(z, H) : Q.getAllKeys(z, H)).onsuccess = function(Z) {
                return T({ result: Z.target.result });
              }, H.onerror = Et(C)) : (P = 0, I = !V && "openKeyCursor" in Q ? Q.openKeyCursor(z) : Q.openCursor(z), k = [], I.onsuccess = function(Z) {
                var ye = I.result;
                return ye ? (k.push(V ? ye.value : ye.primaryKey), ++P === X ? T({ result: k }) : void ye.continue()) : T({ result: k });
              }, I.onerror = Et(C));
            });
          }), openCursor: function(E) {
            var T = E.trans, C = E.values, P = E.query, I = E.reverse, k = E.unique;
            return new Promise(function(V, X) {
              V = Le(V);
              var Q = P.index, H = P.range, G = T.objectStore(_), G = Q.isPrimaryKey ? G : G.index(Q.name), Q = I ? k ? "prevunique" : "prev" : k ? "nextunique" : "next", z = !C && "openKeyCursor" in G ? G.openKeyCursor(i(H), Q) : G.openCursor(i(H), Q);
              z.onerror = Et(X), z.onsuccess = Le(function(Z) {
                var ye, Te, he, Ke, pe = z.result;
                pe ? (pe.___id = ++Cs, pe.done = !1, ye = pe.continue.bind(pe), Te = (Te = pe.continuePrimaryKey) && Te.bind(pe), he = pe.advance.bind(pe), Ke = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = T, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Le(X), pe.next = function() {
                  var Je = this, Ze = 1;
                  return this.start(function() {
                    return Ze-- ? Je.continue() : Je.stop();
                  }).then(function() {
                    return Je;
                  });
                }, pe.start = function(Je) {
                  function Ze() {
                    if (z.result) try {
                      Je();
                    } catch (it) {
                      pe.fail(it);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var yr = new Promise(function(it, on) {
                    it = Le(it), z.onerror = Et(on), pe.fail = on, pe.stop = function(po) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ke, it(po);
                    };
                  });
                  return z.onsuccess = Le(function(it) {
                    z.onsuccess = Ze, Ze();
                  }), pe.continue = ye, pe.continuePrimaryKey = Te, pe.advance = he, Ze(), yr;
                }, V(pe)) : V(null);
              }, X);
            });
          }, count: function(E) {
            var T = E.query, C = E.trans, P = T.index, I = T.range;
            return new Promise(function(k, V) {
              var X = C.objectStore(_), H = P.isPrimaryKey ? X : X.index(P.name), X = i(I), H = X ? H.count(X) : H.count();
              H.onsuccess = Le(function(G) {
                return k(G.target.result);
              }), H.onerror = Et(V);
            });
          } };
        }
        var l, d, m, O = (d = v, m = Qo((l = e).objectStoreNames), { schema: { name: l.name, tables: m.map(function(N) {
          return d.objectStore(N);
        }).map(function(N) {
          var b = N.keyPath, T = N.autoIncrement, _ = h(b), E = {}, T = { name: N.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: b == null, compound: _, keyPath: b, autoIncrement: T, unique: !0, extractKey: Yr(b) }, indexes: Qo(N.indexNames).map(function(C) {
            return N.index(C);
          }).map(function(k) {
            var P = k.name, I = k.unique, V = k.multiEntry, k = k.keyPath, V = { name: P, compound: h(k), keyPath: k, unique: I, multiEntry: V, extractKey: Yr(k) };
            return E[kn(k)] = V;
          }), getIndexByKeyPath: function(C) {
            return E[kn(C)];
          } };
          return E[":id"] = T.primaryKey, b != null && (E[kn(b)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < m.length && "getAll" in d.objectStore(m[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), v = O.schema, w = O.hasGetAll, O = v.tables.map(a), y = {};
        return O.forEach(function(N) {
          return y[N.name] = N;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(N) {
          if (!y[N]) throw new Error("Table '".concat(N, "' not found"));
          return y[N];
        }, MIN_KEY: -1 / 0, MAX_KEY: In(t), schema: v };
      }
      function As(e, t, o, i) {
        var a = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = Ss(t, a, i), e.dbcore.reduce(function(l, d) {
          return d = d.create, u(u({}, l), d(l));
        }, i)) };
      }
      function ir(e, i) {
        var o = i.db, i = As(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(a) {
          var l = a.name;
          e.core.schema.tables.some(function(d) {
            return d.name === l;
          }) && (a.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = a.core));
        });
      }
      function sr(e, t, o, i) {
        o.forEach(function(a) {
          var l = i[a];
          t.forEach(function(d) {
            var m = function v(w, O) {
              return xe(w, O) || (w = R(w)) && v(w, O);
            }(d, a);
            (!m || "value" in m && m.value === void 0) && (d === e.Transaction.prototype || d instanceof e.Transaction ? ie(d, a, { get: function() {
              return this.table(a);
            }, set: function(v) {
              ee(this, a, { value: v, writable: !0, configurable: !0, enumerable: !0 });
            } }) : d[a] = new e.Table(a, l));
          });
        });
      }
      function Xr(e, t) {
        t.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function Ps(e, t) {
        return e._cfg.version - t._cfg.version;
      }
      function Ds(e, t, o, i) {
        var a = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !a.$meta && (a.$meta = Gr("$meta", Zo("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, a);
        l.create(o), l._completion.catch(i);
        var d = l._reject.bind(l), m = re.transless || re;
        Ft(function() {
          return re.trans = l, re.transless = m, t !== 0 ? (ir(e, o), w = t, ((v = l).storeNames.includes("$meta") ? v.table("$meta").get("version").then(function(O) {
            return O ?? w;
          }) : J.resolve(w)).then(function(O) {
            return N = O, b = l, _ = o, E = [], O = (y = e)._versions, T = y._dbSchema = ur(0, y.idbdb, _), (O = O.filter(function(C) {
              return C._cfg.version >= N;
            })).length !== 0 ? (O.forEach(function(C) {
              E.push(function() {
                var P = T, I = C._cfg.dbschema;
                lr(y, P, _), lr(y, I, _), T = y._dbSchema = I;
                var k = zr(P, I);
                k.add.forEach(function(Q) {
                  Qr(_, Q[0], Q[1].primKey, Q[1].indexes);
                }), k.change.forEach(function(Q) {
                  if (Q.recreate) throw new K.Upgrade("Not yet support for changing primary key");
                  var z = _.objectStore(Q.name);
                  Q.add.forEach(function(Z) {
                    return ar(z, Z);
                  }), Q.change.forEach(function(Z) {
                    z.deleteIndex(Z.name), ar(z, Z);
                  }), Q.del.forEach(function(Z) {
                    return z.deleteIndex(Z);
                  });
                });
                var V = C._cfg.contentUpgrade;
                if (V && C._cfg.version > N) {
                  ir(y, _), b._memoizedTables = {};
                  var X = _e(I);
                  k.del.forEach(function(Q) {
                    X[Q] = P[Q];
                  }), Xr(y, [y.Transaction.prototype]), sr(y, [y.Transaction.prototype], p(X), X), b.schema = X;
                  var H, G = _t(V);
                  return G && vn(), k = J.follow(function() {
                    var Q;
                    (H = V(b)) && G && (Q = Mt.bind(null, null), H.then(Q, Q));
                  }), H && typeof H.then == "function" ? J.resolve(H) : k.then(function() {
                    return H;
                  });
                }
              }), E.push(function(P) {
                var I, k, V = C._cfg.dbschema;
                I = V, k = P, [].slice.call(k.db.objectStoreNames).forEach(function(X) {
                  return I[X] == null && k.db.deleteObjectStore(X);
                }), Xr(y, [y.Transaction.prototype]), sr(y, [y.Transaction.prototype], y._storeNames, y._dbSchema), b.schema = y._dbSchema;
              }), E.push(function(P) {
                y.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(y.idbdb.version / 10) === C._cfg.version ? (y.idbdb.deleteObjectStore("$meta"), delete y._dbSchema.$meta, y._storeNames = y._storeNames.filter(function(I) {
                  return I !== "$meta";
                })) : P.objectStore("$meta").put(C._cfg.version, "version"));
              });
            }), function C() {
              return E.length ? J.resolve(E.shift()(b.idbtrans)).then(C) : J.resolve();
            }().then(function() {
              Jo(T, _);
            })) : J.resolve();
            var y, N, b, _, E, T;
          }).catch(d)) : (p(a).forEach(function(O) {
            Qr(o, O, a[O].primKey, a[O].indexes);
          }), ir(e, o), void J.follow(function() {
            return e.on.populate.fire(l);
          }).catch(d));
          var v, w;
        });
      }
      function Rs(e, t) {
        Jo(e._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var o = ur(0, e.idbdb, t);
        lr(e, e._dbSchema, t);
        for (var i = 0, a = zr(o, e._dbSchema).change; i < a.length; i++) {
          var l = function(d) {
            if (d.change.length || d.recreate) return console.warn("Unable to patch indexes of table ".concat(d.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var m = t.objectStore(d.name);
            d.add.forEach(function(v) {
              ae && console.debug("Dexie upgrade patch: Creating missing index ".concat(d.name, ".").concat(v.src)), ar(m, v);
            });
          }(a[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function zr(e, t) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) t[o] || i.del.push(o);
        for (o in t) {
          var a = e[o], l = t[o];
          if (a) {
            var d = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (a.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || a.primKey.auto !== l.primKey.auto) d.recreate = !0, i.change.push(d);
            else {
              var m = a.idxByName, v = l.idxByName, w = void 0;
              for (w in m) v[w] || d.del.push(w);
              for (w in v) {
                var O = m[w], y = v[w];
                O ? O.src !== y.src && d.change.push(y) : d.add.push(y);
              }
              (0 < d.del.length || 0 < d.add.length || 0 < d.change.length) && i.change.push(d);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Qr(e, t, o, i) {
        var a = e.db.createObjectStore(t, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return ar(a, l);
        }), a;
      }
      function Jo(e, t) {
        p(e).forEach(function(o) {
          t.db.objectStoreNames.contains(o) || (ae && console.debug("Dexie: Creating missing table", o), Qr(t, o, e[o].primKey, e[o].indexes));
        });
      }
      function ar(e, t) {
        e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function ur(e, t, o) {
        var i = {};
        return U(t.objectStoreNames, 0).forEach(function(a) {
          for (var l = o.objectStore(a), d = Wr(zo(w = l.keyPath), w || "", !0, !1, !!l.autoIncrement, w && typeof w != "string", !0), m = [], v = 0; v < l.indexNames.length; ++v) {
            var O = l.index(l.indexNames[v]), w = O.keyPath, O = Wr(O.name, w, !!O.unique, !!O.multiEntry, !1, w && typeof w != "string", !1);
            m.push(O);
          }
          i[a] = Gr(a, d, m);
        }), i;
      }
      function lr(e, t, o) {
        for (var i = o.db.objectStoreNames, a = 0; a < i.length; ++a) {
          var l = i[a], d = o.objectStore(l);
          e._hasGetAll = "getAll" in d;
          for (var m = 0; m < d.indexNames.length; ++m) {
            var v = d.indexNames[m], w = d.index(v).keyPath, O = typeof w == "string" ? w : "[" + U(w).join("+") + "]";
            !t[l] || (w = t[l].idxByName[O]) && (w.name = v, delete t[l].idxByName[O], t[l].idxByName[v] = w);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function Zo(e) {
        return e.split(",").map(function(t, o) {
          var l = t.split(":"), i = (a = l[1]) === null || a === void 0 ? void 0 : a.trim(), a = (t = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(a) ? a.match(/^\[(.*)\]$/)[1].split("+") : a;
          return Wr(a, l || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), h(l), o === 0, i);
        });
      }
      var Is = (_n.prototype._createTableSchema = Gr, _n.prototype._parseIndexSyntax = Zo, _n.prototype._parseStoresSpec = function(e, t) {
        var o = this;
        p(e).forEach(function(i) {
          if (e[i] !== null) {
            var a = o._parseIndexSyntax(e[i]), l = a.shift();
            if (!l) throw new K.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new K.Schema("Primary key cannot be multiEntry*");
            a.forEach(function(d) {
              if (d.auto) throw new K.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!d.keyPath) throw new K.Schema("Index must have a name and cannot be an empty string");
            }), a = o._createTableSchema(i, l, a), t[i] = a;
          }
        });
      }, _n.prototype.stores = function(o) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? g(this._cfg.storesSource, o) : o;
        var o = t._versions, i = {}, a = {};
        return o.forEach(function(l) {
          g(i, l._cfg.storesSource), a = l._cfg.dbschema = {}, l._parseStoresSpec(i, a);
        }), t._dbSchema = a, Xr(t, [t._allTables, t, t.Transaction.prototype]), sr(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], p(a), a), t._storeNames = p(a), this;
      }, _n.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = de(this._cfg.contentUpgrade || S, e), this;
      }, _n);
      function _n() {
      }
      function Jr(e, t) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Rt(Zn, { addons: [], indexedDB: e, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function Zr(e) {
        return e && typeof e.databases == "function";
      }
      function eo(e) {
        return Ft(function() {
          return re.letThrough = !0, e();
        });
      }
      function to(e) {
        return !("from" in e);
      }
      var Qe = function(e, t) {
        if (!this) {
          var o = new Qe();
          return e && "d" in e && g(o, e), o;
        }
        g(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? t : e } : { d: 0 });
      };
      function jn(e, t, o) {
        var i = Oe(t, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (to(e)) return g(e, { from: t, to: o, d: 1 });
          var a = e.l, i = e.r;
          if (Oe(o, e.from) < 0) return a ? jn(a, t, o) : e.l = { from: t, to: o, d: 1, l: null, r: null }, ti(e);
          if (0 < Oe(t, e.to)) return i ? jn(i, t, o) : e.r = { from: t, to: o, d: 1, l: null, r: null }, ti(e);
          Oe(t, e.from) < 0 && (e.from = t, e.l = null, e.d = i ? i.d + 1 : 1), 0 < Oe(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, a && !e.l && Ln(e, a), i && o && Ln(e, i);
        }
      }
      function Ln(e, t) {
        to(t) || function o(i, v) {
          var l = v.from, d = v.to, m = v.l, v = v.r;
          jn(i, l, d), m && o(i, m), v && o(i, v);
        }(e, t);
      }
      function ei(e, t) {
        var o = cr(t), i = o.next();
        if (i.done) return !1;
        for (var a = i.value, l = cr(e), d = l.next(a.from), m = d.value; !i.done && !d.done; ) {
          if (Oe(m.from, a.to) <= 0 && 0 <= Oe(m.to, a.from)) return !0;
          Oe(a.from, m.from) < 0 ? a = (i = o.next(m.from)).value : m = (d = l.next(a.from)).value;
        }
        return !1;
      }
      function cr(e) {
        var t = to(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, i) for (; t.n.l && Oe(o, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !i || Oe(o, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function ti(e) {
        var t, o, i = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), a = 1 < i ? "r" : i < -1 ? "l" : "";
        a && (t = a == "r" ? "l" : "r", o = u({}, e), i = e[a], e.from = i.from, e.to = i.to, e[a] = i[a], o[a] = i[t], (e[t] = o).d = ni(o)), e.d = ni(e);
      }
      function ni(o) {
        var t = o.r, o = o.l;
        return (t ? o ? Math.max(t.d, o.d) : t.d : o ? o.d : 0) + 1;
      }
      function fr(e, t) {
        return p(t).forEach(function(o) {
          e[o] ? Ln(e[o], t[o]) : e[o] = function i(a) {
            var l, d, m = {};
            for (l in a) L(a, l) && (d = a[l], m[l] = !d || typeof d != "object" || dt.has(d.constructor) ? d : i(d));
            return m;
          }(t[o]);
        }), e;
      }
      function no(e, t) {
        return e.all || t.all || Object.keys(e).some(function(o) {
          return t[o] && ei(t[o], e[o]);
        });
      }
      B(Qe.prototype, ((wt = { add: function(e) {
        return Ln(this, e), this;
      }, addKey: function(e) {
        return jn(this, e, e), this;
      }, addKeys: function(e) {
        var t = this;
        return e.forEach(function(o) {
          return jn(t, o, o);
        }), this;
      }, hasKey: function(e) {
        var t = cr(this).next(e).value;
        return t && Oe(t.from, e) <= 0 && 0 <= Oe(t.to, e);
      } })[nt] = function() {
        return cr(this);
      }, wt));
      var nn = {}, ro = {}, oo = !1;
      function dr(e) {
        fr(ro, e), oo || (oo = !0, setTimeout(function() {
          oo = !1, io(ro, !(ro = {}));
        }, 0));
      }
      function io(e, t) {
        t === void 0 && (t = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, a = Object.values(nn); i < a.length; i++) ri(d = a[i], e, o, t);
        else for (var l in e) {
          var d, m = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          m && (l = m[1], m = m[2], (d = nn["idb://".concat(l, "/").concat(m)]) && ri(d, e, o, t));
        }
        o.forEach(function(v) {
          return v();
        });
      }
      function ri(e, t, o, i) {
        for (var a = [], l = 0, d = Object.entries(e.queries.query); l < d.length; l++) {
          for (var m = d[l], v = m[0], w = [], O = 0, y = m[1]; O < y.length; O++) {
            var N = y[O];
            no(t, N.obsSet) ? N.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && w.push(N);
          }
          i && a.push([v, w]);
        }
        if (i) for (var b = 0, _ = a; b < _.length; b++) {
          var E = _[b], v = E[0], w = E[1];
          e.queries.query[v] = w;
        }
      }
      function ks(e) {
        var t = e._state, o = e._deps.indexedDB;
        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? Be(t.dbOpenError) : e;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var i = t.openCanceller, a = Math.round(10 * e.verno), l = !1;
        function d() {
          if (t.openCanceller !== i) throw new K.DatabaseClosed("db.open() was cancelled");
        }
        function m() {
          return new J(function(N, b) {
            if (d(), !o) throw new K.MissingAPI();
            var _ = e.name, E = t.autoSchema || !a ? o.open(_) : o.open(_, a);
            if (!E) throw new K.MissingAPI();
            E.onerror = Et(b), E.onblocked = Le(e._fireOnBlocked), E.onupgradeneeded = Le(function(T) {
              var C;
              O = E.transaction, t.autoSchema && !e._options.allowEmptyDB ? (E.onerror = Dn, O.abort(), E.result.close(), (C = o.deleteDatabase(_)).onsuccess = C.onerror = Le(function() {
                b(new K.NoSuchDatabase("Database ".concat(_, " doesnt exist")));
              })) : (O.onerror = Et(b), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, y = T < 1, e.idbdb = E.result, l && Rs(e, O), Ds(e, T / 10, O, b));
            }, b), E.onsuccess = Le(function() {
              O = null;
              var T, C, P, I, k, V = e.idbdb = E.result, X = U(V.objectStoreNames);
              if (0 < X.length) try {
                var H = V.transaction((I = X).length === 1 ? I[0] : I, "readonly");
                if (t.autoSchema) C = V, P = H, (T = e).verno = C.version / 10, P = T._dbSchema = ur(0, C, P), T._storeNames = U(C.objectStoreNames, 0), sr(T, [T._allTables], p(P), P);
                else if (lr(e, e._dbSchema, H), ((k = zr(ur(0, (k = e).idbdb, H), k._dbSchema)).add.length || k.change.some(function(G) {
                  return G.add.length || G.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), V.close(), a = V.version + 1, l = !0, N(m());
                ir(e, H);
              } catch {
              }
              gn.push(e), V.onversionchange = Le(function(G) {
                t.vcFired = !0, e.on("versionchange").fire(G);
              }), V.onclose = Le(function(G) {
                e.on("close").fire(G);
              }), y && (k = e._deps, H = _, V = k.indexedDB, k = k.IDBKeyRange, Zr(V) || H === Zn || Jr(V, k).put({ name: H }).catch(S)), N();
            }, b);
          }).catch(function(N) {
            switch (N?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), m();
                break;
              case "VersionError":
                if (0 < a) return a = 0, m();
            }
            return J.reject(N);
          });
        }
        var v, w = t.dbReadyResolve, O = null, y = !1;
        return J.race([i, (typeof navigator > "u" ? J.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(N) {
          function b() {
            return indexedDB.databases().finally(N);
          }
          v = setInterval(b, 100), b();
        }).finally(function() {
          return clearInterval(v);
        }) : Promise.resolve()).then(m)]).then(function() {
          return d(), t.onReadyBeingFired = [], J.resolve(eo(function() {
            return e.on.ready.fire(e.vip);
          })).then(function N() {
            if (0 < t.onReadyBeingFired.length) {
              var b = t.onReadyBeingFired.reduce(de, S);
              return t.onReadyBeingFired = [], J.resolve(eo(function() {
                return b(e.vip);
              })).then(N);
            }
          });
        }).finally(function() {
          t.openCanceller === i && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(N) {
          t.dbOpenError = N;
          try {
            O && O.abort();
          } catch {
          }
          return i === t.openCanceller && e._close(), Be(N);
        }).finally(function() {
          t.openComplete = !0, w();
        }).then(function() {
          var N;
          return y && (N = {}, e.tables.forEach(function(b) {
            b.schema.indexes.forEach(function(_) {
              _.name && (N["idb://".concat(e.name, "/").concat(b.name, "/").concat(_.name)] = new Qe(-1 / 0, [[[]]]));
            }), N["idb://".concat(e.name, "/").concat(b.name, "/")] = N["idb://".concat(e.name, "/").concat(b.name, "/:dels")] = new Qe(-1 / 0, [[[]]]);
          }), qt(Rn).fire(N), io(N, !0)), e;
        });
      }
      function so(e) {
        function t(l) {
          return e.next(l);
        }
        var o = a(t), i = a(function(l) {
          return e.throw(l);
        });
        function a(l) {
          return function(v) {
            var m = l(v), v = m.value;
            return m.done ? v : v && typeof v.then == "function" ? v.then(o, i) : h(v) ? Promise.all(v).then(o, i) : o(v);
          };
        }
        return a(t)();
      }
      function pr(e, t, o) {
        for (var i = h(e) ? e.slice() : [e], a = 0; a < o; ++a) i.push(t);
        return i;
      }
      var js = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema, a = {}, l = [];
          function d(y, N, b) {
            var _ = kn(y), E = a[_] = a[_] || [], T = y == null ? 0 : typeof y == "string" ? 1 : y.length, C = 0 < N, C = u(u({}, b), { name: C ? "".concat(_, "(virtual-from:").concat(b.name, ")") : b.name, lowLevelIndex: b, isVirtual: C, keyTail: N, keyLength: T, extractKey: Yr(y), unique: !C && b.unique });
            return E.push(C), C.isPrimaryKey || l.push(C), 1 < T && d(T === 2 ? y[0] : y.slice(0, T - 1), N + 1, b), E.sort(function(P, I) {
              return P.keyTail - I.keyTail;
            }), C;
          }
          t = d(i.primaryKey.keyPath, 0, i.primaryKey), a[":id"] = [t];
          for (var m = 0, v = i.indexes; m < v.length; m++) {
            var w = v[m];
            d(w.keyPath, 0, w);
          }
          function O(y) {
            var N, b = y.query.index;
            return b.isVirtual ? u(u({}, y), { query: { index: b.lowLevelIndex, range: (N = y.query.range, b = b.keyTail, { type: N.type === 1 ? 2 : N.type, lower: pr(N.lower, N.lowerOpen ? e.MAX_KEY : e.MIN_KEY, b), lowerOpen: !0, upper: pr(N.upper, N.upperOpen ? e.MIN_KEY : e.MAX_KEY, b), upperOpen: !0 }) } }) : y;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: t, indexes: l, getIndexByKeyPath: function(y) {
            return (y = a[kn(y)]) && y[0];
          } }), count: function(y) {
            return o.count(O(y));
          }, query: function(y) {
            return o.query(O(y));
          }, openCursor: function(y) {
            var N = y.query.index, b = N.keyTail, _ = N.isVirtual, E = N.keyLength;
            return _ ? o.openCursor(O(y)).then(function(C) {
              return C && T(C);
            }) : o.openCursor(y);
            function T(C) {
              return Object.create(C, { continue: { value: function(P) {
                P != null ? C.continue(pr(P, y.reverse ? e.MAX_KEY : e.MIN_KEY, b)) : y.unique ? C.continue(C.key.slice(0, E).concat(y.reverse ? e.MIN_KEY : e.MAX_KEY, b)) : C.continue();
              } }, continuePrimaryKey: { value: function(P, I) {
                C.continuePrimaryKey(pr(P, e.MAX_KEY, b), I);
              } }, primaryKey: { get: function() {
                return C.primaryKey;
              } }, key: { get: function() {
                var P = C.key;
                return E === 1 ? P[0] : P.slice(0, E);
              } }, value: { get: function() {
                return C.value;
              } } });
            }
          } });
        } });
      } };
      function ao(e, t, o, i) {
        return o = o || {}, i = i || "", p(e).forEach(function(a) {
          var l, d, m;
          L(t, a) ? (l = e[a], d = t[a], typeof l == "object" && typeof d == "object" && l && d ? (m = It(l)) !== It(d) ? o[i + a] = t[a] : m === "Object" ? ao(l, d, o, i + a + ".") : l !== d && (o[i + a] = t[a]) : l !== d && (o[i + a] = t[a])) : o[i + a] = void 0;
        }), p(t).forEach(function(a) {
          L(e, a) || (o[i + a] = t[a]);
        }), o;
      }
      function uo(e, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey);
      }
      var Ls = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(a) {
            var l = re.trans, d = l.table(t).hook, m = d.deleting, v = d.creating, w = d.updating;
            switch (a.type) {
              case "add":
                if (v.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "put":
                if (v.fire === S && w.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "delete":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "deleteRange":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return function y(N, b, _) {
                    return o.query({ trans: N, values: !1, query: { index: i, range: b }, limit: _ }).then(function(E) {
                      var T = E.result;
                      return O({ type: "delete", keys: T, trans: N }).then(function(C) {
                        return 0 < C.numFailures ? Promise.reject(C.failures[0]) : T.length < _ ? { failures: [], numFailures: 0, lastResult: void 0 } : y(N, u(u({}, b), { lower: T[T.length - 1], lowerOpen: !0 }), _);
                      });
                    });
                  }(a.trans, a.range, 1e4);
                }, !0);
            }
            return o.mutate(a);
            function O(y) {
              var N, b, _, E = re.trans, T = y.keys || uo(i, y);
              if (!T) throw new Error("Keys missing");
              return (y = y.type === "add" || y.type === "put" ? u(u({}, y), { keys: T }) : u({}, y)).type !== "delete" && (y.values = c([], y.values)), y.keys && (y.keys = c([], y.keys)), N = o, _ = T, ((b = y).type === "add" ? Promise.resolve([]) : N.getMany({ trans: b.trans, keys: _, cache: "immutable" })).then(function(C) {
                var P = T.map(function(I, k) {
                  var V, X, H, G = C[k], Q = { onerror: null, onsuccess: null };
                  return y.type === "delete" ? m.fire.call(Q, I, G, E) : y.type === "add" || G === void 0 ? (V = v.fire.call(Q, I, y.values[k], E), I == null && V != null && (y.keys[k] = I = V, i.outbound || we(y.values[k], i.keyPath, I))) : (V = ao(G, y.values[k]), (X = w.fire.call(Q, V, I, G, E)) && (H = y.values[k], Object.keys(X).forEach(function(z) {
                    L(H, z) ? H[z] = X[z] : we(H, z, X[z]);
                  }))), Q;
                });
                return o.mutate(y).then(function(I) {
                  for (var k = I.failures, V = I.results, X = I.numFailures, I = I.lastResult, H = 0; H < T.length; ++H) {
                    var G = (V || T)[H], Q = P[H];
                    G == null ? Q.onerror && Q.onerror(k[H]) : Q.onsuccess && Q.onsuccess(y.type === "put" && C[H] ? y.values[H] : G);
                  }
                  return { failures: k, results: V, numFailures: X, lastResult: I };
                }).catch(function(I) {
                  return P.forEach(function(k) {
                    return k.onerror && k.onerror(I);
                  }), Promise.reject(I);
                });
              });
            }
          } });
        } });
      } };
      function oi(e, t, o) {
        try {
          if (!t || t.keys.length < e.length) return null;
          for (var i = [], a = 0, l = 0; a < t.keys.length && l < e.length; ++a) Oe(t.keys[a], e[l]) === 0 && (i.push(o ? st(t.values[a]) : t.values[a]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Ks = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(t) {
          var o = e.table(t);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var a = oi(i.keys, i.trans._cache, i.cache === "clone");
            return a ? J.resolve(a) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? st(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function ii(e, t) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function si(e, t) {
        switch (e) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Fs = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var t = e.schema.name, o = new Qe(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, a, l) {
          if (re.subscr && a !== "readonly") throw new K.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return e.transaction(i, a, l);
        }, table: function(i) {
          var a = e.table(i), l = a.schema, d = l.primaryKey, y = l.indexes, m = d.extractKey, v = d.outbound, w = d.autoIncrement && y.filter(function(b) {
            return b.compound && b.keyPath.includes(d.keyPath);
          }), O = u(u({}, a), { mutate: function(b) {
            function _(z) {
              return z = "idb://".concat(t, "/").concat(i, "/").concat(z), I[z] || (I[z] = new Qe());
            }
            var E, T, C, P = b.trans, I = b.mutatedParts || (b.mutatedParts = {}), k = _(""), V = _(":dels"), X = b.type, Q = b.type === "deleteRange" ? [b.range] : b.type === "delete" ? [b.keys] : b.values.length < 50 ? [uo(d, b).filter(function(z) {
              return z;
            }), b.values] : [], H = Q[0], G = Q[1], Q = b.trans._cache;
            return h(H) ? (k.addKeys(H), (Q = X === "delete" || H.length === G.length ? oi(H, Q) : null) || V.addKeys(H), (Q || G) && (E = _, T = Q, C = G, l.indexes.forEach(function(z) {
              var Z = E(z.name || "");
              function ye(he) {
                return he != null ? z.extractKey(he) : null;
              }
              function Te(he) {
                return z.multiEntry && h(he) ? he.forEach(function(Ke) {
                  return Z.addKey(Ke);
                }) : Z.addKey(he);
              }
              (T || C).forEach(function(he, Je) {
                var pe = T && ye(T[Je]), Je = C && ye(C[Je]);
                Oe(pe, Je) !== 0 && (pe != null && Te(pe), Je != null && Te(Je));
              });
            }))) : H ? (G = { from: (G = H.lower) !== null && G !== void 0 ? G : e.MIN_KEY, to: (G = H.upper) !== null && G !== void 0 ? G : e.MAX_KEY }, V.add(G), k.add(G)) : (k.add(o), V.add(o), l.indexes.forEach(function(z) {
              return _(z.name).add(o);
            })), a.mutate(b).then(function(z) {
              return !H || b.type !== "add" && b.type !== "put" || (k.addKeys(z.results), w && w.forEach(function(Z) {
                for (var ye = b.values.map(function(pe) {
                  return Z.extractKey(pe);
                }), Te = Z.keyPath.findIndex(function(pe) {
                  return pe === d.keyPath;
                }), he = 0, Ke = z.results.length; he < Ke; ++he) ye[he][Te] = z.results[he];
                _(Z.name).addKeys(ye);
              })), P.mutatedParts = fr(P.mutatedParts || {}, I), z;
            });
          } }), y = function(_) {
            var E = _.query, _ = E.index, E = E.range;
            return [_, new Qe((_ = E.lower) !== null && _ !== void 0 ? _ : e.MIN_KEY, (E = E.upper) !== null && E !== void 0 ? E : e.MAX_KEY)];
          }, N = { get: function(b) {
            return [d, new Qe(b.key)];
          }, getMany: function(b) {
            return [d, new Qe().addKeys(b.keys)];
          }, count: y, query: y, openCursor: y };
          return p(N).forEach(function(b) {
            O[b] = function(_) {
              var E = re.subscr, T = !!E, C = ii(re, a) && si(b, _) ? _.obsSet = {} : E;
              if (T) {
                var P = function(G) {
                  return G = "idb://".concat(t, "/").concat(i, "/").concat(G), C[G] || (C[G] = new Qe());
                }, I = P(""), k = P(":dels"), E = N[b](_), T = E[0], E = E[1];
                if ((b === "query" && T.isPrimaryKey && !_.values ? k : P(T.name || "")).add(E), !T.isPrimaryKey) {
                  if (b !== "count") {
                    var V = b === "query" && v && _.values && a.query(u(u({}, _), { values: !1 }));
                    return a[b].apply(this, arguments).then(function(G) {
                      if (b === "query") {
                        if (v && _.values) return V.then(function(ye) {
                          return ye = ye.result, I.addKeys(ye), G;
                        });
                        var Q = _.values ? G.result.map(m) : G.result;
                        (_.values ? I : k).addKeys(Q);
                      } else if (b === "openCursor") {
                        var z = G, Z = _.values;
                        return z && Object.create(z, { key: { get: function() {
                          return k.addKey(z.primaryKey), z.key;
                        } }, primaryKey: { get: function() {
                          var ye = z.primaryKey;
                          return k.addKey(ye), ye;
                        } }, value: { get: function() {
                          return Z && I.addKey(z.primaryKey), z.value;
                        } } });
                      }
                      return G;
                    });
                  }
                  k.add(o);
                }
              }
              return a[b].apply(this, arguments);
            };
          }), O;
        } });
      } };
      function ai(e, t, o) {
        if (o.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var i = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return o.numFailures === i ? null : (t = u({}, t), h(t.keys) && (t.keys = t.keys.filter(function(a, l) {
          return !(l in o.failures);
        })), "values" in t && h(t.values) && (t.values = t.values.filter(function(a, l) {
          return !(l in o.failures);
        })), t);
      }
      function lo(e, t) {
        return o = e, ((i = t).lower === void 0 || (i.lowerOpen ? 0 < Oe(o, i.lower) : 0 <= Oe(o, i.lower))) && (e = e, (t = t).upper === void 0 || (t.upperOpen ? Oe(e, t.upper) < 0 : Oe(e, t.upper) <= 0));
        var o, i;
      }
      function ui(e, t, N, i, a, l) {
        if (!N || N.length === 0) return e;
        var d = t.query.index, m = d.multiEntry, v = t.query.range, w = i.schema.primaryKey.extractKey, O = d.extractKey, y = (d.lowLevelIndex || d).extractKey, N = N.reduce(function(b, _) {
          var E = b, T = [];
          if (_.type === "add" || _.type === "put") for (var C = new Qe(), P = _.values.length - 1; 0 <= P; --P) {
            var I, k = _.values[P], V = w(k);
            C.hasKey(V) || (I = O(k), (m && h(I) ? I.some(function(z) {
              return lo(z, v);
            }) : lo(I, v)) && (C.addKey(V), T.push(k)));
          }
          switch (_.type) {
            case "add":
              var X = new Qe().addKeys(t.values ? b.map(function(Z) {
                return w(Z);
              }) : b), E = b.concat(t.values ? T.filter(function(Z) {
                return Z = w(Z), !X.hasKey(Z) && (X.addKey(Z), !0);
              }) : T.map(function(Z) {
                return w(Z);
              }).filter(function(Z) {
                return !X.hasKey(Z) && (X.addKey(Z), !0);
              }));
              break;
            case "put":
              var H = new Qe().addKeys(_.values.map(function(Z) {
                return w(Z);
              }));
              E = b.filter(function(Z) {
                return !H.hasKey(t.values ? w(Z) : Z);
              }).concat(t.values ? T : T.map(function(Z) {
                return w(Z);
              }));
              break;
            case "delete":
              var G = new Qe().addKeys(_.keys);
              E = b.filter(function(Z) {
                return !G.hasKey(t.values ? w(Z) : Z);
              });
              break;
            case "deleteRange":
              var Q = _.range;
              E = b.filter(function(Z) {
                return !lo(w(Z), Q);
              });
          }
          return E;
        }, e);
        return N === e ? e : (N.sort(function(b, _) {
          return Oe(y(b), y(_)) || Oe(w(b), w(_));
        }), t.limit && t.limit < 1 / 0 && (N.length > t.limit ? N.length = t.limit : e.length === t.limit && N.length < t.limit && (a.dirty = !0)), l ? Object.freeze(N) : N);
      }
      function li(e, t) {
        return Oe(e.lower, t.lower) === 0 && Oe(e.upper, t.upper) === 0 && !!e.lowerOpen == !!t.lowerOpen && !!e.upperOpen == !!t.upperOpen;
      }
      function Ms(e, t) {
        return function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = Oe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, t.lower, e.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = Oe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, t.upper, e.upperOpen, t.upperOpen);
      }
      function Bs(e, t, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var a, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (a = e, l = t, setTimeout(function() {
            a.subscribers.size === 0 && Fe(l, a);
          }, 3e3));
        });
      }
      var $s = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var t = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, a) {
          var l, d, m = e.transaction(o, i, a);
          return i === "readwrite" && (d = (l = new AbortController()).signal, a = function(v) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var w = /* @__PURE__ */ new Set(), O = 0, y = o; O < y.length; O++) {
                  var N = y[O], b = nn["idb://".concat(t, "/").concat(N)];
                  if (b) {
                    var _ = e.table(N), E = b.optimisticOps.filter(function(Z) {
                      return Z.trans === m;
                    });
                    if (m._explicit && v && m.mutatedParts) for (var T = 0, C = Object.values(b.queries.query); T < C.length; T++) for (var P = 0, I = (X = C[T]).slice(); P < I.length; P++) no((H = I[P]).obsSet, m.mutatedParts) && (Fe(X, H), H.subscribers.forEach(function(Z) {
                      return w.add(Z);
                    }));
                    else if (0 < E.length) {
                      b.optimisticOps = b.optimisticOps.filter(function(Z) {
                        return Z.trans !== m;
                      });
                      for (var k = 0, V = Object.values(b.queries.query); k < V.length; k++) for (var X, H, G, Q = 0, z = (X = V[k]).slice(); Q < z.length; Q++) (H = z[Q]).res != null && m.mutatedParts && (v && !H.dirty ? (G = Object.isFrozen(H.res), G = ui(H.res, H.req, E, _, H, G), H.dirty ? (Fe(X, H), H.subscribers.forEach(function(Z) {
                        return w.add(Z);
                      })) : G !== H.res && (H.res = G, H.promise = J.resolve({ result: G }))) : (H.dirty && Fe(X, H), H.subscribers.forEach(function(Z) {
                        return w.add(Z);
                      })));
                    }
                  }
                }
                w.forEach(function(Z) {
                  return Z();
                });
              }
            };
          }, m.addEventListener("abort", a(!1), { signal: d }), m.addEventListener("error", a(!1), { signal: d }), m.addEventListener("complete", a(!0), { signal: d })), m;
        }, table: function(o) {
          var i = e.table(o), a = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var d = re.trans;
            if (a.outbound || d.db._options.cache === "disabled" || d.explicit || d.idbtrans.mode !== "readwrite") return i.mutate(l);
            var m = nn["idb://".concat(t, "/").concat(o)];
            return m ? (d = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || uo(a, l).some(function(v) {
              return v == null;
            })) ? (m.optimisticOps.push(l), l.mutatedParts && dr(l.mutatedParts), d.then(function(v) {
              0 < v.numFailures && (Fe(m.optimisticOps, l), (v = ai(0, l, v)) && m.optimisticOps.push(v), l.mutatedParts && dr(l.mutatedParts));
            }), d.catch(function() {
              Fe(m.optimisticOps, l), l.mutatedParts && dr(l.mutatedParts);
            })) : d.then(function(v) {
              var w = ai(0, u(u({}, l), { values: l.values.map(function(O, y) {
                var N;
                return v.failures[y] ? O : (O = (N = a.keyPath) !== null && N !== void 0 && N.includes(".") ? st(O) : u({}, O), we(O, a.keyPath, v.results[y]), O);
              }) }), v);
              m.optimisticOps.push(w), queueMicrotask(function() {
                return l.mutatedParts && dr(l.mutatedParts);
              });
            }), d) : i.mutate(l);
          }, query: function(l) {
            if (!ii(re, i) || !si("query", l)) return i.query(l);
            var d = ((w = re.trans) === null || w === void 0 ? void 0 : w.db._options.cache) === "immutable", y = re, m = y.requery, v = y.signal, w = function(_, E, T, C) {
              var P = nn["idb://".concat(_, "/").concat(E)];
              if (!P) return [];
              if (!(E = P.queries[T])) return [null, !1, P, null];
              var I = E[(C.query ? C.query.index.name : null) || ""];
              if (!I) return [null, !1, P, null];
              switch (T) {
                case "query":
                  var k = I.find(function(V) {
                    return V.req.limit === C.limit && V.req.values === C.values && li(V.req.query.range, C.query.range);
                  });
                  return k ? [k, !0, P, I] : [I.find(function(V) {
                    return ("limit" in V.req ? V.req.limit : 1 / 0) >= C.limit && (!C.values || V.req.values) && Ms(V.req.query.range, C.query.range);
                  }), !1, P, I];
                case "count":
                  return k = I.find(function(V) {
                    return li(V.req.query.range, C.query.range);
                  }), [k, !!k, P, I];
              }
            }(t, o, "query", l), O = w[0], y = w[1], N = w[2], b = w[3];
            return O && y ? O.obsSet = l.obsSet : (y = i.query(l).then(function(_) {
              var E = _.result;
              if (O && (O.res = E), d) {
                for (var T = 0, C = E.length; T < C; ++T) Object.freeze(E[T]);
                Object.freeze(E);
              } else _.result = st(E);
              return _;
            }).catch(function(_) {
              return b && O && Fe(b, O), Promise.reject(_);
            }), O = { obsSet: l.obsSet, promise: y, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, b ? b.push(O) : (b = [O], (N = N || (nn["idb://".concat(t, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = b)), Bs(O, b, m, v), O.promise.then(function(_) {
              return { result: ui(_.result, l, N?.optimisticOps, i, O, d) };
            });
          } });
        } });
      } };
      function hr(e, t) {
        return new Proxy(e, { get: function(o, i, a) {
          return i === "db" ? t : Reflect.get(o, i, a);
        } });
      }
      var Rt = ($e.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new K.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new K.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var t = this._versions, o = t.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), t.push(o), t.sort(Ps), o.stores({}), this._state.autoSchema = !1, o);
      }, $e.prototype._whenReady = function(e) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? e() : new J(function(o, i) {
          if (t._state.openComplete) return i(new K.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void i(new K.DatabaseClosed());
            t.open().catch(S);
          }
          t._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, $e.prototype.use = function(e) {
        var t = e.stack, o = e.create, i = e.level, a = e.name;
        return a && this.unuse({ stack: t, name: a }), e = this._middlewares[t] || (this._middlewares[t] = []), e.push({ stack: t, create: o, level: i ?? 10, name: a }), e.sort(function(l, d) {
          return l.level - d.level;
        }), this;
      }, $e.prototype.unuse = function(e) {
        var t = e.stack, o = e.name, i = e.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(a) {
          return i ? a.create !== i : !!o && a.name !== o;
        })), this;
      }, $e.prototype.open = function() {
        var e = this;
        return Zt(ot, function() {
          return ks(e);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, t = gn.indexOf(this);
        if (0 <= t && gn.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new J(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new J(function(o, i) {
          e.cancelOpen = i;
        }));
      }, $e.prototype.close = function(o) {
        var t = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        t ? (o.isBeingOpened && o.cancelOpen(new K.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new K.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, $e.prototype.delete = function(e) {
        var t = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new J(function(a, l) {
          function d() {
            t.close(e);
            var m = t._deps.indexedDB.deleteDatabase(t.name);
            m.onsuccess = Le(function() {
              var v, w, O;
              v = t._deps, w = t.name, O = v.indexedDB, v = v.IDBKeyRange, Zr(O) || w === Zn || Jr(O, v).delete(w).catch(S), a();
            }), m.onerror = Et(l), m.onblocked = t._fireOnBlocked;
          }
          if (o) throw new K.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(d) : d();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var e = this;
        return p(this._allTables).map(function(t) {
          return e._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var e = (function(t, o, i) {
          var a = arguments.length;
          if (a < 2) throw new K.InvalidArgument("Too few arguments");
          for (var l = new Array(a - 1); --a; ) l[a - 1] = arguments[a];
          return i = l.pop(), [t, ze(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, $e.prototype._transaction = function(e, t, o) {
        var i = this, a = re.trans;
        a && a.db === this && e.indexOf("!") === -1 || (a = null);
        var l, d, m = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (d = t.map(function(w) {
            if (w = w instanceof i.Table ? w.name : w, typeof w != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return w;
          }), e == "r" || e === $r) l = $r;
          else {
            if (e != "rw" && e != qr) throw new K.InvalidArgument("Invalid transaction mode: " + e);
            l = qr;
          }
          if (a) {
            if (a.mode === $r && l === qr) {
              if (!m) throw new K.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              a = null;
            }
            a && d.forEach(function(w) {
              if (a && a.storeNames.indexOf(w) === -1) {
                if (!m) throw new K.SubTransaction("Table " + w + " not included in parent transaction.");
                a = null;
              }
            }), m && a && !a.active && (a = null);
          }
        } catch (w) {
          return a ? a._promise(null, function(O, y) {
            y(w);
          }) : Be(w);
        }
        var v = (function w(O, y, N, b, _) {
          return J.resolve().then(function() {
            var E = re.transless || re, T = O._createTransaction(y, N, O._dbSchema, b);
            if (T.explicit = !0, E = { trans: T, transless: E }, b) T.idbtrans = b.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, O._state.PR1398_maxLoop = 3;
            } catch (I) {
              return I.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                return w(O, y, N, null, _);
              })) : Be(I);
            }
            var C, P = _t(_);
            return P && vn(), E = J.follow(function() {
              var I;
              (C = _.call(T, T)) && (P ? (I = Mt.bind(null, null), C.then(I, I)) : typeof C.next == "function" && typeof C.throw == "function" && (C = so(C)));
            }, E), (C && typeof C.then == "function" ? J.resolve(C).then(function(I) {
              return T.active ? I : Be(new K.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : E.then(function() {
              return C;
            })).then(function(I) {
              return b && T._resolve(), T._completion.then(function() {
                return I;
              });
            }).catch(function(I) {
              return T._reject(I), Be(I);
            });
          });
        }).bind(null, this, l, d, a, o);
        return a ? a._promise(l, v, "lock") : re.trans ? Zt(re.transless, function() {
          return i._whenReady(v);
        }) : this._whenReady(v);
      }, $e.prototype.table = function(e) {
        if (!L(this._allTables, e)) throw new K.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, $e);
      function $e(e, t) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = $e.dependencies;
        this._options = t = u({ addons: $e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, i = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var a, l, d, m, v, w = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: S, dbReadyPromise: null, cancelOpen: S, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        w.dbReadyPromise = new J(function(y) {
          w.dbReadyResolve = y;
        }), w.openCanceller = new J(function(y, N) {
          w.cancelOpen = N;
        }), this._state = w, this.name = e, this.on = Sn(this, "populate", "blocked", "versionchange", "close", { ready: [de, S] }), this.once = function(y, N) {
          var b = function() {
            for (var _ = [], E = 0; E < arguments.length; E++) _[E] = arguments[E];
            o.on(y).unsubscribe(b), N.apply(o, _);
          };
          return o.on(y, b);
        }, this.on.ready.subscribe = Y(this.on.ready.subscribe, function(y) {
          return function(N, b) {
            $e.vip(function() {
              var _, E = o._state;
              E.openComplete ? (E.dbOpenError || J.resolve().then(N), b && y(N)) : E.onReadyBeingFired ? (E.onReadyBeingFired.push(N), b && y(N)) : (y(N), _ = o, b || y(function T() {
                _.on.ready.unsubscribe(N), _.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (a = this, An(Os.prototype, function(C, T) {
          this.db = a;
          var b = Mo, _ = null;
          if (T) try {
            b = T();
          } catch (P) {
            _ = P;
          }
          var E = C._ctx, T = E.table, C = T.hook.reading.fire;
          this._ctx = { table: T, index: E.index, isPrimKey: !E.index || T.schema.primKey.keyPath && E.index === T.schema.primKey.name, range: b, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: _, or: E.or, valueMapper: C !== F ? C : null };
        })), this.Table = (l = this, An(Uo.prototype, function(y, N, b) {
          this.db = l, this._tx = b, this.name = y, this.schema = N, this.hook = l._allTables[y] ? l._allTables[y].hook : Sn(null, { creating: [ue, S], reading: [te, F], updating: [me, S], deleting: [se, S] });
        })), this.Transaction = (d = this, An(Ns.prototype, function(y, N, b, _, E) {
          var T = this;
          y !== "readonly" && N.forEach(function(C) {
            C = (C = b[C]) === null || C === void 0 ? void 0 : C.yProps, C && (N = N.concat(C.map(function(P) {
              return P.updatesTable;
            })));
          }), this.db = d, this.mode = y, this.storeNames = N, this.schema = b, this.chromeTransactionDurability = _, this.idbtrans = null, this.on = Sn(this, "complete", "error", "abort"), this.parent = E || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new J(function(C, P) {
            T._resolve = C, T._reject = P;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(C) {
            var P = T.active;
            return T.active = !1, T.on.error.fire(C), T.parent ? T.parent._reject(C) : P && T.idbtrans && T.idbtrans.abort(), Be(C);
          });
        })), this.Version = (m = this, An(Is.prototype, function(y) {
          this.db = m, this._cfg = { version: y, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (v = this, An(Xo.prototype, function(y, N, b) {
          if (this.db = v, this._ctx = { table: y, index: N === ":id" ? null : N, or: b }, this._cmp = this._ascending = Oe, this._descending = function(_, E) {
            return Oe(E, _);
          }, this._max = function(_, E) {
            return 0 < Oe(_, E) ? _ : E;
          }, this._min = function(_, E) {
            return Oe(_, E) < 0 ? _ : E;
          }, this._IDBKeyRange = v._deps.IDBKeyRange, !this._IDBKeyRange) throw new K.MissingAPI();
        })), this.on("versionchange", function(y) {
          0 < y.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(y) {
          !y.newVersion || y.newVersion < y.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(y.oldVersion / 10));
        }), this._maxKey = In(t.IDBKeyRange), this._createTransaction = function(y, N, b, _) {
          return new o.Transaction(y, N, b, o._options.chromeTransactionDurability, _);
        }, this._fireOnBlocked = function(y) {
          o.on("blocked").fire(y), gn.filter(function(N) {
            return N.name === o.name && N !== o && !N._state.vcFired;
          }).map(function(N) {
            return N.on("versionchange").fire(y);
          });
        }, this.use(Ks), this.use($s), this.use(Fs), this.use(js), this.use(Ls);
        var O = new Proxy(this, { get: function(y, N, b) {
          if (N === "_vip") return !0;
          if (N === "table") return function(E) {
            return hr(o.table(E), O);
          };
          var _ = Reflect.get(y, N, b);
          return _ instanceof Uo ? hr(_, O) : N === "tables" ? _.map(function(E) {
            return hr(E, O);
          }) : N === "_createTransaction" ? function() {
            return hr(_.apply(this, arguments), O);
          } : _;
        } });
        this.vip = O, i.forEach(function(y) {
          return y(o);
        });
      }
      var mr, wt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", qs = (co.prototype.subscribe = function(e, t, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: o });
      }, co.prototype[wt] = function() {
        return this;
      }, co);
      function co(e) {
        this._subscribe = e;
      }
      try {
        mr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
      } catch {
        mr = { indexedDB: null, IDBKeyRange: null };
      }
      function ci(e) {
        var t, o = !1, i = new qs(function(a) {
          var l = _t(e), d, m = !1, v = {}, w = {}, O = { get closed() {
            return m;
          }, unsubscribe: function() {
            m || (m = !0, d && d.abort(), y && qt.storagemutated.unsubscribe(b));
          } };
          a.start && a.start(O);
          var y = !1, N = function() {
            return Br(_);
          }, b = function(E) {
            fr(v, E), no(w, v) && N();
          }, _ = function() {
            var E, T, C;
            !m && mr.indexedDB && (v = {}, E = {}, d && d.abort(), d = new AbortController(), C = function(P) {
              var I = mn();
              try {
                l && vn();
                var k = Ft(e, P);
                return k = l ? k.finally(Mt) : k;
              } finally {
                I && yn();
              }
            }(T = { subscr: E, signal: d.signal, requery: N, querier: e, trans: null }), Promise.resolve(C).then(function(P) {
              o = !0, t = P, m || T.signal.aborted || (v = {}, function(I) {
                for (var k in I) if (L(I, k)) return;
                return 1;
              }(w = E) || y || (qt(Rn, b), y = !0), Br(function() {
                return !m && a.next && a.next(P);
              }));
            }, function(P) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(P?.name) || m || Br(function() {
                m || a.error && a.error(P);
              });
            }));
          };
          return setTimeout(N, 0), O;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return t;
        }, i;
      }
      var rn = Rt;
      function fo(e) {
        var t = Ut;
        try {
          Ut = !0, qt.storagemutated.fire(e), io(e, !0);
        } finally {
          Ut = t;
        }
      }
      B(rn, u(u({}, Ve), { delete: function(e) {
        return new rn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new rn(e, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return t = rn.dependencies, o = t.indexedDB, t = t.IDBKeyRange, (Zr(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(a) {
              return a.name;
            }).filter(function(a) {
              return a !== Zn;
            });
          }) : Jr(o, t).toCollection().primaryKeys()).then(e);
        } catch {
          return Be(new K.MissingAPI());
        }
        var t, o;
      }, defineClass: function() {
        return function(e) {
          g(this, e);
        };
      }, ignoreTransaction: function(e) {
        return re.trans ? Zt(re.transless, e) : e();
      }, vip: eo, async: function(e) {
        return function() {
          try {
            var t = so(e.apply(this, arguments));
            return t && typeof t.then == "function" ? t : J.resolve(t);
          } catch (o) {
            return Be(o);
          }
        };
      }, spawn: function(e, t, o) {
        try {
          var i = so(e.apply(o, t || []));
          return i && typeof i.then == "function" ? i : J.resolve(i);
        } catch (a) {
          return Be(a);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(e, t) {
        return t = J.resolve(typeof e == "function" ? rn.ignoreTransaction(e) : e).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: J, debug: { get: function() {
        return ae;
      }, set: function(e) {
        Se(e);
      } }, derive: ce, extend: g, props: B, override: Y, Events: Sn, on: qt, liveQuery: ci, extendObservabilitySet: fr, getByKeyPath: ne, setByKeyPath: we, delByKeyPath: function(e, t) {
        typeof t == "string" ? we(e, t, void 0) : "length" in t && [].map.call(t, function(o) {
          we(e, o, void 0);
        });
      }, shallowClone: _e, deepClone: st, getObjectDiff: ao, cmp: Oe, asap: M, minKey: -1 / 0, addons: [], connections: gn, errnames: A, dependencies: mr, cache: nn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, t, o) {
        return e + t / Math.pow(10, 2 * o);
      }) })), rn.maxKey = In(rn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (qt(Rn, function(e) {
        Ut || (e = new CustomEvent(Hr, { detail: e }), Ut = !0, dispatchEvent(e), Ut = !1);
      }), addEventListener(Hr, function(e) {
        e = e.detail, Ut || fo(e);
      }));
      var En, Ut = !1, fi = function() {
      };
      return typeof BroadcastChannel < "u" && ((fi = function() {
        (En = new BroadcastChannel(Hr)).onmessage = function(e) {
          return e.data && fo(e.data);
        };
      })(), typeof En.unref == "function" && En.unref(), qt(Rn, function(e) {
        Ut || En.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Rt.disableBfCache && e.persisted) {
          ae && console.debug("Dexie: handling persisted pagehide"), En?.close();
          for (var t = 0, o = gn; t < o.length; t++) o[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Rt.disableBfCache && e.persisted && (ae && console.debug("Dexie: handling persisted pageshow"), fi(), fo({ all: new Qe(-1 / 0, [[]]) }));
      })), J.rejectionMapper = function(e, t) {
        return !e || e instanceof jt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !W[e.name] ? e : (t = new W[e.name](t || e.message, e), "stack" in e && ie(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Se(ae), u(Rt, Object.freeze({ __proto__: null, Dexie: Rt, liveQuery: ci, Entity: Bo, cmp: Oe, PropModification: Pn, replacePrefix: function(e, t) {
        return new Pn({ replacePrefix: [e, t] });
      }, add: function(e) {
        return new Pn({ add: e });
      }, remove: function(e) {
        return new Pn({ remove: e });
      }, default: Rt, RangeSet: Qe, mergeRanges: Ln, rangesOverlap: ei }), { default: Rt }), Rt;
    });
  }(Yi)), Yi.exports;
}
var kd = Id();
const ya = /* @__PURE__ */ Dd(kd), Su = Symbol.for("Dexie"), os = globalThis[Su] || (globalThis[Su] = ya);
if (ya.semVer !== os.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${ya.semVer} and ${os.semVer}`);
const {
  liveQuery: iy,
  mergeRanges: sy,
  rangesOverlap: ay,
  RangeSet: uy,
  cmp: ly,
  Entity: cy,
  PropModification: fy,
  replacePrefix: dy,
  add: py,
  remove: hy,
  DexieYProvider: my
} = os;
var jd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ld(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function Kd(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var r = n.default;
  if (typeof r == "function") {
    var s = function u() {
      var c = !1;
      try {
        c = this instanceof u;
      } catch {
      }
      return c ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    s.prototype = r.prototype;
  } else s = {};
  return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(n).forEach(function(u) {
    var c = Object.getOwnPropertyDescriptor(n, u);
    Object.defineProperty(s, u, c.get ? c : {
      enumerable: !0,
      get: function() {
        return n[u];
      }
    });
  }), s;
}
var Au = {};
const Fd = {}, Md = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Fd
}, Symbol.toStringTag, { value: "Module" })), Pu = /* @__PURE__ */ Kd(Md);
var Du;
function Bd() {
  return Du || (Du = 1, function(n) {
    (function(r) {
      r.parser = function(A, x) {
        return new u(A, x);
      }, r.SAXParser = u, r.SAXStream = D, r.createStream = R, r.MAX_BUFFER_LENGTH = 64 * 1024;
      var s = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      r.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function u(A, x) {
        if (!(this instanceof u))
          return new u(A, x);
        var K = this;
        f(K), K.q = K.c = "", K.bufferCheckPosition = r.MAX_BUFFER_LENGTH, K.opt = x || {}, K.opt.lowercase = K.opt.lowercase || K.opt.lowercasetags, K.looseCase = K.opt.lowercase ? "toLowerCase" : "toUpperCase", K.tags = [], K.closed = K.closedRoot = K.sawRoot = !1, K.tag = K.error = null, K.strict = !!A, K.noscript = !!(A || K.opt.noscript), K.state = $.BEGIN, K.strictEntities = K.opt.strictEntities, K.ENTITIES = K.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), K.attribList = [], K.opt.xmlns && (K.ns = Object.create(ce)), K.opt.unquotedAttributeValues === void 0 && (K.opt.unquotedAttributeValues = !A), K.trackPosition = K.opt.position !== !1, K.trackPosition && (K.position = K.line = K.column = 0), dt(K, "onready");
      }
      Object.create || (Object.create = function(A) {
        function x() {
        }
        x.prototype = A;
        var K = new x();
        return K;
      }), Object.keys || (Object.keys = function(A) {
        var x = [];
        for (var K in A) A.hasOwnProperty(K) && x.push(K);
        return x;
      });
      function c(A) {
        for (var x = Math.max(r.MAX_BUFFER_LENGTH, 10), K = 0, W = 0, Ve = s.length; W < Ve; W++) {
          var S = A[s[W]].length;
          if (S > x)
            switch (s[W]) {
              case "textNode":
                st(A);
                break;
              case "cdata":
                Me(A, "oncdata", A.cdata), A.cdata = "";
                break;
              case "script":
                Me(A, "onscript", A.script), A.script = "";
                break;
              default:
                It(A, "Max buffer length exceeded: " + s[W]);
            }
          K = Math.max(K, S);
        }
        var F = r.MAX_BUFFER_LENGTH - K;
        A.bufferCheckPosition = F + A.position;
      }
      function f(A) {
        for (var x = 0, K = s.length; x < K; x++)
          A[s[x]] = "";
      }
      function p(A) {
        st(A), A.cdata !== "" && (Me(A, "oncdata", A.cdata), A.cdata = ""), A.script !== "" && (Me(A, "onscript", A.script), A.script = "");
      }
      u.prototype = {
        end: function() {
          nt(this);
        },
        write: Tt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          p(this);
        }
      };
      var h;
      try {
        h = Pu.Stream;
      } catch {
        h = function() {
        };
      }
      h || (h = function() {
      });
      var g = r.EVENTS.filter(function(A) {
        return A !== "error" && A !== "end";
      });
      function R(A, x) {
        return new D(A, x);
      }
      function D(A, x) {
        if (!(this instanceof D))
          return new D(A, x);
        h.apply(this), this._parser = new u(A, x), this.writable = !0, this.readable = !0;
        var K = this;
        this._parser.onend = function() {
          K.emit("end");
        }, this._parser.onerror = function(W) {
          K.emit("error", W), K._parser.error = null;
        }, this._decoder = null, g.forEach(function(W) {
          Object.defineProperty(K, "on" + W, {
            get: function() {
              return K._parser["on" + W];
            },
            set: function(Ve) {
              if (!Ve)
                return K.removeAllListeners(W), K._parser["on" + W] = Ve, Ve;
              K.on(W, Ve);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      D.prototype = Object.create(h.prototype, {
        constructor: {
          value: D
        }
      }), D.prototype.write = function(A) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(A)) {
          if (!this._decoder) {
            var x = Pu.StringDecoder;
            this._decoder = new x("utf8");
          }
          A = this._decoder.write(A);
        }
        return this._parser.write(A.toString()), this.emit("data", A), !0;
      }, D.prototype.end = function(A) {
        return A && A.length && this.write(A), this._parser.end(), !0;
      }, D.prototype.on = function(A, x) {
        var K = this;
        return !K._parser["on" + A] && g.indexOf(A) !== -1 && (K._parser["on" + A] = function() {
          var W = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          W.splice(0, 0, A), K.emit.apply(K, W);
        }), h.prototype.on.call(K, A, x);
      };
      var L = "[CDATA[", B = "DOCTYPE", ee = "http://www.w3.org/XML/1998/namespace", ie = "http://www.w3.org/2000/xmlns/", ce = { xml: ee, xmlns: ie }, xe = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, le = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, U = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, Y = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function q(A) {
        return A === " " || A === `
` || A === "\r" || A === "	";
      }
      function M(A) {
        return A === '"' || A === "'";
      }
      function ne(A) {
        return A === ">" || q(A);
      }
      function we(A, x) {
        return A.test(x);
      }
      function _e(A, x) {
        return !we(A, x);
      }
      var $ = 0;
      r.STATE = {
        BEGIN: $++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: $++,
        // leading whitespace
        TEXT: $++,
        // general stuff
        TEXT_ENTITY: $++,
        // &amp and such.
        OPEN_WAKA: $++,
        // <
        SGML_DECL: $++,
        // <!BLARG
        SGML_DECL_QUOTED: $++,
        // <!BLARG foo "bar
        DOCTYPE: $++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: $++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: $++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: $++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: $++,
        // <!-
        COMMENT: $++,
        // <!--
        COMMENT_ENDING: $++,
        // <!-- blah -
        COMMENT_ENDED: $++,
        // <!-- blah --
        CDATA: $++,
        // <![CDATA[ something
        CDATA_ENDING: $++,
        // ]
        CDATA_ENDING_2: $++,
        // ]]
        PROC_INST: $++,
        // <?hi
        PROC_INST_BODY: $++,
        // <?hi there
        PROC_INST_ENDING: $++,
        // <?hi "there" ?
        OPEN_TAG: $++,
        // <strong
        OPEN_TAG_SLASH: $++,
        // <strong /
        ATTRIB: $++,
        // <a
        ATTRIB_NAME: $++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: $++,
        // <a foo _
        ATTRIB_VALUE: $++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: $++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: $++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: $++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: $++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: $++,
        // <foo bar=&quot
        CLOSE_TAG: $++,
        // </a
        CLOSE_TAG_SAW_WHITE: $++,
        // </a   >
        SCRIPT: $++,
        // <script> ...
        SCRIPT_ENDING: $++
        // <script> ... <
      }, r.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, r.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(r.ENTITIES).forEach(function(A) {
        var x = r.ENTITIES[A], K = typeof x == "number" ? String.fromCharCode(x) : x;
        r.ENTITIES[A] = K;
      });
      for (var ze in r.STATE)
        r.STATE[r.STATE[ze]] = ze;
      $ = r.STATE;
      function dt(A, x, K) {
        A[x] && A[x](K);
      }
      function Me(A, x, K) {
        A.textNode && st(A), dt(A, x, K);
      }
      function st(A) {
        A.textNode = Tn(A.opt, A.textNode), A.textNode && dt(A, "ontext", A.textNode), A.textNode = "";
      }
      function Tn(A, x) {
        return A.trim && (x = x.trim()), A.normalize && (x = x.replace(/\s+/g, " ")), x;
      }
      function It(A, x) {
        return st(A), A.trackPosition && (x += `
Line: ` + A.line + `
Column: ` + A.column + `
Char: ` + A.c), x = new Error(x), A.error = x, dt(A, "onerror", x), A;
      }
      function nt(A) {
        return A.sawRoot && !A.closedRoot && Ne(A, "Unclosed root tag"), A.state !== $.BEGIN && A.state !== $.BEGIN_WHITESPACE && A.state !== $.TEXT && It(A, "Unexpected end"), st(A), A.c = "", A.closed = !0, dt(A, "onend"), u.call(A, A.strict, A.opt), A;
      }
      function Ne(A, x) {
        if (typeof A != "object" || !(A instanceof u))
          throw new Error("bad call to strictFail");
        A.strict && It(A, x);
      }
      function Fe(A) {
        A.strict || (A.tagName = A.tagName[A.looseCase]());
        var x = A.tags[A.tags.length - 1] || A, K = A.tag = { name: A.tagName, attributes: {} };
        A.opt.xmlns && (K.ns = x.ns), A.attribList.length = 0, Me(A, "onopentagstart", K);
      }
      function bt(A, x) {
        var K = A.indexOf(":"), W = K < 0 ? ["", A] : A.split(":"), Ve = W[0], S = W[1];
        return x && A === "xmlns" && (Ve = "xmlns", S = ""), { prefix: Ve, local: S };
      }
      function ct(A) {
        if (A.strict || (A.attribName = A.attribName[A.looseCase]()), A.attribList.indexOf(A.attribName) !== -1 || A.tag.attributes.hasOwnProperty(A.attribName)) {
          A.attribName = A.attribValue = "";
          return;
        }
        if (A.opt.xmlns) {
          var x = bt(A.attribName, !0), K = x.prefix, W = x.local;
          if (K === "xmlns")
            if (W === "xml" && A.attribValue !== ee)
              Ne(
                A,
                "xml: prefix must be bound to " + ee + `
Actual: ` + A.attribValue
              );
            else if (W === "xmlns" && A.attribValue !== ie)
              Ne(
                A,
                "xmlns: prefix must be bound to " + ie + `
Actual: ` + A.attribValue
              );
            else {
              var Ve = A.tag, S = A.tags[A.tags.length - 1] || A;
              Ve.ns === S.ns && (Ve.ns = Object.create(S.ns)), Ve.ns[W] = A.attribValue;
            }
          A.attribList.push([A.attribName, A.attribValue]);
        } else
          A.tag.attributes[A.attribName] = A.attribValue, Me(A, "onattribute", {
            name: A.attribName,
            value: A.attribValue
          });
        A.attribName = A.attribValue = "";
      }
      function _t(A, x) {
        if (A.opt.xmlns) {
          var K = A.tag, W = bt(A.tagName);
          K.prefix = W.prefix, K.local = W.local, K.uri = K.ns[W.prefix] || "", K.prefix && !K.uri && (Ne(A, "Unbound namespace prefix: " + JSON.stringify(A.tagName)), K.uri = W.prefix);
          var Ve = A.tags[A.tags.length - 1] || A;
          K.ns && Ve.ns !== K.ns && Object.keys(K.ns).forEach(function(Se) {
            Me(A, "onopennamespace", {
              prefix: Se,
              uri: K.ns[Se]
            });
          });
          for (var S = 0, F = A.attribList.length; S < F; S++) {
            var te = A.attribList[S], oe = te[0], ue = te[1], se = bt(oe, !0), me = se.prefix, ge = se.local, de = me === "" ? "" : K.ns[me] || "", ae = {
              name: oe,
              value: ue,
              prefix: me,
              local: ge,
              uri: de
            };
            me && me !== "xmlns" && !de && (Ne(A, "Unbound namespace prefix: " + JSON.stringify(me)), ae.uri = me), A.tag.attributes[oe] = ae, Me(A, "onattribute", ae);
          }
          A.attribList.length = 0;
        }
        A.tag.isSelfClosing = !!x, A.sawRoot = !0, A.tags.push(A.tag), Me(A, "onopentag", A.tag), x || (!A.noscript && A.tagName.toLowerCase() === "script" ? A.state = $.SCRIPT : A.state = $.TEXT, A.tag = null, A.tagName = ""), A.attribName = A.attribValue = "", A.attribList.length = 0;
      }
      function kt(A) {
        if (!A.tagName) {
          Ne(A, "Weird empty close tag."), A.textNode += "</>", A.state = $.TEXT;
          return;
        }
        if (A.script) {
          if (A.tagName !== "script") {
            A.script += "</" + A.tagName + ">", A.tagName = "", A.state = $.SCRIPT;
            return;
          }
          Me(A, "onscript", A.script), A.script = "";
        }
        var x = A.tags.length, K = A.tagName;
        A.strict || (K = K[A.looseCase]());
        for (var W = K; x--; ) {
          var Ve = A.tags[x];
          if (Ve.name !== W)
            Ne(A, "Unexpected close tag");
          else
            break;
        }
        if (x < 0) {
          Ne(A, "Unmatched closing tag: " + A.tagName), A.textNode += "</" + A.tagName + ">", A.state = $.TEXT;
          return;
        }
        A.tagName = K;
        for (var S = A.tags.length; S-- > x; ) {
          var F = A.tag = A.tags.pop();
          A.tagName = A.tag.name, Me(A, "onclosetag", A.tagName);
          var te = {};
          for (var oe in F.ns)
            te[oe] = F.ns[oe];
          var ue = A.tags[A.tags.length - 1] || A;
          A.opt.xmlns && F.ns !== ue.ns && Object.keys(F.ns).forEach(function(se) {
            var me = F.ns[se];
            Me(A, "onclosenamespace", { prefix: se, uri: me });
          });
        }
        x === 0 && (A.closedRoot = !0), A.tagName = A.attribValue = A.attribName = "", A.attribList.length = 0, A.state = $.TEXT;
      }
      function jt(A) {
        var x = A.entity, K = x.toLowerCase(), W, Ve = "";
        return A.ENTITIES[x] ? A.ENTITIES[x] : A.ENTITIES[K] ? A.ENTITIES[K] : (x = K, x.charAt(0) === "#" && (x.charAt(1) === "x" ? (x = x.slice(2), W = parseInt(x, 16), Ve = W.toString(16)) : (x = x.slice(1), W = parseInt(x, 10), Ve = W.toString(10))), x = x.replace(/^0+/, ""), isNaN(W) || Ve.toLowerCase() !== x ? (Ne(A, "Invalid character entity"), "&" + A.entity + ";") : String.fromCodePoint(W));
      }
      function Mn(A, x) {
        x === "<" ? (A.state = $.OPEN_WAKA, A.startTagPosition = A.position) : q(x) || (Ne(A, "Non-whitespace before first tag."), A.textNode = x, A.state = $.TEXT);
      }
      function fn(A, x) {
        var K = "";
        return x < A.length && (K = A.charAt(x)), K;
      }
      function Tt(A) {
        var x = this;
        if (this.error)
          throw this.error;
        if (x.closed)
          return It(
            x,
            "Cannot write after close. Assign an onready handler."
          );
        if (A === null)
          return nt(x);
        typeof A == "object" && (A = A.toString());
        for (var K = 0, W = ""; W = fn(A, K++), x.c = W, !!W; )
          switch (x.trackPosition && (x.position++, W === `
` ? (x.line++, x.column = 0) : x.column++), x.state) {
            case $.BEGIN:
              if (x.state = $.BEGIN_WHITESPACE, W === "\uFEFF")
                continue;
              Mn(x, W);
              continue;
            case $.BEGIN_WHITESPACE:
              Mn(x, W);
              continue;
            case $.TEXT:
              if (x.sawRoot && !x.closedRoot) {
                for (var Ve = K - 1; W && W !== "<" && W !== "&"; )
                  W = fn(A, K++), W && x.trackPosition && (x.position++, W === `
` ? (x.line++, x.column = 0) : x.column++);
                x.textNode += A.substring(Ve, K - 1);
              }
              W === "<" && !(x.sawRoot && x.closedRoot && !x.strict) ? (x.state = $.OPEN_WAKA, x.startTagPosition = x.position) : (!q(W) && (!x.sawRoot || x.closedRoot) && Ne(x, "Text data outside of root node."), W === "&" ? x.state = $.TEXT_ENTITY : x.textNode += W);
              continue;
            case $.SCRIPT:
              W === "<" ? x.state = $.SCRIPT_ENDING : x.script += W;
              continue;
            case $.SCRIPT_ENDING:
              W === "/" ? x.state = $.CLOSE_TAG : (x.script += "<" + W, x.state = $.SCRIPT);
              continue;
            case $.OPEN_WAKA:
              if (W === "!")
                x.state = $.SGML_DECL, x.sgmlDecl = "";
              else if (!q(W)) if (we(xe, W))
                x.state = $.OPEN_TAG, x.tagName = W;
              else if (W === "/")
                x.state = $.CLOSE_TAG, x.tagName = "";
              else if (W === "?")
                x.state = $.PROC_INST, x.procInstName = x.procInstBody = "";
              else {
                if (Ne(x, "Unencoded <"), x.startTagPosition + 1 < x.position) {
                  var S = x.position - x.startTagPosition;
                  W = new Array(S).join(" ") + W;
                }
                x.textNode += "<" + W, x.state = $.TEXT;
              }
              continue;
            case $.SGML_DECL:
              if (x.sgmlDecl + W === "--") {
                x.state = $.COMMENT, x.comment = "", x.sgmlDecl = "";
                continue;
              }
              x.doctype && x.doctype !== !0 && x.sgmlDecl ? (x.state = $.DOCTYPE_DTD, x.doctype += "<!" + x.sgmlDecl + W, x.sgmlDecl = "") : (x.sgmlDecl + W).toUpperCase() === L ? (Me(x, "onopencdata"), x.state = $.CDATA, x.sgmlDecl = "", x.cdata = "") : (x.sgmlDecl + W).toUpperCase() === B ? (x.state = $.DOCTYPE, (x.doctype || x.sawRoot) && Ne(
                x,
                "Inappropriately located doctype declaration"
              ), x.doctype = "", x.sgmlDecl = "") : W === ">" ? (Me(x, "onsgmldeclaration", x.sgmlDecl), x.sgmlDecl = "", x.state = $.TEXT) : (M(W) && (x.state = $.SGML_DECL_QUOTED), x.sgmlDecl += W);
              continue;
            case $.SGML_DECL_QUOTED:
              W === x.q && (x.state = $.SGML_DECL, x.q = ""), x.sgmlDecl += W;
              continue;
            case $.DOCTYPE:
              W === ">" ? (x.state = $.TEXT, Me(x, "ondoctype", x.doctype), x.doctype = !0) : (x.doctype += W, W === "[" ? x.state = $.DOCTYPE_DTD : M(W) && (x.state = $.DOCTYPE_QUOTED, x.q = W));
              continue;
            case $.DOCTYPE_QUOTED:
              x.doctype += W, W === x.q && (x.q = "", x.state = $.DOCTYPE);
              continue;
            case $.DOCTYPE_DTD:
              W === "]" ? (x.doctype += W, x.state = $.DOCTYPE) : W === "<" ? (x.state = $.OPEN_WAKA, x.startTagPosition = x.position) : M(W) ? (x.doctype += W, x.state = $.DOCTYPE_DTD_QUOTED, x.q = W) : x.doctype += W;
              continue;
            case $.DOCTYPE_DTD_QUOTED:
              x.doctype += W, W === x.q && (x.state = $.DOCTYPE_DTD, x.q = "");
              continue;
            case $.COMMENT:
              W === "-" ? x.state = $.COMMENT_ENDING : x.comment += W;
              continue;
            case $.COMMENT_ENDING:
              W === "-" ? (x.state = $.COMMENT_ENDED, x.comment = Tn(x.opt, x.comment), x.comment && Me(x, "oncomment", x.comment), x.comment = "") : (x.comment += "-" + W, x.state = $.COMMENT);
              continue;
            case $.COMMENT_ENDED:
              W !== ">" ? (Ne(x, "Malformed comment"), x.comment += "--" + W, x.state = $.COMMENT) : x.doctype && x.doctype !== !0 ? x.state = $.DOCTYPE_DTD : x.state = $.TEXT;
              continue;
            case $.CDATA:
              W === "]" ? x.state = $.CDATA_ENDING : x.cdata += W;
              continue;
            case $.CDATA_ENDING:
              W === "]" ? x.state = $.CDATA_ENDING_2 : (x.cdata += "]" + W, x.state = $.CDATA);
              continue;
            case $.CDATA_ENDING_2:
              W === ">" ? (x.cdata && Me(x, "oncdata", x.cdata), Me(x, "onclosecdata"), x.cdata = "", x.state = $.TEXT) : W === "]" ? x.cdata += "]" : (x.cdata += "]]" + W, x.state = $.CDATA);
              continue;
            case $.PROC_INST:
              W === "?" ? x.state = $.PROC_INST_ENDING : q(W) ? x.state = $.PROC_INST_BODY : x.procInstName += W;
              continue;
            case $.PROC_INST_BODY:
              if (!x.procInstBody && q(W))
                continue;
              W === "?" ? x.state = $.PROC_INST_ENDING : x.procInstBody += W;
              continue;
            case $.PROC_INST_ENDING:
              W === ">" ? (Me(x, "onprocessinginstruction", {
                name: x.procInstName,
                body: x.procInstBody
              }), x.procInstName = x.procInstBody = "", x.state = $.TEXT) : (x.procInstBody += "?" + W, x.state = $.PROC_INST_BODY);
              continue;
            case $.OPEN_TAG:
              we(le, W) ? x.tagName += W : (Fe(x), W === ">" ? _t(x) : W === "/" ? x.state = $.OPEN_TAG_SLASH : (q(W) || Ne(x, "Invalid character in tag name"), x.state = $.ATTRIB));
              continue;
            case $.OPEN_TAG_SLASH:
              W === ">" ? (_t(x, !0), kt(x)) : (Ne(x, "Forward-slash in opening tag not followed by >"), x.state = $.ATTRIB);
              continue;
            case $.ATTRIB:
              if (q(W))
                continue;
              W === ">" ? _t(x) : W === "/" ? x.state = $.OPEN_TAG_SLASH : we(xe, W) ? (x.attribName = W, x.attribValue = "", x.state = $.ATTRIB_NAME) : Ne(x, "Invalid attribute name");
              continue;
            case $.ATTRIB_NAME:
              W === "=" ? x.state = $.ATTRIB_VALUE : W === ">" ? (Ne(x, "Attribute without value"), x.attribValue = x.attribName, ct(x), _t(x)) : q(W) ? x.state = $.ATTRIB_NAME_SAW_WHITE : we(le, W) ? x.attribName += W : Ne(x, "Invalid attribute name");
              continue;
            case $.ATTRIB_NAME_SAW_WHITE:
              if (W === "=")
                x.state = $.ATTRIB_VALUE;
              else {
                if (q(W))
                  continue;
                Ne(x, "Attribute without value"), x.tag.attributes[x.attribName] = "", x.attribValue = "", Me(x, "onattribute", {
                  name: x.attribName,
                  value: ""
                }), x.attribName = "", W === ">" ? _t(x) : we(xe, W) ? (x.attribName = W, x.state = $.ATTRIB_NAME) : (Ne(x, "Invalid attribute name"), x.state = $.ATTRIB);
              }
              continue;
            case $.ATTRIB_VALUE:
              if (q(W))
                continue;
              M(W) ? (x.q = W, x.state = $.ATTRIB_VALUE_QUOTED) : (x.opt.unquotedAttributeValues || It(x, "Unquoted attribute value"), x.state = $.ATTRIB_VALUE_UNQUOTED, x.attribValue = W);
              continue;
            case $.ATTRIB_VALUE_QUOTED:
              if (W !== x.q) {
                W === "&" ? x.state = $.ATTRIB_VALUE_ENTITY_Q : x.attribValue += W;
                continue;
              }
              ct(x), x.q = "", x.state = $.ATTRIB_VALUE_CLOSED;
              continue;
            case $.ATTRIB_VALUE_CLOSED:
              q(W) ? x.state = $.ATTRIB : W === ">" ? _t(x) : W === "/" ? x.state = $.OPEN_TAG_SLASH : we(xe, W) ? (Ne(x, "No whitespace between attributes"), x.attribName = W, x.attribValue = "", x.state = $.ATTRIB_NAME) : Ne(x, "Invalid attribute name");
              continue;
            case $.ATTRIB_VALUE_UNQUOTED:
              if (!ne(W)) {
                W === "&" ? x.state = $.ATTRIB_VALUE_ENTITY_U : x.attribValue += W;
                continue;
              }
              ct(x), W === ">" ? _t(x) : x.state = $.ATTRIB;
              continue;
            case $.CLOSE_TAG:
              if (x.tagName)
                W === ">" ? kt(x) : we(le, W) ? x.tagName += W : x.script ? (x.script += "</" + x.tagName, x.tagName = "", x.state = $.SCRIPT) : (q(W) || Ne(x, "Invalid tagname in closing tag"), x.state = $.CLOSE_TAG_SAW_WHITE);
              else {
                if (q(W))
                  continue;
                _e(xe, W) ? x.script ? (x.script += "</" + W, x.state = $.SCRIPT) : Ne(x, "Invalid tagname in closing tag.") : x.tagName = W;
              }
              continue;
            case $.CLOSE_TAG_SAW_WHITE:
              if (q(W))
                continue;
              W === ">" ? kt(x) : Ne(x, "Invalid characters in closing tag");
              continue;
            case $.TEXT_ENTITY:
            case $.ATTRIB_VALUE_ENTITY_Q:
            case $.ATTRIB_VALUE_ENTITY_U:
              var F, te;
              switch (x.state) {
                case $.TEXT_ENTITY:
                  F = $.TEXT, te = "textNode";
                  break;
                case $.ATTRIB_VALUE_ENTITY_Q:
                  F = $.ATTRIB_VALUE_QUOTED, te = "attribValue";
                  break;
                case $.ATTRIB_VALUE_ENTITY_U:
                  F = $.ATTRIB_VALUE_UNQUOTED, te = "attribValue";
                  break;
              }
              if (W === ";") {
                var oe = jt(x);
                x.opt.unparsedEntities && !Object.values(r.XML_ENTITIES).includes(oe) ? (x.entity = "", x.state = F, x.write(oe)) : (x[te] += oe, x.entity = "", x.state = F);
              } else we(x.entity.length ? Y : U, W) ? x.entity += W : (Ne(x, "Invalid character in entity name"), x[te] += "&" + x.entity + W, x.entity = "", x.state = F);
              continue;
            default:
              throw new Error(x, "Unknown state: " + x.state);
          }
        return x.position >= x.bufferCheckPosition && c(x), x;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var A = String.fromCharCode, x = Math.floor, K = function() {
          var W = 16384, Ve = [], S, F, te = -1, oe = arguments.length;
          if (!oe)
            return "";
          for (var ue = ""; ++te < oe; ) {
            var se = Number(arguments[te]);
            if (!isFinite(se) || // `NaN`, `+Infinity`, or `-Infinity`
            se < 0 || // not a valid Unicode code point
            se > 1114111 || // not a valid Unicode code point
            x(se) !== se)
              throw RangeError("Invalid code point: " + se);
            se <= 65535 ? Ve.push(se) : (se -= 65536, S = (se >> 10) + 55296, F = se % 1024 + 56320, Ve.push(S, F)), (te + 1 === oe || Ve.length > W) && (ue += A.apply(null, Ve), Ve.length = 0);
          }
          return ue;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: K,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = K;
      }();
    })(n);
  }(Au)), Au;
}
Bd();
const ut = "sclElements", $d = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
var va = { exports: {} }, qd = va.exports, Ru;
function Ud() {
  return Ru || (Ru = 1, function(n, r) {
    (function(s, u) {
      n.exports = u();
    })(qd, function() {
      var s = function(e, t) {
        return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (o[a] = i[a]);
        })(e, t);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var t, o = 1, i = arguments.length; o < i; o++) for (var a in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, a) && (e[a] = t[a]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, t, o) {
        for (var i, a = 0, l = t.length; a < l; a++) !i && a in t || ((i = i || Array.prototype.slice.call(t, 0, a))[a] = t[a]);
        return e.concat(i || Array.prototype.slice.call(t));
      }
      var f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : jd, p = Object.keys, h = Array.isArray;
      function g(e, t) {
        return typeof t != "object" || p(t).forEach(function(o) {
          e[o] = t[o];
        }), e;
      }
      typeof Promise > "u" || f.Promise || (f.Promise = Promise);
      var R = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function L(e, t) {
        return D.call(e, t);
      }
      function B(e, t) {
        typeof t == "function" && (t = t(R(e))), (typeof Reflect > "u" ? p : Reflect.ownKeys)(t).forEach(function(o) {
          ie(e, o, t[o]);
        });
      }
      var ee = Object.defineProperty;
      function ie(e, t, o, i) {
        ee(e, t, g(o && L(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function ce(e) {
        return { from: function(t) {
          return e.prototype = Object.create(t.prototype), ie(e.prototype, "constructor", e), { extend: B.bind(null, e.prototype) };
        } };
      }
      var xe = Object.getOwnPropertyDescriptor, le = [].slice;
      function U(e, t, o) {
        return le.call(e, t, o);
      }
      function Y(e, t) {
        return t(e);
      }
      function q(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function M(e) {
        f.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function ne(e, t) {
        if (typeof t == "string" && L(e, t)) return e[t];
        if (!t) return e;
        if (typeof t != "string") {
          for (var o = [], i = 0, a = t.length; i < a; ++i) {
            var l = ne(e, t[i]);
            o.push(l);
          }
          return o;
        }
        var d = t.indexOf(".");
        if (d !== -1) {
          var m = e[t.substr(0, d)];
          return m == null ? void 0 : ne(m, t.substr(d + 1));
        }
      }
      function we(e, t, o) {
        if (e && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) {
          q(typeof o != "string" && "length" in o);
          for (var i = 0, a = t.length; i < a; ++i) we(e, t[i], o[i]);
        } else {
          var l, d, m = t.indexOf(".");
          m !== -1 ? (l = t.substr(0, m), (d = t.substr(m + 1)) === "" ? o === void 0 ? h(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : we(m = !(m = e[l]) || !L(e, l) ? e[l] = {} : m, d, o)) : o === void 0 ? h(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = o;
        }
      }
      function _e(e) {
        var t, o = {};
        for (t in e) L(e, t) && (o[t] = e[t]);
        return o;
      }
      var $ = [].concat;
      function ze(e) {
        return $.apply([], e);
      }
      var je = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(ze([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + e + "Array";
        });
      }))).filter(function(e) {
        return f[e];
      }), dt = new Set(je.map(function(e) {
        return f[e];
      })), Me = null;
      function st(e) {
        return Me = /* @__PURE__ */ new WeakMap(), e = function t(o) {
          if (!o || typeof o != "object") return o;
          var i = Me.get(o);
          if (i) return i;
          if (h(o)) {
            i = [], Me.set(o, i);
            for (var a = 0, l = o.length; a < l; ++a) i.push(t(o[a]));
          } else if (dt.has(o.constructor)) i = o;
          else {
            var d, m = R(o);
            for (d in i = m === Object.prototype ? {} : Object.create(m), Me.set(o, i), o) L(o, d) && (i[d] = t(o[d]));
          }
          return i;
        }(e), Me = null, e;
      }
      var Tn = {}.toString;
      function It(e) {
        return Tn.call(e).slice(8, -1);
      }
      var nt = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ne = typeof nt == "symbol" ? function(e) {
        var t;
        return e != null && (t = e[nt]) && t.apply(e);
      } : function() {
        return null;
      };
      function Fe(e, t) {
        return t = e.indexOf(t), 0 <= t && e.splice(t, 1), 0 <= t;
      }
      var bt = {};
      function ct(e) {
        var t, o, i, a;
        if (arguments.length === 1) {
          if (h(e)) return e.slice();
          if (this === bt && typeof e == "string") return [e];
          if (a = Ne(e)) {
            for (o = []; !(i = a.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (t = e.length) != "number") return [e];
          for (o = new Array(t); t--; ) o[t] = e[t];
          return o;
        }
        for (t = arguments.length, o = new Array(t); t--; ) o[t] = arguments[t];
        return o;
      }
      var _t = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Pe = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], wt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Pe), kt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function jt(e, t) {
        this.name = e, this.message = t;
      }
      function Mn(e, t) {
        return e + ". Errors: " + Object.keys(t).map(function(o) {
          return t[o].toString();
        }).filter(function(o, i, a) {
          return a.indexOf(o) === i;
        }).join(`
`);
      }
      function fn(e, t, o, i) {
        this.failures = t, this.failedKeys = i, this.successCount = o, this.message = Mn(e, t);
      }
      function Tt(e, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(o) {
          return t[o];
        }), this.failuresByPos = t, this.message = Mn(e, this.failures);
      }
      ce(jt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), ce(fn).from(jt), ce(Tt).from(jt);
      var A = wt.reduce(function(e, t) {
        return e[t] = t + "Error", e;
      }, {}), x = jt, K = wt.reduce(function(e, t) {
        var o = t + "Error";
        function i(a, l) {
          this.name = o, a ? typeof a == "string" ? (this.message = "".concat(a).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof a == "object" && (this.message = "".concat(a.name, " ").concat(a.message), this.inner = a) : (this.message = kt[t] || o, this.inner = null);
        }
        return ce(i).from(x), e[t] = i, e;
      }, {});
      K.Syntax = SyntaxError, K.Type = TypeError, K.Range = RangeError;
      var W = Pe.reduce(function(e, t) {
        return e[t + "Error"] = K[t], e;
      }, {}), Ve = wt.reduce(function(e, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = K[t]), e;
      }, {});
      function S() {
      }
      function F(e) {
        return e;
      }
      function te(e, t) {
        return e == null || e === F ? t : function(o) {
          return t(e(o));
        };
      }
      function oe(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function ue(e, t) {
        return e === S ? t : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, a = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = t.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? oe(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? oe(a, this.onerror) : a), l !== void 0 ? l : o;
        };
      }
      function se(e, t) {
        return e === S ? t : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? oe(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? oe(i, this.onerror) : i);
        };
      }
      function me(e, t) {
        return e === S ? t : function(o) {
          var i = e.apply(this, arguments);
          g(o, i);
          var a = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = t.apply(this, arguments), a && (this.onsuccess = this.onsuccess ? oe(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? oe(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : g(i, o);
        };
      }
      function ge(e, t) {
        return e === S ? t : function() {
          return t.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function de(e, t) {
        return e === S ? t : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, a = arguments.length, l = new Array(a); a--; ) l[a] = arguments[a];
            return o.then(function() {
              return t.apply(i, l);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Ve.ModifyError = fn, Ve.DexieError = jt, Ve.BulkError = Tt;
      var ae = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Se(e) {
        ae = e;
      }
      var be = {}, Ae = 100, je = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, R(e), e];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, R(t), e];
      }(), Pe = je[0], wt = je[1], je = je[2], wt = wt && wt.then, Ue = Pe && Pe.constructor, We = !!je, ht = function(e, t) {
        dn.push([e, t]), Pt && (queueMicrotask(bs), Pt = !1);
      }, Ot = !0, Pt = !0, mt = [], Qt = [], Bn = F, ot = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: S, pgp: !1, env: {}, finalize: S }, re = ot, dn = [], Jt = 0, Gn = [];
      function J(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = re;
        if (typeof e != "function") {
          if (e !== be) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Kr(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function o(i, a) {
          try {
            a(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var d = i._lib && mn();
                l && typeof l.then == "function" ? o(i, function(m, v) {
                  l instanceof J ? l._then(m, v) : l.then(m, v);
                }) : (i._state = !0, i._value = l, jo(i)), d && yn();
              }
            }, Kr.bind(null, i));
          } catch (l) {
            Kr(i, l);
          }
        }(this, e);
      }
      var Lr = { get: function() {
        var e = re, t = Qn;
        function o(i, a) {
          var l = this, d = !e.global && (e !== re || t !== Qn), m = d && !Mt(), v = new J(function(w, O) {
            Fr(l, new ko(Ko(i, e, d, m), Ko(a, e, d, m), w, O, e));
          });
          return this._consoleTask && (v._consoleTask = this._consoleTask), v;
        }
        return o.prototype = be, o;
      }, set: function(e) {
        ie(this, "then", e && e.prototype === be ? Lr : { get: function() {
          return e;
        }, set: Lr.set });
      } };
      function ko(e, t, o, i, a) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = o, this.reject = i, this.psd = a;
      }
      function Kr(e, t) {
        var o, i;
        Qt.push(t), e._state === null && (o = e._lib && mn(), t = Bn(t), e._state = !1, e._value = t, i = e, mt.some(function(a) {
          return a._value === i._value;
        }) || mt.push(i), jo(e), o && yn());
      }
      function jo(e) {
        var t = e._listeners;
        e._listeners = [];
        for (var o = 0, i = t.length; o < i; ++o) Fr(e, t[o]);
        var a = e._PSD;
        --a.ref || a.finalize(), Jt === 0 && (++Jt, ht(function() {
          --Jt == 0 && Mr();
        }, []));
      }
      function Fr(e, t) {
        if (e._state !== null) {
          var o = e._state ? t.onFulfilled : t.onRejected;
          if (o === null) return (e._state ? t.resolve : t.reject)(e._value);
          ++t.psd.ref, ++Jt, ht(gs, [o, e, t]);
        } else e._listeners.push(t);
      }
      function gs(e, t, o) {
        try {
          var i, a = t._value;
          !t._state && Qt.length && (Qt = []), i = ae && t._consoleTask ? t._consoleTask.run(function() {
            return e(a);
          }) : e(a), t._state || Qt.indexOf(a) !== -1 || function(l) {
            for (var d = mt.length; d; ) if (mt[--d]._value === l._value) return mt.splice(d, 1);
          }(t), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Jt == 0 && Mr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function bs() {
        Zt(ot, function() {
          mn() && yn();
        });
      }
      function mn() {
        var e = Ot;
        return Pt = Ot = !1, e;
      }
      function yn() {
        var e, t, o;
        do
          for (; 0 < dn.length; ) for (e = dn, dn = [], o = e.length, t = 0; t < o; ++t) {
            var i = e[t];
            i[0].apply(null, i[1]);
          }
        while (0 < dn.length);
        Pt = Ot = !0;
      }
      function Mr() {
        var e = mt;
        mt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var t = Gn.slice(0), o = t.length; o; ) t[--o]();
      }
      function Yn(e) {
        return new J(be, !1, e);
      }
      function Le(e, t) {
        var o = re;
        return function() {
          var i = mn(), a = re;
          try {
            return Bt(o, !0), e.apply(this, arguments);
          } catch (l) {
            t && t(l);
          } finally {
            Bt(a, !1), i && yn();
          }
        };
      }
      B(J.prototype, { then: Lr, _then: function(e, t) {
        Fr(this, new ko(null, null, e, t, re));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var t = e, o = arguments[1];
        return typeof t == "function" ? this.then(null, function(i) {
          return (i instanceof t ? o : Yn)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === t ? o : Yn)(i);
        });
      }, finally: function(e) {
        return this.then(function(t) {
          return J.resolve(e()).then(function() {
            return t;
          });
        }, function(t) {
          return J.resolve(e()).then(function() {
            return Yn(t);
          });
        });
      }, timeout: function(e, t) {
        var o = this;
        return e < 1 / 0 ? new J(function(i, a) {
          var l = setTimeout(function() {
            return a(new K.Timeout(t));
          }, e);
          o.then(i, a).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && ie(J.prototype, Symbol.toStringTag, "Dexie.Promise"), ot.env = Lo(), B(J, { all: function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t, o) {
          e.length === 0 && t([]);
          var i = e.length;
          e.forEach(function(a, l) {
            return J.resolve(a).then(function(d) {
              e[l] = d, --i || t(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof J ? e : e && typeof e.then == "function" ? new J(function(t, o) {
          e.then(t, o);
        }) : new J(be, !0, e);
      }, reject: Yn, race: function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t, o) {
          e.map(function(i) {
            return J.resolve(i).then(t, o);
          });
        });
      }, PSD: { get: function() {
        return re;
      }, set: function(e) {
        return re = e;
      } }, totalEchoes: { get: function() {
        return Qn;
      } }, newPSD: Ft, usePSD: Zt, scheduler: { get: function() {
        return ht;
      }, set: function(e) {
        ht = e;
      } }, rejectionMapper: { get: function() {
        return Bn;
      }, set: function(e) {
        Bn = e;
      } }, follow: function(e, t) {
        return new J(function(o, i) {
          return Ft(function(a, l) {
            var d = re;
            d.unhandleds = [], d.onunhandled = l, d.finalize = oe(function() {
              var m, v = this;
              m = function() {
                v.unhandleds.length === 0 ? a() : l(v.unhandleds[0]);
              }, Gn.push(function w() {
                m(), Gn.splice(Gn.indexOf(w), 1);
              }), ++Jt, ht(function() {
                --Jt == 0 && Mr();
              }, []);
            }, d.finalize), e();
          }, t, o, i);
        });
      } }), Ue && (Ue.allSettled && ie(J, "allSettled", function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t) {
          e.length === 0 && t([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(a, l) {
            return J.resolve(a).then(function(d) {
              return i[l] = { status: "fulfilled", value: d };
            }, function(d) {
              return i[l] = { status: "rejected", reason: d };
            }).then(function() {
              return --o || t(i);
            });
          });
        });
      }), Ue.any && typeof AggregateError < "u" && ie(J, "any", function() {
        var e = ct.apply(null, arguments).map(Jn);
        return new J(function(t, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, a = new Array(i);
          e.forEach(function(l, d) {
            return J.resolve(l).then(function(m) {
              return t(m);
            }, function(m) {
              a[d] = m, --i || o(new AggregateError(a));
            });
          });
        });
      }), Ue.withResolvers && (J.withResolvers = Ue.withResolvers));
      var Ge = { awaits: 0, echoes: 0, id: 0 }, ws = 0, Xn = [], zn = 0, Qn = 0, _s = 0;
      function Ft(e, t, o, i) {
        var a = re, l = Object.create(a);
        return l.parent = a, l.ref = 0, l.global = !1, l.id = ++_s, ot.env, l.env = We ? { Promise: J, PromiseProp: { value: J, configurable: !0, writable: !0 }, all: J.all, race: J.race, allSettled: J.allSettled, any: J.any, resolve: J.resolve, reject: J.reject } : {}, t && g(l, t), ++a.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = Zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function vn() {
        return Ge.id || (Ge.id = ++ws), ++Ge.awaits, Ge.echoes += Ae, Ge.id;
      }
      function Mt() {
        return !!Ge.awaits && (--Ge.awaits == 0 && (Ge.id = 0), Ge.echoes = Ge.awaits * Ae, !0);
      }
      function Jn(e) {
        return Ge.echoes && e && e.constructor === Ue ? (vn(), e.then(function(t) {
          return Mt(), t;
        }, function(t) {
          return Mt(), Be(t);
        })) : e;
      }
      function xs() {
        var e = Xn[Xn.length - 1];
        Xn.pop(), Bt(e, !1);
      }
      function Bt(e, t) {
        var o, i = re;
        (t ? !Ge.echoes || zn++ && e === re : !zn || --zn && e === re) || queueMicrotask(t ? (function(a) {
          ++Qn, Ge.echoes && --Ge.echoes != 0 || (Ge.echoes = Ge.awaits = Ge.id = 0), Xn.push(re), Bt(a, !0);
        }).bind(null, e) : xs), e !== re && (re = e, i === ot && (ot.env = Lo()), We && (o = ot.env.Promise, t = e.env, (i.global || e.global) && (Object.defineProperty(f, "Promise", t.PromiseProp), o.all = t.all, o.race = t.race, o.resolve = t.resolve, o.reject = t.reject, t.allSettled && (o.allSettled = t.allSettled), t.any && (o.any = t.any))));
      }
      function Lo() {
        var e = f.Promise;
        return We ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function Zt(e, t, o, i, a) {
        var l = re;
        try {
          return Bt(e, !0), t(o, i, a);
        } finally {
          Bt(l, !1);
        }
      }
      function Ko(e, t, o, i) {
        return typeof e != "function" ? e : function() {
          var a = re;
          o && vn(), Bt(t, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Bt(a, !1), i && queueMicrotask(Mt);
          }
        };
      }
      function Br(e) {
        Promise === Ue && Ge.echoes === 0 ? zn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + wt).indexOf("[native code]") === -1 && (vn = Mt = S);
      var Be = J.reject, en = "￿", Dt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Fo = "String expected.", gn = [], Zn = "__dbnames", $r = "readonly", qr = "readwrite";
      function tn(e, t) {
        return e ? t ? function() {
          return e.apply(this, arguments) && t.apply(this, arguments);
        } : e : t;
      }
      var Mo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function er(e) {
        return typeof e != "string" || /\./.test(e) ? function(t) {
          return t;
        } : function(t) {
          return t[e] === void 0 && e in t && delete (t = st(t))[e], t;
        };
      }
      function Bo() {
        throw K.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function Oe(e, t) {
        try {
          var o = $o(e), i = $o(t);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return t < e ? 1 : e < t ? -1 : 0;
            case "binary":
              return function(a, l) {
                for (var d = a.length, m = l.length, v = d < m ? d : m, w = 0; w < v; ++w) if (a[w] !== l[w]) return a[w] < l[w] ? -1 : 1;
                return d === m ? 0 : d < m ? -1 : 1;
              }(qo(e), qo(t));
            case "Array":
              return function(a, l) {
                for (var d = a.length, m = l.length, v = d < m ? d : m, w = 0; w < v; ++w) {
                  var O = Oe(a[w], l[w]);
                  if (O !== 0) return O;
                }
                return d === m ? 0 : d < m ? -1 : 1;
              }(e, t);
          }
        } catch {
        }
        return NaN;
      }
      function $o(e) {
        var t = typeof e;
        return t != "object" ? t : ArrayBuffer.isView(e) ? "binary" : (e = It(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function qo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function tr(e, t, o) {
        var i = e.schema.yProps;
        return i ? (t && 0 < o.numFailures && (t = t.filter(function(a, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(a) {
          return a = a.updatesTable, t ? e.db.table(a).where("k").anyOf(t).delete() : e.db.table(a).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Uo = (Ie.prototype._trans = function(e, t, o) {
        var i = this._tx || re.trans, a = this.name, l = ae && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function d(w, O, y) {
          if (!y.schema[a]) throw new K.NotFound("Table " + a + " not part of transaction");
          return t(y.idbtrans, y);
        }
        var m = mn();
        try {
          var v = i && i.db._novip === this.db._novip ? i === re.trans ? i._promise(e, d, o) : Ft(function() {
            return i._promise(e, d, o);
          }, { trans: i, transless: re.transless || re }) : function w(O, y, N, b) {
            if (O.idbdb && (O._state.openComplete || re.letThrough || O._vip)) {
              var _ = O._createTransaction(y, N, O._dbSchema);
              try {
                _.create(), O._state.PR1398_maxLoop = 3;
              } catch (E) {
                return E.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                  return w(O, y, N, b);
                })) : Be(E);
              }
              return _._promise(y, function(E, T) {
                return Ft(function() {
                  return re.trans = _, b(E, T, _);
                });
              }).then(function(E) {
                if (y === "readwrite") try {
                  _.idbtrans.commit();
                } catch {
                }
                return y === "readonly" ? E : _._completion.then(function() {
                  return E;
                });
              });
            }
            if (O._state.openComplete) return Be(new K.DatabaseClosed(O._state.dbOpenError));
            if (!O._state.isBeingOpened) {
              if (!O._state.autoOpen) return Be(new K.DatabaseClosed());
              O.open().catch(S);
            }
            return O._state.dbReadyPromise.then(function() {
              return w(O, y, N, b);
            });
          }(this.db, e, [this.name], d);
          return l && (v._consoleTask = l, v = v.catch(function(w) {
            return console.trace(w), Be(w);
          })), v;
        } finally {
          m && yn();
        }
      }, Ie.prototype.get = function(e, t) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(t) : e == null ? Be(new K.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(a) {
            return o.hook.reading.fire(a);
          });
        }).then(t);
      }, Ie.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (h(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var t = p(e);
        if (t.length === 1) return this.where(t[0]).equals(e[t[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(m) {
          if (m.compound && t.every(function(w) {
            return 0 <= m.keyPath.indexOf(w);
          })) {
            for (var v = 0; v < t.length; ++v) if (t.indexOf(m.keyPath[v]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(m, v) {
          return m.keyPath.length - v.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== en) {
          var l = o.keyPath.slice(0, t.length);
          return this.where(l).equals(l.map(function(v) {
            return e[v];
          }));
        }
        !o && ae && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var i = this.schema.idxByName;
        function a(m, v) {
          return Oe(m, v) === 0;
        }
        var d = t.reduce(function(y, v) {
          var w = y[0], O = y[1], y = i[v], N = e[v];
          return [w || y, w || !y ? tn(O, y && y.multi ? function(b) {
            return b = ne(b, v), h(b) && b.some(function(_) {
              return a(N, _);
            });
          } : function(b) {
            return a(N, ne(b, v));
          }) : O];
        }, [null, null]), l = d[0], d = d[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(d) : o ? this.filter(d) : this.where(t).equals("");
      }, Ie.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Ie.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Ie.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Ie.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Ie.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Ie.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Ie.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ie.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, h(e) ? "[".concat(e.join("+"), "]") : e));
      }, Ie.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ie.prototype.mapToClass = function(e) {
        var t, o = this.db, i = this.name;
        function a() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Bo && (function(v, w) {
          if (typeof w != "function" && w !== null) throw new TypeError("Class extends value " + String(w) + " is not a constructor or null");
          function O() {
            this.constructor = v;
          }
          s(v, w), v.prototype = w === null ? Object.create(w) : (O.prototype = w.prototype, new O());
        }(a, t = e), Object.defineProperty(a.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), a.prototype.table = function() {
          return i;
        }, e = a);
        for (var l = /* @__PURE__ */ new Set(), d = e.prototype; d; d = R(d)) Object.getOwnPropertyNames(d).forEach(function(v) {
          return l.add(v);
        });
        function m(v) {
          if (!v) return v;
          var w, O = Object.create(e.prototype);
          for (w in v) if (!l.has(w)) try {
            O[w] = v[w];
          } catch {
          }
          return O;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = m, this.hook("reading", m), e;
      }, Ie.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          g(this, e);
        });
      }, Ie.prototype.add = function(e, t) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, d = e;
        return l && a && (d = er(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "add", keys: t != null ? [t] : null, values: [d] });
        }).then(function(m) {
          return m.numFailures ? J.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            we(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.update = function(e, t) {
        return typeof e != "object" || h(e) ? this.where(":id").equals(e).modify(t) : (e = ne(e, this.schema.primKey.keyPath), e === void 0 ? Be(new K.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(t));
      }, Ie.prototype.put = function(e, t) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, d = e;
        return l && a && (d = er(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "put", values: [d], keys: t != null ? [t] : null });
        }).then(function(m) {
          return m.numFailures ? J.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            we(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.delete = function(e) {
        var t = this;
        return this._trans("readwrite", function(o) {
          return t.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return tr(t, [e], i);
          }).then(function(i) {
            return i.numFailures ? J.reject(i.failures[0]) : void 0;
          });
        });
      }, Ie.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(t) {
          return e.core.mutate({ trans: t, type: "deleteRange", range: Mo }).then(function(o) {
            return tr(e, null, o);
          });
        }).then(function(t) {
          return t.numFailures ? J.reject(t.failures[0]) : void 0;
        });
      }, Ie.prototype.bulkGet = function(e) {
        var t = this;
        return this._trans("readonly", function(o) {
          return t.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(a) {
              return t.hook.reading.fire(a);
            });
          });
        });
      }, Ie.prototype.bulkAdd = function(e, t, o) {
        var i = this, a = Array.isArray(t) ? t : void 0, l = (o = o || (a ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var w = i.schema.primKey, m = w.auto, w = w.keyPath;
          if (w && a) throw new K.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, w = w && m ? e.map(er(w)) : e;
          return i.core.mutate({ trans: d, type: "add", keys: a, values: w, wantResults: l }).then(function(_) {
            var y = _.numFailures, N = _.results, b = _.lastResult, _ = _.failures;
            if (y === 0) return l ? N : b;
            throw new Tt("".concat(i.name, ".bulkAdd(): ").concat(y, " of ").concat(v, " operations failed"), _);
          });
        });
      }, Ie.prototype.bulkPut = function(e, t, o) {
        var i = this, a = Array.isArray(t) ? t : void 0, l = (o = o || (a ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var w = i.schema.primKey, m = w.auto, w = w.keyPath;
          if (w && a) throw new K.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, w = w && m ? e.map(er(w)) : e;
          return i.core.mutate({ trans: d, type: "put", keys: a, values: w, wantResults: l }).then(function(_) {
            var y = _.numFailures, N = _.results, b = _.lastResult, _ = _.failures;
            if (y === 0) return l ? N : b;
            throw new Tt("".concat(i.name, ".bulkPut(): ").concat(y, " of ").concat(v, " operations failed"), _);
          });
        });
      }, Ie.prototype.bulkUpdate = function(e) {
        var t = this, o = this.core, i = e.map(function(d) {
          return d.key;
        }), a = e.map(function(d) {
          return d.changes;
        }), l = [];
        return this._trans("readwrite", function(d) {
          return o.getMany({ trans: d, keys: i, cache: "clone" }).then(function(m) {
            var v = [], w = [];
            e.forEach(function(y, N) {
              var b = y.key, _ = y.changes, E = m[N];
              if (E) {
                for (var T = 0, C = Object.keys(_); T < C.length; T++) {
                  var P = C[T], I = _[P];
                  if (P === t.schema.primKey.keyPath) {
                    if (Oe(I, b) !== 0) throw new K.Constraint("Cannot update primary key in bulkUpdate()");
                  } else we(E, P, I);
                }
                l.push(N), v.push(b), w.push(E);
              }
            });
            var O = v.length;
            return o.mutate({ trans: d, type: "put", keys: v, values: w, updates: { keys: i, changeSpecs: a } }).then(function(y) {
              var N = y.numFailures, b = y.failures;
              if (N === 0) return O;
              for (var _ = 0, E = Object.keys(b); _ < E.length; _++) {
                var T, C = E[_], P = l[Number(C)];
                P != null && (T = b[C], delete b[C], b[P] = T);
              }
              throw new Tt("".concat(t.name, ".bulkUpdate(): ").concat(N, " of ").concat(O, " operations failed"), b);
            });
          });
        });
      }, Ie.prototype.bulkDelete = function(e) {
        var t = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return t.core.mutate({ trans: i, type: "delete", keys: e }).then(function(a) {
            return tr(t, e, a);
          });
        }).then(function(d) {
          var a = d.numFailures, l = d.lastResult, d = d.failures;
          if (a === 0) return l;
          throw new Tt("".concat(t.name, ".bulkDelete(): ").concat(a, " of ").concat(o, " operations failed"), d);
        });
      }, Ie);
      function Ie() {
      }
      function Sn(e) {
        function t(d, m) {
          if (m) {
            for (var v = arguments.length, w = new Array(v - 1); --v; ) w[v - 1] = arguments[v];
            return o[d].subscribe.apply(null, w), e;
          }
          if (typeof d == "string") return o[d];
        }
        var o = {};
        t.addEventType = l;
        for (var i = 1, a = arguments.length; i < a; ++i) l(arguments[i]);
        return t;
        function l(d, m, v) {
          if (typeof d != "object") {
            var w;
            m = m || ge;
            var O = { subscribers: [], fire: v = v || S, subscribe: function(y) {
              O.subscribers.indexOf(y) === -1 && (O.subscribers.push(y), O.fire = m(O.fire, y));
            }, unsubscribe: function(y) {
              O.subscribers = O.subscribers.filter(function(N) {
                return N !== y;
              }), O.fire = O.subscribers.reduce(m, v);
            } };
            return o[d] = t[d] = O;
          }
          p(w = d).forEach(function(y) {
            var N = w[y];
            if (h(N)) l(y, w[y][0], w[y][1]);
            else {
              if (N !== "asap") throw new K.InvalidArgument("Invalid event config");
              var b = l(y, F, function() {
                for (var _ = arguments.length, E = new Array(_); _--; ) E[_] = arguments[_];
                b.subscribers.forEach(function(T) {
                  M(function() {
                    T.apply(null, E);
                  });
                });
              });
            }
          });
        }
      }
      function An(e, t) {
        return ce(t).from({ prototype: e }), t;
      }
      function bn(e, t) {
        return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);
      }
      function Ur(e, t) {
        e.filter = tn(e.filter, t);
      }
      function Vr(e, t, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return tn(i(), t());
        } : t, e.justLimit = o && !i;
      }
      function nr(e, t) {
        if (e.isPrimKey) return t.primaryKey;
        var o = t.getIndexByKeyPath(e.index);
        if (!o) throw new K.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return o;
      }
      function Vo(e, t, o) {
        var i = nr(e, t.schema);
        return t.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function rr(e, t, o, i) {
        var a = e.replayFilter ? tn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, d = function(m, v, w) {
            var O, y;
            a && !a(v, w, function(N) {
              return v.stop(N);
            }, function(N) {
              return v.fail(N);
            }) || ((y = "" + (O = v.primaryKey)) == "[object ArrayBuffer]" && (y = "" + new Uint8Array(O)), L(l, y) || (l[y] = !0, t(m, v, w)));
          };
          return Promise.all([e.or._iterate(d, o), Ho(Vo(e, i, o), e.algorithm, d, !e.keysOnly && e.valueMapper)]);
        }
        return Ho(Vo(e, i, o), tn(e.algorithm, a), t, !e.keysOnly && e.valueMapper);
      }
      function Ho(e, t, o, i) {
        var a = Le(i ? function(l, d, m) {
          return o(i(l), d, m);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var d = function() {
              return l.continue();
            };
            t && !t(l, function(m) {
              return d = m;
            }, function(m) {
              l.stop(m), d = S;
            }, function(m) {
              l.fail(m), d = S;
            }) || a(l.value, l, function(m) {
              return d = m;
            }), d();
          });
        });
      }
      var Pn = (Wo.prototype.execute = function(e) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var o = t.add;
          if (h(o)) return c(c([], h(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (t.remove !== void 0) {
          var i = t.remove;
          if (h(i)) return h(e) ? e.filter(function(a) {
            return !i.includes(a);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = t.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? t.replacePrefix[1] + e.substring(o.length) : e;
      }, Wo);
      function Wo(e) {
        this["@@propmod"] = e;
      }
      var Os = (Ce.prototype._read = function(e, t) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, Be.bind(null, o.error)) : o.table._trans("readonly", e).then(t);
      }, Ce.prototype._write = function(e) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, Be.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
      }, Ce.prototype._addAlgorithm = function(e) {
        var t = this._ctx;
        t.algorithm = tn(t.algorithm, e);
      }, Ce.prototype._iterate = function(e, t) {
        return rr(this._ctx, e, t, this._ctx.table.core);
      }, Ce.prototype.clone = function(e) {
        var t = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && g(o, e), t._ctx = o, t;
      }, Ce.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ce.prototype.each = function(e) {
        var t = this._ctx;
        return this._read(function(o) {
          return rr(t, e, o, t.table.core);
        });
      }, Ce.prototype.count = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx, a = i.table.core;
          if (bn(i, !0)) return a.count({ trans: o, query: { index: nr(i, a.schema), range: i.range } }).then(function(d) {
            return Math.min(d, i.limit);
          });
          var l = 0;
          return rr(i, function() {
            return ++l, !1;
          }, o, a).then(function() {
            return l;
          });
        }).then(e);
      }, Ce.prototype.sortBy = function(e, t) {
        var o = e.split(".").reverse(), i = o[0], a = o.length - 1;
        function l(v, w) {
          return w ? l(v[o[w]], w - 1) : v[i];
        }
        var d = this._ctx.dir === "next" ? 1 : -1;
        function m(v, w) {
          return Oe(l(v, a), l(w, a)) * d;
        }
        return this.toArray(function(v) {
          return v.sort(m);
        }).then(t);
      }, Ce.prototype.toArray = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx;
          if (i.dir === "next" && bn(i, !0) && 0 < i.limit) {
            var a = i.valueMapper, l = nr(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(m) {
              return m = m.result, a ? m.map(a) : m;
            });
          }
          var d = [];
          return rr(i, function(m) {
            return d.push(m);
          }, o, i.table.core).then(function() {
            return d;
          });
        }, e);
      }, Ce.prototype.offset = function(e) {
        var t = this._ctx;
        return e <= 0 || (t.offset += e, bn(t) ? Vr(t, function() {
          var o = e;
          return function(i, a) {
            return o === 0 || (o === 1 ? --o : a(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : Vr(t, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Ce.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Vr(this._ctx, function() {
          var t = e;
          return function(o, i, a) {
            return --t <= 0 && i(a), 0 <= t;
          };
        }, !0), this;
      }, Ce.prototype.until = function(e, t) {
        return Ur(this._ctx, function(o, i, a) {
          return !e(o.value) || (i(a), t);
        }), this;
      }, Ce.prototype.first = function(e) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(e);
      }, Ce.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Ce.prototype.filter = function(e) {
        var t;
        return Ur(this._ctx, function(o) {
          return e(o.value);
        }), (t = this._ctx).isMatch = tn(t.isMatch, e), this;
      }, Ce.prototype.and = function(e) {
        return this.filter(e);
      }, Ce.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Ce.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ce.prototype.desc = function() {
        return this.reverse();
      }, Ce.prototype.eachKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, Ce.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Ce.prototype.eachPrimaryKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, Ce.prototype.keys = function(e) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Ce.prototype.primaryKeys = function(e) {
        var t = this._ctx;
        if (t.dir === "next" && bn(t, !0) && 0 < t.limit) return this._read(function(i) {
          var a = nr(t, t.table.core.schema);
          return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: a, range: t.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Ce.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Ce.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(e);
      }, Ce.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Ce.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var t = {};
        return Ur(this._ctx, function(a) {
          var i = a.primaryKey.toString(), a = L(t, i);
          return t[i] = !0, !a;
        }), this;
      }, Ce.prototype.modify = function(e) {
        var t = this, o = this._ctx;
        return this._write(function(i) {
          var a, l, d;
          d = typeof e == "function" ? e : (a = p(e), l = a.length, function(C) {
            for (var P = !1, I = 0; I < l; ++I) {
              var k = a[I], V = e[k], X = ne(C, k);
              V instanceof Pn ? (we(C, k, V.execute(X)), P = !0) : X !== V && (we(C, k, V), P = !0);
            }
            return P;
          });
          var m = o.table.core, y = m.schema.primaryKey, v = y.outbound, w = y.extractKey, O = 200, y = t.db._options.modifyChunkSize;
          y && (O = typeof y == "object" ? y[m.name] || y["*"] || 200 : y);
          function N(C, k) {
            var I = k.failures, k = k.numFailures;
            _ += C - k;
            for (var V = 0, X = p(I); V < X.length; V++) {
              var H = X[V];
              b.push(I[H]);
            }
          }
          var b = [], _ = 0, E = [], T = e === Go;
          return t.clone().primaryKeys().then(function(C) {
            function P(k) {
              var V = Math.min(O, C.length - k), X = C.slice(k, k + V);
              return (T ? Promise.resolve([]) : m.getMany({ trans: i, keys: X, cache: "immutable" })).then(function(H) {
                var G = [], Q = [], z = v ? [] : null, Z = T ? X : [];
                if (!T) for (var ye = 0; ye < V; ++ye) {
                  var Te = H[ye], he = { value: st(Te), primKey: C[k + ye] };
                  d.call(he, he.value, he) !== !1 && (he.value == null ? Z.push(C[k + ye]) : v || Oe(w(Te), w(he.value)) === 0 ? (Q.push(he.value), v && z.push(C[k + ye])) : (Z.push(C[k + ye]), G.push(he.value)));
                }
                return Promise.resolve(0 < G.length && m.mutate({ trans: i, type: "add", values: G }).then(function(Ke) {
                  for (var pe in Ke.failures) Z.splice(parseInt(pe), 1);
                  N(G.length, Ke);
                })).then(function() {
                  return (0 < Q.length || I && typeof e == "object") && m.mutate({ trans: i, type: "put", keys: z, values: Q, criteria: I, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < k }).then(function(Ke) {
                    return N(Q.length, Ke);
                  });
                }).then(function() {
                  return (0 < Z.length || I && T) && m.mutate({ trans: i, type: "delete", keys: Z, criteria: I, isAdditionalChunk: 0 < k }).then(function(Ke) {
                    return tr(o.table, Z, Ke);
                  }).then(function(Ke) {
                    return N(Z.length, Ke);
                  });
                }).then(function() {
                  return C.length > k + V && P(k + O);
                });
              });
            }
            var I = bn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return P(0).then(function() {
              if (0 < b.length) throw new fn("Error modifying one or more objects", b, _, E);
              return C.length;
            });
          });
        });
      }, Ce.prototype.delete = function() {
        var e = this._ctx, t = e.range;
        return !bn(e) || e.table.schema.yProps || !e.isPrimKey && t.type !== 3 ? this.modify(Go) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, a = t;
          return e.table.core.count({ trans: o, query: { index: i, range: a } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: a }).then(function(v) {
              var m = v.failures, v = v.numFailures;
              if (v) throw new fn("Could not delete some values", Object.keys(m).map(function(w) {
                return m[w];
              }), l - v);
              return l - v;
            });
          });
        });
      }, Ce);
      function Ce() {
      }
      var Go = function(e, t) {
        return t.value = null;
      };
      function Ts(e, t) {
        return e < t ? -1 : e === t ? 0 : 1;
      }
      function Es(e, t) {
        return t < e ? -1 : e === t ? 0 : 1;
      }
      function pt(e, t, o) {
        return e = e instanceof Xo ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(t), e;
      }
      function wn(e) {
        return new e.Collection(e, function() {
          return Yo("");
        }).limit(0);
      }
      function or(e, t, o, i) {
        var a, l, d, m, v, w, O, y = o.length;
        if (!o.every(function(_) {
          return typeof _ == "string";
        })) return pt(e, Fo);
        function N(_) {
          a = _ === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = _ === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, d = _ === "next" ? Ts : Es;
          var E = o.map(function(T) {
            return { lower: l(T), upper: a(T) };
          }).sort(function(T, C) {
            return d(T.lower, C.lower);
          });
          m = E.map(function(T) {
            return T.upper;
          }), v = E.map(function(T) {
            return T.lower;
          }), O = (w = _) === "next" ? "" : i;
        }
        N("next"), e = new e.Collection(e, function() {
          return $t(m[0], v[y - 1] + i);
        }), e._ondirectionchange = function(_) {
          N(_);
        };
        var b = 0;
        return e._addAlgorithm(function(_, E, T) {
          var C = _.key;
          if (typeof C != "string") return !1;
          var P = l(C);
          if (t(P, v, b)) return !0;
          for (var I = null, k = b; k < y; ++k) {
            var V = function(X, H, G, Q, z, Z) {
              for (var ye = Math.min(X.length, Q.length), Te = -1, he = 0; he < ye; ++he) {
                var Ke = H[he];
                if (Ke !== Q[he]) return z(X[he], G[he]) < 0 ? X.substr(0, he) + G[he] + G.substr(he + 1) : z(X[he], Q[he]) < 0 ? X.substr(0, he) + Q[he] + G.substr(he + 1) : 0 <= Te ? X.substr(0, Te) + H[Te] + G.substr(Te + 1) : null;
                z(X[he], Ke) < 0 && (Te = he);
              }
              return ye < Q.length && Z === "next" ? X + G.substr(X.length) : ye < X.length && Z === "prev" ? X.substr(0, G.length) : Te < 0 ? null : X.substr(0, Te) + Q[Te] + G.substr(Te + 1);
            }(C, P, m[k], v[k], d, w);
            V === null && I === null ? b = k + 1 : (I === null || 0 < d(I, V)) && (I = V);
          }
          return E(I !== null ? function() {
            _.continue(I + O);
          } : T), !1;
        }), e;
      }
      function $t(e, t, o, i) {
        return { type: 2, lower: e, upper: t, lowerOpen: o, upperOpen: i };
      }
      function Yo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var Xo = (Object.defineProperty(Ye.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Ye.prototype.between = function(e, t, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, t) || this._cmp(e, t) === 0 && (o || i) && (!o || !i) ? wn(this) : new this.Collection(this, function() {
            return $t(e, t, !o, !i);
          });
        } catch {
          return pt(this, Dt);
        }
      }, Ye.prototype.equals = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return Yo(e);
        });
      }, Ye.prototype.above = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(e, void 0, !0);
        });
      }, Ye.prototype.aboveOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(e, void 0, !1);
        });
      }, Ye.prototype.below = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(void 0, e, !1, !0);
        });
      }, Ye.prototype.belowOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return $t(void 0, e);
        });
      }, Ye.prototype.startsWith = function(e) {
        return typeof e != "string" ? pt(this, Fo) : this.between(e, e + en, !0, !0);
      }, Ye.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : or(this, function(t, o) {
          return t.indexOf(o[0]) === 0;
        }, [e], en);
      }, Ye.prototype.equalsIgnoreCase = function(e) {
        return or(this, function(t, o) {
          return t === o[0];
        }, [e], "");
      }, Ye.prototype.anyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? wn(this) : or(this, function(t, o) {
          return o.indexOf(t) !== -1;
        }, e, "");
      }, Ye.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? wn(this) : or(this, function(t, o) {
          return o.some(function(i) {
            return t.indexOf(i) === 0;
          });
        }, e, en);
      }, Ye.prototype.anyOf = function() {
        var e = this, t = ct.apply(bt, arguments), o = this._cmp;
        try {
          t.sort(o);
        } catch {
          return pt(this, Dt);
        }
        if (t.length === 0) return wn(this);
        var i = new this.Collection(this, function() {
          return $t(t[0], t[t.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, t.sort(o);
        };
        var a = 0;
        return i._addAlgorithm(function(l, d, m) {
          for (var v = l.key; 0 < o(v, t[a]); ) if (++a === t.length) return d(m), !1;
          return o(v, t[a]) === 0 || (d(function() {
            l.continue(t[a]);
          }), !1);
        }), i;
      }, Ye.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.noneOf = function() {
        var e = ct.apply(bt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return pt(this, Dt);
        }
        var t = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.inAnyRange = function(C, t) {
        var o = this, i = this._cmp, a = this._ascending, l = this._descending, d = this._min, m = this._max;
        if (C.length === 0) return wn(this);
        if (!C.every(function(P) {
          return P[0] !== void 0 && P[1] !== void 0 && a(P[0], P[1]) <= 0;
        })) return pt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", K.InvalidArgument);
        var v = !t || t.includeLowers !== !1, w = t && t.includeUppers === !0, O, y = a;
        function N(P, I) {
          return y(P[0], I[0]);
        }
        try {
          (O = C.reduce(function(P, I) {
            for (var k = 0, V = P.length; k < V; ++k) {
              var X = P[k];
              if (i(I[0], X[1]) < 0 && 0 < i(I[1], X[0])) {
                X[0] = d(X[0], I[0]), X[1] = m(X[1], I[1]);
                break;
              }
            }
            return k === V && P.push(I), P;
          }, [])).sort(N);
        } catch {
          return pt(this, Dt);
        }
        var b = 0, _ = w ? function(P) {
          return 0 < a(P, O[b][1]);
        } : function(P) {
          return 0 <= a(P, O[b][1]);
        }, E = v ? function(P) {
          return 0 < l(P, O[b][0]);
        } : function(P) {
          return 0 <= l(P, O[b][0]);
        }, T = _, C = new this.Collection(this, function() {
          return $t(O[0][0], O[O.length - 1][1], !v, !w);
        });
        return C._ondirectionchange = function(P) {
          y = P === "next" ? (T = _, a) : (T = E, l), O.sort(N);
        }, C._addAlgorithm(function(P, I, k) {
          for (var V, X = P.key; T(X); ) if (++b === O.length) return I(k), !1;
          return !_(V = X) && !E(V) || (o._cmp(X, O[b][1]) === 0 || o._cmp(X, O[b][0]) === 0 || I(function() {
            y === a ? P.continue(O[b][0]) : P.continue(O[b][1]);
          }), !1);
        }), C;
      }, Ye.prototype.startsWithAnyOf = function() {
        var e = ct.apply(bt, arguments);
        return e.every(function(t) {
          return typeof t == "string";
        }) ? e.length === 0 ? wn(this) : this.inAnyRange(e.map(function(t) {
          return [t, t + en];
        })) : pt(this, "startsWithAnyOf() only works with strings");
      }, Ye);
      function Ye() {
      }
      function Et(e) {
        return Le(function(t) {
          return Dn(t), e(t.target.error), !1;
        });
      }
      function Dn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Rn = "storagemutated", Hr = "x-storagemutated-1", qt = Sn(null, Rn), Ns = (Nt.prototype._lock = function() {
        return q(!re.global), ++this._reculock, this._reculock !== 1 || re.global || (re.lockOwnerFor = this), this;
      }, Nt.prototype._unlock = function() {
        if (q(!re.global), --this._reculock == 0) for (re.global || (re.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            Zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Nt.prototype._locked = function() {
        return this._reculock && re.lockOwnerFor !== this;
      }, Nt.prototype.create = function(e) {
        var t = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (q(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new K.DatabaseClosed(i);
          case "MissingAPIError":
            throw new K.MissingAPI(i.message, i);
          default:
            throw new K.OpenFailed(i);
        }
        if (!this.active) throw new K.TransactionInactive();
        return q(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Le(function(a) {
          Dn(a), t._reject(e.error);
        }), e.onabort = Le(function(a) {
          Dn(a), t.active && t._reject(new K.Abort(e.error)), t.active = !1, t.on("abort").fire(a);
        }), e.oncomplete = Le(function() {
          t.active = !1, t._resolve(), "mutatedParts" in e && qt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Nt.prototype._promise = function(e, t, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return Be(new K.ReadOnly("Transaction is readonly"));
        if (!this.active) return Be(new K.TransactionInactive());
        if (this._locked()) return new J(function(l, d) {
          i._blockedFuncs.push([function() {
            i._promise(e, t, o).then(l, d);
          }, re]);
        });
        if (o) return Ft(function() {
          var l = new J(function(d, m) {
            i._lock();
            var v = t(d, m, i);
            v && v.then && v.then(d, m);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var a = new J(function(l, d) {
          var m = t(l, d, i);
          m && m.then && m.then(l, d);
        });
        return a._lib = !0, a;
      }, Nt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Nt.prototype.waitFor = function(e) {
        var t, o = this._root(), i = J.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], t = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (t.get(-1 / 0).onsuccess = l);
        }());
        var a = o._waitingFor;
        return new J(function(l, d) {
          i.then(function(m) {
            return o._waitingQueue.push(Le(l.bind(null, m)));
          }, function(m) {
            return o._waitingQueue.push(Le(d.bind(null, m)));
          }).finally(function() {
            o._waitingFor === a && (o._waitingFor = null);
          });
        });
      }, Nt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new K.Abort()));
      }, Nt.prototype.table = function(e) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (L(t, e)) return t[e];
        var o = this.schema[e];
        if (!o) throw new K.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), t[e] = o;
      }, Nt);
      function Nt() {
      }
      function Wr(e, t, o, i, a, l, d, m) {
        return { name: e, keyPath: t, unique: o, multi: i, auto: a, compound: l, src: (o && !d ? "&" : "") + (i ? "*" : "") + (a ? "++" : "") + zo(t), type: m };
      }
      function zo(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Gr(e, t, o) {
        return { name: e, primKey: t, indexes: o, mappedClass: null, idxByName: (i = function(a) {
          return [a.name, a];
        }, o.reduce(function(a, l, d) {
          return d = i(l, d), d && (a[d[0]] = d[1]), a;
        }, {})) };
        var i;
      }
      var In = function(e) {
        try {
          return e.only([[]]), In = function() {
            return [[]];
          }, [[]];
        } catch {
          return In = function() {
            return en;
          }, en;
        }
      };
      function Yr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (t = e).split(".").length === 1 ? function(o) {
          return o[t];
        } : function(o) {
          return ne(o, t);
        } : function(o) {
          return ne(o, e);
        };
        var t;
      }
      function Qo(e) {
        return [].slice.call(e);
      }
      var Cs = 0;
      function kn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Ss(e, t, v) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var b = T.lower, _ = T.upper, E = T.lowerOpen, T = T.upperOpen;
          return b === void 0 ? _ === void 0 ? null : t.upperBound(_, !!T) : _ === void 0 ? t.lowerBound(b, !!E) : t.bound(b, _, !!E, !!T);
        }
        function a(N) {
          var b, _ = N.name;
          return { name: _, schema: N, mutate: function(E) {
            var T = E.trans, C = E.type, P = E.keys, I = E.values, k = E.range;
            return new Promise(function(V, X) {
              V = Le(V);
              var H = T.objectStore(_), G = H.keyPath == null, Q = C === "put" || C === "add";
              if (!Q && C !== "delete" && C !== "deleteRange") throw new Error("Invalid operation type: " + C);
              var z, Z = (P || I || { length: 1 }).length;
              if (P && I && P.length !== I.length) throw new Error("Given keys array must have same length as given values array.");
              if (Z === 0) return V({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ye(it) {
                ++Ke, Dn(it);
              }
              var Te = [], he = [], Ke = 0;
              if (C === "deleteRange") {
                if (k.type === 4) return V({ numFailures: Ke, failures: he, results: [], lastResult: void 0 });
                k.type === 3 ? Te.push(z = H.clear()) : Te.push(z = H.delete(i(k)));
              } else {
                var G = Q ? G ? [I, P] : [I, null] : [P, null], pe = G[0], Je = G[1];
                if (Q) for (var Ze = 0; Ze < Z; ++Ze) Te.push(z = Je && Je[Ze] !== void 0 ? H[C](pe[Ze], Je[Ze]) : H[C](pe[Ze])), z.onerror = ye;
                else for (Ze = 0; Ze < Z; ++Ze) Te.push(z = H[C](pe[Ze])), z.onerror = ye;
              }
              function yr(it) {
                it = it.target.result, Te.forEach(function(on, po) {
                  return on.error != null && (he[po] = on.error);
                }), V({ numFailures: Ke, failures: he, results: C === "delete" ? P : Te.map(function(on) {
                  return on.result;
                }), lastResult: it });
              }
              z.onerror = function(it) {
                ye(it), yr(it);
              }, z.onsuccess = yr;
            });
          }, getMany: function(E) {
            var T = E.trans, C = E.keys;
            return new Promise(function(P, I) {
              P = Le(P);
              for (var k, V = T.objectStore(_), X = C.length, H = new Array(X), G = 0, Q = 0, z = function(Te) {
                Te = Te.target, H[Te._pos] = Te.result, ++Q === G && P(H);
              }, Z = Et(I), ye = 0; ye < X; ++ye) C[ye] != null && ((k = V.get(C[ye]))._pos = ye, k.onsuccess = z, k.onerror = Z, ++G);
              G === 0 && P(H);
            });
          }, get: function(E) {
            var T = E.trans, C = E.key;
            return new Promise(function(P, I) {
              P = Le(P);
              var k = T.objectStore(_).get(C);
              k.onsuccess = function(V) {
                return P(V.target.result);
              }, k.onerror = Et(I);
            });
          }, query: (b = w, function(E) {
            return new Promise(function(T, C) {
              T = Le(T);
              var P, I, k, G = E.trans, V = E.values, X = E.limit, z = E.query, H = X === 1 / 0 ? void 0 : X, Q = z.index, z = z.range, G = G.objectStore(_), Q = Q.isPrimaryKey ? G : G.index(Q.name), z = i(z);
              if (X === 0) return T({ result: [] });
              b ? ((H = V ? Q.getAll(z, H) : Q.getAllKeys(z, H)).onsuccess = function(Z) {
                return T({ result: Z.target.result });
              }, H.onerror = Et(C)) : (P = 0, I = !V && "openKeyCursor" in Q ? Q.openKeyCursor(z) : Q.openCursor(z), k = [], I.onsuccess = function(Z) {
                var ye = I.result;
                return ye ? (k.push(V ? ye.value : ye.primaryKey), ++P === X ? T({ result: k }) : void ye.continue()) : T({ result: k });
              }, I.onerror = Et(C));
            });
          }), openCursor: function(E) {
            var T = E.trans, C = E.values, P = E.query, I = E.reverse, k = E.unique;
            return new Promise(function(V, X) {
              V = Le(V);
              var Q = P.index, H = P.range, G = T.objectStore(_), G = Q.isPrimaryKey ? G : G.index(Q.name), Q = I ? k ? "prevunique" : "prev" : k ? "nextunique" : "next", z = !C && "openKeyCursor" in G ? G.openKeyCursor(i(H), Q) : G.openCursor(i(H), Q);
              z.onerror = Et(X), z.onsuccess = Le(function(Z) {
                var ye, Te, he, Ke, pe = z.result;
                pe ? (pe.___id = ++Cs, pe.done = !1, ye = pe.continue.bind(pe), Te = (Te = pe.continuePrimaryKey) && Te.bind(pe), he = pe.advance.bind(pe), Ke = function() {
                  throw new Error("Cursor not stopped");
                }, pe.trans = T, pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = function() {
                  throw new Error("Cursor not started");
                }, pe.fail = Le(X), pe.next = function() {
                  var Je = this, Ze = 1;
                  return this.start(function() {
                    return Ze-- ? Je.continue() : Je.stop();
                  }).then(function() {
                    return Je;
                  });
                }, pe.start = function(Je) {
                  function Ze() {
                    if (z.result) try {
                      Je();
                    } catch (it) {
                      pe.fail(it);
                    }
                    else pe.done = !0, pe.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, pe.stop();
                  }
                  var yr = new Promise(function(it, on) {
                    it = Le(it), z.onerror = Et(on), pe.fail = on, pe.stop = function(po) {
                      pe.stop = pe.continue = pe.continuePrimaryKey = pe.advance = Ke, it(po);
                    };
                  });
                  return z.onsuccess = Le(function(it) {
                    z.onsuccess = Ze, Ze();
                  }), pe.continue = ye, pe.continuePrimaryKey = Te, pe.advance = he, Ze(), yr;
                }, V(pe)) : V(null);
              }, X);
            });
          }, count: function(E) {
            var T = E.query, C = E.trans, P = T.index, I = T.range;
            return new Promise(function(k, V) {
              var X = C.objectStore(_), H = P.isPrimaryKey ? X : X.index(P.name), X = i(I), H = X ? H.count(X) : H.count();
              H.onsuccess = Le(function(G) {
                return k(G.target.result);
              }), H.onerror = Et(V);
            });
          } };
        }
        var l, d, m, O = (d = v, m = Qo((l = e).objectStoreNames), { schema: { name: l.name, tables: m.map(function(N) {
          return d.objectStore(N);
        }).map(function(N) {
          var b = N.keyPath, T = N.autoIncrement, _ = h(b), E = {}, T = { name: N.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: b == null, compound: _, keyPath: b, autoIncrement: T, unique: !0, extractKey: Yr(b) }, indexes: Qo(N.indexNames).map(function(C) {
            return N.index(C);
          }).map(function(k) {
            var P = k.name, I = k.unique, V = k.multiEntry, k = k.keyPath, V = { name: P, compound: h(k), keyPath: k, unique: I, multiEntry: V, extractKey: Yr(k) };
            return E[kn(k)] = V;
          }), getIndexByKeyPath: function(C) {
            return E[kn(C)];
          } };
          return E[":id"] = T.primaryKey, b != null && (E[kn(b)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < m.length && "getAll" in d.objectStore(m[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), v = O.schema, w = O.hasGetAll, O = v.tables.map(a), y = {};
        return O.forEach(function(N) {
          return y[N.name] = N;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(N) {
          if (!y[N]) throw new Error("Table '".concat(N, "' not found"));
          return y[N];
        }, MIN_KEY: -1 / 0, MAX_KEY: In(t), schema: v };
      }
      function As(e, t, o, i) {
        var a = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = Ss(t, a, i), e.dbcore.reduce(function(l, d) {
          return d = d.create, u(u({}, l), d(l));
        }, i)) };
      }
      function ir(e, i) {
        var o = i.db, i = As(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(a) {
          var l = a.name;
          e.core.schema.tables.some(function(d) {
            return d.name === l;
          }) && (a.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = a.core));
        });
      }
      function sr(e, t, o, i) {
        o.forEach(function(a) {
          var l = i[a];
          t.forEach(function(d) {
            var m = function v(w, O) {
              return xe(w, O) || (w = R(w)) && v(w, O);
            }(d, a);
            (!m || "value" in m && m.value === void 0) && (d === e.Transaction.prototype || d instanceof e.Transaction ? ie(d, a, { get: function() {
              return this.table(a);
            }, set: function(v) {
              ee(this, a, { value: v, writable: !0, configurable: !0, enumerable: !0 });
            } }) : d[a] = new e.Table(a, l));
          });
        });
      }
      function Xr(e, t) {
        t.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function Ps(e, t) {
        return e._cfg.version - t._cfg.version;
      }
      function Ds(e, t, o, i) {
        var a = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !a.$meta && (a.$meta = Gr("$meta", Zo("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, a);
        l.create(o), l._completion.catch(i);
        var d = l._reject.bind(l), m = re.transless || re;
        Ft(function() {
          return re.trans = l, re.transless = m, t !== 0 ? (ir(e, o), w = t, ((v = l).storeNames.includes("$meta") ? v.table("$meta").get("version").then(function(O) {
            return O ?? w;
          }) : J.resolve(w)).then(function(O) {
            return N = O, b = l, _ = o, E = [], O = (y = e)._versions, T = y._dbSchema = ur(0, y.idbdb, _), (O = O.filter(function(C) {
              return C._cfg.version >= N;
            })).length !== 0 ? (O.forEach(function(C) {
              E.push(function() {
                var P = T, I = C._cfg.dbschema;
                lr(y, P, _), lr(y, I, _), T = y._dbSchema = I;
                var k = zr(P, I);
                k.add.forEach(function(Q) {
                  Qr(_, Q[0], Q[1].primKey, Q[1].indexes);
                }), k.change.forEach(function(Q) {
                  if (Q.recreate) throw new K.Upgrade("Not yet support for changing primary key");
                  var z = _.objectStore(Q.name);
                  Q.add.forEach(function(Z) {
                    return ar(z, Z);
                  }), Q.change.forEach(function(Z) {
                    z.deleteIndex(Z.name), ar(z, Z);
                  }), Q.del.forEach(function(Z) {
                    return z.deleteIndex(Z);
                  });
                });
                var V = C._cfg.contentUpgrade;
                if (V && C._cfg.version > N) {
                  ir(y, _), b._memoizedTables = {};
                  var X = _e(I);
                  k.del.forEach(function(Q) {
                    X[Q] = P[Q];
                  }), Xr(y, [y.Transaction.prototype]), sr(y, [y.Transaction.prototype], p(X), X), b.schema = X;
                  var H, G = _t(V);
                  return G && vn(), k = J.follow(function() {
                    var Q;
                    (H = V(b)) && G && (Q = Mt.bind(null, null), H.then(Q, Q));
                  }), H && typeof H.then == "function" ? J.resolve(H) : k.then(function() {
                    return H;
                  });
                }
              }), E.push(function(P) {
                var I, k, V = C._cfg.dbschema;
                I = V, k = P, [].slice.call(k.db.objectStoreNames).forEach(function(X) {
                  return I[X] == null && k.db.deleteObjectStore(X);
                }), Xr(y, [y.Transaction.prototype]), sr(y, [y.Transaction.prototype], y._storeNames, y._dbSchema), b.schema = y._dbSchema;
              }), E.push(function(P) {
                y.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(y.idbdb.version / 10) === C._cfg.version ? (y.idbdb.deleteObjectStore("$meta"), delete y._dbSchema.$meta, y._storeNames = y._storeNames.filter(function(I) {
                  return I !== "$meta";
                })) : P.objectStore("$meta").put(C._cfg.version, "version"));
              });
            }), function C() {
              return E.length ? J.resolve(E.shift()(b.idbtrans)).then(C) : J.resolve();
            }().then(function() {
              Jo(T, _);
            })) : J.resolve();
            var y, N, b, _, E, T;
          }).catch(d)) : (p(a).forEach(function(O) {
            Qr(o, O, a[O].primKey, a[O].indexes);
          }), ir(e, o), void J.follow(function() {
            return e.on.populate.fire(l);
          }).catch(d));
          var v, w;
        });
      }
      function Rs(e, t) {
        Jo(e._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var o = ur(0, e.idbdb, t);
        lr(e, e._dbSchema, t);
        for (var i = 0, a = zr(o, e._dbSchema).change; i < a.length; i++) {
          var l = function(d) {
            if (d.change.length || d.recreate) return console.warn("Unable to patch indexes of table ".concat(d.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var m = t.objectStore(d.name);
            d.add.forEach(function(v) {
              ae && console.debug("Dexie upgrade patch: Creating missing index ".concat(d.name, ".").concat(v.src)), ar(m, v);
            });
          }(a[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function zr(e, t) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) t[o] || i.del.push(o);
        for (o in t) {
          var a = e[o], l = t[o];
          if (a) {
            var d = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (a.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || a.primKey.auto !== l.primKey.auto) d.recreate = !0, i.change.push(d);
            else {
              var m = a.idxByName, v = l.idxByName, w = void 0;
              for (w in m) v[w] || d.del.push(w);
              for (w in v) {
                var O = m[w], y = v[w];
                O ? O.src !== y.src && d.change.push(y) : d.add.push(y);
              }
              (0 < d.del.length || 0 < d.add.length || 0 < d.change.length) && i.change.push(d);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Qr(e, t, o, i) {
        var a = e.db.createObjectStore(t, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return ar(a, l);
        }), a;
      }
      function Jo(e, t) {
        p(e).forEach(function(o) {
          t.db.objectStoreNames.contains(o) || (ae && console.debug("Dexie: Creating missing table", o), Qr(t, o, e[o].primKey, e[o].indexes));
        });
      }
      function ar(e, t) {
        e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function ur(e, t, o) {
        var i = {};
        return U(t.objectStoreNames, 0).forEach(function(a) {
          for (var l = o.objectStore(a), d = Wr(zo(w = l.keyPath), w || "", !0, !1, !!l.autoIncrement, w && typeof w != "string", !0), m = [], v = 0; v < l.indexNames.length; ++v) {
            var O = l.index(l.indexNames[v]), w = O.keyPath, O = Wr(O.name, w, !!O.unique, !!O.multiEntry, !1, w && typeof w != "string", !1);
            m.push(O);
          }
          i[a] = Gr(a, d, m);
        }), i;
      }
      function lr(e, t, o) {
        for (var i = o.db.objectStoreNames, a = 0; a < i.length; ++a) {
          var l = i[a], d = o.objectStore(l);
          e._hasGetAll = "getAll" in d;
          for (var m = 0; m < d.indexNames.length; ++m) {
            var v = d.indexNames[m], w = d.index(v).keyPath, O = typeof w == "string" ? w : "[" + U(w).join("+") + "]";
            !t[l] || (w = t[l].idxByName[O]) && (w.name = v, delete t[l].idxByName[O], t[l].idxByName[v] = w);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function Zo(e) {
        return e.split(",").map(function(t, o) {
          var l = t.split(":"), i = (a = l[1]) === null || a === void 0 ? void 0 : a.trim(), a = (t = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(a) ? a.match(/^\[(.*)\]$/)[1].split("+") : a;
          return Wr(a, l || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), h(l), o === 0, i);
        });
      }
      var Is = (_n.prototype._createTableSchema = Gr, _n.prototype._parseIndexSyntax = Zo, _n.prototype._parseStoresSpec = function(e, t) {
        var o = this;
        p(e).forEach(function(i) {
          if (e[i] !== null) {
            var a = o._parseIndexSyntax(e[i]), l = a.shift();
            if (!l) throw new K.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new K.Schema("Primary key cannot be multiEntry*");
            a.forEach(function(d) {
              if (d.auto) throw new K.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!d.keyPath) throw new K.Schema("Index must have a name and cannot be an empty string");
            }), a = o._createTableSchema(i, l, a), t[i] = a;
          }
        });
      }, _n.prototype.stores = function(o) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? g(this._cfg.storesSource, o) : o;
        var o = t._versions, i = {}, a = {};
        return o.forEach(function(l) {
          g(i, l._cfg.storesSource), a = l._cfg.dbschema = {}, l._parseStoresSpec(i, a);
        }), t._dbSchema = a, Xr(t, [t._allTables, t, t.Transaction.prototype]), sr(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], p(a), a), t._storeNames = p(a), this;
      }, _n.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = de(this._cfg.contentUpgrade || S, e), this;
      }, _n);
      function _n() {
      }
      function Jr(e, t) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Rt(Zn, { addons: [], indexedDB: e, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function Zr(e) {
        return e && typeof e.databases == "function";
      }
      function eo(e) {
        return Ft(function() {
          return re.letThrough = !0, e();
        });
      }
      function to(e) {
        return !("from" in e);
      }
      var Qe = function(e, t) {
        if (!this) {
          var o = new Qe();
          return e && "d" in e && g(o, e), o;
        }
        g(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? t : e } : { d: 0 });
      };
      function jn(e, t, o) {
        var i = Oe(t, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (to(e)) return g(e, { from: t, to: o, d: 1 });
          var a = e.l, i = e.r;
          if (Oe(o, e.from) < 0) return a ? jn(a, t, o) : e.l = { from: t, to: o, d: 1, l: null, r: null }, ti(e);
          if (0 < Oe(t, e.to)) return i ? jn(i, t, o) : e.r = { from: t, to: o, d: 1, l: null, r: null }, ti(e);
          Oe(t, e.from) < 0 && (e.from = t, e.l = null, e.d = i ? i.d + 1 : 1), 0 < Oe(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, a && !e.l && Ln(e, a), i && o && Ln(e, i);
        }
      }
      function Ln(e, t) {
        to(t) || function o(i, v) {
          var l = v.from, d = v.to, m = v.l, v = v.r;
          jn(i, l, d), m && o(i, m), v && o(i, v);
        }(e, t);
      }
      function ei(e, t) {
        var o = cr(t), i = o.next();
        if (i.done) return !1;
        for (var a = i.value, l = cr(e), d = l.next(a.from), m = d.value; !i.done && !d.done; ) {
          if (Oe(m.from, a.to) <= 0 && 0 <= Oe(m.to, a.from)) return !0;
          Oe(a.from, m.from) < 0 ? a = (i = o.next(m.from)).value : m = (d = l.next(a.from)).value;
        }
        return !1;
      }
      function cr(e) {
        var t = to(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, i) for (; t.n.l && Oe(o, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !i || Oe(o, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function ti(e) {
        var t, o, i = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), a = 1 < i ? "r" : i < -1 ? "l" : "";
        a && (t = a == "r" ? "l" : "r", o = u({}, e), i = e[a], e.from = i.from, e.to = i.to, e[a] = i[a], o[a] = i[t], (e[t] = o).d = ni(o)), e.d = ni(e);
      }
      function ni(o) {
        var t = o.r, o = o.l;
        return (t ? o ? Math.max(t.d, o.d) : t.d : o ? o.d : 0) + 1;
      }
      function fr(e, t) {
        return p(t).forEach(function(o) {
          e[o] ? Ln(e[o], t[o]) : e[o] = function i(a) {
            var l, d, m = {};
            for (l in a) L(a, l) && (d = a[l], m[l] = !d || typeof d != "object" || dt.has(d.constructor) ? d : i(d));
            return m;
          }(t[o]);
        }), e;
      }
      function no(e, t) {
        return e.all || t.all || Object.keys(e).some(function(o) {
          return t[o] && ei(t[o], e[o]);
        });
      }
      B(Qe.prototype, ((wt = { add: function(e) {
        return Ln(this, e), this;
      }, addKey: function(e) {
        return jn(this, e, e), this;
      }, addKeys: function(e) {
        var t = this;
        return e.forEach(function(o) {
          return jn(t, o, o);
        }), this;
      }, hasKey: function(e) {
        var t = cr(this).next(e).value;
        return t && Oe(t.from, e) <= 0 && 0 <= Oe(t.to, e);
      } })[nt] = function() {
        return cr(this);
      }, wt));
      var nn = {}, ro = {}, oo = !1;
      function dr(e) {
        fr(ro, e), oo || (oo = !0, setTimeout(function() {
          oo = !1, io(ro, !(ro = {}));
        }, 0));
      }
      function io(e, t) {
        t === void 0 && (t = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, a = Object.values(nn); i < a.length; i++) ri(d = a[i], e, o, t);
        else for (var l in e) {
          var d, m = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          m && (l = m[1], m = m[2], (d = nn["idb://".concat(l, "/").concat(m)]) && ri(d, e, o, t));
        }
        o.forEach(function(v) {
          return v();
        });
      }
      function ri(e, t, o, i) {
        for (var a = [], l = 0, d = Object.entries(e.queries.query); l < d.length; l++) {
          for (var m = d[l], v = m[0], w = [], O = 0, y = m[1]; O < y.length; O++) {
            var N = y[O];
            no(t, N.obsSet) ? N.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && w.push(N);
          }
          i && a.push([v, w]);
        }
        if (i) for (var b = 0, _ = a; b < _.length; b++) {
          var E = _[b], v = E[0], w = E[1];
          e.queries.query[v] = w;
        }
      }
      function ks(e) {
        var t = e._state, o = e._deps.indexedDB;
        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? Be(t.dbOpenError) : e;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var i = t.openCanceller, a = Math.round(10 * e.verno), l = !1;
        function d() {
          if (t.openCanceller !== i) throw new K.DatabaseClosed("db.open() was cancelled");
        }
        function m() {
          return new J(function(N, b) {
            if (d(), !o) throw new K.MissingAPI();
            var _ = e.name, E = t.autoSchema || !a ? o.open(_) : o.open(_, a);
            if (!E) throw new K.MissingAPI();
            E.onerror = Et(b), E.onblocked = Le(e._fireOnBlocked), E.onupgradeneeded = Le(function(T) {
              var C;
              O = E.transaction, t.autoSchema && !e._options.allowEmptyDB ? (E.onerror = Dn, O.abort(), E.result.close(), (C = o.deleteDatabase(_)).onsuccess = C.onerror = Le(function() {
                b(new K.NoSuchDatabase("Database ".concat(_, " doesnt exist")));
              })) : (O.onerror = Et(b), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, y = T < 1, e.idbdb = E.result, l && Rs(e, O), Ds(e, T / 10, O, b));
            }, b), E.onsuccess = Le(function() {
              O = null;
              var T, C, P, I, k, V = e.idbdb = E.result, X = U(V.objectStoreNames);
              if (0 < X.length) try {
                var H = V.transaction((I = X).length === 1 ? I[0] : I, "readonly");
                if (t.autoSchema) C = V, P = H, (T = e).verno = C.version / 10, P = T._dbSchema = ur(0, C, P), T._storeNames = U(C.objectStoreNames, 0), sr(T, [T._allTables], p(P), P);
                else if (lr(e, e._dbSchema, H), ((k = zr(ur(0, (k = e).idbdb, H), k._dbSchema)).add.length || k.change.some(function(G) {
                  return G.add.length || G.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), V.close(), a = V.version + 1, l = !0, N(m());
                ir(e, H);
              } catch {
              }
              gn.push(e), V.onversionchange = Le(function(G) {
                t.vcFired = !0, e.on("versionchange").fire(G);
              }), V.onclose = Le(function(G) {
                e.on("close").fire(G);
              }), y && (k = e._deps, H = _, V = k.indexedDB, k = k.IDBKeyRange, Zr(V) || H === Zn || Jr(V, k).put({ name: H }).catch(S)), N();
            }, b);
          }).catch(function(N) {
            switch (N?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), m();
                break;
              case "VersionError":
                if (0 < a) return a = 0, m();
            }
            return J.reject(N);
          });
        }
        var v, w = t.dbReadyResolve, O = null, y = !1;
        return J.race([i, (typeof navigator > "u" ? J.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(N) {
          function b() {
            return indexedDB.databases().finally(N);
          }
          v = setInterval(b, 100), b();
        }).finally(function() {
          return clearInterval(v);
        }) : Promise.resolve()).then(m)]).then(function() {
          return d(), t.onReadyBeingFired = [], J.resolve(eo(function() {
            return e.on.ready.fire(e.vip);
          })).then(function N() {
            if (0 < t.onReadyBeingFired.length) {
              var b = t.onReadyBeingFired.reduce(de, S);
              return t.onReadyBeingFired = [], J.resolve(eo(function() {
                return b(e.vip);
              })).then(N);
            }
          });
        }).finally(function() {
          t.openCanceller === i && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(N) {
          t.dbOpenError = N;
          try {
            O && O.abort();
          } catch {
          }
          return i === t.openCanceller && e._close(), Be(N);
        }).finally(function() {
          t.openComplete = !0, w();
        }).then(function() {
          var N;
          return y && (N = {}, e.tables.forEach(function(b) {
            b.schema.indexes.forEach(function(_) {
              _.name && (N["idb://".concat(e.name, "/").concat(b.name, "/").concat(_.name)] = new Qe(-1 / 0, [[[]]]));
            }), N["idb://".concat(e.name, "/").concat(b.name, "/")] = N["idb://".concat(e.name, "/").concat(b.name, "/:dels")] = new Qe(-1 / 0, [[[]]]);
          }), qt(Rn).fire(N), io(N, !0)), e;
        });
      }
      function so(e) {
        function t(l) {
          return e.next(l);
        }
        var o = a(t), i = a(function(l) {
          return e.throw(l);
        });
        function a(l) {
          return function(v) {
            var m = l(v), v = m.value;
            return m.done ? v : v && typeof v.then == "function" ? v.then(o, i) : h(v) ? Promise.all(v).then(o, i) : o(v);
          };
        }
        return a(t)();
      }
      function pr(e, t, o) {
        for (var i = h(e) ? e.slice() : [e], a = 0; a < o; ++a) i.push(t);
        return i;
      }
      var js = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema, a = {}, l = [];
          function d(y, N, b) {
            var _ = kn(y), E = a[_] = a[_] || [], T = y == null ? 0 : typeof y == "string" ? 1 : y.length, C = 0 < N, C = u(u({}, b), { name: C ? "".concat(_, "(virtual-from:").concat(b.name, ")") : b.name, lowLevelIndex: b, isVirtual: C, keyTail: N, keyLength: T, extractKey: Yr(y), unique: !C && b.unique });
            return E.push(C), C.isPrimaryKey || l.push(C), 1 < T && d(T === 2 ? y[0] : y.slice(0, T - 1), N + 1, b), E.sort(function(P, I) {
              return P.keyTail - I.keyTail;
            }), C;
          }
          t = d(i.primaryKey.keyPath, 0, i.primaryKey), a[":id"] = [t];
          for (var m = 0, v = i.indexes; m < v.length; m++) {
            var w = v[m];
            d(w.keyPath, 0, w);
          }
          function O(y) {
            var N, b = y.query.index;
            return b.isVirtual ? u(u({}, y), { query: { index: b.lowLevelIndex, range: (N = y.query.range, b = b.keyTail, { type: N.type === 1 ? 2 : N.type, lower: pr(N.lower, N.lowerOpen ? e.MAX_KEY : e.MIN_KEY, b), lowerOpen: !0, upper: pr(N.upper, N.upperOpen ? e.MIN_KEY : e.MAX_KEY, b), upperOpen: !0 }) } }) : y;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: t, indexes: l, getIndexByKeyPath: function(y) {
            return (y = a[kn(y)]) && y[0];
          } }), count: function(y) {
            return o.count(O(y));
          }, query: function(y) {
            return o.query(O(y));
          }, openCursor: function(y) {
            var N = y.query.index, b = N.keyTail, _ = N.isVirtual, E = N.keyLength;
            return _ ? o.openCursor(O(y)).then(function(C) {
              return C && T(C);
            }) : o.openCursor(y);
            function T(C) {
              return Object.create(C, { continue: { value: function(P) {
                P != null ? C.continue(pr(P, y.reverse ? e.MAX_KEY : e.MIN_KEY, b)) : y.unique ? C.continue(C.key.slice(0, E).concat(y.reverse ? e.MIN_KEY : e.MAX_KEY, b)) : C.continue();
              } }, continuePrimaryKey: { value: function(P, I) {
                C.continuePrimaryKey(pr(P, e.MAX_KEY, b), I);
              } }, primaryKey: { get: function() {
                return C.primaryKey;
              } }, key: { get: function() {
                var P = C.key;
                return E === 1 ? P[0] : P.slice(0, E);
              } }, value: { get: function() {
                return C.value;
              } } });
            }
          } });
        } });
      } };
      function ao(e, t, o, i) {
        return o = o || {}, i = i || "", p(e).forEach(function(a) {
          var l, d, m;
          L(t, a) ? (l = e[a], d = t[a], typeof l == "object" && typeof d == "object" && l && d ? (m = It(l)) !== It(d) ? o[i + a] = t[a] : m === "Object" ? ao(l, d, o, i + a + ".") : l !== d && (o[i + a] = t[a]) : l !== d && (o[i + a] = t[a])) : o[i + a] = void 0;
        }), p(t).forEach(function(a) {
          L(e, a) || (o[i + a] = t[a]);
        }), o;
      }
      function uo(e, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey);
      }
      var Ls = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(a) {
            var l = re.trans, d = l.table(t).hook, m = d.deleting, v = d.creating, w = d.updating;
            switch (a.type) {
              case "add":
                if (v.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "put":
                if (v.fire === S && w.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "delete":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "deleteRange":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return function y(N, b, _) {
                    return o.query({ trans: N, values: !1, query: { index: i, range: b }, limit: _ }).then(function(E) {
                      var T = E.result;
                      return O({ type: "delete", keys: T, trans: N }).then(function(C) {
                        return 0 < C.numFailures ? Promise.reject(C.failures[0]) : T.length < _ ? { failures: [], numFailures: 0, lastResult: void 0 } : y(N, u(u({}, b), { lower: T[T.length - 1], lowerOpen: !0 }), _);
                      });
                    });
                  }(a.trans, a.range, 1e4);
                }, !0);
            }
            return o.mutate(a);
            function O(y) {
              var N, b, _, E = re.trans, T = y.keys || uo(i, y);
              if (!T) throw new Error("Keys missing");
              return (y = y.type === "add" || y.type === "put" ? u(u({}, y), { keys: T }) : u({}, y)).type !== "delete" && (y.values = c([], y.values)), y.keys && (y.keys = c([], y.keys)), N = o, _ = T, ((b = y).type === "add" ? Promise.resolve([]) : N.getMany({ trans: b.trans, keys: _, cache: "immutable" })).then(function(C) {
                var P = T.map(function(I, k) {
                  var V, X, H, G = C[k], Q = { onerror: null, onsuccess: null };
                  return y.type === "delete" ? m.fire.call(Q, I, G, E) : y.type === "add" || G === void 0 ? (V = v.fire.call(Q, I, y.values[k], E), I == null && V != null && (y.keys[k] = I = V, i.outbound || we(y.values[k], i.keyPath, I))) : (V = ao(G, y.values[k]), (X = w.fire.call(Q, V, I, G, E)) && (H = y.values[k], Object.keys(X).forEach(function(z) {
                    L(H, z) ? H[z] = X[z] : we(H, z, X[z]);
                  }))), Q;
                });
                return o.mutate(y).then(function(I) {
                  for (var k = I.failures, V = I.results, X = I.numFailures, I = I.lastResult, H = 0; H < T.length; ++H) {
                    var G = (V || T)[H], Q = P[H];
                    G == null ? Q.onerror && Q.onerror(k[H]) : Q.onsuccess && Q.onsuccess(y.type === "put" && C[H] ? y.values[H] : G);
                  }
                  return { failures: k, results: V, numFailures: X, lastResult: I };
                }).catch(function(I) {
                  return P.forEach(function(k) {
                    return k.onerror && k.onerror(I);
                  }), Promise.reject(I);
                });
              });
            }
          } });
        } });
      } };
      function oi(e, t, o) {
        try {
          if (!t || t.keys.length < e.length) return null;
          for (var i = [], a = 0, l = 0; a < t.keys.length && l < e.length; ++a) Oe(t.keys[a], e[l]) === 0 && (i.push(o ? st(t.values[a]) : t.values[a]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Ks = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(t) {
          var o = e.table(t);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var a = oi(i.keys, i.trans._cache, i.cache === "clone");
            return a ? J.resolve(a) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? st(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function ii(e, t) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function si(e, t) {
        switch (e) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var Fs = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var t = e.schema.name, o = new Qe(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, a, l) {
          if (re.subscr && a !== "readonly") throw new K.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(re.querier));
          return e.transaction(i, a, l);
        }, table: function(i) {
          var a = e.table(i), l = a.schema, d = l.primaryKey, y = l.indexes, m = d.extractKey, v = d.outbound, w = d.autoIncrement && y.filter(function(b) {
            return b.compound && b.keyPath.includes(d.keyPath);
          }), O = u(u({}, a), { mutate: function(b) {
            function _(z) {
              return z = "idb://".concat(t, "/").concat(i, "/").concat(z), I[z] || (I[z] = new Qe());
            }
            var E, T, C, P = b.trans, I = b.mutatedParts || (b.mutatedParts = {}), k = _(""), V = _(":dels"), X = b.type, Q = b.type === "deleteRange" ? [b.range] : b.type === "delete" ? [b.keys] : b.values.length < 50 ? [uo(d, b).filter(function(z) {
              return z;
            }), b.values] : [], H = Q[0], G = Q[1], Q = b.trans._cache;
            return h(H) ? (k.addKeys(H), (Q = X === "delete" || H.length === G.length ? oi(H, Q) : null) || V.addKeys(H), (Q || G) && (E = _, T = Q, C = G, l.indexes.forEach(function(z) {
              var Z = E(z.name || "");
              function ye(he) {
                return he != null ? z.extractKey(he) : null;
              }
              function Te(he) {
                return z.multiEntry && h(he) ? he.forEach(function(Ke) {
                  return Z.addKey(Ke);
                }) : Z.addKey(he);
              }
              (T || C).forEach(function(he, Je) {
                var pe = T && ye(T[Je]), Je = C && ye(C[Je]);
                Oe(pe, Je) !== 0 && (pe != null && Te(pe), Je != null && Te(Je));
              });
            }))) : H ? (G = { from: (G = H.lower) !== null && G !== void 0 ? G : e.MIN_KEY, to: (G = H.upper) !== null && G !== void 0 ? G : e.MAX_KEY }, V.add(G), k.add(G)) : (k.add(o), V.add(o), l.indexes.forEach(function(z) {
              return _(z.name).add(o);
            })), a.mutate(b).then(function(z) {
              return !H || b.type !== "add" && b.type !== "put" || (k.addKeys(z.results), w && w.forEach(function(Z) {
                for (var ye = b.values.map(function(pe) {
                  return Z.extractKey(pe);
                }), Te = Z.keyPath.findIndex(function(pe) {
                  return pe === d.keyPath;
                }), he = 0, Ke = z.results.length; he < Ke; ++he) ye[he][Te] = z.results[he];
                _(Z.name).addKeys(ye);
              })), P.mutatedParts = fr(P.mutatedParts || {}, I), z;
            });
          } }), y = function(_) {
            var E = _.query, _ = E.index, E = E.range;
            return [_, new Qe((_ = E.lower) !== null && _ !== void 0 ? _ : e.MIN_KEY, (E = E.upper) !== null && E !== void 0 ? E : e.MAX_KEY)];
          }, N = { get: function(b) {
            return [d, new Qe(b.key)];
          }, getMany: function(b) {
            return [d, new Qe().addKeys(b.keys)];
          }, count: y, query: y, openCursor: y };
          return p(N).forEach(function(b) {
            O[b] = function(_) {
              var E = re.subscr, T = !!E, C = ii(re, a) && si(b, _) ? _.obsSet = {} : E;
              if (T) {
                var P = function(G) {
                  return G = "idb://".concat(t, "/").concat(i, "/").concat(G), C[G] || (C[G] = new Qe());
                }, I = P(""), k = P(":dels"), E = N[b](_), T = E[0], E = E[1];
                if ((b === "query" && T.isPrimaryKey && !_.values ? k : P(T.name || "")).add(E), !T.isPrimaryKey) {
                  if (b !== "count") {
                    var V = b === "query" && v && _.values && a.query(u(u({}, _), { values: !1 }));
                    return a[b].apply(this, arguments).then(function(G) {
                      if (b === "query") {
                        if (v && _.values) return V.then(function(ye) {
                          return ye = ye.result, I.addKeys(ye), G;
                        });
                        var Q = _.values ? G.result.map(m) : G.result;
                        (_.values ? I : k).addKeys(Q);
                      } else if (b === "openCursor") {
                        var z = G, Z = _.values;
                        return z && Object.create(z, { key: { get: function() {
                          return k.addKey(z.primaryKey), z.key;
                        } }, primaryKey: { get: function() {
                          var ye = z.primaryKey;
                          return k.addKey(ye), ye;
                        } }, value: { get: function() {
                          return Z && I.addKey(z.primaryKey), z.value;
                        } } });
                      }
                      return G;
                    });
                  }
                  k.add(o);
                }
              }
              return a[b].apply(this, arguments);
            };
          }), O;
        } });
      } };
      function ai(e, t, o) {
        if (o.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var i = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return o.numFailures === i ? null : (t = u({}, t), h(t.keys) && (t.keys = t.keys.filter(function(a, l) {
          return !(l in o.failures);
        })), "values" in t && h(t.values) && (t.values = t.values.filter(function(a, l) {
          return !(l in o.failures);
        })), t);
      }
      function lo(e, t) {
        return o = e, ((i = t).lower === void 0 || (i.lowerOpen ? 0 < Oe(o, i.lower) : 0 <= Oe(o, i.lower))) && (e = e, (t = t).upper === void 0 || (t.upperOpen ? Oe(e, t.upper) < 0 : Oe(e, t.upper) <= 0));
        var o, i;
      }
      function ui(e, t, N, i, a, l) {
        if (!N || N.length === 0) return e;
        var d = t.query.index, m = d.multiEntry, v = t.query.range, w = i.schema.primaryKey.extractKey, O = d.extractKey, y = (d.lowLevelIndex || d).extractKey, N = N.reduce(function(b, _) {
          var E = b, T = [];
          if (_.type === "add" || _.type === "put") for (var C = new Qe(), P = _.values.length - 1; 0 <= P; --P) {
            var I, k = _.values[P], V = w(k);
            C.hasKey(V) || (I = O(k), (m && h(I) ? I.some(function(z) {
              return lo(z, v);
            }) : lo(I, v)) && (C.addKey(V), T.push(k)));
          }
          switch (_.type) {
            case "add":
              var X = new Qe().addKeys(t.values ? b.map(function(Z) {
                return w(Z);
              }) : b), E = b.concat(t.values ? T.filter(function(Z) {
                return Z = w(Z), !X.hasKey(Z) && (X.addKey(Z), !0);
              }) : T.map(function(Z) {
                return w(Z);
              }).filter(function(Z) {
                return !X.hasKey(Z) && (X.addKey(Z), !0);
              }));
              break;
            case "put":
              var H = new Qe().addKeys(_.values.map(function(Z) {
                return w(Z);
              }));
              E = b.filter(function(Z) {
                return !H.hasKey(t.values ? w(Z) : Z);
              }).concat(t.values ? T : T.map(function(Z) {
                return w(Z);
              }));
              break;
            case "delete":
              var G = new Qe().addKeys(_.keys);
              E = b.filter(function(Z) {
                return !G.hasKey(t.values ? w(Z) : Z);
              });
              break;
            case "deleteRange":
              var Q = _.range;
              E = b.filter(function(Z) {
                return !lo(w(Z), Q);
              });
          }
          return E;
        }, e);
        return N === e ? e : (N.sort(function(b, _) {
          return Oe(y(b), y(_)) || Oe(w(b), w(_));
        }), t.limit && t.limit < 1 / 0 && (N.length > t.limit ? N.length = t.limit : e.length === t.limit && N.length < t.limit && (a.dirty = !0)), l ? Object.freeze(N) : N);
      }
      function li(e, t) {
        return Oe(e.lower, t.lower) === 0 && Oe(e.upper, t.upper) === 0 && !!e.lowerOpen == !!t.lowerOpen && !!e.upperOpen == !!t.upperOpen;
      }
      function Ms(e, t) {
        return function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = Oe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, t.lower, e.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = Oe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, t.upper, e.upperOpen, t.upperOpen);
      }
      function Bs(e, t, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var a, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (a = e, l = t, setTimeout(function() {
            a.subscribers.size === 0 && Fe(l, a);
          }, 3e3));
        });
      }
      var $s = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var t = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, a) {
          var l, d, m = e.transaction(o, i, a);
          return i === "readwrite" && (d = (l = new AbortController()).signal, a = function(v) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var w = /* @__PURE__ */ new Set(), O = 0, y = o; O < y.length; O++) {
                  var N = y[O], b = nn["idb://".concat(t, "/").concat(N)];
                  if (b) {
                    var _ = e.table(N), E = b.optimisticOps.filter(function(Z) {
                      return Z.trans === m;
                    });
                    if (m._explicit && v && m.mutatedParts) for (var T = 0, C = Object.values(b.queries.query); T < C.length; T++) for (var P = 0, I = (X = C[T]).slice(); P < I.length; P++) no((H = I[P]).obsSet, m.mutatedParts) && (Fe(X, H), H.subscribers.forEach(function(Z) {
                      return w.add(Z);
                    }));
                    else if (0 < E.length) {
                      b.optimisticOps = b.optimisticOps.filter(function(Z) {
                        return Z.trans !== m;
                      });
                      for (var k = 0, V = Object.values(b.queries.query); k < V.length; k++) for (var X, H, G, Q = 0, z = (X = V[k]).slice(); Q < z.length; Q++) (H = z[Q]).res != null && m.mutatedParts && (v && !H.dirty ? (G = Object.isFrozen(H.res), G = ui(H.res, H.req, E, _, H, G), H.dirty ? (Fe(X, H), H.subscribers.forEach(function(Z) {
                        return w.add(Z);
                      })) : G !== H.res && (H.res = G, H.promise = J.resolve({ result: G }))) : (H.dirty && Fe(X, H), H.subscribers.forEach(function(Z) {
                        return w.add(Z);
                      })));
                    }
                  }
                }
                w.forEach(function(Z) {
                  return Z();
                });
              }
            };
          }, m.addEventListener("abort", a(!1), { signal: d }), m.addEventListener("error", a(!1), { signal: d }), m.addEventListener("complete", a(!0), { signal: d })), m;
        }, table: function(o) {
          var i = e.table(o), a = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var d = re.trans;
            if (a.outbound || d.db._options.cache === "disabled" || d.explicit || d.idbtrans.mode !== "readwrite") return i.mutate(l);
            var m = nn["idb://".concat(t, "/").concat(o)];
            return m ? (d = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || uo(a, l).some(function(v) {
              return v == null;
            })) ? (m.optimisticOps.push(l), l.mutatedParts && dr(l.mutatedParts), d.then(function(v) {
              0 < v.numFailures && (Fe(m.optimisticOps, l), (v = ai(0, l, v)) && m.optimisticOps.push(v), l.mutatedParts && dr(l.mutatedParts));
            }), d.catch(function() {
              Fe(m.optimisticOps, l), l.mutatedParts && dr(l.mutatedParts);
            })) : d.then(function(v) {
              var w = ai(0, u(u({}, l), { values: l.values.map(function(O, y) {
                var N;
                return v.failures[y] || (O = (N = a.keyPath) !== null && N !== void 0 && N.includes(".") ? st(O) : u({}, O), we(O, a.keyPath, v.results[y])), O;
              }) }), v);
              m.optimisticOps.push(w), queueMicrotask(function() {
                return l.mutatedParts && dr(l.mutatedParts);
              });
            }), d) : i.mutate(l);
          }, query: function(l) {
            if (!ii(re, i) || !si("query", l)) return i.query(l);
            var d = ((w = re.trans) === null || w === void 0 ? void 0 : w.db._options.cache) === "immutable", y = re, m = y.requery, v = y.signal, w = function(_, E, T, C) {
              var P = nn["idb://".concat(_, "/").concat(E)];
              if (!P) return [];
              if (!(E = P.queries[T])) return [null, !1, P, null];
              var I = E[(C.query ? C.query.index.name : null) || ""];
              if (!I) return [null, !1, P, null];
              switch (T) {
                case "query":
                  var k = I.find(function(V) {
                    return V.req.limit === C.limit && V.req.values === C.values && li(V.req.query.range, C.query.range);
                  });
                  return k ? [k, !0, P, I] : [I.find(function(V) {
                    return ("limit" in V.req ? V.req.limit : 1 / 0) >= C.limit && (!C.values || V.req.values) && Ms(V.req.query.range, C.query.range);
                  }), !1, P, I];
                case "count":
                  return k = I.find(function(V) {
                    return li(V.req.query.range, C.query.range);
                  }), [k, !!k, P, I];
              }
            }(t, o, "query", l), O = w[0], y = w[1], N = w[2], b = w[3];
            return O && y ? O.obsSet = l.obsSet : (y = i.query(l).then(function(_) {
              var E = _.result;
              if (O && (O.res = E), d) {
                for (var T = 0, C = E.length; T < C; ++T) Object.freeze(E[T]);
                Object.freeze(E);
              } else _.result = st(E);
              return _;
            }).catch(function(_) {
              return b && O && Fe(b, O), Promise.reject(_);
            }), O = { obsSet: l.obsSet, promise: y, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, b ? b.push(O) : (b = [O], (N = N || (nn["idb://".concat(t, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = b)), Bs(O, b, m, v), O.promise.then(function(_) {
              return { result: ui(_.result, l, N?.optimisticOps, i, O, d) };
            });
          } });
        } });
      } };
      function hr(e, t) {
        return new Proxy(e, { get: function(o, i, a) {
          return i === "db" ? t : Reflect.get(o, i, a);
        } });
      }
      var Rt = ($e.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new K.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new K.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var t = this._versions, o = t.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), t.push(o), t.sort(Ps), o.stores({}), this._state.autoSchema = !1, o);
      }, $e.prototype._whenReady = function(e) {
        var t = this;
        return this.idbdb && (this._state.openComplete || re.letThrough || this._vip) ? e() : new J(function(o, i) {
          if (t._state.openComplete) return i(new K.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void i(new K.DatabaseClosed());
            t.open().catch(S);
          }
          t._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, $e.prototype.use = function(e) {
        var t = e.stack, o = e.create, i = e.level, a = e.name;
        return a && this.unuse({ stack: t, name: a }), e = this._middlewares[t] || (this._middlewares[t] = []), e.push({ stack: t, create: o, level: i ?? 10, name: a }), e.sort(function(l, d) {
          return l.level - d.level;
        }), this;
      }, $e.prototype.unuse = function(e) {
        var t = e.stack, o = e.name, i = e.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(a) {
          return i ? a.create !== i : !!o && a.name !== o;
        })), this;
      }, $e.prototype.open = function() {
        var e = this;
        return Zt(ot, function() {
          return ks(e);
        });
      }, $e.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, t = gn.indexOf(this);
        if (0 <= t && gn.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new J(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new J(function(o, i) {
          e.cancelOpen = i;
        }));
      }, $e.prototype.close = function(o) {
        var t = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        t ? (o.isBeingOpened && o.cancelOpen(new K.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new K.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, $e.prototype.delete = function(e) {
        var t = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new J(function(a, l) {
          function d() {
            t.close(e);
            var m = t._deps.indexedDB.deleteDatabase(t.name);
            m.onsuccess = Le(function() {
              var v, w, O;
              v = t._deps, w = t.name, O = v.indexedDB, v = v.IDBKeyRange, Zr(O) || w === Zn || Jr(O, v).delete(w).catch(S), a();
            }), m.onerror = Et(l), m.onblocked = t._fireOnBlocked;
          }
          if (o) throw new K.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(d) : d();
        });
      }, $e.prototype.backendDB = function() {
        return this.idbdb;
      }, $e.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, $e.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, $e.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, $e.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty($e.prototype, "tables", { get: function() {
        var e = this;
        return p(this._allTables).map(function(t) {
          return e._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), $e.prototype.transaction = function() {
        var e = (function(t, o, i) {
          var a = arguments.length;
          if (a < 2) throw new K.InvalidArgument("Too few arguments");
          for (var l = new Array(a - 1); --a; ) l[a - 1] = arguments[a];
          return i = l.pop(), [t, ze(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, $e.prototype._transaction = function(e, t, o) {
        var i = this, a = re.trans;
        a && a.db === this && e.indexOf("!") === -1 || (a = null);
        var l, d, m = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (d = t.map(function(w) {
            if (w = w instanceof i.Table ? w.name : w, typeof w != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return w;
          }), e == "r" || e === $r) l = $r;
          else {
            if (e != "rw" && e != qr) throw new K.InvalidArgument("Invalid transaction mode: " + e);
            l = qr;
          }
          if (a) {
            if (a.mode === $r && l === qr) {
              if (!m) throw new K.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              a = null;
            }
            a && d.forEach(function(w) {
              if (a && a.storeNames.indexOf(w) === -1) {
                if (!m) throw new K.SubTransaction("Table " + w + " not included in parent transaction.");
                a = null;
              }
            }), m && a && !a.active && (a = null);
          }
        } catch (w) {
          return a ? a._promise(null, function(O, y) {
            y(w);
          }) : Be(w);
        }
        var v = (function w(O, y, N, b, _) {
          return J.resolve().then(function() {
            var E = re.transless || re, T = O._createTransaction(y, N, O._dbSchema, b);
            if (T.explicit = !0, E = { trans: T, transless: E }, b) T.idbtrans = b.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, O._state.PR1398_maxLoop = 3;
            } catch (I) {
              return I.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                return w(O, y, N, null, _);
              })) : Be(I);
            }
            var C, P = _t(_);
            return P && vn(), E = J.follow(function() {
              var I;
              (C = _.call(T, T)) && (P ? (I = Mt.bind(null, null), C.then(I, I)) : typeof C.next == "function" && typeof C.throw == "function" && (C = so(C)));
            }, E), (C && typeof C.then == "function" ? J.resolve(C).then(function(I) {
              return T.active ? I : Be(new K.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : E.then(function() {
              return C;
            })).then(function(I) {
              return b && T._resolve(), T._completion.then(function() {
                return I;
              });
            }).catch(function(I) {
              return T._reject(I), Be(I);
            });
          });
        }).bind(null, this, l, d, a, o);
        return a ? a._promise(l, v, "lock") : re.trans ? Zt(re.transless, function() {
          return i._whenReady(v);
        }) : this._whenReady(v);
      }, $e.prototype.table = function(e) {
        if (!L(this._allTables, e)) throw new K.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, $e);
      function $e(e, t) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = $e.dependencies;
        this._options = t = u({ addons: $e.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, i = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var a, l, d, m, v, w = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: S, dbReadyPromise: null, cancelOpen: S, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        w.dbReadyPromise = new J(function(y) {
          w.dbReadyResolve = y;
        }), w.openCanceller = new J(function(y, N) {
          w.cancelOpen = N;
        }), this._state = w, this.name = e, this.on = Sn(this, "populate", "blocked", "versionchange", "close", { ready: [de, S] }), this.once = function(y, N) {
          var b = function() {
            for (var _ = [], E = 0; E < arguments.length; E++) _[E] = arguments[E];
            o.on(y).unsubscribe(b), N.apply(o, _);
          };
          return o.on(y, b);
        }, this.on.ready.subscribe = Y(this.on.ready.subscribe, function(y) {
          return function(N, b) {
            $e.vip(function() {
              var _, E = o._state;
              E.openComplete ? (E.dbOpenError || J.resolve().then(N), b && y(N)) : E.onReadyBeingFired ? (E.onReadyBeingFired.push(N), b && y(N)) : (y(N), _ = o, b || y(function T() {
                _.on.ready.unsubscribe(N), _.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (a = this, An(Os.prototype, function(C, T) {
          this.db = a;
          var b = Mo, _ = null;
          if (T) try {
            b = T();
          } catch (P) {
            _ = P;
          }
          var E = C._ctx, T = E.table, C = T.hook.reading.fire;
          this._ctx = { table: T, index: E.index, isPrimKey: !E.index || T.schema.primKey.keyPath && E.index === T.schema.primKey.name, range: b, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: _, or: E.or, valueMapper: C !== F ? C : null };
        })), this.Table = (l = this, An(Uo.prototype, function(y, N, b) {
          this.db = l, this._tx = b, this.name = y, this.schema = N, this.hook = l._allTables[y] ? l._allTables[y].hook : Sn(null, { creating: [ue, S], reading: [te, F], updating: [me, S], deleting: [se, S] });
        })), this.Transaction = (d = this, An(Ns.prototype, function(y, N, b, _, E) {
          var T = this;
          y !== "readonly" && N.forEach(function(C) {
            C = (C = b[C]) === null || C === void 0 ? void 0 : C.yProps, C && (N = N.concat(C.map(function(P) {
              return P.updatesTable;
            })));
          }), this.db = d, this.mode = y, this.storeNames = N, this.schema = b, this.chromeTransactionDurability = _, this.idbtrans = null, this.on = Sn(this, "complete", "error", "abort"), this.parent = E || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new J(function(C, P) {
            T._resolve = C, T._reject = P;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(C) {
            var P = T.active;
            return T.active = !1, T.on.error.fire(C), T.parent ? T.parent._reject(C) : P && T.idbtrans && T.idbtrans.abort(), Be(C);
          });
        })), this.Version = (m = this, An(Is.prototype, function(y) {
          this.db = m, this._cfg = { version: y, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (v = this, An(Xo.prototype, function(y, N, b) {
          if (this.db = v, this._ctx = { table: y, index: N === ":id" ? null : N, or: b }, this._cmp = this._ascending = Oe, this._descending = function(_, E) {
            return Oe(E, _);
          }, this._max = function(_, E) {
            return 0 < Oe(_, E) ? _ : E;
          }, this._min = function(_, E) {
            return Oe(_, E) < 0 ? _ : E;
          }, this._IDBKeyRange = v._deps.IDBKeyRange, !this._IDBKeyRange) throw new K.MissingAPI();
        })), this.on("versionchange", function(y) {
          0 < y.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(y) {
          !y.newVersion || y.newVersion < y.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(y.oldVersion / 10));
        }), this._maxKey = In(t.IDBKeyRange), this._createTransaction = function(y, N, b, _) {
          return new o.Transaction(y, N, b, o._options.chromeTransactionDurability, _);
        }, this._fireOnBlocked = function(y) {
          o.on("blocked").fire(y), gn.filter(function(N) {
            return N.name === o.name && N !== o && !N._state.vcFired;
          }).map(function(N) {
            return N.on("versionchange").fire(y);
          });
        }, this.use(Ks), this.use($s), this.use(Fs), this.use(js), this.use(Ls);
        var O = new Proxy(this, { get: function(y, N, b) {
          if (N === "_vip") return !0;
          if (N === "table") return function(E) {
            return hr(o.table(E), O);
          };
          var _ = Reflect.get(y, N, b);
          return _ instanceof Uo ? hr(_, O) : N === "tables" ? _.map(function(E) {
            return hr(E, O);
          }) : N === "_createTransaction" ? function() {
            return hr(_.apply(this, arguments), O);
          } : _;
        } });
        this.vip = O, i.forEach(function(y) {
          return y(o);
        });
      }
      var mr, wt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", qs = (co.prototype.subscribe = function(e, t, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: o });
      }, co.prototype[wt] = function() {
        return this;
      }, co);
      function co(e) {
        this._subscribe = e;
      }
      try {
        mr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
      } catch {
        mr = { indexedDB: null, IDBKeyRange: null };
      }
      function ci(e) {
        var t, o = !1, i = new qs(function(a) {
          var l = _t(e), d, m = !1, v = {}, w = {}, O = { get closed() {
            return m;
          }, unsubscribe: function() {
            m || (m = !0, d && d.abort(), y && qt.storagemutated.unsubscribe(b));
          } };
          a.start && a.start(O);
          var y = !1, N = function() {
            return Br(_);
          }, b = function(E) {
            fr(v, E), no(w, v) && N();
          }, _ = function() {
            var E, T, C;
            !m && mr.indexedDB && (v = {}, E = {}, d && d.abort(), d = new AbortController(), C = function(P) {
              var I = mn();
              try {
                l && vn();
                var k = Ft(e, P);
                return k = l ? k.finally(Mt) : k;
              } finally {
                I && yn();
              }
            }(T = { subscr: E, signal: d.signal, requery: N, querier: e, trans: null }), Promise.resolve(C).then(function(P) {
              o = !0, t = P, m || T.signal.aborted || (v = {}, function(I) {
                for (var k in I) if (L(I, k)) return;
                return 1;
              }(w = E) || y || (qt(Rn, b), y = !0), Br(function() {
                return !m && a.next && a.next(P);
              }));
            }, function(P) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(P?.name) || m || Br(function() {
                m || a.error && a.error(P);
              });
            }));
          };
          return setTimeout(N, 0), O;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return t;
        }, i;
      }
      var rn = Rt;
      function fo(e) {
        var t = Ut;
        try {
          Ut = !0, qt.storagemutated.fire(e), io(e, !0);
        } finally {
          Ut = t;
        }
      }
      B(rn, u(u({}, Ve), { delete: function(e) {
        return new rn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new rn(e, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return t = rn.dependencies, o = t.indexedDB, t = t.IDBKeyRange, (Zr(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(a) {
              return a.name;
            }).filter(function(a) {
              return a !== Zn;
            });
          }) : Jr(o, t).toCollection().primaryKeys()).then(e);
        } catch {
          return Be(new K.MissingAPI());
        }
        var t, o;
      }, defineClass: function() {
        return function(e) {
          g(this, e);
        };
      }, ignoreTransaction: function(e) {
        return re.trans ? Zt(re.transless, e) : e();
      }, vip: eo, async: function(e) {
        return function() {
          try {
            var t = so(e.apply(this, arguments));
            return t && typeof t.then == "function" ? t : J.resolve(t);
          } catch (o) {
            return Be(o);
          }
        };
      }, spawn: function(e, t, o) {
        try {
          var i = so(e.apply(o, t || []));
          return i && typeof i.then == "function" ? i : J.resolve(i);
        } catch (a) {
          return Be(a);
        }
      }, currentTransaction: { get: function() {
        return re.trans || null;
      } }, waitFor: function(e, t) {
        return t = J.resolve(typeof e == "function" ? rn.ignoreTransaction(e) : e).timeout(t || 6e4), re.trans ? re.trans.waitFor(t) : t;
      }, Promise: J, debug: { get: function() {
        return ae;
      }, set: function(e) {
        Se(e);
      } }, derive: ce, extend: g, props: B, override: Y, Events: Sn, on: qt, liveQuery: ci, extendObservabilitySet: fr, getByKeyPath: ne, setByKeyPath: we, delByKeyPath: function(e, t) {
        typeof t == "string" ? we(e, t, void 0) : "length" in t && [].map.call(t, function(o) {
          we(e, o, void 0);
        });
      }, shallowClone: _e, deepClone: st, getObjectDiff: ao, cmp: Oe, asap: M, minKey: -1 / 0, addons: [], connections: gn, errnames: A, dependencies: mr, cache: nn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, t, o) {
        return e + t / Math.pow(10, 2 * o);
      }) })), rn.maxKey = In(rn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (qt(Rn, function(e) {
        Ut || (e = new CustomEvent(Hr, { detail: e }), Ut = !0, dispatchEvent(e), Ut = !1);
      }), addEventListener(Hr, function(e) {
        e = e.detail, Ut || fo(e);
      }));
      var En, Ut = !1, fi = function() {
      };
      return typeof BroadcastChannel < "u" && ((fi = function() {
        (En = new BroadcastChannel(Hr)).onmessage = function(e) {
          return e.data && fo(e.data);
        };
      })(), typeof En.unref == "function" && En.unref(), qt(Rn, function(e) {
        Ut || En.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Rt.disableBfCache && e.persisted) {
          ae && console.debug("Dexie: handling persisted pagehide"), En?.close();
          for (var t = 0, o = gn; t < o.length; t++) o[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Rt.disableBfCache && e.persisted && (ae && console.debug("Dexie: handling persisted pageshow"), fi(), fo({ all: new Qe(-1 / 0, [[]]) }));
      })), J.rejectionMapper = function(e, t) {
        return !e || e instanceof jt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !W[e.name] ? e : (t = new W[e.name](t || e.message, e), "stack" in e && ie(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Se(ae), u(Rt, Object.freeze({ __proto__: null, Dexie: Rt, liveQuery: ci, Entity: Bo, cmp: Oe, PropModification: Pn, replacePrefix: function(e, t) {
        return new Pn({ replacePrefix: [e, t] });
      }, add: function(e) {
        return new Pn({ add: e });
      }, remove: function(e) {
        return new Pn({ remove: e });
      }, default: Rt, RangeSet: Qe, mergeRanges: Ln, rangesOverlap: ei }), { default: Rt }), Rt;
    });
  }(va)), va.exports;
}
var Vd = Ud();
const ga = /* @__PURE__ */ Ld(Vd), Iu = Symbol.for("Dexie"), ba = globalThis[Iu] || (globalThis[Iu] = ga);
if (ga.semVer !== ba.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${ga.semVer} and ${ba.semVer}`);
const {
  liveQuery: yy,
  mergeRanges: vy,
  rangesOverlap: gy,
  RangeSet: by,
  cmp: wy,
  Entity: _y,
  PropModification: xy,
  replacePrefix: Oy,
  add: Ty,
  remove: Ey,
  DexieYProvider: Ny
} = ba;
function Ql(n) {
  return {
    addRecord: r,
    findChildRecords: f,
    findChildRecordsByTagName: p,
    ensureRelationship: u,
    removeRelationship: c,
    findParentRecordsWithinDepthAndGivenTagName: h,
    db: n
  };
  async function r(g) {
    const R = { ...g, id: crypto.randomUUID() };
    try {
      return await n.table(ut).add(R), R;
    } catch (D) {
      const L = {
        msg: "could not add record",
        db: n.name,
        newRecord: R,
        err: D
      };
      throw console.error(L), new Error(JSON.stringify(L));
    }
  }
  async function s(g) {
    try {
      if (await n.table(ut).update(g.id, g) < 1) {
        const D = { msg: "nothing has been updated", record: g };
        throw console.error(D), new Error(JSON.stringify(D));
      }
    } catch (R) {
      console.error(R);
    }
  }
  async function u(g, R) {
    const D = g.children?.some((B) => B.id === R.id), L = R.parent?.id === g.id;
    if (D || await n.table(ut).where({ id: g.id }).modify((B) => {
      B.children.push({ id: R.id, tagName: R.tagName });
    }), !L) {
      const B = {
        id: g.id,
        tagName: g.tagName
      };
      await n.table(ut).update(R.id, { parent: B });
    }
  }
  async function c(g, R) {
    R.parent = null, await s(R), g.children && (g.children = g.children.filter((D) => D.id !== R.id), await s(g));
  }
  async function f(g, R) {
    if (!g.children?.length)
      return [];
    let D = (await n.table(ut).bulkGet(g.children.map((L) => L.id))).filter(Boolean);
    return R?.tagNames && R.tagNames.length > 0 && (D = D.filter((L) => R?.tagNames?.includes(L.tagName))), R?.attrs && R.attrs.length > 0 && (D = D.filter(
      (L) => R.attrs.every(
        (B) => L.attributes.some(
          (ee) => ee.name === B.name && ee.value === B.value
        )
      )
    )), D;
  }
  async function p(g, R) {
    return (await f(g)).filter((L) => R.includes(L.tagName));
  }
  async function h(g, R, D = []) {
    const L = [];
    let B = g;
    for (let ee = 0; ee < R; ee++) {
      if (!B.parent)
        return L;
      const ie = await n.table(ut).get(B.parent.id);
      if (!ie)
        break;
      (D.length == 0 || D.length > 0 && D.includes(ie.tagName)) && L.push(ie), B = ie;
    }
    return L;
  }
}
function Re(n, r) {
  return n?.attributes?.find((s) => s.name === r)?.value;
}
var vt = /* @__PURE__ */ ((n) => (n.GOOSE = "GOOSE", n.SMV = "SMV", n.REPORT = "Report", n.INTERNAL = "Internal", n.WIRED = "Wired", n.CONTROL = "Control", n))(vt || {});
const Ro = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: [],
  Internal: []
}, Gt = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
};
function Hd(n) {
  const r = Ql(n), s = cn();
  return {
    createControlledConnection: c,
    createConnection: u,
    createSourcePlaceholder: p,
    createDestinationPlaceholder: f,
    calculateNextInputInstance: h,
    calculateNextOutputInstance: g,
    findExistingInputs: R,
    findExistingOutputs: D
  };
  async function u(L, B, ee, ie) {
    const ce = await qi(r, ee), xe = await Wd(
      r,
      B,
      ce,
      L
    );
    await Gd(r, B, L), ie && (await ku(
      r,
      ee,
      xe
    ), await ju(
      r,
      B,
      ee,
      L.type,
      L.signal,
      L.attribute
    )), await s.refreshConnections(), await s.refreshLNode(B.id);
  }
  async function c(L, B, ee, ie) {
    const ce = await ea(r, B), xe = tp(
      L,
      ee
    ), le = await Yd(r, xe);
    if (await r.ensureRelationship(ce, le), !ee.dataObjectSpecifications?.find(
      (Y) => Y.name === L.controlledSignal
    )) {
      const M = cn().lnodeTypes.find(
        ($) => $.lnClass === ee.lnClass
      )?.dataObjects.find(
        ($) => $.name === L.controlledSignal
      );
      let ne = await Di(
        r,
        ee,
        Gt.prefix
      );
      const we = {
        name: L.controlledSignal,
        desc: M?.desc || ""
      }, _e = await wa(r, we);
      await r.ensureRelationship(ne, _e);
    }
    ie && (await Qd(r, B, le), await ju(
      r,
      B,
      ee,
      L.type,
      L.controlledSignal
    )), await s.refreshConnections(), await s.refreshLNode(ee.id);
  }
  async function f(L, B, ee) {
    const ie = await qi(r, B), ce = await Xi(
      r,
      np(L)
    );
    await r.ensureRelationship(ie, ce), ee && await ku(r, B, [
      ce
    ]), await s.refreshConnections();
  }
  async function p(L, B, ee) {
    let ie = [{ name: "inputName", value: B.inputName }];
    B.preferredLNode && ie.push({ name: "pLN", value: B.preferredLNode }), B.dataflowType && ie.push({ name: "service", value: B.dataflowType }), B.processResource && ie.push({ name: "resourceName", value: B.processResource });
    const ce = L.dataObjectSpecifications?.find(
      (_e) => _e.name === B.dataObject
    ), xe = ce?.dataAttributeSpecifications.find(
      (_e) => _e.name === B.dataAttribute
    ), le = cn(), Y = le.lnodeTypes.find((_e) => _e.lnClass === L.lnClass)?.dataObjects.find((_e) => _e.name === B.dataObject), q = Y?.dataAttributes.find((_e) => _e.name === B.dataAttribute);
    let M, ne;
    if (ce)
      M = await r.db.table(ut).get(ce.id);
    else {
      const _e = await Di(
        r,
        L,
        Gt.prefix
      ), $ = {
        name: B.dataObject,
        desc: Y?.desc || ""
      };
      M = await wa(r, $), await r.ensureRelationship(_e, M);
    }
    if (!M) {
      const _e = "DOS element could not be found or created for source placeholder";
      throw console.error(_e), new Error(JSON.stringify(_e));
    }
    if (xe)
      ne = await r.db.table(ut).get(xe.id);
    else {
      const _e = {
        name: B.dataAttribute,
        desc: q?.desc || ""
      };
      ne = await Jl(
        r,
        _e
      ), await r.ensureRelationship(M, ne);
    }
    if (!ne) {
      const _e = "DAS element could not be found or created for source placeholder";
      throw console.error(_e), new Error(JSON.stringify(_e));
    }
    const we = await r.addRecord({
      tagName: "SubscriberLNode",
      attributes: ie,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(ne, we), ee && await Jd(
      r,
      L,
      B.dataObject,
      B.dataAttribute,
      B.dataflowType || void 0
    ), await le.refreshLNode(L.id);
  }
  async function h(L, B, ee) {
    const ie = await qi(r, ee), le = (await r.findChildRecordsByTagName(ie, [
      "SourceRef"
    ])).map((U) => ({
      input: Re(U, "input"),
      pDA: Re(U, "pDA")
    })).filter(
      (U) => U.input === L && U.pDA === B
    );
    return le.length === 0 ? 1 : le.length + 1;
  }
  async function g(L, B) {
    const ee = await ea(r, B), xe = (await r.findChildRecordsByTagName(ee, [
      "ControlRef"
    ])).map((le) => Re(le, "output")).filter((le) => !!le).filter(
      (le) => le === L
    );
    return xe.length === 0 ? 1 : xe.length + 1;
  }
  async function R(L) {
    const B = await qi(r, L), ie = (await r.findChildRecordsByTagName(B, [
      "SourceRef"
    ])).map((xe) => Re(xe, "input")).filter((xe) => !!xe);
    return Array.from(new Set(ie));
  }
  async function D(L) {
    const B = await ea(r, L), ie = (await r.findChildRecordsByTagName(B, [
      "ControlRef"
    ])).map((xe) => Re(xe, "output")).filter((xe) => !!xe);
    return Array.from(new Set(ie));
  }
}
async function qi(n, r) {
  const s = await Di(
    n,
    r,
    Gt.prefix
  ), u = await n.findChildRecordsByTagName(s, [
    "LNodeInputs"
  ]);
  if (u.length == 1)
    return u[0];
  if (u.length == 0) {
    const f = await n.addRecord({
      tagName: "LNodeInputs",
      attributes: [],
      parent: null,
      namespace: Gt,
      value: "",
      children: []
    });
    return await n.ensureRelationship(s, f), f;
  }
  const c = {
    msg: `More than one LNodeInputs element found in LNode with uuid ${r.uuid}`
  };
  throw console.error(c), new Error(JSON.stringify(c));
}
async function ea(n, r) {
  const s = await Di(
    n,
    r,
    Gt.prefix
  ), u = await n.findChildRecordsByTagName(s, [
    "LNodeOutputs"
  ]);
  if (u.length == 1)
    return u[0];
  if (u.length == 0) {
    const f = await n.addRecord({
      tagName: "LNodeOutputs",
      attributes: [],
      parent: null,
      namespace: Gt,
      value: "",
      children: []
    });
    return await n.ensureRelationship(s, f), f;
  }
  const c = {
    msg: `More than one LNodeOutputs element found in LNode with uuid ${r.uuid}`
  };
  throw console.error(c), new Error(JSON.stringify(c));
}
async function Wd(n, r, s, u) {
  const c = [], f = await Xi(
    n,
    ta(u, r)
  );
  if (c.push(f), await n.ensureRelationship(s, f), u.includeQuality) {
    const p = {
      ...u,
      attribute: "q"
      // Set to 'q' for Quality
    }, h = await Xi(
      n,
      ta(p, r)
    );
    c.push(h), await n.ensureRelationship(s, h);
  }
  if (u.includeTimestamp) {
    const p = {
      ...u,
      attribute: "t"
      // Set to 't' for Timestamp
    }, h = await Xi(
      n,
      ta(p, r)
    );
    c.push(h), await n.ensureRelationship(s, h);
  }
  return c;
}
async function Di(n, r, s) {
  const u = await n.db.table(ut).where({ "parent.id": r.id, tagName: "Private" }).and((p) => Re(p, "type") === s).first();
  if (u)
    return u;
  const c = await n.db.table(ut).get(r.id);
  if (!c) {
    const p = {
      msg: `LNode element with uuid ${r.uuid} not found`
    };
    throw console.error(p), new Error(JSON.stringify(p));
  }
  const f = await n.addRecord({
    tagName: "Private",
    attributes: [{ name: "type", value: s }],
    parent: null,
    namespace: $d.default,
    value: "",
    children: []
  });
  return await n.ensureRelationship(c, f), f;
}
async function Xi(n, r) {
  const s = {
    tagName: "SourceRef",
    namespace: Gt,
    attributes: [
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pDA",
        value: r.pDA
      },
      {
        name: "input",
        value: r.inputName
      },
      {
        name: "inputInst",
        value: r.inputInstance
      },
      {
        name: "service",
        value: r.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: r.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: r.sourceDoName
      },
      {
        name: "sourceDaName",
        value: r.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: r.resourceName
      },
      {
        name: "source",
        value: await wo(
          n.db,
          r.sourceLNodeUuid,
          r.sourceDoName,
          r.sourceDaName
        )
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(s);
}
async function Gd(n, r, s) {
  const u = r.dataObjectSpecifications?.find(
    (B) => B.name === s.signal
  ), c = u?.dataAttributeSpecifications.find(
    (B) => B.name === s.attribute
  );
  if (u && c)
    return;
  const h = cn().lnodeTypes.find((B) => B.lnClass === r.lnClass)?.dataObjects.find((B) => B.name === s.signal), g = h?.dataAttributes.find((B) => B.name === s.attribute);
  let R;
  if (!u) {
    const B = await Di(
      n,
      r,
      Gt.prefix
    ), ee = {
      name: s.signal,
      desc: h?.desc || ""
    };
    R = await wa(n, ee), await n.ensureRelationship(B, R);
  }
  if (R || (R = await n.db.table(ut).get(u.id)), !R)
    throw new Error(`DOS element with id ${u.id} not found`);
  const D = {
    name: s.attribute,
    desc: g?.desc || ""
  }, L = await Jl(
    n,
    D
  );
  await n.ensureRelationship(R, L);
}
async function Yd(n, r) {
  const s = {
    tagName: "ControlRef",
    namespace: Gt,
    attributes: [
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "controlled",
        value: await wo(
          n.db,
          r.controlledLNodeUuid,
          r.controlledDoName
        )
      },
      {
        name: "output",
        value: r.output
      },
      {
        name: "outputInst",
        value: r.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: r.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: r.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(s);
}
async function wo(n, r, s, u) {
  if (!r) return "";
  const c = await n.table(ut).where({ tagName: "LNode" }).and((D) => Re(D, "uuid") === r).first();
  if (!c) return "";
  const f = [];
  let p = c;
  const h = ["LNode", "SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
  for (; p && p.parent; ) {
    if (h.includes(p.tagName)) {
      const D = Re(p, "name");
      D && f.unshift(D);
    }
    p = await n.table(ut).get(p.parent.id);
  }
  const g = (() => {
    const D = c.attributes?.find((ee) => ee.name === "prefix")?.value || "", L = c.attributes?.find((ee) => ee.name === "lnClass")?.value || "", B = c.attributes?.find((ee) => ee.name === "lnInst")?.value || "";
    return `${D}${L}${B}`;
  })();
  f.push(g);
  let R = f.join("/");
  return s && (R += `.${s}`, u && (R += "." + u)), R;
}
async function Xd(n, r, s) {
  const u = await wo(n, r), c = Re(s, "input"), f = Re(s, "inputInst"), p = Re(s, "pDA");
  let h = `${u}.${c}`;
  return f && (h += `(${f})`), p && (h += `.${p}`), h;
}
async function zd(n, r, s) {
  const u = await wo(n, r), c = Re(s, "output"), f = Re(s, "outputInst");
  let p = `${u}.${c}`;
  return f && (p += `(${f})`), p;
}
async function Ri(n, r) {
  const s = await n.db.table(ut).get(r);
  if (!s || !s?.parent)
    return;
  const u = await n.db.table(ut).get(s.parent.id);
  if (!(u?.tagName === "Function" || u?.tagName === "SubFunction"))
    return;
  const f = await n.db.table(ut).where({ tagName: "FunctionRef" }).and(
    (p) => Re(p, "functionUuid") === Re(u, "uuid")
  ).toArray();
  if (f.length !== 0)
    return f[0];
}
async function Ii(n, r) {
  const s = await n.findParentRecordsWithinDepthAndGivenTagName(
    r,
    3,
    ["Application"]
  );
  if (s.length == 1)
    return s[0];
}
async function ku(n, r, s) {
  const u = await Ri(n, r.id);
  if (!u || !await Ii(n, u))
    return;
  let f = (await n.findChildRecords(u, {
    tagNames: ["SignalRole"],
    attrs: [{ name: "name", value: "Input" }]
  }))[0];
  f || (f = await n.addRecord({
    tagName: "SignalRole",
    attributes: [
      { name: "name", value: "Input" },
      { name: "uuid", value: crypto.randomUUID() }
    ],
    parent: null,
    namespace: Gt,
    value: "",
    children: []
  }), await n.ensureRelationship(u, f));
  for (const p of s) {
    const h = await n.addRecord({
      tagName: "LNodeInputRef",
      attributes: [
        {
          name: "sourceRef",
          value: await Xd(n.db, r.uuid, p)
        },
        { name: "sourceRefUuid", value: Re(p, "uuid") || "" }
      ],
      parent: null,
      namespace: Gt,
      value: "",
      children: []
    });
    await n.ensureRelationship(f, h);
  }
}
async function Qd(n, r, s) {
  const u = await Ri(n, r.id);
  if (!u || !await Ii(n, u))
    return;
  let f = (await n.findChildRecords(u, {
    tagNames: ["SignalRole"],
    attrs: [{ name: "name", value: "Output" }]
  }))[0];
  f || (f = await n.addRecord({
    tagName: "SignalRole",
    attributes: [
      { name: "name", value: "Output" },
      { name: "uuid", value: crypto.randomUUID() }
    ],
    parent: null,
    namespace: Gt,
    value: "",
    children: []
  }), await n.ensureRelationship(u, f));
  const p = await n.addRecord({
    tagName: "LNodeOutputRef",
    attributes: [
      {
        name: "controlRef",
        value: await zd(
          n.db,
          r.uuid,
          s
        )
      },
      { name: "controlRefUuid", value: Re(s, "uuid") || "" }
    ],
    parent: null,
    namespace: Gt,
    value: "",
    children: []
  });
  await n.ensureRelationship(f, p);
}
async function Jd(n, r, s, u, c) {
  const f = await Ri(n, r.id);
  if (!f || !await Ii(n, f))
    return;
  const h = await wo(n.db, r.uuid, s, u);
  c === vt.REPORT && await mi(
    n,
    f,
    "Signalisation",
    h,
    r.uuid,
    s,
    u
  );
}
async function ju(n, r, s, u, c, f) {
  const p = await Ri(n, r.id);
  if (!p)
    return;
  const h = await Ii(
    n,
    p
  );
  if (!h)
    return;
  const g = await Ri(
    n,
    s.id
  );
  if (!g)
    return;
  const R = await Ii(
    n,
    g
  );
  if (!R)
    return;
  let D = "", L, B;
  u === vt.CONTROL ? (D = await wo(n.db, s.uuid, c), L = s, B = g) : (D = await wo(n.db, r.uuid, c, f), L = r, B = p), u === vt.REPORT && await mi(
    n,
    B,
    "Signalisation",
    D,
    r.uuid,
    c,
    f
  ), u === vt.CONTROL && await mi(
    n,
    B,
    "Control",
    D,
    L.uuid,
    c
  ), h.id === R.id ? await mi(
    n,
    B,
    "Internal",
    D,
    L.uuid,
    c,
    f
  ) : await mi(
    n,
    B,
    "Process",
    D,
    L.uuid,
    c,
    f
  );
}
async function mi(n, r, s, u, c, f, p) {
  const h = await Zd(
    n,
    r,
    s
  );
  await ep(
    n,
    h,
    u,
    c,
    f,
    p
  );
}
async function Zd(n, r, s) {
  let u = (await n.findChildRecords(r, {
    tagNames: ["SignalRole"],
    attrs: [{ name: "name", value: s }]
  }))[0];
  return u || (u = await n.addRecord({
    tagName: "SignalRole",
    attributes: [
      { name: "name", value: s },
      { name: "uuid", value: crypto.randomUUID() }
    ],
    parent: null,
    namespace: Gt,
    value: "",
    children: []
  }), await n.ensureRelationship(r, u), u);
}
async function ep(n, r, s, u, c, f) {
  const p = [
    { name: "data", value: s },
    { name: "lnodeUuid", value: u },
    { name: "doName", value: c }
  ];
  if (f && p.push({ name: "daName", value: f }), !(await n.findChildRecords(r, {
    tagNames: ["LNodeDataRef"],
    attrs: p
  }))[0]) {
    const g = await n.addRecord({
      tagName: "LNodeDataRef",
      attributes: p,
      parent: null,
      namespace: Gt,
      value: "",
      children: []
    });
    await n.ensureRelationship(r, g);
  }
}
function ta(n, r) {
  return {
    dataflowType: n.type,
    inputName: n.inputName,
    inputInstance: n.inputInstance,
    sourceLNodeUuid: r.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: n.signal,
    sourceDaName: n.attribute,
    pLN: r.lnClass,
    // SETRULE: set lnClass of source LNode also as preferred LN
    pDO: n.signal,
    // SETRULE: set signal/data object also as preferred DO
    pDA: n.attribute
    // SETRULE: set data attribute also as preferred DA
  };
}
function tp(n, r) {
  return {
    pDO: "",
    // TODO
    pLN: "",
    // TODO
    output: n.outputName,
    outputInst: n.outputInstance,
    controlledLNodeUuid: r.uuid,
    controlledDoName: n.controlledSignal
  };
}
function np(n) {
  return {
    dataflowType: n.dataflowType,
    inputName: n.inputName,
    inputInstance: n.inputInstance,
    sourceLNodeUuid: "",
    resourceName: n.processResource,
    sourceDoName: "",
    sourceDaName: "",
    pLN: n.preferredLNode,
    pDO: n.preferredDataObject,
    pDA: n.preferredDataAttribute
  };
}
async function wa(n, r) {
  const s = {
    tagName: "DOS",
    namespace: Gt,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(s);
}
async function Jl(n, r) {
  const s = {
    tagName: "DAS",
    namespace: Gt,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(s);
}
function rp(n) {
  return {
    findAllEnrichedLNodes: r,
    findAllLNodeTypes: s,
    enrichWithDataObjectSpecifications: f
  };
  async function r() {
    const h = await p();
    return h.length ? await f(h) : [];
  }
  async function s() {
    const h = await n.table(ut).where({ tagName: "LNodeType" }).toArray(), g = [];
    for (const R of h)
      g.push({
        id: R.id,
        typeId: Re(R, "id") ?? "",
        lnClass: Re(R, "lnClass") ?? "",
        dataObjects: await u(R)
      });
    return g;
  }
  async function u(h) {
    if (!h.children) return [];
    const g = [];
    for (const R of h.children) {
      if (R.tagName !== "DO") continue;
      const D = await n.table(ut).get(R.id);
      D && g.push({
        id: D.id,
        name: Re(D, "name") ?? "",
        type: Re(D, "type") ?? "",
        desc: Re(D, "desc") ?? "",
        dataAttributes: await c(D)
      });
    }
    return g;
  }
  async function c(h) {
    const g = Re(h, "type");
    if (!g) return [];
    const R = (await n.table(ut).where({ tagName: "DOType" }).toArray()).find((L) => L.attributes?.find((B) => B.name === "id" && B.value === g));
    if (!R || !R.children) return [];
    const D = [];
    for (const L of R.children) {
      if (L.tagName !== "DA") continue;
      const B = await n.table(ut).get(L.id);
      B && D.push({
        id: B.id,
        name: Re(B, "name") ?? "",
        type: Re(B, "type") ?? "",
        desc: Re(B, "desc") ?? "",
        bType: Re(B, "bType") ?? "",
        fc: Re(B, "fc") ?? ""
      });
    }
    return D;
  }
  async function f(h) {
    const g = await n.table(ut).where({ tagName: "Private" }).toArray(), R = await n.table(ut).where({ tagName: "DOS" }).toArray(), D = await n.table(ut).where({ tagName: "DAS" }).toArray(), L = await n.table(ut).where({ tagName: "SubscriberLNode" }).toArray();
    return Promise.all(
      h.map(async (B) => {
        const ee = g.find(
          (ce) => ce.parent?.id === B.id && ce.parent?.tagName === "LNode" && Re(ce, "type") === "eIEC61850-6-100"
        );
        if (!ee || !ee.children)
          return { ...B, dataObjectSpecifications: [] };
        const ie = [];
        for (const ce of ee.children) {
          if (ce.tagName !== "DOS") continue;
          const xe = R.find((U) => U.id === ce.id);
          if (!xe) continue;
          const le = [];
          if (xe.children)
            for (const U of xe.children) {
              if (U.tagName !== "DAS") continue;
              const Y = D.find((M) => M.id === U.id);
              if (!Y) continue;
              let q = [];
              if (Y.children) {
                const M = Y.children.filter((we) => we.tagName === "SubscriberLNode"), ne = L.filter(
                  (we) => M.some((_e) => _e.id === we.id)
                );
                for (const we of ne)
                  q.push({
                    id: we.id,
                    inputName: Re(we, "inputName") ?? "",
                    service: Zl(we, "service"),
                    pLN: Re(we, "pLN") ?? "",
                    resourceName: Re(we, "resourceName") ?? ""
                  });
              }
              le.push({
                id: Y.id,
                name: Re(Y, "name") ?? "",
                desc: Re(Y, "desc") ?? "",
                subscriberLNodes: q
              });
            }
          ie.push({
            id: xe.id,
            name: Re(xe, "name") ?? "",
            desc: Re(xe, "desc") ?? "",
            dataAttributeSpecifications: le
          });
        }
        return { ...B, dataObjectSpecifications: ie };
      })
    );
  }
  async function p() {
    return (await n.table(ut).where({ tagName: "LNode" }).toArray()).map((g) => ({
      id: g.id,
      uuid: Re(g, "uuid") ?? "",
      iedName: Re(g, "iedName") ?? "",
      prefix: Re(g, "prefix") ?? "",
      lnClass: Re(g, "lnClass") ?? "",
      lnInst: Re(g, "lnInst") ?? "",
      lnType: Re(g, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function Zl(n, r) {
  const s = n?.attributes?.find((c) => c.name === r)?.value;
  if (!s) return;
  switch (s.toUpperCase()) {
    case "GOOSE":
      return vt.GOOSE;
    case "SMV":
      return vt.SMV;
    case "REPORT":
      return vt.REPORT;
    case "WIRED":
      return vt.WIRED;
    case "CONTROL":
      return vt.CONTROL;
    case "INTERNAL":
      return vt.INTERNAL;
    default:
      return;
  }
}
function op(n) {
  const r = Ql(n);
  return {
    findAllExistingConnections: s,
    findAllExistingControlledConnections: u
  };
  async function s() {
    const c = await n.table(ut).where({ tagName: "SourceRef" }).toArray();
    if (!c.length) return [];
    const f = [];
    for (const p of c) {
      if (!p.attributes) continue;
      const h = Re(p, "sourceLNodeUuid"), g = await n.table(ut).where({ tagName: "LNode" }).toArray().then(
        (L) => L.find(
          (B) => B.attributes?.some(
            (ee) => ee.name === "uuid" && ee.value === h
          )
        )?.id
      ) || null, R = await r.findParentRecordsWithinDepthAndGivenTagName(
        p,
        3,
        ["LNode"]
      );
      if (R.length != 1) {
        const L = {
          msg: "LNode record not found for SourceRef id",
          id: p.id
        };
        throw console.error(L), new Error(JSON.stringify(L));
      }
      const D = {
        id: p.id,
        sourceLNodeId: g,
        destinationLNodeId: R[0].id,
        sourceDataObject: Re(p, "sourceDoName") || "",
        sourceDataAttribute: Re(p, "sourceDaName") || "",
        dataflowType: Zl(p, "service"),
        inputInstance: Re(p, "inputInst") || "",
        input: Re(p, "input") || "",
        preferredLNode: Re(p, "pLN") || "",
        preferredDataObject: Re(p, "pDO") || "",
        preferredDataAttribute: Re(p, "pDA") || "",
        processResource: Re(p, "resourceName") || ""
      };
      f.push(D);
    }
    return f;
  }
  async function u() {
    const c = await n.table(ut).where({ tagName: "ControlRef" }).toArray();
    if (!c.length) return [];
    const f = [];
    for (const p of c) {
      if (!p.attributes) continue;
      const h = Re(p, "controlledLNodeUuid"), g = Re(p, "controlledDoName"), R = await n.table(ut).where({ tagName: "LNode" }).toArray().then(
        (B) => B.find(
          (ee) => ee.attributes?.some(
            (ie) => ie.name === "uuid" && ie.value === h
          )
        )?.id
      ) || null, D = await r.findParentRecordsWithinDepthAndGivenTagName(
        p,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (D.length != 1) {
        const B = {
          msg: "LNode record not found for ControlRef id",
          id: p.id
        };
        throw console.error(B), new Error(JSON.stringify(B));
      }
      const L = {
        controllerLNodeId: D[0].id,
        controlledLNodeId: R,
        controlledDataObject: g || "",
        dataflowType: vt.CONTROL,
        outputInstance: Re(p, "outputInst") || "",
        outputName: Re(p, "output") || "",
        id: p.id
      };
      f.push(L);
    }
    return f;
  }
}
const cn = /* @__PURE__ */ zl("dataflow/app", () => {
  let n = null;
  const r = rt(""), s = rt([]), u = rt([]), c = rt([]), f = rt([]), p = Vi(), h = Vi(), g = Vi();
  async function R(ee) {
    D(), n = new os(ee), await n.open(), g.value = rp(n), h.value = op(n), r.value = ee, p.value = Hd(n), s.value = await g.value.findAllEnrichedLNodes(), u.value = await g.value.findAllLNodeTypes(), c.value = await h.value.findAllExistingConnections(), f.value = await h.value.findAllExistingControlledConnections();
  }
  function D() {
    n && (n.close(), n = null);
  }
  async function L() {
    c.value = await h.value.findAllExistingConnections(), f.value = await h.value.findAllExistingControlledConnections();
  }
  async function B(ee) {
    const ce = (await g.value.findAllEnrichedLNodes()).find((xe) => xe.id === ee);
    if (ce) {
      const xe = s.value.findIndex((le) => le.id === ee);
      xe !== -1 && (s.value[xe] = ce);
    }
  }
  return {
    // states
    activeFilename: r,
    lnodes: s,
    lnodeTypes: u,
    connections: c,
    controlledConnections: f,
    // getters
    dataflowSdk: p,
    // actions
    initApp: R,
    closeDatabase: D,
    refreshConnections: L,
    refreshLNode: B
  };
}), ip = { key: 0 }, sp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, ap = { key: 1 }, up = { key: 2 }, lp = /* @__PURE__ */ Kt({
  __name: "connection-details",
  props: {
    connection: {}
  },
  setup(n) {
    const r = n, s = cn(), { lnodes: u } = hn(s), c = tt(() => u.value.find((h) => h.id === r.connection.sourceLNodeId)?.dataObjectSpecifications?.find(
      (h) => h.name === r.connection.sourceDataObject
    )), f = tt(() => c?.value?.dataAttributeSpecifications?.find(
      (p) => p.name === r.connection.sourceDataAttribute
    ));
    return (p, h) => (fe(), ve("div", null, [
      (fe(), ve("div", ip, [
        h[0] || (h[0] = j("h2", { class: "text-lg font-bold mb-2" }, "Connection Details", -1)),
        p.connection.dataflowType ? (fe(), ve("span", sp, Ee(p.connection.dataflowType), 1)) : lt("", !0),
        j("p", null, "Input: " + Ee(p.connection.input), 1),
        j("p", null, "Input Instance: " + Ee(p.connection.inputInstance || "-"), 1),
        h[1] || (h[1] = j("br", null, null, -1)),
        j("p", null, "Data Object: " + Ee(p.connection.sourceDataObject || "-"), 1),
        c.value?.desc ? (fe(), ve("p", ap, "Data Object Desc: " + Ee(c.value?.desc), 1)) : lt("", !0),
        j("p", null, "Data Attribute: " + Ee(p.connection.sourceDataAttribute || "-"), 1),
        f.value?.desc ? (fe(), ve("p", up, "Data Attribute Desc: " + Ee(f.value?.desc), 1)) : lt("", !0),
        h[2] || (h[2] = j("br", null, null, -1)),
        j("p", null, "Preferred LNode: " + Ee(p.connection.preferredLNode || "-"), 1),
        j("p", null, "Preferred Data Object: " + Ee(p.connection.preferredDataObject || "-"), 1),
        j("p", null, "Preferred Data Attribute: " + Ee(p.connection.preferredDataAttribute || "-"), 1),
        j("p", null, "Process Resource: " + Ee(p.connection.processResource || "-"), 1)
      ]))
    ]));
  }
}), cp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, fp = ["onClick"], dp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, pp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, hp = ["onClick"], mp = ["onClick", "data-testid"], yp = ["onClick"], vp = ["onClick"], gp = ["onClick"], bp = ["onClick"], wp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, _p = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, xp = /* @__PURE__ */ Kt({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(n) {
    const r = n, s = vs(), { activeElement: u } = hn(s), c = tt(() => [...r.connections].sort((f, p) => f.dataflowType < p.dataflowType ? -1 : f.dataflowType > p.dataflowType ? 1 : 0));
    return (f, p) => (fe(!0), ve(Xe, null, Ct(c.value, (h, g) => (fe(), ve("div", cp, [
      j("div", {
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer",
        onClick: (R) => De(s).setOrResetActiveElement(h.id)
      }, [
        j("span", dp, Ee(h.sourceDataObject), 1),
        j("span", pp, Ee(h.sourceDataAttribute), 1)
      ], 8, fp),
      j("div", {
        onClick: (R) => De(s).setOrResetActiveElement(h.id),
        class: On(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": De(u) === h.id,
          "bg-(--color-ocean-gray-100)": De(u) !== h.id
        }])
      }, null, 10, hp),
      j("div", {
        onClick: (R) => De(s).setOrResetActiveElement(h.id),
        class: On(["col-start-3 col-span-1 h-[2px] self-center row-start-1 hover:cursor-pointer", {
          "bg-(--color-primary)": De(u) === h.id,
          "bg-(--color-ocean-gray-100)": De(u) !== h.id
        }]),
        "data-testid": `dataflow-line-${g}`
      }, null, 10, mp),
      (fe(), ve("svg", {
        onClick: (R) => De(s).setOrResetActiveElement(h.id),
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        j("polygon", {
          points: "0,0 8,6 0,12",
          style: ji({
            fill: De(u) === h.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ], 8, yp)),
      j("div", {
        onClick: (R) => De(s).setOrResetActiveElement(h.id),
        class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
      }, Ee(h.dataflowType), 9, vp),
      j("div", {
        onClick: (R) => De(s).setOrResetActiveElement(h.id),
        class: On(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": De(u) === h.id,
          "bg-(--color-ocean-gray-100)": De(u) !== h.id
        }])
      }, null, 10, gp),
      j("div", {
        onClick: (R) => De(s).setOrResetActiveElement(h.id),
        class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
      }, [
        j("span", wp, Ee(h.input), 1),
        j("span", _p, Ee(h.inputInstance), 1)
      ], 8, bp),
      De(u) == h.id ? (fe(), pn(fs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        St(lp, { connection: h }, null, 8, ["connection"])
      ])) : lt("", !0)
    ]))), 256));
  }
}), Op = { key: 0 }, Tp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, Ep = { key: 1 }, Np = { key: 2 }, Cp = /* @__PURE__ */ Kt({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(n) {
    const r = n, s = cn(), { lnodeTypes: u } = hn(s), c = tt(() => u.value.find((h) => h.lnClass === r.placeholder.preferredLNode)?.dataObjects.find(
      (h) => h.name === r.placeholder.preferredDataObject
    )), f = tt(() => c?.value?.dataAttributes?.find(
      (p) => p.name === r.placeholder.preferredDataAttribute
    ));
    return (p, h) => (fe(), ve("div", null, [
      (fe(), ve("div", Op, [
        h[0] || (h[0] = j("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
        p.placeholder.dataflowType ? (fe(), ve("span", Tp, Ee(p.placeholder.dataflowType), 1)) : lt("", !0),
        j("p", null, "Input: " + Ee(p.placeholder.input), 1),
        j("p", null, "Input Instance: " + Ee(p.placeholder.inputInstance || "-"), 1),
        h[1] || (h[1] = j("br", null, null, -1)),
        j("p", null, "Preferred LNode: " + Ee(p.placeholder.preferredLNode || "-"), 1),
        j("p", null, "Preferred DO: " + Ee(p.placeholder.preferredDataObject || "-"), 1),
        c.value?.desc ? (fe(), ve("p", Ep, "Preferred DO Desc: " + Ee(c.value?.desc), 1)) : lt("", !0),
        j("p", null, "Preferred DA: " + Ee(p.placeholder.preferredDataAttribute || "-"), 1),
        f.value?.desc ? (fe(), ve("p", Np, "Preferred DA Desc: " + Ee(f.value?.desc), 1)) : lt("", !0),
        j("p", null, "Process Resource: " + Ee(p.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Sp = ["y1", "x2", "y2"], Ap = ["points"], Pp = /* @__PURE__ */ Kt({
  __name: "arrow",
  props: {
    height: {},
    length: {}
  },
  setup(n) {
    return (r, s) => (fe(), ve(Xe, null, [
      j("line", {
        x1: 0,
        y1: r.height / 2,
        x2: r.length - r.height / 2,
        y2: r.height / 2,
        stroke: "currentColor",
        "stroke-width": "2"
      }, null, 8, Sp),
      j("polygon", {
        points: `${r.length - r.height * 0.7}, 0 ${r.length}, ${r.height / 2} ${r.length - r.height * 0.7}, ${r.height}`,
        fill: "currentColor"
      }, null, 8, Ap)
    ], 64));
  }
}), Dp = ["onClick"], Rp = ["data-testid"], Ip = ["onClick"], kp = { class: "col-start-5 col-span-1 self-center justify-self-start" }, jp = ["onClick"], Lp = ["onClick"], Kp = /* @__PURE__ */ Kt({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(n) {
    const r = vs(), { activeElement: s } = hn(r);
    return (u, c) => (fe(!0), ve(Xe, null, Ct(u.destinationPlaceHolderPorts, (f, p) => (fe(), ve("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
      key: `destination-placeholder-port-${p}`
    }, [
      (fe(), ve("svg", {
        height: "12",
        width: "35",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 text-(--color-ocean-gray-100) hover:cursor-pointer",
        onClick: (h) => De(r).setOrResetActiveElement(f.id)
      }, [
        j("g", {
          "data-testid": `placeholder-line-${p}`,
          class: On({
            "text-(--color-primary)": De(s) === f.id
          })
        }, [
          St(Pp, {
            height: 12,
            length: 35
          })
        ], 10, Rp)
      ], 8, Dp)),
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: On(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": De(s) === f.id
        }])
      }, null, 10, Ip),
      j("div", kp, [
        j("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
          onClick: (h) => De(r).setOrResetActiveElement(f.id)
        }, Ee(f.input), 9, jp),
        j("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm hover:cursor-pointer",
          onClick: (h) => De(r).setOrResetActiveElement(f.id)
        }, Ee(f.inputInstance), 9, Lp)
      ]),
      De(s) == f.id ? (fe(), pn(fs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        St(Cp, { placeholder: f }, null, 8, ["placeholder"])
      ])) : lt("", !0)
    ]))), 128));
  }
}), Fp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Mp = { class: "modal-box" }, Bp = { class: "grid grid-cols-2 gap-4 mt-4" }, $p = { class: "flex items-center" }, qp = { class: "flex items-center" }, Up = ["value"], Vp = { class: "grid grid-cols-2 gap-4 mt-4" }, Hp = { class: "grid grid-cols-2 gap-4 mt-4" }, Wp = ["value", "disabled"], Gp = { class: "grid grid-cols-2 gap-4 mt-4" }, Yp = ["value"], Xp = { class: "grid grid-cols-2 gap-4 mt-4" }, zp = ["value", "title"], Qp = { class: "grid grid-cols-2 gap-4 mt-4" }, Jp = ["value", "title"], Zp = { class: "grid grid-cols-2 gap-4 mt-4" }, eh = { class: "mt-4 flex items-center" }, th = /* @__PURE__ */ Kt({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {}
  },
  setup(n) {
    const r = n, s = cn(), { connections: u, lnodeTypes: c, dataflowSdk: f } = hn(s), p = rt(
      ce()
    ), h = rt(!0), g = rt(!1), R = rt([]), D = bl("dialog");
    Ht(
      [() => r.destinationLNode, u],
      async ([q, M]) => {
        R.value = await f.value.findExistingInputs(q);
      },
      { immediate: !0 }
    ), Ht(g, () => {
      p.value.inputName = "";
    }), Ht(
      [
        () => p.value.inputName,
        () => p.value.preferredDataAttribute
      ],
      async ([q, M]) => {
        if (!q) {
          p.value.inputInstance = "";
          return;
        }
        const ne = await f.value.calculateNextInputInstance(
          q,
          M,
          r.destinationLNode
        );
        p.value.inputInstance = ne.toString();
      }
    );
    const L = tt(
      () => Object.values(vt).filter((q) => q !== vt.INTERNAL)
    ), B = tt(
      () => [...c.value].sort((q, M) => q.lnClass.localeCompare(M.lnClass))
    ), ee = tt(() => {
      const q = c.value.find(
        (M) => M.lnClass === p.value.preferredLNode
      );
      return q ? p.value.dataflowType ? q.dataObjects.filter(
        (M) => M.dataAttributes.some(
          (ne) => Ro[p.value.dataflowType].includes(ne.fc)
        )
      ).map((M) => ({
        name: M.name,
        desc: M.desc
      })).sort((M, ne) => M.name.localeCompare(ne.name)) : q.dataObjects.map((M) => ({
        name: M.name,
        desc: M.desc
      })).sort((M, ne) => M.name.localeCompare(ne.name)) : [];
    }), ie = tt(() => {
      const q = c.value.find(
        (ne) => ne.lnClass === p.value.preferredLNode
      );
      if (!q) return [];
      const M = q.dataObjects.find(
        (ne) => ne.name === p.value.preferredDataObject
      );
      return M ? p.value.dataflowType ? M.dataAttributes.filter(
        (ne) => Ro[p.value.dataflowType].includes(ne.fc)
      ).filter((ne) => !Pi.includes(ne.name)).sort((ne, we) => ne.name.localeCompare(we.name)) : M.dataAttributes.filter((ne) => !Pi.includes(ne.name)).sort((ne, we) => ne.name.localeCompare(we.name)) : [];
    });
    function ce() {
      return {
        dataflowType: null,
        inputName: "",
        inputInstance: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    async function xe() {
      try {
        await f.value.createDestinationPlaceholder(
          p.value,
          r.destinationLNode,
          h.value
        ), le();
      } catch (q) {
        console.error("Error creating destination placeholder port:", q), alert(`Error creating placeholder: ${q instanceof Error ? q.message : "Unknown error"}`);
      }
    }
    function le() {
      p.value = ce(), g.value = !1, h.value = !0;
    }
    function U(q) {
      for (const M of q)
        p.value[M] = "";
    }
    function Y(q) {
      q?.showModal(), le();
    }
    return (q, M) => (fe(), ve("div", Fp, [
      j("button", {
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center",
        onClick: M[0] || (M[0] = (ne) => Y(D.value)),
        "aria-label": "Add destination placeholder"
      }, M[15] || (M[15] = [
        j("svg", {
          width: "16px",
          height: "16px",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          j("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          j("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      j("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: D
      }, [
        j("div", Mp, [
          M[31] || (M[31] = j("h3", { class: "text-lg font-bold" }, "Create Placeholder - Receive data from", -1)),
          M[32] || (M[32] = j("form", { method: "dialog" }, [
            j("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close destination placeholder creation"
            }, [
              j("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                j("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          j("form", {
            method: "dialog",
            onSubmit: xe
          }, [
            j("div", Bp, [
              j("fieldset", null, [
                M[18] || (M[18] = j("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
                j("div", $p, [
                  He(j("input", {
                    type: "radio",
                    id: "destination-placeholder-new-input",
                    name: "input",
                    "onUpdate:modelValue": M[1] || (M[1] = (ne) => g.value = ne),
                    value: !1,
                    class: "radio radio-sm mr-2"
                  }, null, 512), [
                    [jr, g.value]
                  ]),
                  M[16] || (M[16] = j("label", { for: "destination-placeholder-new-input" }, "New Input", -1))
                ]),
                j("div", qp, [
                  He(j("input", {
                    type: "radio",
                    id: "destination-placeholder-existing-input",
                    name: "input",
                    "onUpdate:modelValue": M[2] || (M[2] = (ne) => g.value = ne),
                    value: !0,
                    class: "radio radio-sm mr-2"
                  }, null, 512), [
                    [jr, g.value]
                  ]),
                  M[17] || (M[17] = j("label", { for: "destination-placeholder-existing-input" }, "Existing Input", -1))
                ])
              ]),
              g.value ? lt("", !0) : He((fe(), ve("input", {
                key: 0,
                "aria-label": "New Input Name",
                required: "",
                type: "text",
                placeholder: "Input Name",
                class: "input col-start-2",
                "onUpdate:modelValue": M[3] || (M[3] = (ne) => p.value.inputName = ne)
              }, null, 512)), [
                [Or, p.value.inputName]
              ]),
              g.value ? He((fe(), ve("select", {
                key: 1,
                "aria-label": "Existing Input Name Select",
                required: "",
                class: "select col-start-2",
                "onUpdate:modelValue": M[4] || (M[4] = (ne) => p.value.inputName = ne)
              }, [
                (fe(!0), ve(Xe, null, Ct(R.value, (ne) => (fe(), ve("option", {
                  key: ne,
                  value: ne
                }, Ee(ne), 9, Up))), 128))
              ], 512)), [
                [ln, p.value.inputName]
              ]) : lt("", !0)
            ]),
            j("div", Vp, [
              M[19] || (M[19] = j("label", {
                for: "input-instance-input",
                class: "col-start-1 self-center"
              }, "Input Instance", -1)),
              He(j("input", {
                id: "input-instance-input",
                required: "",
                disabled: "",
                type: "text",
                class: "input col-start-2",
                "onUpdate:modelValue": M[5] || (M[5] = (ne) => p.value.inputInstance = ne)
              }, null, 512), [
                [Or, p.value.inputInstance]
              ])
            ]),
            j("div", Hp, [
              M[21] || (M[21] = j("label", {
                for: "dataflow-type-select",
                class: "col-start-1 self-center"
              }, "Dataflow Type", -1)),
              He(j("select", {
                id: "dataflow-type-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[6] || (M[6] = (ne) => p.value.dataflowType = ne),
                onChange: M[7] || (M[7] = (ne) => U(["preferredDataObject"]))
              }, [
                M[20] || (M[20] = j("option", {
                  key: "empty",
                  value: null
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(L.value, (ne) => (fe(), ve("option", {
                  key: ne,
                  value: ne,
                  disabled: ne === De(vt).CONTROL
                }, Ee(ne), 9, Wp))), 128))
              ], 544), [
                [ln, p.value.dataflowType]
              ])
            ]),
            j("div", Gp, [
              M[23] || (M[23] = j("label", {
                for: "preferred-lnode-select",
                class: "col-start-1 self-center"
              }, "Preferred LNode", -1)),
              He(j("select", {
                id: "preferred-lnode-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[8] || (M[8] = (ne) => p.value.preferredLNode = ne),
                onChange: M[9] || (M[9] = (ne) => U(["preferredDataObject"]))
              }, [
                M[22] || (M[22] = j("option", {
                  key: "empty",
                  value: ""
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(B.value, (ne) => (fe(), ve("option", {
                  key: ne.id,
                  value: ne.lnClass
                }, Ee(ne.lnClass), 9, Yp))), 128))
              ], 544), [
                [ln, p.value.preferredLNode]
              ])
            ]),
            j("div", Xp, [
              M[25] || (M[25] = j("label", {
                for: "data-object-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Object", -1)),
              He(j("select", {
                id: "data-object-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[10] || (M[10] = (ne) => p.value.preferredDataObject = ne),
                onChange: M[11] || (M[11] = (ne) => U(["preferredDataAttribute"]))
              }, [
                M[24] || (M[24] = j("option", {
                  key: "empty",
                  value: ""
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(ee.value, (ne) => (fe(), ve("option", {
                  key: ne.name,
                  value: ne.name,
                  title: ne.desc ? `Desc: ${ne.desc}` : ""
                }, Ee(ne.desc ? ne.name + " ⓘ" : ne.name), 9, zp))), 128))
              ], 544), [
                [ln, p.value.preferredDataObject]
              ])
            ]),
            j("div", Qp, [
              M[27] || (M[27] = j("label", {
                for: "data-attribute-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Attribute", -1)),
              He(j("select", {
                id: "data-attribute-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[12] || (M[12] = (ne) => p.value.preferredDataAttribute = ne)
              }, [
                M[26] || (M[26] = j("option", {
                  key: "empty",
                  value: ""
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(ie.value, (ne) => (fe(), ve("option", {
                  key: ne.name,
                  value: ne.name,
                  title: ne.desc ? `Desc: ${ne.desc}` : ""
                }, Ee(ne.desc ? ne.name + " ⓘ" : ne.name), 9, Jp))), 128))
              ], 512), [
                [ln, p.value.preferredDataAttribute]
              ])
            ]),
            j("div", Zp, [
              M[28] || (M[28] = j("label", {
                for: "process-resource-input",
                class: "col-start-1 self-center"
              }, "Process Resource", -1)),
              He(j("input", {
                id: "process-resource-input",
                type: "text",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": M[13] || (M[13] = (ne) => p.value.processResource = ne)
              }, null, 512), [
                [Or, p.value.processResource]
              ])
            ]),
            j("div", eh, [
              He(j("input", {
                type: "checkbox",
                "onUpdate:modelValue": M[14] || (M[14] = (ne) => h.value = ne),
                class: "checkbox mr-2",
                id: "destination-placeholder-checkbox-add-references"
              }, null, 512), [
                [Ao, h.value]
              ]),
              M[29] || (M[29] = j("label", { for: "destination-placeholder-checkbox-add-references" }, "Add References to Application", -1))
            ]),
            M[30] || (M[30] = j("div", { class: "modal-action" }, [
              j("button", {
                class: "btn bg-(--color-primary) border-none text-white",
                type: "submit"
              }, " Save ")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), nh = { key: 0 }, rh = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, oh = { key: 1 }, ih = { key: 2 }, sh = /* @__PURE__ */ Kt({
  __name: "source-placeholder-details",
  props: {
    placeholder: {},
    sourceLNodeId: {}
  },
  setup(n) {
    const r = n, s = cn(), { lnodes: u } = hn(s), c = tt(() => u.value.find((h) => h.id === r.sourceLNodeId)?.dataObjectSpecifications?.find(
      (h) => h.name === r.placeholder.dataObject
    )), f = tt(() => c?.value?.dataAttributeSpecifications?.find(
      (p) => p.name === r.placeholder.dataAttribute
    ));
    return (p, h) => (fe(), ve("div", null, [
      (fe(), ve("div", nh, [
        h[0] || (h[0] = j("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder Details", -1)),
        p.placeholder.dataflowType ? (fe(), ve("span", rh, Ee(p.placeholder.dataflowType), 1)) : lt("", !0),
        j("p", null, "Input: " + Ee(p.placeholder.input), 1),
        h[1] || (h[1] = j("br", null, null, -1)),
        j("p", null, "Data Object: " + Ee(p.placeholder.dataObject || "-"), 1),
        c.value?.desc ? (fe(), ve("p", oh, "Data Object Desc: " + Ee(c.value?.desc), 1)) : lt("", !0),
        j("p", null, "Data Attribute: " + Ee(p.placeholder.dataAttribute || "-"), 1),
        f.value?.desc ? (fe(), ve("p", ih, "Data Attribute Desc: " + Ee(f.value?.desc), 1)) : lt("", !0),
        h[2] || (h[2] = j("br", null, null, -1)),
        j("p", null, "Preferred LNode: " + Ee(p.placeholder.preferredLNode || "-"), 1),
        j("p", null, "Process Resource: " + Ee(p.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), ah = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12 *:pointer-events-auto" }, uh = ["onClick"], lh = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, ch = ["onClick"], fh = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, dh = ["onClick"], ph = {
  height: "12",
  width: "24"
}, hh = { class: "ml-2" }, mh = /* @__PURE__ */ Kt({
  __name: "source-placeholder-ports",
  props: {
    sourceLNodeId: {},
    dataObjectSpecifications: {}
  },
  setup(n) {
    const r = n, s = tt(
      () => r.dataObjectSpecifications.flatMap(
        (f) => f.dataAttributeSpecifications.flatMap(
          (p) => p.subscriberLNodes?.map(
            (h) => ({
              id: h.id,
              dataObject: f.name,
              dataAttribute: p.name,
              dataflowType: h.service,
              preferredLNode: h.pLN,
              input: h.inputName,
              processResource: h.resourceName
            })
          ) ?? []
        )
      )
    ), u = vs(), { activeElement: c } = hn(u);
    return (f, p) => (fe(!0), ve(Xe, null, Ct(s.value, (h) => (fe(), ve("div", ah, [
      j("div", {
        onClick: (g) => De(u).setOrResetActiveElement(h.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        j("span", lh, Ee(h.dataObject) + "." + Ee(h.dataAttribute), 1)
      ], 8, uh),
      j("div", {
        onClick: (g) => De(u).setOrResetActiveElement(h.id),
        class: On([{
          "bg-(--color-primary)": De(c) === h.id
        }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
      }, null, 10, ch),
      j("div", fh, [
        j("div", {
          class: "inline-flex items-center h-full max-w-max hover:cursor-pointer",
          onClick: (g) => De(u).setOrResetActiveElement(h.id)
        }, [
          (fe(), ve("svg", ph, [
            j("line", {
              x1: "0",
              y1: "6",
              x2: "24",
              y2: "6",
              stroke: "currentColor",
              "stroke-width": "2",
              class: On({
                "text-(--color-primary)": De(c) === h.id,
                "text-(--color-ocean-gray-100)": De(c) !== h.id
              })
            }, null, 2)
          ])),
          j("span", hh, Ee(h.input), 1)
        ], 8, dh)
      ]),
      De(c) == h.id ? (fe(), pn(fs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        St(sh, {
          placeholder: h,
          sourceLNodeId: r.sourceLNodeId
        }, null, 8, ["placeholder", "sourceLNodeId"])
      ])) : lt("", !0)
    ]))), 256));
  }
}), yh = { key: 0 }, vh = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, gh = { key: 1 }, bh = /* @__PURE__ */ Kt({
  __name: "controlled-connection-details",
  props: {
    controlledConnection: {}
  },
  setup(n) {
    const r = n, s = cn(), { lnodes: u } = hn(s), c = tt(() => u.value.find(
      (p) => p.id === r.controlledConnection.controlledLNodeId
    )?.dataObjectSpecifications?.find(
      (p) => p.name === r.controlledConnection.controlledDataObject
    ));
    return (f, p) => (fe(), ve("div", null, [
      (fe(), ve("div", yh, [
        p[0] || (p[0] = j("h2", { class: "text-lg font-bold mb-2" }, "Controlled Connection Details", -1)),
        f.controlledConnection.dataflowType ? (fe(), ve("span", vh, Ee(f.controlledConnection.dataflowType), 1)) : lt("", !0),
        j("p", null, "Output: " + Ee(f.controlledConnection.outputName), 1),
        j("p", null, "Output Instance: " + Ee(f.controlledConnection.outputInstance || "-"), 1),
        p[1] || (p[1] = j("br", null, null, -1)),
        j("p", null, "Controlled Data Object: " + Ee(f.controlledConnection.controlledDataObject || "-"), 1),
        c.value?.desc ? (fe(), ve("p", gh, "Controlled Data Object Desc: " + Ee(c.value?.desc), 1)) : lt("", !0)
      ]))
    ]));
  }
}), wh = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, _h = ["onClick"], xh = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Oh = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Th = ["onClick"], Eh = ["onClick", "data-testid"], Nh = ["onClick"], Ch = ["onClick"], Sh = ["onClick"], Ah = ["onClick"], Ph = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Dh = /* @__PURE__ */ Kt({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(n) {
    const r = vs(), { activeElement: s } = hn(r);
    return (u, c) => (fe(!0), ve(Xe, null, Ct(u.controlledConnections, (f, p) => (fe(), ve("div", wh, [
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        j("span", xh, Ee(f.outputName), 1),
        j("span", Oh, Ee(f.outputInstance), 1)
      ], 8, _h),
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: On(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": De(s) === f.id,
          "bg-(--color-ocean-gray-100)": De(s) !== f.id
        }])
      }, null, 10, Th),
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: On(["col-start-3 col-span-1 h-[2px] self-center row-start-1 hover:cursor-pointer", {
          "bg-(--color-primary)": De(s) === f.id,
          "bg-(--color-ocean-gray-100)": De(s) !== f.id
        }]),
        "data-testid": `dataflow-controlled-connection-line-${p}`
      }, null, 10, Eh),
      (fe(), ve("svg", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        j("polygon", {
          points: "0,0 8,6 0,12",
          style: ji({
            fill: De(s) === f.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ], 8, Nh)),
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
      }, Ee(f.dataflowType), 9, Ch),
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: On(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": De(s) === f.id,
          "bg-(--color-ocean-gray-100)": De(s) !== f.id
        }])
      }, null, 10, Sh),
      j("div", {
        onClick: (h) => De(r).setOrResetActiveElement(f.id),
        class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
      }, [
        j("span", Ph, Ee(f.controlledDataObject), 1)
      ], 8, Ah),
      De(s) == f.id ? (fe(), pn(fs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        St(bh, { "controlled-connection": f }, null, 8, ["controlled-connection"])
      ])) : lt("", !0)
    ]))), 256));
  }
}), Rh = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Ih = { class: "modal-box" }, kh = { class: "grid grid-cols-2 gap-4 items-center" }, jh = { class: "grid grid-cols-2 gap-4 items-center" }, Lh = ["value", "disabled"], Kh = { class: "grid grid-cols-2 gap-4 items-center" }, Fh = ["value", "title"], Mh = { class: "grid grid-cols-2 gap-4 items-center" }, Bh = ["value", "title"], $h = { class: "grid grid-cols-2 gap-4 items-center" }, qh = { class: "grid grid-cols-2 gap-4 items-center" }, Uh = ["value"], Vh = { class: "flex items-center" }, Hh = /* @__PURE__ */ Kt({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {}
  },
  setup(n) {
    const r = n, s = cn(), { lnodeTypes: u, dataflowSdk: c } = hn(s), f = rt(
      ie()
    ), p = rt(!0);
    async function h(le) {
      try {
        await c.value.createSourcePlaceholder(
          r.sourceLNode,
          f.value,
          p.value
        ), xe();
      } catch (U) {
        console.error("Error creating source placeholder port:", U), alert(`Error creating placeholder: ${U instanceof Error ? U.message : "Unknown error"}`);
      }
    }
    const g = tt(
      () => [...u.value].sort((le, U) => le.lnClass.localeCompare(U.lnClass))
    ), R = tt(
      () => Object.values(vt).filter((le) => le !== vt.INTERNAL)
    ), D = tt(() => {
      const le = u.value.find((U) => U.typeId === r.sourceLNode.lnType);
      return le ? f.value.dataflowType ? le.dataObjects.filter(
        (U) => U.dataAttributes.some(
          (Y) => Ro[f.value.dataflowType].includes(
            Y.fc
          )
        )
      ).sort((U, Y) => U.name.localeCompare(Y.name)) : le.dataObjects.sort((U, Y) => U.name.localeCompare(Y.name)) : [];
    }), L = tt(() => {
      const le = u.value.find((U) => U.typeId === r.sourceLNode.lnType)?.dataObjects.find((U) => U.name === f.value.dataObject);
      return le ? f.value.dataflowType ? le.dataAttributes.filter(
        (U) => Ro[f.value.dataflowType].includes(
          U.fc
        )
      ).filter((U) => !Pi.includes(U.name)).sort((U, Y) => U.name.localeCompare(Y.name)) : le.dataAttributes.filter((U) => !Pi.includes(U.name)).sort((U, Y) => U.name.localeCompare(Y.name)) : [];
    }), B = bl("dialog");
    function ee(le) {
      le?.showModal(), xe();
    }
    function ie() {
      return {
        dataObject: "",
        dataAttribute: "",
        inputName: "",
        dataflowType: "",
        processResource: "",
        preferredLNode: ""
      };
    }
    function ce(le) {
      for (const U of le)
        f.value[U] = "";
    }
    function xe() {
      f.value = ie(), p.value = !0;
    }
    return (le, U) => (fe(), ve("div", Rh, [
      j("button", {
        onClick: U[0] || (U[0] = (Y) => ee(B.value)),
        "aria-label": "Add source placeholder",
        class: "btn btn-primary btn-circle size-5 col-start-3 col-span-1 -ml-[12px] self-center relative z-10"
      }, U[10] || (U[10] = [
        j("svg", {
          width: "16",
          height: "16",
          viewBox: "0 0 20 20",
          fill: "currentColor"
        }, [
          j("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          j("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      j("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: B
      }, [
        j("div", Ih, [
          U[23] || (U[23] = j("h3", { class: "text-lg font-bold" }, "Create Placeholder - Provide data", -1)),
          U[24] || (U[24] = j("form", { method: "dialog" }, [
            j("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close source placeholder creation"
            }, [
              j("svg", {
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                j("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          j("form", {
            onSubmit: h,
            method: "dialog",
            class: "flex flex-col gap-4 mt-4"
          }, [
            j("div", kh, [
              U[11] || (U[11] = j("label", { for: "input-name" }, "Input Name", -1)),
              He(j("input", {
                required: "",
                id: "input-name",
                name: "inputName",
                "onUpdate:modelValue": U[1] || (U[1] = (Y) => f.value.inputName = Y),
                placeholder: "Input Name",
                class: "input col-start-2"
              }, null, 512), [
                [Or, f.value.inputName]
              ])
            ]),
            j("div", jh, [
              U[13] || (U[13] = j("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
              He(j("select", {
                id: "dataflow-type-select",
                name: "dataflowType",
                class: "select col-start-2",
                "onUpdate:modelValue": U[2] || (U[2] = (Y) => f.value.dataflowType = Y),
                onChange: U[3] || (U[3] = (Y) => ce(["dataObject", "dataAttribute"]))
              }, [
                U[12] || (U[12] = j("option", { value: "" }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(R.value, (Y) => (fe(), ve("option", {
                  key: Y,
                  value: Y,
                  disabled: Y === De(vt).CONTROL
                }, Ee(Y), 9, Lh))), 128))
              ], 544), [
                [ln, f.value.dataflowType]
              ])
            ]),
            j("div", Kh, [
              U[15] || (U[15] = j("label", { for: "data-object-select" }, "Data Object", -1)),
              He(j("select", {
                required: "",
                id: "data-object-select",
                name: "data object",
                class: "select col-start-2",
                "onUpdate:modelValue": U[4] || (U[4] = (Y) => f.value.dataObject = Y),
                onChange: U[5] || (U[5] = (Y) => ce(["dataAttribute"]))
              }, [
                U[14] || (U[14] = j("option", {
                  key: "empty",
                  value: "",
                  disabled: ""
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(D.value, (Y) => (fe(), ve("option", {
                  key: Y.id,
                  value: Y.name,
                  title: Y.desc ? `Desc: ${Y.desc}` : ""
                }, Ee(Y.desc ? Y.name + " ⓘ" : Y.name), 9, Fh))), 128))
              ], 544), [
                [ln, f.value.dataObject]
              ])
            ]),
            j("div", Mh, [
              U[17] || (U[17] = j("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
              He(j("select", {
                required: "",
                id: "data-attribute-select",
                name: "data attribute",
                "onUpdate:modelValue": U[6] || (U[6] = (Y) => f.value.dataAttribute = Y),
                class: "select col-start-2"
              }, [
                U[16] || (U[16] = j("option", {
                  key: "empty",
                  value: "",
                  disabled: ""
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(L.value, (Y) => (fe(), ve("option", {
                  key: Y.id,
                  value: Y.name,
                  title: Y.desc ? `Desc: ${Y.desc}` : ""
                }, Ee(Y.desc ? Y.name + " ⓘ" : Y.name), 9, Bh))), 128))
              ], 512), [
                [ln, f.value.dataAttribute]
              ])
            ]),
            j("div", $h, [
              U[18] || (U[18] = j("label", { for: "process-resource-input" }, "Process Resource", -1)),
              He(j("input", {
                id: "process-resource-input",
                name: "processResource",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": U[7] || (U[7] = (Y) => f.value.processResource = Y)
              }, null, 512), [
                [Or, f.value.processResource]
              ])
            ]),
            j("div", qh, [
              U[20] || (U[20] = j("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
              He(j("select", {
                id: "preferred-lnode-select",
                name: "preferredLNode",
                class: "select col-start-2",
                "onUpdate:modelValue": U[8] || (U[8] = (Y) => f.value.preferredLNode = Y)
              }, [
                U[19] || (U[19] = j("option", {
                  key: "empty",
                  value: ""
                }, "-", -1)),
                (fe(!0), ve(Xe, null, Ct(g.value, (Y) => (fe(), ve("option", {
                  key: Y.lnClass,
                  value: Y.lnClass
                }, Ee(Y.lnClass), 9, Uh))), 128))
              ], 512), [
                [ln, f.value.preferredLNode]
              ])
            ]),
            j("div", Vh, [
              He(j("input", {
                type: "checkbox",
                "onUpdate:modelValue": U[9] || (U[9] = (Y) => p.value = Y),
                class: "checkbox mr-2",
                id: "source-placeholder-checkbox-add-references"
              }, null, 512), [
                [Ao, p.value]
              ]),
              U[21] || (U[21] = j("label", { for: "source-placeholder-checkbox-add-references" }, "Add References to Application", -1))
            ]),
            U[22] || (U[22] = j("div", { class: "modal-action" }, [
              j("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), Wh = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, Gh = ["value"], Yh = ["value"], Xh = ["value"], zh = ["value"], Qh = { class: "col-span-full row-start-2" }, Jh = { class: "grid" }, Zh = { class: "col-start-1 row-start-1 pointer-events-none" }, em = { class: "col-start-1 row-start-1 -order-1" }, tm = /* @__PURE__ */ Kt({
  __name: "dataflow-visualisation",
  emits: ["sourceLNodeChange", "destinationLNodeChange"],
  setup(n, { emit: r }) {
    const s = r, u = cn(), { lnodes: c, connections: f, controlledConnections: p } = hn(u), h = rt(), g = rt(), R = rt(), D = rt();
    Ht(
      () => c.value,
      () => {
        h.value = void 0, g.value = void 0;
      }
    );
    const L = tt(
      () => c.value.filter((q) => q.id !== g.value).sort((q, M) => Vn(q).localeCompare(Vn(M)))
    ), B = tt(() => c.value.find((M) => M.id === h.value)?.dataObjectSpecifications ?? []), ee = tt(
      () => c.value.filter((q) => q.id !== h.value).sort((q, M) => Vn(q).localeCompare(Vn(M)))
    ), ie = tt(() => !h.value || !g.value ? [] : f.value.filter(
      (q) => q.sourceLNodeId === h.value && q.destinationLNodeId === g.value
    )), ce = tt(() => !h.value || !g.value ? [] : p.value.filter(
      (q) => q.controllerLNodeId === h.value && q.controlledLNodeId === g.value
    )), xe = tt(() => g.value ? f.value.filter(
      (q) => q.destinationLNodeId === g.value && !q.sourceLNodeId
    ) : []);
    function le(q) {
      return c.value.find((M) => M.id === q) ?? void 0;
    }
    function U(q) {
      h.value = q, R.value = le(q), s("sourceLNodeChange", q);
    }
    function Y(q) {
      g.value = q, D.value = le(q), s("destinationLNodeChange", q);
    }
    return (q, M) => (fe(), ve("div", Wh, [
      M[5] || (M[5] = j("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      j("select", {
        value: h.value ?? "",
        onChange: M[0] || (M[0] = (ne) => U(ne.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        M[2] || (M[2] = $l(" > ")),
        M[3] || (M[3] = j("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (fe(!0), ve(Xe, null, Ct(L.value, (ne) => (fe(), ve("option", {
          key: ne.id,
          value: ne.id
        }, Ee(De(Vn)(ne)), 9, Yh))), 128))
      ], 40, Gh),
      M[6] || (M[6] = j("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      j("select", {
        value: g.value ?? "",
        onChange: M[1] || (M[1] = (ne) => Y(ne.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        M[4] || (M[4] = j("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (fe(!0), ve(Xe, null, Ct(ee.value, (ne) => (fe(), ve("option", {
          key: ne.id,
          value: ne.id
        }, Ee(De(Vn)(ne)), 9, zh))), 128))
      ], 40, Xh),
      j("div", Qh, [
        ie.value.length > 0 ? (fe(), pn(xp, {
          key: 0,
          connections: ie.value
        }, null, 8, ["connections"])) : lt("", !0),
        ce.value.length > 0 ? (fe(), pn(Dh, {
          key: 1,
          controlledConnections: ce.value
        }, null, 8, ["controlledConnections"])) : lt("", !0),
        j("div", Jh, [
          j("div", Zh, [
            h.value ? (fe(), pn(mh, {
              key: 0,
              dataObjectSpecifications: B.value,
              sourceLNodeId: h.value
            }, null, 8, ["dataObjectSpecifications", "sourceLNodeId"])) : lt("", !0)
          ]),
          j("div", em, [
            St(Kp, { destinationPlaceHolderPorts: xe.value }, null, 8, ["destinationPlaceHolderPorts"])
          ])
        ])
      ]),
      R.value ? (fe(), pn(Hh, {
        key: R.value.id,
        sourceLNode: R.value,
        class: "col-span-full row-start-3"
      }, null, 8, ["sourceLNode"])) : lt("", !0),
      D.value ? (fe(), pn(th, {
        key: 1,
        destinationLNode: D.value,
        class: "col-span-full row-start-3"
      }, null, 8, ["destinationLNode"])) : lt("", !0)
    ]));
  }
}), nm = { class: "grid grid-cols-2 gap-4 mt-4" }, rm = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, om = ["value"], im = { class: "grid grid-cols-2 gap-4 mt-4" }, sm = ["value", "title"], am = { class: "grid grid-cols-2 gap-4 mt-4" }, um = ["value", "title"], lm = { class: "grid grid-cols-2 gap-4 mt-4" }, cm = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, fm = ["value"], dm = { class: "grid grid-cols-2 gap-4 mt-4" }, pm = { class: "flex items-center" }, hm = { class: "flex items-center" }, mm = ["value"], ym = { class: "grid grid-cols-2 gap-4 mt-4" }, vm = { class: "mt-4" }, gm = { class: "mt-4" }, bm = { class: "mt-4 flex items-center" }, wm = /* @__PURE__ */ Kt({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {},
    isVisible: { type: Boolean }
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const s = n, u = r, c = cn(), { connections: f, lnodeTypes: p, dataflowSdk: h } = hn(c), g = rt(ie()), R = rt(!1), D = rt([]), L = rt(!0);
    Ht(
      () => s.isVisible,
      (Y, q) => {
        !Y && q && U();
      }
    ), Ht(R, (Y) => {
      Y ? g.value.inputName = "" : g.value.inputName = g.value.signal;
    }), Ht(
      [
        () => g.value.inputName,
        () => g.value.attribute
      ],
      async ([Y, q]) => {
        const M = await h.value.calculateNextInputInstance(
          Y,
          q,
          s.destinationLNode
        );
        g.value.inputInstance = M.toString();
      }
    ), Ht(
      [() => s.destinationLNode, f],
      async ([Y, q]) => {
        D.value = await h.value.findExistingInputs(Y);
      },
      { immediate: !0 }
    ), Ht(
      () => g.value.signal,
      (Y, q) => {
        const M = g.value.inputName !== q && g.value.inputName !== "";
        !R.value && !M && (g.value.inputName = Y);
      }
    ), Pf(() => {
      switch (U(), g.value.type = s.dataflowType, s.dataflowType) {
        case vt.GOOSE:
        case vt.SMV:
          g.value.includeQuality = !0, g.value.includeTimestamp = !1;
          break;
        case vt.REPORT:
          g.value.includeQuality = !0, g.value.includeTimestamp = !0;
          break;
        default:
          g.value.includeQuality = !1, g.value.includeTimestamp = !1;
      }
    });
    const B = tt(() => !s.dataflowType || !s.sourceLNode ? [] : p.value.find((Y) => Y.typeId === s.sourceLNode.lnType)?.dataObjects.filter(
      (Y) => Y.dataAttributes.some(
        (q) => Ro[s.dataflowType]?.includes(q.fc)
      )
    ).sort((Y, q) => Y.name.localeCompare(q.name)) ?? []), ee = tt(() => !s.dataflowType || !s.sourceLNode ? [] : p.value.find((Y) => Y.typeId === s.sourceLNode.lnType)?.dataObjects.find((Y) => Y.name === g.value.signal)?.dataAttributes.filter(
      (Y) => Ro[s.dataflowType].includes(Y.fc)
    ).filter((Y) => !Pi.includes(Y.name)).sort((Y, q) => Y.name.localeCompare(q.name)) ?? []);
    function ie() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function ce(Y) {
      for (const q of Y)
        g.value[q] = "";
    }
    async function xe() {
      try {
        if (!le(g.value))
          return;
        await h.value.createConnection(
          g.value,
          s.sourceLNode,
          s.destinationLNode,
          L.value
        ), u("connectionCreated"), U();
      } catch (Y) {
        console.error("Error creating dataflow:", Y), alert(`Error creating dataflow: ${Y instanceof Error ? Y.message : "Unknown error"}`);
      }
    }
    function le(Y) {
      return Y.type ? Y.signal ? Y.attribute ? Y.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function U() {
      g.value = ie(), R.value = !1, L.value = !0;
    }
    return (Y, q) => (fe(), ve(Xe, null, [
      q[24] || (q[24] = j("hr", { class: "solid mt-4" }, null, -1)),
      j("div", nm, [
        q[11] || (q[11] = j("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Source", -1)),
        j("select", rm, [
          j("option", {
            value: s.sourceLNode.id
          }, Ee(De(Vn)(Y.sourceLNode)), 9, om)
        ])
      ]),
      j("div", im, [
        q[13] || (q[13] = j("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Signal (DO)", -1)),
        He(j("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": q[0] || (q[0] = (M) => g.value.signal = M),
          onChange: q[1] || (q[1] = (M) => ce(["attribute"]))
        }, [
          q[12] || (q[12] = j("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (fe(!0), ve(Xe, null, Ct(B.value, (M) => (fe(), ve("option", {
            key: M.name,
            value: M.name,
            title: M.desc ? `Desc: ${M.desc}` : ""
          }, Ee(M.desc ? M.name + " ⓘ" : M.name), 9, sm))), 128))
        ], 544), [
          [ln, g.value.signal]
        ])
      ]),
      j("div", am, [
        q[15] || (q[15] = j("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Attribute (DA)", -1)),
        He(j("select", {
          id: "data-attribute-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": q[2] || (q[2] = (M) => g.value.attribute = M)
        }, [
          q[14] || (q[14] = j("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (fe(!0), ve(Xe, null, Ct(ee.value, (M) => (fe(), ve("option", {
            key: M.name,
            value: M.name,
            title: M.desc ? `Desc: ${M.desc}` : ""
          }, Ee(M.desc ? M.name + " ⓘ" : M.name), 9, um))), 128))
        ], 512), [
          [ln, g.value.attribute]
        ])
      ]),
      q[25] || (q[25] = j("hr", { class: "solid mt-4" }, null, -1)),
      j("div", lm, [
        q[16] || (q[16] = j("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Destination", -1)),
        j("select", cm, [
          j("option", {
            value: s.destinationLNode.id
          }, Ee(De(Vn)(Y.destinationLNode)), 9, fm)
        ])
      ]),
      j("div", dm, [
        j("fieldset", null, [
          q[19] || (q[19] = j("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
          j("div", pm, [
            He(j("input", {
              type: "radio",
              id: "dataflow-new-input",
              name: "input",
              "onUpdate:modelValue": q[3] || (q[3] = (M) => R.value = M),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [jr, R.value]
            ]),
            q[17] || (q[17] = j("label", { for: "dataflow-new-input" }, "New Input", -1))
          ]),
          j("div", hm, [
            He(j("input", {
              type: "radio",
              id: "dataflow-existing-input",
              name: "input",
              "onUpdate:modelValue": q[4] || (q[4] = (M) => R.value = M),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [jr, R.value]
            ]),
            q[18] || (q[18] = j("label", { for: "dataflow-existing-input" }, "Existing Input", -1))
          ])
        ]),
        R.value ? lt("", !0) : He((fe(), ve("input", {
          key: 0,
          "aria-label": "New Input Name",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": q[5] || (q[5] = (M) => g.value.inputName = M)
        }, null, 512)), [
          [Or, g.value.inputName]
        ]),
        R.value ? He((fe(), ve("select", {
          key: 1,
          "aria-label": "Existing Input Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": q[6] || (q[6] = (M) => g.value.inputName = M)
        }, [
          (fe(!0), ve(Xe, null, Ct(D.value, (M) => (fe(), ve("option", {
            key: M,
            value: M
          }, Ee(M), 9, mm))), 128))
        ], 512)), [
          [ln, g.value.inputName]
        ]) : lt("", !0)
      ]),
      j("div", ym, [
        q[20] || (q[20] = j("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        He(j("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": q[7] || (q[7] = (M) => g.value.inputInstance = M)
        }, null, 512), [
          [Or, g.value.inputInstance]
        ])
      ]),
      q[26] || (q[26] = j("hr", { class: "solid mt-4" }, null, -1)),
      j("div", vm, [
        He(j("input", {
          type: "checkbox",
          "onUpdate:modelValue": q[8] || (q[8] = (M) => g.value.includeQuality = M),
          class: "checkbox mr-2",
          id: "checkbox-include-quality"
        }, null, 512), [
          [Ao, g.value.includeQuality]
        ]),
        q[21] || (q[21] = j("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
      ]),
      j("div", gm, [
        He(j("input", {
          type: "checkbox",
          "onUpdate:modelValue": q[9] || (q[9] = (M) => g.value.includeTimestamp = M),
          class: "checkbox mr-2",
          id: "checkbox-include-timestamp"
        }, null, 512), [
          [Ao, g.value.includeTimestamp]
        ]),
        q[22] || (q[22] = j("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
      ]),
      j("div", bm, [
        He(j("input", {
          type: "checkbox",
          "onUpdate:modelValue": q[10] || (q[10] = (M) => L.value = M),
          class: "checkbox mr-2",
          id: "dataflow-checkbox-add-references"
        }, null, 512), [
          [Ao, L.value]
        ]),
        q[23] || (q[23] = j("label", { for: "dataflow-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      j("div", { class: "modal-action" }, [
        j("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: xe,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), _m = { class: "grid grid-cols-2 gap-4 mt-4" }, xm = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Om = ["value"], Tm = { class: "grid grid-cols-2 gap-4 mt-4" }, Em = ["value", "title"], Nm = { class: "grid grid-cols-2 gap-4 mt-4" }, Cm = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Sm = ["value"], Am = { class: "grid grid-cols-2 gap-4 mt-4" }, Pm = { class: "flex items-center" }, Dm = { class: "flex items-center" }, Rm = ["value"], Im = { class: "grid grid-cols-2 gap-4 mt-4" }, km = { class: "mt-4 flex items-center" }, jm = /* @__PURE__ */ Kt({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const s = n, u = r, c = cn(), { controlledConnections: f, lnodeTypes: p, dataflowSdk: h } = hn(c), g = rt(
      ee()
    ), R = rt(!1), D = rt([]), L = rt(!0);
    Ht(R, (le) => {
      le ? g.value.outputName = "" : g.value.outputName = g.value.controlledSignal;
    }), Ht(
      [() => s.sourceLNode, f],
      async ([le, U]) => {
        D.value = await h.value.findExistingOutputs(le);
      },
      { immediate: !0 }
    ), Ht(
      () => g.value.outputName,
      async (le) => {
        const U = await h.value.calculateNextOutputInstance(
          le,
          s.sourceLNode
        );
        g.value.outputInstance = U.toString();
      }
    ), Ht(
      () => g.value.controlledSignal,
      (le, U) => {
        const Y = g.value.outputName !== U && g.value.outputName !== "";
        !R.value && !Y && (g.value.outputName = le);
      }
    );
    const B = tt(() => s.destinationLNode ? p.value.find((U) => U.typeId === s.destinationLNode.lnType)?.dataObjects.map((U) => ({
      name: U.name,
      desc: U.desc
    })).sort((U, Y) => U.name.localeCompare(Y.name)) ?? [] : []);
    function ee() {
      return {
        type: vt.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function ie() {
      try {
        if (!ce(g.value))
          return;
        await h.value.createControlledConnection(
          g.value,
          s.sourceLNode,
          s.destinationLNode,
          L.value
        ), u("connectionCreated"), xe();
      } catch (le) {
        console.error("Error creating controlled dataflow:", le), alert(`Error creating controlled dataflow: ${le instanceof Error ? le.message : "Unknown error"}`);
      }
    }
    function ce(le) {
      return le.type ? le.outputName ? le.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function xe() {
      g.value = ee(), R.value = !1, L.value = !0;
    }
    return (le, U) => (fe(), ve(Xe, null, [
      U[16] || (U[16] = j("hr", { class: "solid mt-4" }, null, -1)),
      j("div", _m, [
        U[7] || (U[7] = j("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        j("select", xm, [
          j("option", {
            value: s.destinationLNode.id
          }, Ee(De(Vn)(le.destinationLNode)), 9, Om)
        ])
      ]),
      j("div", Tm, [
        U[9] || (U[9] = j("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        He(j("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": U[0] || (U[0] = (Y) => g.value.controlledSignal = Y)
        }, [
          U[8] || (U[8] = j("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (fe(!0), ve(Xe, null, Ct(B.value, (Y) => (fe(), ve("option", {
            key: Y.name,
            value: Y.name,
            title: Y.desc ? `Desc: ${Y.desc}` : ""
          }, Ee(Y.desc ? Y.name + " ⓘ" : Y.name), 9, Em))), 128))
        ], 512), [
          [ln, g.value.controlledSignal]
        ])
      ]),
      U[17] || (U[17] = j("hr", { class: "solid mt-4" }, null, -1)),
      j("div", Nm, [
        U[10] || (U[10] = j("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        j("select", Cm, [
          j("option", {
            value: s.sourceLNode.id
          }, Ee(De(Vn)(le.sourceLNode)), 9, Sm)
        ])
      ]),
      j("div", Am, [
        j("fieldset", null, [
          U[13] || (U[13] = j("legend", { class: "col-start-1 self-start" }, "Controller Output Name", -1)),
          j("div", Pm, [
            He(j("input", {
              type: "radio",
              id: "dataflow-control-new-output",
              name: "output",
              "onUpdate:modelValue": U[1] || (U[1] = (Y) => R.value = Y),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [jr, R.value]
            ]),
            U[11] || (U[11] = j("label", { for: "dataflow-control-new-output" }, "New Output", -1))
          ]),
          j("div", Dm, [
            He(j("input", {
              type: "radio",
              id: "dataflow-control-existing-output",
              name: "output",
              "onUpdate:modelValue": U[2] || (U[2] = (Y) => R.value = Y),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [jr, R.value]
            ]),
            U[12] || (U[12] = j("label", { for: "dataflow-control-existing-output" }, "Existing Output", -1))
          ])
        ]),
        R.value ? lt("", !0) : He((fe(), ve("input", {
          key: 0,
          "aria-label": "New Output Name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": U[3] || (U[3] = (Y) => g.value.outputName = Y)
        }, null, 512)), [
          [Or, g.value.outputName]
        ]),
        R.value ? He((fe(), ve("select", {
          key: 1,
          "aria-label": "Existing Output Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": U[4] || (U[4] = (Y) => g.value.outputName = Y)
        }, [
          (fe(!0), ve(Xe, null, Ct(D.value, (Y) => (fe(), ve("option", {
            key: Y,
            value: Y
          }, Ee(Y), 9, Rm))), 128))
        ], 512)), [
          [ln, g.value.outputName]
        ]) : lt("", !0)
      ]),
      j("div", Im, [
        U[14] || (U[14] = j("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Output Instance", -1)),
        He(j("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": U[5] || (U[5] = (Y) => g.value.outputInstance = Y)
        }, null, 512), [
          [Or, g.value.outputInstance]
        ])
      ]),
      j("div", km, [
        He(j("input", {
          type: "checkbox",
          "onUpdate:modelValue": U[6] || (U[6] = (Y) => L.value = Y),
          class: "checkbox mr-2",
          id: "dataflow-control-checkbox-add-references"
        }, null, 512), [
          [Ao, L.value]
        ]),
        U[15] || (U[15] = j("label", { for: "dataflow-control-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      U[18] || (U[18] = j("hr", { class: "solid mt-4" }, null, -1)),
      j("div", { class: "modal-action" }, [
        j("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: ie,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), Lm = ["disabled"], Km = ["open"], Fm = { class: "modal-box" }, Mm = { class: "grid grid-cols-2 gap-4 mt-4" }, Bm = ["value", "disabled"], $m = /* @__PURE__ */ Kt({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {}
  },
  setup(n) {
    const r = n, s = rt(!1), u = rt(null), c = tt(
      () => Object.values(vt).filter((D) => D !== vt.INTERNAL)
    ), f = tt(
      () => r.sourceLNode?.lnClass === "IHMI" || r.sourceLNode?.lnClass === "ITCI"
    );
    function p(D) {
      const L = D.target.value;
      u.value = L;
    }
    function h() {
      R();
    }
    function g() {
      s.value = !0;
    }
    function R() {
      s.value = !1, u.value = null;
    }
    return (D, L) => (fe(), ve(Xe, null, [
      j("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: g,
        disabled: !r.sourceLNode || !r.destinationLNode,
        "aria-label": "Add connection"
      }, " + ", 8, Lm),
      r.sourceLNode && r.destinationLNode ? (fe(), ve("dialog", {
        key: 0,
        class: "modal",
        open: s.value
      }, [
        j("div", Fm, [
          L[4] || (L[4] = j("h3", { class: "text-lg font-bold" }, "Create Connection", -1)),
          j("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: R,
            "aria-label": "Close dataflow creation",
            "data-testId": "close-dataflow-creation"
          }, L[1] || (L[1] = [
            j("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              j("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          j("div", Mm, [
            L[3] || (L[3] = j("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            He(j("select", {
              id: "dataflow-type-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": L[0] || (L[0] = (B) => u.value = B),
              onChange: p
            }, [
              L[2] || (L[2] = j("option", {
                key: "empty",
                value: null
              }, "-", -1)),
              (fe(!0), ve(Xe, null, Ct(c.value, (B) => (fe(), ve("option", {
                key: B,
                value: B,
                disabled: B === De(vt).CONTROL && !f.value
              }, Ee(B), 9, Bm))), 128))
            ], 544), [
              [ln, u.value]
            ])
          ]),
          u.value !== De(vt).CONTROL ? (fe(), pn(wm, {
            key: 0,
            sourceLNode: r.sourceLNode,
            destinationLNode: r.destinationLNode,
            dataflowType: u.value,
            onConnectionCreated: h,
            isVisible: s.value
          }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType", "isVisible"])) : (fe(), pn(jm, {
            key: 1,
            sourceLNode: r.sourceLNode,
            destinationLNode: r.destinationLNode,
            dataflowType: u.value,
            onConnectionCreated: h
          }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType"]))
        ])
      ], 8, Km)) : lt("", !0)
    ], 64));
  }
}), qm = { class: "flex flex-col items-center justify-center w-full" }, Um = /* @__PURE__ */ Kt({
  __name: "dataflow-view",
  setup(n) {
    const r = rt(), s = rt(), u = cn(), { lnodes: c } = hn(u), f = tt(() => R(r.value)), p = tt(() => R(s.value));
    function h(D) {
      r.value = D;
    }
    function g(D) {
      s.value = D;
    }
    function R(D) {
      return c.value.find((L) => L.id === D) ?? void 0;
    }
    return (D, L) => (fe(), ve("div", qm, [
      St(tm, {
        onSourceLNodeChange: h,
        onDestinationLNodeChange: g
      }),
      St($m, {
        sourceLNode: f.value,
        destinationLNode: p.value
      }, null, 8, ["sourceLNode", "destinationLNode"])
    ]));
  }
}), ec = (n, r) => {
  const s = n.__vccOpts || n;
  for (const [u, c] of r)
    s[u] = c;
  return s;
}, Vm = {}, Hm = { class: "layout" }, Wm = { class: "main" }, Gm = { class: "sidebar" };
function Ym(n, r) {
  return fe(), ve("div", Hm, [
    j("div", Wm, [
      Ja(n.$slots, "main", {}, void 0)
    ]),
    j("div", Gm, [
      Ja(n.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const Xm = /* @__PURE__ */ ec(Vm, [["render", Ym], ["__scopeId", "data-v-5f95d421"]]), zm = {
  name: "sidebar",
  class: "root"
}, Qm = { class: "tabs tabs-box" }, Jm = { key: 0 }, Zm = { key: 1 }, ey = /* @__PURE__ */ Kt({
  __name: "sidebar",
  setup(n) {
    const r = rt("details");
    return (s, u) => (fe(), ve("div", zm, [
      j("div", Qm, [
        He(j("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": u[0] || (u[0] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [jr, r.value]
        ]),
        He(j("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": u[1] || (u[1] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [jr, r.value]
        ])
      ]),
      j("div", null, [
        r.value === "details" ? (fe(), ve("div", Jm, u[2] || (u[2] = [
          j("div", { id: "sidebar-details" }, null, -1)
        ]))) : lt("", !0),
        r.value === "advanced" ? (fe(), ve("div", Zm)) : lt("", !0)
      ])
    ]));
  }
}), ty = /* @__PURE__ */ ec(ey, [["__scopeId", "data-v-ec5c053a"]]), ny = ["id"], ry = { class: "p-10" }, oy = /* @__PURE__ */ Kt({
  __name: "app",
  props: {
    api: {}
  },
  setup(n) {
    const r = "dataflow", s = n, u = cn();
    let c = () => {
    };
    return xl(() => {
      c = s.api.activeFileName.subscribe((f) => {
        u.initApp(f);
      }), u.initApp(s.api.activeFileName.value);
    }), Ka(() => {
      u.closeDatabase(), c();
    }), (f, p) => (fe(), ve("article", {
      id: De(r),
      style: { height: "100%" }
    }, [
      St(Xm, null, {
        main: sa(() => [
          j("div", ry, [
            St(Um)
          ])
        ]),
        sidebar: sa(() => [
          St(ty)
        ]),
        _: 1
      })
    ], 8, ny));
  }
});
function Cy(n, r) {
  if (!document.getElementById(n)) {
    console.error({ msg: "could not found root element", rootId: n });
    return;
  }
  const u = _d(oy, { api: r });
  return u.use(Td()), u.mount(`#${n}`), u.unmount;
}
export {
  Cy as default
};
