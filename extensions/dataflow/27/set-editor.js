(function(){"use strict";try{if(typeof document<"u"){var e=document.createElement("style");e.appendChild(document.createTextNode(`.backdrop[data-v-9cc5b747]{position:fixed;inset:0;z-index:5;width:100vw;height:100vh;background:transparent}:where(.custom-plus-btn-left[data-v-749a83f4]){width:unset}.custom-plus-btn-left[data-v-749a83f4]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.custom-plus-btn-left[data-v-749a83f4]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.custom-plus-btn-left[data-v-749a83f4]{--btn-noise:var(--fx-noise)}.prose .custom-plus-btn-left[data-v-749a83f4]{text-decoration-line:none}@media (hover:hover){.custom-plus-btn-left[data-v-749a83f4]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.custom-plus-btn-left[data-v-749a83f4]:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.custom-plus-btn-left[data-v-749a83f4]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.custom-plus-btn-left[data-v-749a83f4]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.custom-plus-btn-left[data-v-749a83f4]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-left[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.custom-plus-btn-left[data-v-749a83f4]:is(input[type=checkbox],input[type=radio]){appearance:none}.custom-plus-btn-left[data-v-749a83f4]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.custom-plus-btn-left[data-v-749a83f4]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.custom-plus-btn-left[data-v-749a83f4]{z-index:10;width:var(--size);height:var(--size);width:calc(var(--spacing,.25rem)*5);height:calc(var(--spacing,.25rem)*5);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);border-radius:3.40282e38px;grid-column:3/span 1;grid-row-start:4;align-self:center;margin-left:-12px;padding-inline:0}:where(.custom-plus-btn-right[data-v-749a83f4]){width:unset}.custom-plus-btn-right[data-v-749a83f4]{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.custom-plus-btn-right[data-v-749a83f4]{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.custom-plus-btn-right[data-v-749a83f4]{--btn-noise:var(--fx-noise)}.prose .custom-plus-btn-right[data-v-749a83f4]{text-decoration-line:none}@media (hover:hover){.custom-plus-btn-right[data-v-749a83f4]:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.custom-plus-btn-right[data-v-749a83f4]:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.custom-plus-btn-right[data-v-749a83f4]:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.custom-plus-btn-right[data-v-749a83f4]:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.custom-plus-btn-right[data-v-749a83f4]:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.custom-plus-btn-right[data-v-749a83f4]:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.custom-plus-btn-right[data-v-749a83f4]:is(input[type=checkbox],input[type=radio]){appearance:none}.custom-plus-btn-right[data-v-749a83f4]:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.custom-plus-btn-right[data-v-749a83f4]:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.custom-plus-btn-right[data-v-749a83f4]{width:var(--size);height:var(--size);width:calc(var(--spacing,.25rem)*5);height:calc(var(--spacing,.25rem)*5);--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);border-radius:3.40282e38px;grid-column:4/span 1;grid-row-start:4;align-self:center;margin-left:-9px;padding-inline:0}.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial;--tw-content:""}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-gray-200:oklch(92.8% .006 264.531);--color-black:#000;--color-white:#fff;--spacing:.25rem;--text-xs:.75rem;--text-xs--line-height:calc(1/.75);--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--font-weight-medium:500;--font-weight-semibold:600;--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-300)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}.menu{--menu-active-fg:var(--color-neutral-content);--menu-active-bg:var(--color-neutral);flex-flow:column wrap;width:fit-content;padding:.5rem;font-size:.875rem;display:flex}.menu :where(li ul){white-space:nowrap;margin-inline-start:1rem;padding-inline-start:.5rem;position:relative}.menu :where(li ul):before{background-color:var(--color-base-content);opacity:.1;width:var(--border);content:"";inset-inline-start:0;position:absolute;top:.75rem;bottom:.75rem}.menu :where(li>.menu-dropdown:not(.menu-dropdown-show)){display:none}.menu :where(li:not(.menu-title)>:not(ul,details,.menu-title,.btn)),.menu :where(li:not(.menu-title)>details>summary:not(.menu-title)){border-radius:var(--radius-field);text-align:start;text-wrap:balance;-webkit-user-select:none;user-select:none;grid-auto-columns:minmax(auto,max-content) auto max-content;grid-auto-flow:column;align-content:flex-start;align-items:center;gap:.5rem;padding-block:.375rem;padding-inline:.75rem;transition-property:color,background-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:grid}.menu :where(li>details>summary){--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li>details>summary){outline-offset:2px;outline:2px solid #0000}}.menu :where(li>details>summary)::-webkit-details-marker{display:none}:is(.menu :where(li>details>summary),.menu :where(li>.menu-dropdown-toggle)):after{content:"";transform-origin:50%;pointer-events:none;justify-self:flex-end;width:.375rem;height:.375rem;transition-property:rotate,translate;transition-duration:.2s;display:block;translate:0 -1px;rotate:-135deg;box-shadow:inset 2px 2px}.menu :where(li>details[open]>summary):after,.menu :where(li>.menu-dropdown-toggle.menu-dropdown-show):after{translate:0 1px;rotate:45deg}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{cursor:pointer;background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{color:var(--color-base-content);--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn).menu-focus,.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title),li:not(.menu-title,.disabled)>details>summary:not(.menu-title)):not(.menu-active,:active,.btn):focus-visible{outline-offset:2px;outline:2px solid #0000}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){cursor:pointer;background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){outline-offset:2px;outline:2px solid #0000}}.menu :where(li:not(.menu-title,.disabled)>:not(ul,details,.menu-title):not(.menu-active,:active,.btn):hover,li:not(.menu-title,.disabled)>details>summary:not(.menu-title):not(.menu-active,:active,.btn):hover){box-shadow:inset 0 1px #00000003,inset 0 -1px #ffffff03}.menu :where(li:empty){background-color:var(--color-base-content);opacity:.1;height:1px;margin:.5rem 1rem}.menu :where(li){flex-flow:column wrap;flex-shrink:0;align-items:stretch;display:flex;position:relative}.menu :where(li) .badge{justify-self:flex-end}.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{outline-offset:2px;outline:2px solid #0000}}.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active{color:var(--menu-active-fg);background-color:var(--menu-active-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise)}:is(.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active):not(:is(.menu :where(li)>:not(ul,.menu-title,details,.btn):active,.menu :where(li)>:not(ul,.menu-title,details,.btn).menu-active,.menu :where(li)>details>summary:active):active){box-shadow:0 2px calc(var(--depth)*3px) -2px var(--menu-active-bg)}.menu :where(li).menu-disabled{pointer-events:none;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.menu :where(li).menu-disabled{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.menu .dropdown:focus-within .menu-dropdown-toggle:after{translate:0 1px;rotate:45deg}.menu .dropdown-content{margin-top:.5rem;padding:.5rem}.menu .dropdown-content:before{display:none}.collapse-arrow>.collapse-title:after{content:"";transform-origin:75% 75%;pointer-events:none;top:1.9rem;width:.5rem;height:.5rem;transition-property:all;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);display:block;position:absolute;inset-inline-end:1.4rem;transform:translateY(-100%)rotate(45deg);box-shadow:2px 2px}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999;transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.collapse:not(td,tr,colgroup){visibility:visible}.collapse{border-radius:var(--radius-box,1rem);isolation:isolate;grid-template-rows:max-content 0fr;width:100%;transition:grid-template-rows .2s;display:grid;position:relative;overflow:hidden}.collapse>input:is([type=checkbox],[type=radio]){appearance:none;opacity:0;z-index:1;grid-row-start:1;grid-column-start:1;width:100%;min-height:1lh;padding:1rem;padding-inline-end:3rem;transition:background-color .2s ease-out}.collapse:is([open],:focus:not(.collapse-close)),.collapse:not(.collapse-close):has(>input:is([type=checkbox],[type=radio]):checked){grid-template-rows:max-content 1fr}.collapse:is([open],:focus:not(.collapse-close))>.collapse-content,.collapse:not(.collapse-close)>:where(input:is([type=checkbox],[type=radio]):checked~.collapse-content){visibility:visible;min-height:fit-content}.collapse:focus-visible,.collapse:has(>input:is([type=checkbox],[type=radio]):focus-visible){outline-color:var(--color-base-content);outline-offset:2px;outline-width:2px;outline-style:solid}.collapse:not(.collapse-close)>input[type=checkbox],.collapse:not(.collapse-close)>input[type=radio]:not(:checked),.collapse:not(.collapse-close)>.collapse-title{cursor:pointer}.collapse:focus:not(.collapse-close,.collapse[open])>.collapse-title{cursor:unset}.collapse:is([open],:focus:not(.collapse-close))>:where(.collapse-content),.collapse:not(.collapse-close)>:where(input:is([type=checkbox],[type=radio]):checked~.collapse-content){padding-bottom:1rem;transition:padding .2s ease-out,background-color .2s ease-out}.collapse[open].collapse-arrow>.collapse-title:after,.collapse.collapse-open.collapse-arrow>.collapse-title:after{transform:translateY(-50%)rotate(225deg)}.collapse.collapse-open.collapse-plus>.collapse-title:after{content:"−"}.collapse.collapse-arrow:focus:not(.collapse-close)>.collapse-title:after,.collapse.collapse-arrow:not(.collapse-close)>input:is([type=checkbox],[type=radio]):checked~.collapse-title:after{transform:translateY(-50%)rotate(225deg)}.collapse[open].collapse-plus>.collapse-title:after,.collapse.collapse-plus:focus:not(.collapse-close)>.collapse-title:after,.collapse.collapse-plus:not(.collapse-close)>input:is([type=checkbox],[type=radio]):checked~.collapse-title:after{content:"−"}.collapse:is(details){width:100%}.collapse:is(details) summary{display:block;position:relative}.collapse:is(details) summary::-webkit-details-marker{display:none}.collapse:is(details) summary{outline:none}.collapse-content{visibility:hidden;min-height:0;cursor:unset;grid-row-start:2;grid-column-start:1;padding-left:1rem;padding-right:1rem;transition:visibility .2s,padding .2s ease-out,background-color .2s ease-out}.collapse{visibility:collapse}.toggle{border:var(--border)solid currentColor;color:var(--input-color);cursor:pointer;appearance:none;vertical-align:middle;webkit-user-select:none;-webkit-user-select:none;user-select:none;--radius-selector-max:calc(var(--radius-selector) + var(--radius-selector) + var(--radius-selector));border-radius:calc(var(--radius-selector) + min(var(--toggle-p),var(--radius-selector-max)) + min(var(--border),var(--radius-selector-max)));padding:var(--toggle-p);flex-shrink:0;grid-template-columns:0fr 1fr 1fr;place-content:center;display:inline-grid;position:relative;box-shadow:inset 0 1px}@supports (color:color-mix(in lab,red,red)){.toggle{box-shadow:0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000) inset}}.toggle{--input-color:var(--color-base-content);transition:color .3s,grid-template-columns .2s}@supports (color:color-mix(in lab,red,red)){.toggle{--input-color:color-mix(in oklab,var(--color-base-content)50%,#0000)}}.toggle{--toggle-p:calc(var(--size)*.125);--size:calc(var(--size-selector,.25rem)*6);width:calc((var(--size)*2) - (var(--border) + var(--toggle-p))*2);height:var(--size)}.toggle>*{z-index:1;cursor:pointer;appearance:none;background-color:#0000;border:none;grid-column:2/span 1;grid-row-start:1;height:100%;padding:.125rem;transition:opacity .2s,rotate .4s}.toggle>:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.toggle>:focus{outline-offset:2px;outline:2px solid #0000}}.toggle>:nth-child(2){color:var(--color-base-100);rotate:none}.toggle>:nth-child(3){color:var(--color-base-100);opacity:0;rotate:-15deg}.toggle:has(:checked)>:nth-child(2){opacity:0;rotate:15deg}.toggle:has(:checked)>:nth-child(3){opacity:1;rotate:none}.toggle:before{aspect-ratio:1;border-radius:var(--radius-selector);--tw-content:"";content:var(--tw-content);height:100%;box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor;background-color:currentColor;grid-row-start:1;grid-column-start:2;transition:background-color .1s,translate .2s,inset-inline-start .2s;position:relative;inset-inline-start:0;translate:0}@supports (color:color-mix(in lab,red,red)){.toggle:before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000)}}.toggle:before{background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise)}@media (forced-colors:active){.toggle:before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{.toggle:before{outline-offset:-1rem;outline:.25rem solid}}.toggle:focus-visible,.toggle:has(:focus-visible){outline-offset:2px;outline:2px solid}.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked){background-color:var(--color-base-100);--input-color:var(--color-base-content);grid-template-columns:1fr 1fr 0fr}:is(.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked)):before{background-color:currentColor}@starting-style{:is(.toggle:checked,.toggle[aria-checked=true],.toggle:has(>input:checked)):before{opacity:0}}.toggle:indeterminate{grid-template-columns:.5fr 1fr .5fr}.toggle:disabled{cursor:not-allowed;opacity:.3}.toggle:disabled:before{border:var(--border)solid currentColor;background-color:#0000}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.range{appearance:none;webkit-appearance:none;--range-thumb:var(--color-base-100);--range-thumb-size:calc(var(--size-selector,.25rem)*6);--range-progress:currentColor;--range-fill:1;--range-p:.25rem;--range-bg:currentColor}@supports (color:color-mix(in lab,red,red)){.range{--range-bg:color-mix(in oklab,currentColor 10%,#0000)}}.range{cursor:pointer;vertical-align:middle;--radius-selector-max:calc(var(--radius-selector) + var(--radius-selector) + var(--radius-selector));border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));width:clamp(3rem,20rem,100%);height:var(--range-thumb-size);background-color:#0000;border:none;overflow:hidden}[dir=rtl] .range{--range-dir:-1}.range:focus{outline:none}.range:focus-visible{outline-offset:2px;outline:2px solid}.range::-webkit-slider-runnable-track{background-color:var(--range-bg);border-radius:var(--radius-selector);width:100%;height:calc(var(--range-thumb-size)*.5)}@media (forced-colors:active){.range::-webkit-slider-runnable-track{border:1px solid}.range::-moz-range-track{border:1px solid}}.range::-webkit-slider-thumb{box-sizing:border-box;border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));height:var(--range-thumb-size);width:var(--range-thumb-size);border:var(--range-p)solid;appearance:none;webkit-appearance:none;color:var(--range-progress);box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor,0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill));background-color:currentColor;position:relative;top:50%;transform:translateY(-50%)}@supports (color:color-mix(in lab,red,red)){.range::-webkit-slider-thumb{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000),0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill))}}.range::-moz-range-track{background-color:var(--range-bg);border-radius:var(--radius-selector);width:100%;height:calc(var(--range-thumb-size)*.5)}.range::-moz-range-thumb{box-sizing:border-box;border-radius:calc(var(--radius-selector) + min(var(--range-p),var(--radius-selector-max)));height:var(--range-thumb-size);width:var(--range-thumb-size);border:var(--range-p)solid;color:var(--range-progress);box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px currentColor,0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill));background-color:currentColor;position:relative;top:50%}@supports (color:color-mix(in lab,red,red)){.range::-moz-range-thumb{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px color-mix(in oklab,currentColor calc(var(--depth)*10%),#0000),0 0 0 2rem var(--range-thumb) inset,calc((var(--range-dir,1)*-100rem) - (var(--range-dir,1)*var(--range-thumb-size)/2)) 0 0 calc(100rem*var(--range-fill))}}.range:disabled{cursor:not-allowed;opacity:.3}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.collapse-title{grid-row-start:1;grid-column-start:1;width:100%;min-height:1lh;padding:1rem;padding-inline-end:3rem;transition:background-color .2s ease-out;position:relative}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.fixed{position:fixed}.relative{position:relative}.-top-3{top:calc(var(--spacing)*-3)}.top-0{top:calc(var(--spacing)*0)}.top-2{top:calc(var(--spacing)*2)}.-right-3{right:calc(var(--spacing)*-3)}.right-2{right:calc(var(--spacing)*2)}.right-\\[10\\%\\]{right:10%}.right-\\[70\\%\\]{right:70%}.left-\\[10\\%\\]{left:10%}.left-\\[70\\%\\]{left:70%}.modal-backdrop{color:#0000;z-index:-1;grid-row-start:1;grid-column-start:1;place-self:stretch stretch;display:grid}.modal-backdrop button{cursor:pointer}.-z-1{z-index:-1}.z-1{z-index:1}.z-2{z-index:2}.z-10{z-index:10}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.row-start-4{grid-row-start:4}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:"×"}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-2{margin-top:calc(var(--spacing)*2)}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-3{margin-right:calc(var(--spacing)*3)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-6{margin-bottom:calc(var(--spacing)*6)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-3{margin-left:calc(var(--spacing)*3)}.status{aspect-ratio:1;border-radius:var(--radius-selector);background-color:var(--color-base-content);width:.5rem;height:.5rem;display:inline-block}@supports (color:color-mix(in lab,red,red)){.status{background-color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.status{vertical-align:middle;color:#0000004d;background-position:50%;background-repeat:no-repeat}@supports (color:color-mix(in lab,red,red)){.status{color:#0000004d}@supports (color:color-mix(in lab,red,red)){.status{color:color-mix(in oklab,var(--color-black)30%,transparent)}}}.status{background-image:radial-gradient(circle at 35% 30%,oklch(1 0 0/calc(var(--depth)*.5)),#0000);box-shadow:0 2px 3px -1px}@supports (color:color-mix(in lab,red,red)){.status{box-shadow:0 2px 3px -1px color-mix(in oklab,currentColor calc(var(--depth)*100%),#0000)}}.badge{border-radius:var(--radius-selector);vertical-align:middle;color:var(--badge-fg);border:var(--border)solid var(--badge-color,var(--color-base-200));width:fit-content;padding-inline:calc(.25rem*3 - var(--border));background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);background-color:var(--badge-bg);--badge-bg:var(--badge-color,var(--color-base-100));--badge-fg:var(--color-base-content);--size:calc(var(--size-selector,.25rem)*6);height:var(--size);justify-content:center;align-items:center;gap:.5rem;font-size:.875rem;display:inline-flex}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.block{display:block}.flex{display:flex}.grid{display:grid}.inline-block{display:inline-block}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-5{height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-18{height:calc(var(--spacing)*18)}.h-\\[2px\\]{height:2px}.h-\\[12px\\]{height:12px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.max-h-\\[85vh\\]{max-height:85vh}.min-h-\\[450px\\]{min-height:450px}.w-1\\/2{width:50%}.w-3\\/4{width:75%}.w-5{width:calc(var(--spacing)*5)}.w-\\[20px\\]{width:20px}.w-\\[50px\\]{width:50px}.w-full{width:100%}.max-w-\\[8ch\\]{max-width:8ch}.max-w-none{max-width:none}.flex-1{flex:1}.link{cursor:pointer;text-decoration-line:underline}.link:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.link:focus{outline-offset:2px;outline:2px solid #0000}}.link:focus-visible{outline-offset:2px;outline:2px solid}.list-disc{list-style-type:disc}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_0\\.5fr_20px_1fr\\]{grid-template-columns:1fr 20px .5fr 20px 1fr}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-cols-\\[max-content_auto\\]{grid-template-columns:max-content auto}.grid-rows-\\[50px_50px_1fr_80px\\]{grid-template-rows:50px 50px 1fr 80px}.grid-rows-\\[50px_50px_80px\\]{grid-template-rows:50px 50px 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-between{justify-content:space-between}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.gap-x-2{column-gap:calc(var(--spacing)*2)}.self-center{align-self:center}.self-end{align-self:flex-end}.self-start{align-self:flex-start}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.truncate{text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-box{border-radius:var(--radius-box)}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border,.border-1{border-style:var(--tw-border-style);border-width:1px}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-dotted{--tw-border-style:dotted;border-style:dotted}.border-none{--tw-border-style:none;border-style:none}.border-solid{--tw-border-style:solid;border-style:solid}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.border-\\(--color-ocean-gray-200\\){border-color:var(--color-ocean-gray-200)}.border-\\(--color-primary\\){border-color:var(--color-primary)}.border-\\[var\\(--color-gray-200\\)\\]{border-color:var(--color-gray-200)}.border-\\[var\\(--color-primary\\)\\]{border-color:var(--color-primary)}.\\!bg-\\(--color-ocean-gray-75\\){background-color:var(--color-ocean-gray-75)!important}.bg-\\(--color-ocean-gray-25\\){background-color:var(--color-ocean-gray-25)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.bg-base-100{background-color:var(--color-base-100)}.radio-sm{padding:.1875rem}.radio-sm[type=radio]{--size:calc(var(--size-selector,.25rem)*5)}.p-0{padding:calc(var(--spacing)*0)}.p-1{padding:calc(var(--spacing)*1)}.p-3{padding:calc(var(--spacing)*3)}.p-4{padding:calc(var(--spacing)*4)}.px-2{padding-inline:calc(var(--spacing)*2)}.px-5{padding-inline:calc(var(--spacing)*5)}.py-1{padding-block:calc(var(--spacing)*1)}.ps-5{padding-inline-start:calc(var(--spacing)*5)}.pt-1{padding-top:calc(var(--spacing)*1)}.pl-5{padding-left:calc(var(--spacing)*5)}.text-center{text-align:center}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.text-xs{font-size:var(--text-xs);line-height:var(--tw-leading,var(--text-xs--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.font-medium{--tw-font-weight:var(--font-weight-medium);font-weight:var(--font-weight-medium)}.font-semibold{--tw-font-weight:var(--font-weight-semibold);font-weight:var(--font-weight-semibold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-ocean-gray-200\\){color:var(--color-ocean-gray-200)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}.after\\:start-0:after{content:var(--tw-content);inset-inline-start:calc(var(--spacing)*0)}.after\\:\\!top-3:after{content:var(--tw-content);top:calc(var(--spacing)*3)!important}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}.\\[\\&_dt\\]\\:mr-1 dt{margin-right:calc(var(--spacing)*1)}.\\[\\&_dt\\,dd\\]\\:inline dt,.\\[\\&_dt\\,dd\\]\\:inline dd{display:inline}.\\[\\&\\>dt\\]\\:text-right>dt{text-align:right}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}@property --tw-content{syntax:"*";inherits:false;initial-value:""}`)),document.head.appendChild(e)}}catch(o){console.error("vite-plugin-css-injected-by-js",o)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Ms(t) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const i of t.split(",")) r[i] = 1;
  return (i) => i in r;
}
const Nt = {}, jo = [], Xn = () => {
}, Dc = () => !1, _a = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Bs = (t) => t.startsWith("onUpdate:"), an = Object.assign, Ks = (t, r) => {
  const i = t.indexOf(r);
  i > -1 && t.splice(i, 1);
}, Pc = Object.prototype.hasOwnProperty, wt = (t, r) => Pc.call(t, r), Xe = Array.isArray, $o = (t) => qi(t) === "[object Map]", Wo = (t) => qi(t) === "[object Set]", pl = (t) => qi(t) === "[object Date]", nt = (t) => typeof t == "function", kt = (t) => typeof t == "string", Wn = (t) => typeof t == "symbol", At = (t) => t !== null && typeof t == "object", uu = (t) => (At(t) || nt(t)) && nt(t.then) && nt(t.catch), cu = Object.prototype.toString, qi = (t) => cu.call(t), Sc = (t) => qi(t).slice(8, -1), du = (t) => qi(t) === "[object Object]", qs = (t) => kt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, Ti = /* @__PURE__ */ Ms(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), Na = (t) => {
  const r = /* @__PURE__ */ Object.create(null);
  return (i) => r[i] || (r[i] = t(i));
}, Lc = /-(\w)/g, Ln = Na(
  (t) => t.replace(Lc, (r, i) => i ? i.toUpperCase() : "")
), kc = /\B([A-Z])/g, Do = Na(
  (t) => t.replace(kc, "-$1").toLowerCase()
), xa = Na((t) => t.charAt(0).toUpperCase() + t.slice(1)), us = Na(
  (t) => t ? `on${xa(t)}` : ""
), Kr = (t, r) => !Object.is(t, r), na = (t, ...r) => {
  for (let i = 0; i < t.length; i++)
    t[i](...r);
}, _s = (t, r, i, s = !1) => {
  Object.defineProperty(t, r, {
    configurable: !0,
    enumerable: !1,
    writable: s,
    value: i
  });
}, ca = (t) => {
  const r = parseFloat(t);
  return isNaN(r) ? t : r;
};
let hl;
const Ra = () => hl || (hl = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function jr(t) {
  if (Xe(t)) {
    const r = {};
    for (let i = 0; i < t.length; i++) {
      const s = t[i], c = kt(s) ? Mc(s) : jr(s);
      if (c)
        for (const f in c)
          r[f] = c[f];
    }
    return r;
  } else if (kt(t) || At(t))
    return t;
}
const jc = /;(?![^(]*\))/g, $c = /:([^]+)/, Fc = /\/\*[^]*?\*\//g;
function Mc(t) {
  const r = {};
  return t.replace(Fc, "").split(jc).forEach((i) => {
    if (i) {
      const s = i.split($c);
      s.length > 1 && (r[s[0].trim()] = s[1].trim());
    }
  }), r;
}
function Tt(t) {
  let r = "";
  if (kt(t))
    r = t;
  else if (Xe(t))
    for (let i = 0; i < t.length; i++) {
      const s = Tt(t[i]);
      s && (r += s + " ");
    }
  else if (At(t))
    for (const i in t)
      t[i] && (r += i + " ");
  return r.trim();
}
function Bc(t) {
  if (!t) return null;
  let { class: r, style: i } = t;
  return r && !kt(r) && (t.class = Tt(r)), i && (t.style = jr(i)), t;
}
const Kc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", qc = /* @__PURE__ */ Ms(Kc);
function fu(t) {
  return !!t || t === "";
}
function Uc(t, r) {
  if (t.length !== r.length) return !1;
  let i = !0;
  for (let s = 0; i && s < t.length; s++)
    i = Io(t[s], r[s]);
  return i;
}
function Io(t, r) {
  if (t === r) return !0;
  let i = pl(t), s = pl(r);
  if (i || s)
    return i && s ? t.getTime() === r.getTime() : !1;
  if (i = Wn(t), s = Wn(r), i || s)
    return t === r;
  if (i = Xe(t), s = Xe(r), i || s)
    return i && s ? Uc(t, r) : !1;
  if (i = At(t), s = At(r), i || s) {
    if (!i || !s)
      return !1;
    const c = Object.keys(t).length, f = Object.keys(r).length;
    if (c !== f)
      return !1;
    for (const u in t) {
      const p = t.hasOwnProperty(u), v = r.hasOwnProperty(u);
      if (p && !v || !p && v || !Io(t[u], r[u]))
        return !1;
    }
  }
  return String(t) === String(r);
}
function Us(t, r) {
  return t.findIndex((i) => Io(i, r));
}
const pu = (t) => !!(t && t.__v_isRef === !0), ne = (t) => kt(t) ? t : t == null ? "" : Xe(t) || At(t) && (t.toString === cu || !nt(t.toString)) ? pu(t) ? ne(t.value) : JSON.stringify(t, hu, 2) : String(t), hu = (t, r) => pu(r) ? hu(t, r.value) : $o(r) ? {
  [`Map(${r.size})`]: [...r.entries()].reduce(
    (i, [s, c], f) => (i[cs(s, f) + " =>"] = c, i),
    {}
  )
} : Wo(r) ? {
  [`Set(${r.size})`]: [...r.values()].map((i) => cs(i))
} : Wn(r) ? cs(r) : At(r) && !Xe(r) && !du(r) ? String(r) : r, cs = (t, r = "") => {
  var i;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Wn(t) ? `Symbol(${(i = t.description) != null ? i : r})` : t
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let rn;
class mu {
  constructor(r = !1) {
    this.detached = r, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = rn, !r && rn && (this.index = (rn.scopes || (rn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let r, i;
      if (this.scopes)
        for (r = 0, i = this.scopes.length; r < i; r++)
          this.scopes[r].pause();
      for (r = 0, i = this.effects.length; r < i; r++)
        this.effects[r].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let r, i;
      if (this.scopes)
        for (r = 0, i = this.scopes.length; r < i; r++)
          this.scopes[r].resume();
      for (r = 0, i = this.effects.length; r < i; r++)
        this.effects[r].resume();
    }
  }
  run(r) {
    if (this._active) {
      const i = rn;
      try {
        return rn = this, r();
      } finally {
        rn = i;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = rn, rn = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (rn = this.prevScope, this.prevScope = void 0);
  }
  stop(r) {
    if (this._active) {
      this._active = !1;
      let i, s;
      for (i = 0, s = this.effects.length; i < s; i++)
        this.effects[i].stop();
      for (this.effects.length = 0, i = 0, s = this.cleanups.length; i < s; i++)
        this.cleanups[i]();
      if (this.cleanups.length = 0, this.scopes) {
        for (i = 0, s = this.scopes.length; i < s; i++)
          this.scopes[i].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !r) {
        const c = this.parent.scopes.pop();
        c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function vu(t) {
  return new mu(t);
}
function Vs() {
  return rn;
}
function yu(t, r = !1) {
  rn && rn.cleanups.push(t);
}
let Ot;
const ds = /* @__PURE__ */ new WeakSet();
class gu {
  constructor(r) {
    this.fn = r, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, rn && rn.active && rn.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, ds.has(this) && (ds.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || wu(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, ml(this), _u(this);
    const r = Ot, i = Vn;
    Ot = this, Vn = !0;
    try {
      return this.fn();
    } finally {
      Nu(this), Ot = r, Vn = i, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let r = this.deps; r; r = r.nextDep)
        Hs(r);
      this.deps = this.depsTail = void 0, ml(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? ds.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Ns(this) && this.run();
  }
  get dirty() {
    return Ns(this);
  }
}
let bu = 0, Ei, Ii;
function wu(t, r = !1) {
  if (t.flags |= 8, r) {
    t.next = Ii, Ii = t;
    return;
  }
  t.next = Ei, Ei = t;
}
function Ws() {
  bu++;
}
function Gs() {
  if (--bu > 0)
    return;
  if (Ii) {
    let r = Ii;
    for (Ii = void 0; r; ) {
      const i = r.next;
      r.next = void 0, r.flags &= -9, r = i;
    }
  }
  let t;
  for (; Ei; ) {
    let r = Ei;
    for (Ei = void 0; r; ) {
      const i = r.next;
      if (r.next = void 0, r.flags &= -9, r.flags & 1)
        try {
          r.trigger();
        } catch (s) {
          t || (t = s);
        }
      r = i;
    }
  }
  if (t) throw t;
}
function _u(t) {
  for (let r = t.deps; r; r = r.nextDep)
    r.version = -1, r.prevActiveLink = r.dep.activeLink, r.dep.activeLink = r;
}
function Nu(t) {
  let r, i = t.depsTail, s = i;
  for (; s; ) {
    const c = s.prevDep;
    s.version === -1 ? (s === i && (i = c), Hs(s), Vc(s)) : r = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = c;
  }
  t.deps = r, t.depsTail = i;
}
function Ns(t) {
  for (let r = t.deps; r; r = r.nextDep)
    if (r.dep.version !== r.version || r.dep.computed && (xu(r.dep.computed) || r.dep.version !== r.version))
      return !0;
  return !!t._dirty;
}
function xu(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === ji) || (t.globalVersion = ji, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !Ns(t))))
    return;
  t.flags |= 2;
  const r = t.dep, i = Ot, s = Vn;
  Ot = t, Vn = !0;
  try {
    _u(t);
    const c = t.fn(t._value);
    (r.version === 0 || Kr(c, t._value)) && (t.flags |= 128, t._value = c, r.version++);
  } catch (c) {
    throw r.version++, c;
  } finally {
    Ot = i, Vn = s, Nu(t), t.flags &= -3;
  }
}
function Hs(t, r = !1) {
  const { dep: i, prevSub: s, nextSub: c } = t;
  if (s && (s.nextSub = c, t.prevSub = void 0), c && (c.prevSub = s, t.nextSub = void 0), i.subs === t && (i.subs = s, !s && i.computed)) {
    i.computed.flags &= -5;
    for (let f = i.computed.deps; f; f = f.nextDep)
      Hs(f, !0);
  }
  !r && !--i.sc && i.map && i.map.delete(i.key);
}
function Vc(t) {
  const { prevDep: r, nextDep: i } = t;
  r && (r.nextDep = i, t.prevDep = void 0), i && (i.prevDep = r, t.nextDep = void 0);
}
let Vn = !0;
const Ru = [];
function Pr() {
  Ru.push(Vn), Vn = !1;
}
function Sr() {
  const t = Ru.pop();
  Vn = t === void 0 ? !0 : t;
}
function ml(t) {
  const { cleanup: r } = t;
  if (t.cleanup = void 0, r) {
    const i = Ot;
    Ot = void 0;
    try {
      r();
    } finally {
      Ot = i;
    }
  }
}
let ji = 0;
class Wc {
  constructor(r, i) {
    this.sub = r, this.dep = i, this.version = i.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class Ys {
  // TODO isolatedDeclarations "__v_skip"
  constructor(r) {
    this.computed = r, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(r) {
    if (!Ot || !Vn || Ot === this.computed)
      return;
    let i = this.activeLink;
    if (i === void 0 || i.sub !== Ot)
      i = this.activeLink = new Wc(Ot, this), Ot.deps ? (i.prevDep = Ot.depsTail, Ot.depsTail.nextDep = i, Ot.depsTail = i) : Ot.deps = Ot.depsTail = i, Cu(i);
    else if (i.version === -1 && (i.version = this.version, i.nextDep)) {
      const s = i.nextDep;
      s.prevDep = i.prevDep, i.prevDep && (i.prevDep.nextDep = s), i.prevDep = Ot.depsTail, i.nextDep = void 0, Ot.depsTail.nextDep = i, Ot.depsTail = i, Ot.deps === i && (Ot.deps = s);
    }
    return i;
  }
  trigger(r) {
    this.version++, ji++, this.notify(r);
  }
  notify(r) {
    Ws();
    try {
      for (let i = this.subs; i; i = i.prevSub)
        i.sub.notify() && i.sub.dep.notify();
    } finally {
      Gs();
    }
  }
}
function Cu(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const r = t.dep.computed;
    if (r && !t.dep.subs) {
      r.flags |= 20;
      for (let s = r.deps; s; s = s.nextDep)
        Cu(s);
    }
    const i = t.dep.subs;
    i !== t && (t.prevSub = i, i && (i.nextSub = t)), t.dep.subs = t;
  }
}
const da = /* @__PURE__ */ new WeakMap(), To = Symbol(
  ""
), xs = Symbol(
  ""
), $i = Symbol(
  ""
);
function on(t, r, i) {
  if (Vn && Ot) {
    let s = da.get(t);
    s || da.set(t, s = /* @__PURE__ */ new Map());
    let c = s.get(i);
    c || (s.set(i, c = new Ys()), c.map = s, c.key = i), c.track();
  }
}
function Tr(t, r, i, s, c, f) {
  const u = da.get(t);
  if (!u) {
    ji++;
    return;
  }
  const p = (v) => {
    v && v.trigger();
  };
  if (Ws(), r === "clear")
    u.forEach(p);
  else {
    const v = Xe(t), k = v && qs(i);
    if (v && i === "length") {
      const D = Number(s);
      u.forEach(($, U) => {
        (U === "length" || U === $i || !Wn(U) && U >= D) && p($);
      });
    } else
      switch ((i !== void 0 || u.has(void 0)) && p(u.get(i)), k && p(u.get($i)), r) {
        case "add":
          v ? k && p(u.get("length")) : (p(u.get(To)), $o(t) && p(u.get(xs)));
          break;
        case "delete":
          v || (p(u.get(To)), $o(t) && p(u.get(xs)));
          break;
        case "set":
          $o(t) && p(u.get(To));
          break;
      }
  }
  Gs();
}
function Gc(t, r) {
  const i = da.get(t);
  return i && i.get(r);
}
function So(t) {
  const r = yt(t);
  return r === t ? r : (on(r, "iterate", $i), Pn(t) ? r : r.map(nn));
}
function Ca(t) {
  return on(t = yt(t), "iterate", $i), t;
}
const Hc = {
  __proto__: null,
  [Symbol.iterator]() {
    return fs(this, Symbol.iterator, nn);
  },
  concat(...t) {
    return So(this).concat(
      ...t.map((r) => Xe(r) ? So(r) : r)
    );
  },
  entries() {
    return fs(this, "entries", (t) => (t[1] = nn(t[1]), t));
  },
  every(t, r) {
    return Rr(this, "every", t, r, void 0, arguments);
  },
  filter(t, r) {
    return Rr(this, "filter", t, r, (i) => i.map(nn), arguments);
  },
  find(t, r) {
    return Rr(this, "find", t, r, nn, arguments);
  },
  findIndex(t, r) {
    return Rr(this, "findIndex", t, r, void 0, arguments);
  },
  findLast(t, r) {
    return Rr(this, "findLast", t, r, nn, arguments);
  },
  findLastIndex(t, r) {
    return Rr(this, "findLastIndex", t, r, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, r) {
    return Rr(this, "forEach", t, r, void 0, arguments);
  },
  includes(...t) {
    return ps(this, "includes", t);
  },
  indexOf(...t) {
    return ps(this, "indexOf", t);
  },
  join(t) {
    return So(this).join(t);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...t) {
    return ps(this, "lastIndexOf", t);
  },
  map(t, r) {
    return Rr(this, "map", t, r, void 0, arguments);
  },
  pop() {
    return Ri(this, "pop");
  },
  push(...t) {
    return Ri(this, "push", t);
  },
  reduce(t, ...r) {
    return vl(this, "reduce", t, r);
  },
  reduceRight(t, ...r) {
    return vl(this, "reduceRight", t, r);
  },
  shift() {
    return Ri(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, r) {
    return Rr(this, "some", t, r, void 0, arguments);
  },
  splice(...t) {
    return Ri(this, "splice", t);
  },
  toReversed() {
    return So(this).toReversed();
  },
  toSorted(t) {
    return So(this).toSorted(t);
  },
  toSpliced(...t) {
    return So(this).toSpliced(...t);
  },
  unshift(...t) {
    return Ri(this, "unshift", t);
  },
  values() {
    return fs(this, "values", nn);
  }
};
function fs(t, r, i) {
  const s = Ca(t), c = s[r]();
  return s !== t && !Pn(t) && (c._next = c.next, c.next = () => {
    const f = c._next();
    return f.value && (f.value = i(f.value)), f;
  }), c;
}
const Yc = Array.prototype;
function Rr(t, r, i, s, c, f) {
  const u = Ca(t), p = u !== t && !Pn(t), v = u[r];
  if (v !== Yc[r]) {
    const $ = v.apply(t, f);
    return p ? nn($) : $;
  }
  let k = i;
  u !== t && (p ? k = function($, U) {
    return i.call(this, nn($), U, t);
  } : i.length > 2 && (k = function($, U) {
    return i.call(this, $, U, t);
  }));
  const D = v.call(u, k, s);
  return p && c ? c(D) : D;
}
function vl(t, r, i, s) {
  const c = Ca(t);
  let f = i;
  return c !== t && (Pn(t) ? i.length > 3 && (f = function(u, p, v) {
    return i.call(this, u, p, v, t);
  }) : f = function(u, p, v) {
    return i.call(this, u, nn(p), v, t);
  }), c[r](f, ...s);
}
function ps(t, r, i) {
  const s = yt(t);
  on(s, "iterate", $i);
  const c = s[r](...i);
  return (c === -1 || c === !1) && zs(i[0]) ? (i[0] = yt(i[0]), s[r](...i)) : c;
}
function Ri(t, r, i = []) {
  Pr(), Ws();
  const s = yt(t)[r].apply(t, i);
  return Gs(), Sr(), s;
}
const zc = /* @__PURE__ */ Ms("__proto__,__v_isRef,__isVue"), Ou = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Wn)
);
function Xc(t) {
  Wn(t) || (t = String(t));
  const r = yt(this);
  return on(r, "has", t), r.hasOwnProperty(t);
}
class Tu {
  constructor(r = !1, i = !1) {
    this._isReadonly = r, this._isShallow = i;
  }
  get(r, i, s) {
    if (i === "__v_skip") return r.__v_skip;
    const c = this._isReadonly, f = this._isShallow;
    if (i === "__v_isReactive")
      return !c;
    if (i === "__v_isReadonly")
      return c;
    if (i === "__v_isShallow")
      return f;
    if (i === "__v_raw")
      return s === (c ? f ? Su : Pu : f ? Du : Au).get(r) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(r) === Object.getPrototypeOf(s) ? r : void 0;
    const u = Xe(r);
    if (!c) {
      let v;
      if (u && (v = Hc[i]))
        return v;
      if (i === "hasOwnProperty")
        return Xc;
    }
    const p = Reflect.get(
      r,
      i,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      St(r) ? r : s
    );
    return (Wn(i) ? Ou.has(i) : zc(i)) || (c || on(r, "get", i), f) ? p : St(p) ? u && qs(i) ? p : p.value : At(p) ? c ? Lu(p) : Ui(p) : p;
  }
}
class Eu extends Tu {
  constructor(r = !1) {
    super(!1, r);
  }
  set(r, i, s, c) {
    let f = r[i];
    if (!this._isShallow) {
      const v = qr(f);
      if (!Pn(s) && !qr(s) && (f = yt(f), s = yt(s)), !Xe(r) && St(f) && !St(s))
        return v ? !1 : (f.value = s, !0);
    }
    const u = Xe(r) && qs(i) ? Number(i) < r.length : wt(r, i), p = Reflect.set(
      r,
      i,
      s,
      St(r) ? r : c
    );
    return r === yt(c) && (u ? Kr(s, f) && Tr(r, "set", i, s) : Tr(r, "add", i, s)), p;
  }
  deleteProperty(r, i) {
    const s = wt(r, i);
    r[i];
    const c = Reflect.deleteProperty(r, i);
    return c && s && Tr(r, "delete", i, void 0), c;
  }
  has(r, i) {
    const s = Reflect.has(r, i);
    return (!Wn(i) || !Ou.has(i)) && on(r, "has", i), s;
  }
  ownKeys(r) {
    return on(
      r,
      "iterate",
      Xe(r) ? "length" : To
    ), Reflect.ownKeys(r);
  }
}
class Iu extends Tu {
  constructor(r = !1) {
    super(!0, r);
  }
  set(r, i) {
    return !0;
  }
  deleteProperty(r, i) {
    return !0;
  }
}
const Qc = /* @__PURE__ */ new Eu(), Jc = /* @__PURE__ */ new Iu(), Zc = /* @__PURE__ */ new Eu(!0), ed = /* @__PURE__ */ new Iu(!0), Rs = (t) => t, Yi = (t) => Reflect.getPrototypeOf(t);
function td(t, r, i) {
  return function(...s) {
    const c = this.__v_raw, f = yt(c), u = $o(f), p = t === "entries" || t === Symbol.iterator && u, v = t === "keys" && u, k = c[t](...s), D = i ? Rs : r ? fa : nn;
    return !r && on(
      f,
      "iterate",
      v ? xs : To
    ), {
      // iterator protocol
      next() {
        const { value: $, done: U } = k.next();
        return U ? { value: $, done: U } : {
          value: p ? [D($[0]), D($[1])] : D($),
          done: U
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function zi(t) {
  return function(...r) {
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function nd(t, r) {
  const i = {
    get(c) {
      const f = this.__v_raw, u = yt(f), p = yt(c);
      t || (Kr(c, p) && on(u, "get", c), on(u, "get", p));
      const { has: v } = Yi(u), k = r ? Rs : t ? fa : nn;
      if (v.call(u, c))
        return k(f.get(c));
      if (v.call(u, p))
        return k(f.get(p));
      f !== u && f.get(c);
    },
    get size() {
      const c = this.__v_raw;
      return !t && on(yt(c), "iterate", To), Reflect.get(c, "size", c);
    },
    has(c) {
      const f = this.__v_raw, u = yt(f), p = yt(c);
      return t || (Kr(c, p) && on(u, "has", c), on(u, "has", p)), c === p ? f.has(c) : f.has(c) || f.has(p);
    },
    forEach(c, f) {
      const u = this, p = u.__v_raw, v = yt(p), k = r ? Rs : t ? fa : nn;
      return !t && on(v, "iterate", To), p.forEach((D, $) => c.call(f, k(D), k($), u));
    }
  };
  return an(
    i,
    t ? {
      add: zi("add"),
      set: zi("set"),
      delete: zi("delete"),
      clear: zi("clear")
    } : {
      add(c) {
        !r && !Pn(c) && !qr(c) && (c = yt(c));
        const f = yt(this);
        return Yi(f).has.call(f, c) || (f.add(c), Tr(f, "add", c, c)), this;
      },
      set(c, f) {
        !r && !Pn(f) && !qr(f) && (f = yt(f));
        const u = yt(this), { has: p, get: v } = Yi(u);
        let k = p.call(u, c);
        k || (c = yt(c), k = p.call(u, c));
        const D = v.call(u, c);
        return u.set(c, f), k ? Kr(f, D) && Tr(u, "set", c, f) : Tr(u, "add", c, f), this;
      },
      delete(c) {
        const f = yt(this), { has: u, get: p } = Yi(f);
        let v = u.call(f, c);
        v || (c = yt(c), v = u.call(f, c)), p && p.call(f, c);
        const k = f.delete(c);
        return v && Tr(f, "delete", c, void 0), k;
      },
      clear() {
        const c = yt(this), f = c.size !== 0, u = c.clear();
        return f && Tr(
          c,
          "clear",
          void 0,
          void 0
        ), u;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((c) => {
    i[c] = td(c, t, r);
  }), i;
}
function Oa(t, r) {
  const i = nd(t, r);
  return (s, c, f) => c === "__v_isReactive" ? !t : c === "__v_isReadonly" ? t : c === "__v_raw" ? s : Reflect.get(
    wt(i, c) && c in s ? i : s,
    c,
    f
  );
}
const rd = {
  get: /* @__PURE__ */ Oa(!1, !1)
}, od = {
  get: /* @__PURE__ */ Oa(!1, !0)
}, id = {
  get: /* @__PURE__ */ Oa(!0, !1)
}, ad = {
  get: /* @__PURE__ */ Oa(!0, !0)
}, Au = /* @__PURE__ */ new WeakMap(), Du = /* @__PURE__ */ new WeakMap(), Pu = /* @__PURE__ */ new WeakMap(), Su = /* @__PURE__ */ new WeakMap();
function sd(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function ld(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : sd(Sc(t));
}
function Ui(t) {
  return qr(t) ? t : Ta(
    t,
    !1,
    Qc,
    rd,
    Au
  );
}
function ud(t) {
  return Ta(
    t,
    !1,
    Zc,
    od,
    Du
  );
}
function Lu(t) {
  return Ta(
    t,
    !0,
    Jc,
    id,
    Pu
  );
}
function cd(t) {
  return Ta(
    t,
    !0,
    ed,
    ad,
    Su
  );
}
function Ta(t, r, i, s, c) {
  if (!At(t) || t.__v_raw && !(r && t.__v_isReactive))
    return t;
  const f = ld(t);
  if (f === 0)
    return t;
  const u = c.get(t);
  if (u)
    return u;
  const p = new Proxy(
    t,
    f === 2 ? s : i
  );
  return c.set(t, p), p;
}
function Ar(t) {
  return qr(t) ? Ar(t.__v_raw) : !!(t && t.__v_isReactive);
}
function qr(t) {
  return !!(t && t.__v_isReadonly);
}
function Pn(t) {
  return !!(t && t.__v_isShallow);
}
function zs(t) {
  return t ? !!t.__v_raw : !1;
}
function yt(t) {
  const r = t && t.__v_raw;
  return r ? yt(r) : t;
}
function Ea(t) {
  return !wt(t, "__v_skip") && Object.isExtensible(t) && _s(t, "__v_skip", !0), t;
}
const nn = (t) => At(t) ? Ui(t) : t, fa = (t) => At(t) ? Lu(t) : t;
function St(t) {
  return t ? t.__v_isRef === !0 : !1;
}
function Ke(t) {
  return ku(t, !1);
}
function Dn(t) {
  return ku(t, !0);
}
function ku(t, r) {
  return St(t) ? t : new dd(t, r);
}
class dd {
  constructor(r, i) {
    this.dep = new Ys(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = i ? r : yt(r), this._value = i ? r : nn(r), this.__v_isShallow = i;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(r) {
    const i = this._rawValue, s = this.__v_isShallow || Pn(r) || qr(r);
    r = s ? r : yt(r), Kr(r, i) && (this._rawValue = r, this._value = s ? r : nn(r), this.dep.trigger());
  }
}
function _e(t) {
  return St(t) ? t.value : t;
}
function fd(t) {
  return nt(t) ? t() : _e(t);
}
const pd = {
  get: (t, r, i) => r === "__v_raw" ? t : _e(Reflect.get(t, r, i)),
  set: (t, r, i, s) => {
    const c = t[r];
    return St(c) && !St(i) ? (c.value = i, !0) : Reflect.set(t, r, i, s);
  }
};
function ju(t) {
  return Ar(t) ? t : new Proxy(t, pd);
}
function hd(t) {
  const r = Xe(t) ? new Array(t.length) : {};
  for (const i in t)
    r[i] = $u(t, i);
  return r;
}
class md {
  constructor(r, i, s) {
    this._object = r, this._key = i, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const r = this._object[this._key];
    return this._value = r === void 0 ? this._defaultValue : r;
  }
  set value(r) {
    this._object[this._key] = r;
  }
  get dep() {
    return Gc(yt(this._object), this._key);
  }
}
class vd {
  constructor(r) {
    this._getter = r, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function yd(t, r, i) {
  return St(t) ? t : nt(t) ? new vd(t) : At(t) && arguments.length > 1 ? $u(t, r, i) : Ke(t);
}
function $u(t, r, i) {
  const s = t[r];
  return St(s) ? s : new md(t, r, i);
}
class gd {
  constructor(r, i, s) {
    this.fn = r, this.setter = i, this._value = void 0, this.dep = new Ys(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = ji - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !i, this.isSSR = s;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    Ot !== this)
      return wu(this, !0), !0;
  }
  get value() {
    const r = this.dep.track();
    return xu(this), r && (r.version = this.dep.version), this._value;
  }
  set value(r) {
    this.setter && this.setter(r);
  }
}
function bd(t, r, i = !1) {
  let s, c;
  return nt(t) ? s = t : (s = t.get, c = t.set), new gd(s, c, i);
}
const Xi = {}, pa = /* @__PURE__ */ new WeakMap();
let Oo;
function wd(t, r = !1, i = Oo) {
  if (i) {
    let s = pa.get(i);
    s || pa.set(i, s = []), s.push(t);
  }
}
function _d(t, r, i = Nt) {
  const { immediate: s, deep: c, once: f, scheduler: u, augmentJob: p, call: v } = i, k = (K) => c ? K : Pn(K) || c === !1 || c === 0 ? Er(K, 1) : Er(K);
  let D, $, U, W, A = !1, P = !1;
  if (St(t) ? ($ = () => t.value, A = Pn(t)) : Ar(t) ? ($ = () => k(t), A = !0) : Xe(t) ? (P = !0, A = t.some((K) => Ar(K) || Pn(K)), $ = () => t.map((K) => {
    if (St(K))
      return K.value;
    if (Ar(K))
      return k(K);
    if (nt(K))
      return v ? v(K, 2) : K();
  })) : nt(t) ? r ? $ = v ? () => v(t, 2) : t : $ = () => {
    if (U) {
      Pr();
      try {
        U();
      } finally {
        Sr();
      }
    }
    const K = Oo;
    Oo = D;
    try {
      return v ? v(t, 3, [W]) : t(W);
    } finally {
      Oo = K;
    }
  } : $ = Xn, r && c) {
    const K = $, we = c === !0 ? 1 / 0 : c;
    $ = () => Er(K(), we);
  }
  const B = Vs(), X = () => {
    D.stop(), B && B.active && Ks(B.effects, D);
  };
  if (f && r) {
    const K = r;
    r = (...we) => {
      K(...we), X();
    };
  }
  let F = P ? new Array(t.length).fill(Xi) : Xi;
  const E = (K) => {
    if (!(!(D.flags & 1) || !D.dirty && !K))
      if (r) {
        const we = D.run();
        if (c || A || (P ? we.some((de, ge) => Kr(de, F[ge])) : Kr(we, F))) {
          U && U();
          const de = Oo;
          Oo = D;
          try {
            const ge = [
              we,
              // pass undefined as the old value when it's changed for the first time
              F === Xi ? void 0 : P && F[0] === Xi ? [] : F,
              W
            ];
            F = we, v ? v(r, 3, ge) : (
              // @ts-expect-error
              r(...ge)
            );
          } finally {
            Oo = de;
          }
        }
      } else
        D.run();
  };
  return p && p(E), D = new gu($), D.scheduler = u ? () => u(E, !1) : E, W = (K) => wd(K, !1, D), U = D.onStop = () => {
    const K = pa.get(D);
    if (K) {
      if (v)
        v(K, 4);
      else
        for (const we of K) we();
      pa.delete(D);
    }
  }, r ? s ? E(!0) : F = D.run() : u ? u(E.bind(null, !0), !0) : D.run(), X.pause = D.pause.bind(D), X.resume = D.resume.bind(D), X.stop = X, X;
}
function Er(t, r = 1 / 0, i) {
  if (r <= 0 || !At(t) || t.__v_skip || (i = i || /* @__PURE__ */ new Set(), i.has(t)))
    return t;
  if (i.add(t), r--, St(t))
    Er(t.value, r, i);
  else if (Xe(t))
    for (let s = 0; s < t.length; s++)
      Er(t[s], r, i);
  else if (Wo(t) || $o(t))
    t.forEach((s) => {
      Er(s, r, i);
    });
  else if (du(t)) {
    for (const s in t)
      Er(t[s], r, i);
    for (const s of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, s) && Er(t[s], r, i);
  }
  return t;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Vi(t, r, i, s) {
  try {
    return s ? t(...s) : t();
  } catch (c) {
    Ia(c, r, i);
  }
}
function Qn(t, r, i, s) {
  if (nt(t)) {
    const c = Vi(t, r, i, s);
    return c && uu(c) && c.catch((f) => {
      Ia(f, r, i);
    }), c;
  }
  if (Xe(t)) {
    const c = [];
    for (let f = 0; f < t.length; f++)
      c.push(Qn(t[f], r, i, s));
    return c;
  }
}
function Ia(t, r, i, s = !0) {
  const c = r ? r.vnode : null, { errorHandler: f, throwUnhandledErrorInProduction: u } = r && r.appContext.config || Nt;
  if (r) {
    let p = r.parent;
    const v = r.proxy, k = `https://vuejs.org/error-reference/#runtime-${i}`;
    for (; p; ) {
      const D = p.ec;
      if (D) {
        for (let $ = 0; $ < D.length; $++)
          if (D[$](t, v, k) === !1)
            return;
      }
      p = p.parent;
    }
    if (f) {
      Pr(), Vi(f, null, 10, [
        t,
        v,
        k
      ]), Sr();
      return;
    }
  }
  Nd(t, i, c, s, u);
}
function Nd(t, r, i, s = !0, c = !1) {
  if (c)
    throw t;
  console.error(t);
}
const gn = [];
let Yn = -1;
const Fo = [];
let Mr = null, ko = 0;
const Fu = /* @__PURE__ */ Promise.resolve();
let ha = null;
function Xs(t) {
  const r = ha || Fu;
  return t ? r.then(this ? t.bind(this) : t) : r;
}
function xd(t) {
  let r = Yn + 1, i = gn.length;
  for (; r < i; ) {
    const s = r + i >>> 1, c = gn[s], f = Fi(c);
    f < t || f === t && c.flags & 2 ? r = s + 1 : i = s;
  }
  return r;
}
function Qs(t) {
  if (!(t.flags & 1)) {
    const r = Fi(t), i = gn[gn.length - 1];
    !i || // fast path when the job id is larger than the tail
    !(t.flags & 2) && r >= Fi(i) ? gn.push(t) : gn.splice(xd(r), 0, t), t.flags |= 1, Mu();
  }
}
function Mu() {
  ha || (ha = Fu.then(Ku));
}
function Rd(t) {
  Xe(t) ? Fo.push(...t) : Mr && t.id === -1 ? Mr.splice(ko + 1, 0, t) : t.flags & 1 || (Fo.push(t), t.flags |= 1), Mu();
}
function yl(t, r, i = Yn + 1) {
  for (; i < gn.length; i++) {
    const s = gn[i];
    if (s && s.flags & 2) {
      if (t && s.id !== t.uid)
        continue;
      gn.splice(i, 1), i--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2);
    }
  }
}
function Bu(t) {
  if (Fo.length) {
    const r = [...new Set(Fo)].sort(
      (i, s) => Fi(i) - Fi(s)
    );
    if (Fo.length = 0, Mr) {
      Mr.push(...r);
      return;
    }
    for (Mr = r, ko = 0; ko < Mr.length; ko++) {
      const i = Mr[ko];
      i.flags & 4 && (i.flags &= -2), i.flags & 8 || i(), i.flags &= -2;
    }
    Mr = null, ko = 0;
  }
}
const Fi = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function Ku(t) {
  try {
    for (Yn = 0; Yn < gn.length; Yn++) {
      const r = gn[Yn];
      r && !(r.flags & 8) && (r.flags & 4 && (r.flags &= -2), Vi(
        r,
        r.i,
        r.i ? 15 : 14
      ), r.flags & 4 || (r.flags &= -2));
    }
  } finally {
    for (; Yn < gn.length; Yn++) {
      const r = gn[Yn];
      r && (r.flags &= -2);
    }
    Yn = -1, gn.length = 0, Bu(), ha = null, (gn.length || Fo.length) && Ku();
  }
}
let Gt = null, qu = null;
function ma(t) {
  const r = Gt;
  return Gt = t, qu = t && t.type.__scopeId || null, r;
}
function Cs(t, r = Gt, i) {
  if (!r || t._n)
    return t;
  const s = (...c) => {
    s._d && Dl(-1);
    const f = ma(r);
    let u;
    try {
      u = t(...c);
    } finally {
      ma(f), s._d && Dl(1);
    }
    return u;
  };
  return s._n = !0, s._c = !0, s._d = !0, s;
}
function Ye(t, r) {
  if (Gt === null)
    return t;
  const i = La(Gt), s = t.dirs || (t.dirs = []);
  for (let c = 0; c < r.length; c++) {
    let [f, u, p, v = Nt] = r[c];
    f && (nt(f) && (f = {
      mounted: f,
      updated: f
    }), f.deep && Er(u), s.push({
      dir: f,
      instance: i,
      value: u,
      oldValue: void 0,
      arg: p,
      modifiers: v
    }));
  }
  return t;
}
function Ro(t, r, i, s) {
  const c = t.dirs, f = r && r.dirs;
  for (let u = 0; u < c.length; u++) {
    const p = c[u];
    f && (p.oldValue = f[u].value);
    let v = p.dir[s];
    v && (Pr(), Qn(v, i, 8, [
      t.el,
      p,
      t,
      r
    ]), Sr());
  }
}
const Uu = Symbol("_vte"), Cd = (t) => t.__isTeleport, Ai = (t) => t && (t.disabled || t.disabled === ""), gl = (t) => t && (t.defer || t.defer === ""), bl = (t) => typeof SVGElement < "u" && t instanceof SVGElement, wl = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, Os = (t, r) => {
  const i = t && t.to;
  return kt(i) ? r ? r(i) : null : i;
}, Vu = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, r, i, s, c, f, u, p, v, k) {
    const {
      mc: D,
      pc: $,
      pbc: U,
      o: { insert: W, querySelector: A, createText: P, createComment: B }
    } = k, X = Ai(r.props);
    let { shapeFlag: F, children: E, dynamicChildren: K } = r;
    if (t == null) {
      const we = r.el = P(""), de = r.anchor = P("");
      W(we, i, s), W(de, i, s);
      const ge = (Y, oe) => {
        F & 16 && (c && c.isCE && (c.ce._teleportTarget = Y), D(
          E,
          Y,
          oe,
          c,
          f,
          u,
          p,
          v
        ));
      }, Ue = () => {
        const Y = r.target = Os(r.props, A), oe = Wu(Y, r, P, W);
        Y && (u !== "svg" && bl(Y) ? u = "svg" : u !== "mathml" && wl(Y) && (u = "mathml"), X || (ge(Y, oe), ra(r, !1)));
      };
      X && (ge(i, de), ra(r, !0)), gl(r.props) ? (r.el.__isMounted = !1, vn(() => {
        Ue(), delete r.el.__isMounted;
      }, f)) : Ue();
    } else {
      if (gl(r.props) && t.el.__isMounted === !1) {
        vn(() => {
          Vu.process(
            t,
            r,
            i,
            s,
            c,
            f,
            u,
            p,
            v,
            k
          );
        }, f);
        return;
      }
      r.el = t.el, r.targetStart = t.targetStart;
      const we = r.anchor = t.anchor, de = r.target = t.target, ge = r.targetAnchor = t.targetAnchor, Ue = Ai(t.props), Y = Ue ? i : de, oe = Ue ? we : ge;
      if (u === "svg" || bl(de) ? u = "svg" : (u === "mathml" || wl(de)) && (u = "mathml"), K ? (U(
        t.dynamicChildren,
        K,
        Y,
        c,
        f,
        u,
        p
      ), nl(t, r, !0)) : v || $(
        t,
        r,
        Y,
        oe,
        c,
        f,
        u,
        p,
        !1
      ), X)
        Ue ? r.props && t.props && r.props.to !== t.props.to && (r.props.to = t.props.to) : Qi(
          r,
          i,
          we,
          k,
          1
        );
      else if ((r.props && r.props.to) !== (t.props && t.props.to)) {
        const ce = r.target = Os(
          r.props,
          A
        );
        ce && Qi(
          r,
          ce,
          null,
          k,
          0
        );
      } else Ue && Qi(
        r,
        de,
        ge,
        k,
        1
      );
      ra(r, X);
    }
  },
  remove(t, r, i, { um: s, o: { remove: c } }, f) {
    const {
      shapeFlag: u,
      children: p,
      anchor: v,
      targetStart: k,
      targetAnchor: D,
      target: $,
      props: U
    } = t;
    if ($ && (c(k), c(D)), f && c(v), u & 16) {
      const W = f || !Ai(U);
      for (let A = 0; A < p.length; A++) {
        const P = p[A];
        s(
          P,
          r,
          i,
          W,
          !!P.dynamicChildren
        );
      }
    }
  },
  move: Qi,
  hydrate: Od
};
function Qi(t, r, i, { o: { insert: s }, m: c }, f = 2) {
  f === 0 && s(t.targetAnchor, r, i);
  const { el: u, anchor: p, shapeFlag: v, children: k, props: D } = t, $ = f === 2;
  if ($ && s(u, r, i), (!$ || Ai(D)) && v & 16)
    for (let U = 0; U < k.length; U++)
      c(
        k[U],
        r,
        i,
        2
      );
  $ && s(p, r, i);
}
function Od(t, r, i, s, c, f, {
  o: { nextSibling: u, parentNode: p, querySelector: v, insert: k, createText: D }
}, $) {
  const U = r.target = Os(
    r.props,
    v
  );
  if (U) {
    const W = Ai(r.props), A = U._lpa || U.firstChild;
    if (r.shapeFlag & 16)
      if (W)
        r.anchor = $(
          u(t),
          r,
          p(t),
          i,
          s,
          c,
          f
        ), r.targetStart = A, r.targetAnchor = A && u(A);
      else {
        r.anchor = u(t);
        let P = A;
        for (; P; ) {
          if (P && P.nodeType === 8) {
            if (P.data === "teleport start anchor")
              r.targetStart = P;
            else if (P.data === "teleport anchor") {
              r.targetAnchor = P, U._lpa = r.targetAnchor && u(r.targetAnchor);
              break;
            }
          }
          P = u(P);
        }
        r.targetAnchor || Wu(U, r, D, k), $(
          A && u(A),
          r,
          U,
          i,
          s,
          c,
          f
        );
      }
    ra(r, W);
  }
  return r.anchor && u(r.anchor);
}
const Ur = Vu;
function ra(t, r) {
  const i = t.ctx;
  if (i && i.ut) {
    let s, c;
    for (r ? (s = t.el, c = t.anchor) : (s = t.targetStart, c = t.targetAnchor); s && s !== c; )
      s.nodeType === 1 && s.setAttribute("data-v-owner", i.uid), s = s.nextSibling;
    i.ut();
  }
}
function Wu(t, r, i, s) {
  const c = r.targetStart = i(""), f = r.targetAnchor = i("");
  return c[Uu] = f, t && (s(c, t), s(f, t)), f;
}
function Js(t, r) {
  t.shapeFlag & 6 && t.component ? (t.transition = r, Js(t.component.subTree, r)) : t.shapeFlag & 128 ? (t.ssContent.transition = r.clone(t.ssContent), t.ssFallback.transition = r.clone(t.ssFallback)) : t.transition = r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function _t(t, r) {
  return nt(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    an({ name: t.name }, r, { setup: t })
  ) : t;
}
function Gu(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
function Td(t) {
  const r = Cf(), i = Dn(null);
  if (r) {
    const c = r.refs === Nt ? r.refs = {} : r.refs;
    Object.defineProperty(c, t, {
      enumerable: !0,
      get: () => i.value,
      set: (f) => i.value = f
    });
  }
  return i;
}
function Di(t, r, i, s, c = !1) {
  if (Xe(t)) {
    t.forEach(
      (A, P) => Di(
        A,
        r && (Xe(r) ? r[P] : r),
        i,
        s,
        c
      )
    );
    return;
  }
  if (Mo(s) && !c) {
    s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && Di(t, r, i, s.component.subTree);
    return;
  }
  const f = s.shapeFlag & 4 ? La(s.component) : s.el, u = c ? null : f, { i: p, r: v } = t, k = r && r.r, D = p.refs === Nt ? p.refs = {} : p.refs, $ = p.setupState, U = yt($), W = $ === Nt ? () => !1 : (A) => wt(U, A);
  if (k != null && k !== v && (kt(k) ? (D[k] = null, W(k) && ($[k] = null)) : St(k) && (k.value = null)), nt(v))
    Vi(v, p, 12, [u, D]);
  else {
    const A = kt(v), P = St(v);
    if (A || P) {
      const B = () => {
        if (t.f) {
          const X = A ? W(v) ? $[v] : D[v] : v.value;
          c ? Xe(X) && Ks(X, f) : Xe(X) ? X.includes(f) || X.push(f) : A ? (D[v] = [f], W(v) && ($[v] = D[v])) : (v.value = [f], t.k && (D[t.k] = v.value));
        } else A ? (D[v] = u, W(v) && ($[v] = u)) : P && (v.value = u, t.k && (D[t.k] = u));
      };
      u ? (B.id = -1, vn(B, i)) : B();
    }
  }
}
Ra().requestIdleCallback;
Ra().cancelIdleCallback;
const Mo = (t) => !!t.type.__asyncLoader, Hu = (t) => t.type.__isKeepAlive;
function Ed(t, r) {
  Yu(t, "a", r);
}
function Id(t, r) {
  Yu(t, "da", r);
}
function Yu(t, r, i = Yt) {
  const s = t.__wdc || (t.__wdc = () => {
    let c = i;
    for (; c; ) {
      if (c.isDeactivated)
        return;
      c = c.parent;
    }
    return t();
  });
  if (Aa(r, s, i), i) {
    let c = i.parent;
    for (; c && c.parent; )
      Hu(c.parent.vnode) && Ad(s, r, i, c), c = c.parent;
  }
}
function Ad(t, r, i, s) {
  const c = Aa(
    r,
    t,
    s,
    !0
    /* prepend */
  );
  Zs(() => {
    Ks(s[r], c);
  }, i);
}
function Aa(t, r, i = Yt, s = !1) {
  if (i) {
    const c = i[t] || (i[t] = []), f = r.__weh || (r.__weh = (...u) => {
      Pr();
      const p = Wi(i), v = Qn(r, i, t, u);
      return p(), Sr(), v;
    });
    return s ? c.unshift(f) : c.push(f), f;
  }
}
const $r = (t) => (r, i = Yt) => {
  (!Bi || t === "sp") && Aa(t, (...s) => r(...s), i);
}, Dd = $r("bm"), Po = $r("m"), Pd = $r(
  "bu"
), Sd = $r("u"), Ld = $r(
  "bum"
), Zs = $r("um"), kd = $r(
  "sp"
), jd = $r("rtg"), $d = $r("rtc");
function Fd(t, r = Yt) {
  Aa("ec", t, r);
}
const Md = "components", zu = Symbol.for("v-ndc");
function Bd(t) {
  return kt(t) ? Kd(Md, t, !1) || t : t || zu;
}
function Kd(t, r, i = !0, s = !1) {
  const c = Gt || Yt;
  if (c) {
    const f = c.type;
    {
      const p = Af(
        f,
        !1
      );
      if (p && (p === r || p === Ln(r) || p === xa(Ln(r))))
        return f;
    }
    const u = (
      // local registration
      // check instance[type] first which is resolved for options API
      _l(c[t] || f[t], r) || // global registration
      _l(c.appContext[t], r)
    );
    return !u && s ? f : u;
  }
}
function _l(t, r) {
  return t && (t[r] || t[Ln(r)] || t[xa(Ln(r))]);
}
function lt(t, r, i, s) {
  let c;
  const f = i, u = Xe(t);
  if (u || kt(t)) {
    const p = u && Ar(t);
    let v = !1, k = !1;
    p && (v = !Pn(t), k = qr(t), t = Ca(t)), c = new Array(t.length);
    for (let D = 0, $ = t.length; D < $; D++)
      c[D] = r(
        v ? k ? fa(nn(t[D])) : nn(t[D]) : t[D],
        D,
        void 0,
        f
      );
  } else if (typeof t == "number") {
    c = new Array(t);
    for (let p = 0; p < t; p++)
      c[p] = r(p + 1, p, void 0, f);
  } else if (At(t))
    if (t[Symbol.iterator])
      c = Array.from(
        t,
        (p, v) => r(p, v, void 0, f)
      );
    else {
      const p = Object.keys(t);
      c = new Array(p.length);
      for (let v = 0, k = p.length; v < k; v++) {
        const D = p[v];
        c[v] = r(t[D], D, v, f);
      }
    }
  else
    c = [];
  return c;
}
function Nl(t, r, i = {}, s, c) {
  if (Gt.ce || Gt.parent && Mo(Gt.parent) && Gt.parent.ce)
    return r !== "default" && (i.name = r), Q(), Lt(
      $e,
      null,
      [ft("slot", i, s)],
      64
    );
  let f = t[r];
  f && f._c && (f._d = !1), Q();
  const u = f && Xu(f(i)), p = i.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  u && u.key, v = Lt(
    $e,
    {
      key: (p && !Wn(p) ? p : `_${r}`) + // #7256 force differentiate fallback content from actual content
      (!u && s ? "_fb" : "")
    },
    u || [],
    u && t._ === 1 ? 64 : -2
  );
  return f && f._c && (f._d = !0), v;
}
function Xu(t) {
  return t.some((r) => ol(r) ? !(r.type === Lr || r.type === $e && !Xu(r.children)) : !0) ? t : null;
}
const Ts = (t) => t ? vc(t) ? La(t) : Ts(t.parent) : null, Pi = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ an(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => Ts(t.parent),
    $root: (t) => Ts(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Ju(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      Qs(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = Xs.bind(t.proxy)),
    $watch: (t) => df.bind(t)
  })
), hs = (t, r) => t !== Nt && !t.__isScriptSetup && wt(t, r), qd = {
  get({ _: t }, r) {
    if (r === "__v_skip")
      return !0;
    const { ctx: i, setupState: s, data: c, props: f, accessCache: u, type: p, appContext: v } = t;
    let k;
    if (r[0] !== "$") {
      const W = u[r];
      if (W !== void 0)
        switch (W) {
          case 1:
            return s[r];
          case 2:
            return c[r];
          case 4:
            return i[r];
          case 3:
            return f[r];
        }
      else {
        if (hs(s, r))
          return u[r] = 1, s[r];
        if (c !== Nt && wt(c, r))
          return u[r] = 2, c[r];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (k = t.propsOptions[0]) && wt(k, r)
        )
          return u[r] = 3, f[r];
        if (i !== Nt && wt(i, r))
          return u[r] = 4, i[r];
        Es && (u[r] = 0);
      }
    }
    const D = Pi[r];
    let $, U;
    if (D)
      return r === "$attrs" && on(t.attrs, "get", ""), D(t);
    if (
      // css module (injected by vue-loader)
      ($ = p.__cssModules) && ($ = $[r])
    )
      return $;
    if (i !== Nt && wt(i, r))
      return u[r] = 4, i[r];
    if (
      // global properties
      U = v.config.globalProperties, wt(U, r)
    )
      return U[r];
  },
  set({ _: t }, r, i) {
    const { data: s, setupState: c, ctx: f } = t;
    return hs(c, r) ? (c[r] = i, !0) : s !== Nt && wt(s, r) ? (s[r] = i, !0) : wt(t.props, r) || r[0] === "$" && r.slice(1) in t ? !1 : (f[r] = i, !0);
  },
  has({
    _: { data: t, setupState: r, accessCache: i, ctx: s, appContext: c, propsOptions: f }
  }, u) {
    let p;
    return !!i[u] || t !== Nt && wt(t, u) || hs(r, u) || (p = f[0]) && wt(p, u) || wt(s, u) || wt(Pi, u) || wt(c.config.globalProperties, u);
  },
  defineProperty(t, r, i) {
    return i.get != null ? t._.accessCache[r] = 0 : wt(i, "value") && this.set(t, r, i.value, null), Reflect.defineProperty(t, r, i);
  }
};
function xl(t) {
  return Xe(t) ? t.reduce(
    (r, i) => (r[i] = null, r),
    {}
  ) : t;
}
let Es = !0;
function Ud(t) {
  const r = Ju(t), i = t.proxy, s = t.ctx;
  Es = !1, r.beforeCreate && Rl(r.beforeCreate, t, "bc");
  const {
    // state
    data: c,
    computed: f,
    methods: u,
    watch: p,
    provide: v,
    inject: k,
    // lifecycle
    created: D,
    beforeMount: $,
    mounted: U,
    beforeUpdate: W,
    updated: A,
    activated: P,
    deactivated: B,
    beforeDestroy: X,
    beforeUnmount: F,
    destroyed: E,
    unmounted: K,
    render: we,
    renderTracked: de,
    renderTriggered: ge,
    errorCaptured: Ue,
    serverPrefetch: Y,
    // public API
    expose: oe,
    inheritAttrs: ce,
    // assets
    components: fe,
    directives: me,
    filters: Pe
  } = r;
  if (k && Vd(k, s, null), u)
    for (const Ne in u) {
      const Fe = u[Ne];
      nt(Fe) && (s[Ne] = Fe.bind(i));
    }
  if (c) {
    const Ne = c.call(i, i);
    At(Ne) && (t.data = Ui(Ne));
  }
  if (Es = !0, f)
    for (const Ne in f) {
      const Fe = f[Ne], pt = nt(Fe) ? Fe.bind(i, i) : nt(Fe.get) ? Fe.get.bind(i, i) : Xn, Me = !nt(Fe) && nt(Fe.set) ? Fe.set.bind(i) : Xn, Qe = He({
        get: pt,
        set: Me
      });
      Object.defineProperty(s, Ne, {
        enumerable: !0,
        configurable: !0,
        get: () => Qe.value,
        set: ($t) => Qe.value = $t
      });
    }
  if (p)
    for (const Ne in p)
      Qu(p[Ne], s, i, Ne);
  if (v) {
    const Ne = nt(v) ? v.call(i) : v;
    Reflect.ownKeys(Ne).forEach((Fe) => {
      Xd(Fe, Ne[Fe]);
    });
  }
  D && Rl(D, t, "c");
  function Se(Ne, Fe) {
    Xe(Fe) ? Fe.forEach((pt) => Ne(pt.bind(i))) : Fe && Ne(Fe.bind(i));
  }
  if (Se(Dd, $), Se(Po, U), Se(Pd, W), Se(Sd, A), Se(Ed, P), Se(Id, B), Se(Fd, Ue), Se($d, de), Se(jd, ge), Se(Ld, F), Se(Zs, K), Se(kd, Y), Xe(oe))
    if (oe.length) {
      const Ne = t.exposed || (t.exposed = {});
      oe.forEach((Fe) => {
        Object.defineProperty(Ne, Fe, {
          get: () => i[Fe],
          set: (pt) => i[Fe] = pt
        });
      });
    } else t.exposed || (t.exposed = {});
  we && t.render === Xn && (t.render = we), ce != null && (t.inheritAttrs = ce), fe && (t.components = fe), me && (t.directives = me), Y && Gu(t);
}
function Vd(t, r, i = Xn) {
  Xe(t) && (t = Is(t));
  for (const s in t) {
    const c = t[s];
    let f;
    At(c) ? "default" in c ? f = Si(
      c.from || s,
      c.default,
      !0
    ) : f = Si(c.from || s) : f = Si(c), St(f) ? Object.defineProperty(r, s, {
      enumerable: !0,
      configurable: !0,
      get: () => f.value,
      set: (u) => f.value = u
    }) : r[s] = f;
  }
}
function Rl(t, r, i) {
  Qn(
    Xe(t) ? t.map((s) => s.bind(r.proxy)) : t.bind(r.proxy),
    r,
    i
  );
}
function Qu(t, r, i, s) {
  let c = s.includes(".") ? uc(i, s) : () => i[s];
  if (kt(t)) {
    const f = r[t];
    nt(f) && qt(c, f);
  } else if (nt(t))
    qt(c, t.bind(i));
  else if (At(t))
    if (Xe(t))
      t.forEach((f) => Qu(f, r, i, s));
    else {
      const f = nt(t.handler) ? t.handler.bind(i) : r[t.handler];
      nt(f) && qt(c, f, t);
    }
}
function Ju(t) {
  const r = t.type, { mixins: i, extends: s } = r, {
    mixins: c,
    optionsCache: f,
    config: { optionMergeStrategies: u }
  } = t.appContext, p = f.get(r);
  let v;
  return p ? v = p : !c.length && !i && !s ? v = r : (v = {}, c.length && c.forEach(
    (k) => va(v, k, u, !0)
  ), va(v, r, u)), At(r) && f.set(r, v), v;
}
function va(t, r, i, s = !1) {
  const { mixins: c, extends: f } = r;
  f && va(t, f, i, !0), c && c.forEach(
    (u) => va(t, u, i, !0)
  );
  for (const u in r)
    if (!(s && u === "expose")) {
      const p = Wd[u] || i && i[u];
      t[u] = p ? p(t[u], r[u]) : r[u];
    }
  return t;
}
const Wd = {
  data: Cl,
  props: Ol,
  emits: Ol,
  // objects
  methods: Oi,
  computed: Oi,
  // lifecycle
  beforeCreate: mn,
  created: mn,
  beforeMount: mn,
  mounted: mn,
  beforeUpdate: mn,
  updated: mn,
  beforeDestroy: mn,
  beforeUnmount: mn,
  destroyed: mn,
  unmounted: mn,
  activated: mn,
  deactivated: mn,
  errorCaptured: mn,
  serverPrefetch: mn,
  // assets
  components: Oi,
  directives: Oi,
  // watch
  watch: Hd,
  // provide / inject
  provide: Cl,
  inject: Gd
};
function Cl(t, r) {
  return r ? t ? function() {
    return an(
      nt(t) ? t.call(this, this) : t,
      nt(r) ? r.call(this, this) : r
    );
  } : r : t;
}
function Gd(t, r) {
  return Oi(Is(t), Is(r));
}
function Is(t) {
  if (Xe(t)) {
    const r = {};
    for (let i = 0; i < t.length; i++)
      r[t[i]] = t[i];
    return r;
  }
  return t;
}
function mn(t, r) {
  return t ? [...new Set([].concat(t, r))] : r;
}
function Oi(t, r) {
  return t ? an(/* @__PURE__ */ Object.create(null), t, r) : r;
}
function Ol(t, r) {
  return t ? Xe(t) && Xe(r) ? [.../* @__PURE__ */ new Set([...t, ...r])] : an(
    /* @__PURE__ */ Object.create(null),
    xl(t),
    xl(r ?? {})
  ) : r;
}
function Hd(t, r) {
  if (!t) return r;
  if (!r) return t;
  const i = an(/* @__PURE__ */ Object.create(null), t);
  for (const s in r)
    i[s] = mn(t[s], r[s]);
  return i;
}
function Zu() {
  return {
    app: null,
    config: {
      isNativeTag: Dc,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Yd = 0;
function zd(t, r) {
  return function(s, c = null) {
    nt(s) || (s = an({}, s)), c != null && !At(c) && (c = null);
    const f = Zu(), u = /* @__PURE__ */ new WeakSet(), p = [];
    let v = !1;
    const k = f.app = {
      _uid: Yd++,
      _component: s,
      _props: c,
      _container: null,
      _context: f,
      _instance: null,
      version: Pf,
      get config() {
        return f.config;
      },
      set config(D) {
      },
      use(D, ...$) {
        return u.has(D) || (D && nt(D.install) ? (u.add(D), D.install(k, ...$)) : nt(D) && (u.add(D), D(k, ...$))), k;
      },
      mixin(D) {
        return f.mixins.includes(D) || f.mixins.push(D), k;
      },
      component(D, $) {
        return $ ? (f.components[D] = $, k) : f.components[D];
      },
      directive(D, $) {
        return $ ? (f.directives[D] = $, k) : f.directives[D];
      },
      mount(D, $, U) {
        if (!v) {
          const W = k._ceVNode || ft(s, c);
          return W.appContext = f, U === !0 ? U = "svg" : U === !1 && (U = void 0), t(W, D, U), v = !0, k._container = D, D.__vue_app__ = k, La(W.component);
        }
      },
      onUnmount(D) {
        p.push(D);
      },
      unmount() {
        v && (Qn(
          p,
          k._instance,
          16
        ), t(null, k._container), delete k._container.__vue_app__);
      },
      provide(D, $) {
        return f.provides[D] = $, k;
      },
      runWithContext(D) {
        const $ = Eo;
        Eo = k;
        try {
          return D();
        } finally {
          Eo = $;
        }
      }
    };
    return k;
  };
}
let Eo = null;
function Xd(t, r) {
  if (Yt) {
    let i = Yt.provides;
    const s = Yt.parent && Yt.parent.provides;
    s === i && (i = Yt.provides = Object.create(s)), i[t] = r;
  }
}
function Si(t, r, i = !1) {
  const s = Yt || Gt;
  if (s || Eo) {
    let c = Eo ? Eo._context.provides : s ? s.parent == null || s.ce ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0;
    if (c && t in c)
      return c[t];
    if (arguments.length > 1)
      return i && nt(r) ? r.call(s && s.proxy) : r;
  }
}
function Qd() {
  return !!(Yt || Gt || Eo);
}
const ec = {}, tc = () => Object.create(ec), nc = (t) => Object.getPrototypeOf(t) === ec;
function Jd(t, r, i, s = !1) {
  const c = {}, f = tc();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), rc(t, r, c, f);
  for (const u in t.propsOptions[0])
    u in c || (c[u] = void 0);
  i ? t.props = s ? c : ud(c) : t.type.props ? t.props = c : t.props = f, t.attrs = f;
}
function Zd(t, r, i, s) {
  const {
    props: c,
    attrs: f,
    vnode: { patchFlag: u }
  } = t, p = yt(c), [v] = t.propsOptions;
  let k = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (s || u > 0) && !(u & 16)
  ) {
    if (u & 8) {
      const D = t.vnode.dynamicProps;
      for (let $ = 0; $ < D.length; $++) {
        let U = D[$];
        if (Pa(t.emitsOptions, U))
          continue;
        const W = r[U];
        if (v)
          if (wt(f, U))
            W !== f[U] && (f[U] = W, k = !0);
          else {
            const A = Ln(U);
            c[A] = As(
              v,
              p,
              A,
              W,
              t,
              !1
            );
          }
        else
          W !== f[U] && (f[U] = W, k = !0);
      }
    }
  } else {
    rc(t, r, c, f) && (k = !0);
    let D;
    for (const $ in p)
      (!r || // for camelCase
      !wt(r, $) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((D = Do($)) === $ || !wt(r, D))) && (v ? i && // for camelCase
      (i[$] !== void 0 || // for kebab-case
      i[D] !== void 0) && (c[$] = As(
        v,
        p,
        $,
        void 0,
        t,
        !0
      )) : delete c[$]);
    if (f !== p)
      for (const $ in f)
        (!r || !wt(r, $)) && (delete f[$], k = !0);
  }
  k && Tr(t.attrs, "set", "");
}
function rc(t, r, i, s) {
  const [c, f] = t.propsOptions;
  let u = !1, p;
  if (r)
    for (let v in r) {
      if (Ti(v))
        continue;
      const k = r[v];
      let D;
      c && wt(c, D = Ln(v)) ? !f || !f.includes(D) ? i[D] = k : (p || (p = {}))[D] = k : Pa(t.emitsOptions, v) || (!(v in s) || k !== s[v]) && (s[v] = k, u = !0);
    }
  if (f) {
    const v = yt(i), k = p || Nt;
    for (let D = 0; D < f.length; D++) {
      const $ = f[D];
      i[$] = As(
        c,
        v,
        $,
        k[$],
        t,
        !wt(k, $)
      );
    }
  }
  return u;
}
function As(t, r, i, s, c, f) {
  const u = t[i];
  if (u != null) {
    const p = wt(u, "default");
    if (p && s === void 0) {
      const v = u.default;
      if (u.type !== Function && !u.skipFactory && nt(v)) {
        const { propsDefaults: k } = c;
        if (i in k)
          s = k[i];
        else {
          const D = Wi(c);
          s = k[i] = v.call(
            null,
            r
          ), D();
        }
      } else
        s = v;
      c.ce && c.ce._setProp(i, s);
    }
    u[
      0
      /* shouldCast */
    ] && (f && !p ? s = !1 : u[
      1
      /* shouldCastTrue */
    ] && (s === "" || s === Do(i)) && (s = !0));
  }
  return s;
}
const ef = /* @__PURE__ */ new WeakMap();
function oc(t, r, i = !1) {
  const s = i ? ef : r.propsCache, c = s.get(t);
  if (c)
    return c;
  const f = t.props, u = {}, p = [];
  let v = !1;
  if (!nt(t)) {
    const D = ($) => {
      v = !0;
      const [U, W] = oc($, r, !0);
      an(u, U), W && p.push(...W);
    };
    !i && r.mixins.length && r.mixins.forEach(D), t.extends && D(t.extends), t.mixins && t.mixins.forEach(D);
  }
  if (!f && !v)
    return At(t) && s.set(t, jo), jo;
  if (Xe(f))
    for (let D = 0; D < f.length; D++) {
      const $ = Ln(f[D]);
      Tl($) && (u[$] = Nt);
    }
  else if (f)
    for (const D in f) {
      const $ = Ln(D);
      if (Tl($)) {
        const U = f[D], W = u[$] = Xe(U) || nt(U) ? { type: U } : an({}, U), A = W.type;
        let P = !1, B = !0;
        if (Xe(A))
          for (let X = 0; X < A.length; ++X) {
            const F = A[X], E = nt(F) && F.name;
            if (E === "Boolean") {
              P = !0;
              break;
            } else E === "String" && (B = !1);
          }
        else
          P = nt(A) && A.name === "Boolean";
        W[
          0
          /* shouldCast */
        ] = P, W[
          1
          /* shouldCastTrue */
        ] = B, (P || wt(W, "default")) && p.push($);
      }
    }
  const k = [u, p];
  return At(t) && s.set(t, k), k;
}
function Tl(t) {
  return t[0] !== "$" && !Ti(t);
}
const el = (t) => t[0] === "_" || t === "$stable", tl = (t) => Xe(t) ? t.map(zn) : [zn(t)], tf = (t, r, i) => {
  if (r._n)
    return r;
  const s = Cs((...c) => tl(r(...c)), i);
  return s._c = !1, s;
}, ic = (t, r, i) => {
  const s = t._ctx;
  for (const c in t) {
    if (el(c)) continue;
    const f = t[c];
    if (nt(f))
      r[c] = tf(c, f, s);
    else if (f != null) {
      const u = tl(f);
      r[c] = () => u;
    }
  }
}, ac = (t, r) => {
  const i = tl(r);
  t.slots.default = () => i;
}, sc = (t, r, i) => {
  for (const s in r)
    (i || !el(s)) && (t[s] = r[s]);
}, nf = (t, r, i) => {
  const s = t.slots = tc();
  if (t.vnode.shapeFlag & 32) {
    const c = r.__;
    c && _s(s, "__", c, !0);
    const f = r._;
    f ? (sc(s, r, i), i && _s(s, "_", f, !0)) : ic(r, s);
  } else r && ac(t, r);
}, rf = (t, r, i) => {
  const { vnode: s, slots: c } = t;
  let f = !0, u = Nt;
  if (s.shapeFlag & 32) {
    const p = r._;
    p ? i && p === 1 ? f = !1 : sc(c, r, i) : (f = !r.$stable, ic(r, c)), u = r;
  } else r && (ac(t, r), u = { default: 1 });
  if (f)
    for (const p in c)
      !el(p) && u[p] == null && delete c[p];
}, vn = gf;
function of(t) {
  return af(t);
}
function af(t, r) {
  const i = Ra();
  i.__VUE__ = !0;
  const {
    insert: s,
    remove: c,
    patchProp: f,
    createElement: u,
    createText: p,
    createComment: v,
    setText: k,
    setElementText: D,
    parentNode: $,
    nextSibling: U,
    setScopeId: W = Xn,
    insertStaticContent: A
  } = t, P = (S, H, ue, he = null, be = null, ve = null, Oe = void 0, Ie = null, xe = !!H.dynamicChildren) => {
    if (S === H)
      return;
    S && !Ci(S, H) && (he = L(S), $t(S, be, ve, !0), S = null), H.patchFlag === -2 && (xe = !1, H.dynamicChildren = null);
    const { type: ye, ref: qe, shapeFlag: Ae } = H;
    switch (ye) {
      case Sa:
        B(S, H, ue, he);
        break;
      case Lr:
        X(S, H, ue, he);
        break;
      case oa:
        S == null && F(H, ue, he, Oe);
        break;
      case $e:
        fe(
          S,
          H,
          ue,
          he,
          be,
          ve,
          Oe,
          Ie,
          xe
        );
        break;
      default:
        Ae & 1 ? we(
          S,
          H,
          ue,
          he,
          be,
          ve,
          Oe,
          Ie,
          xe
        ) : Ae & 6 ? me(
          S,
          H,
          ue,
          he,
          be,
          ve,
          Oe,
          Ie,
          xe
        ) : (Ae & 64 || Ae & 128) && ye.process(
          S,
          H,
          ue,
          he,
          be,
          ve,
          Oe,
          Ie,
          xe,
          Z
        );
    }
    qe != null && be ? Di(qe, S && S.ref, ve, H || S, !H) : qe == null && S && S.ref != null && Di(S.ref, null, ve, S, !0);
  }, B = (S, H, ue, he) => {
    if (S == null)
      s(
        H.el = p(H.children),
        ue,
        he
      );
    else {
      const be = H.el = S.el;
      H.children !== S.children && k(be, H.children);
    }
  }, X = (S, H, ue, he) => {
    S == null ? s(
      H.el = v(H.children || ""),
      ue,
      he
    ) : H.el = S.el;
  }, F = (S, H, ue, he) => {
    [S.el, S.anchor] = A(
      S.children,
      H,
      ue,
      he,
      S.el,
      S.anchor
    );
  }, E = ({ el: S, anchor: H }, ue, he) => {
    let be;
    for (; S && S !== H; )
      be = U(S), s(S, ue, he), S = be;
    s(H, ue, he);
  }, K = ({ el: S, anchor: H }) => {
    let ue;
    for (; S && S !== H; )
      ue = U(S), c(S), S = ue;
    c(H);
  }, we = (S, H, ue, he, be, ve, Oe, Ie, xe) => {
    H.type === "svg" ? Oe = "svg" : H.type === "math" && (Oe = "mathml"), S == null ? de(
      H,
      ue,
      he,
      be,
      ve,
      Oe,
      Ie,
      xe
    ) : Y(
      S,
      H,
      be,
      ve,
      Oe,
      Ie,
      xe
    );
  }, de = (S, H, ue, he, be, ve, Oe, Ie) => {
    let xe, ye;
    const { props: qe, shapeFlag: Ae, transition: Ve, dirs: Ge } = S;
    if (xe = S.el = u(
      S.type,
      ve,
      qe && qe.is,
      qe
    ), Ae & 8 ? D(xe, S.children) : Ae & 16 && Ue(
      S.children,
      xe,
      null,
      he,
      be,
      ms(S, ve),
      Oe,
      Ie
    ), Ge && Ro(S, null, he, "created"), ge(xe, S, S.scopeId, Oe, he), qe) {
      for (const at in qe)
        at !== "value" && !Ti(at) && f(xe, at, null, qe[at], ve, he);
      "value" in qe && f(xe, "value", null, qe.value, ve), (ye = qe.onVnodeBeforeMount) && Hn(ye, he, S);
    }
    Ge && Ro(S, null, he, "beforeMount");
    const Je = sf(be, Ve);
    Je && Ve.beforeEnter(xe), s(xe, H, ue), ((ye = qe && qe.onVnodeMounted) || Je || Ge) && vn(() => {
      ye && Hn(ye, he, S), Je && Ve.enter(xe), Ge && Ro(S, null, he, "mounted");
    }, be);
  }, ge = (S, H, ue, he, be) => {
    if (ue && W(S, ue), he)
      for (let ve = 0; ve < he.length; ve++)
        W(S, he[ve]);
    if (be) {
      let ve = be.subTree;
      if (H === ve || dc(ve.type) && (ve.ssContent === H || ve.ssFallback === H)) {
        const Oe = be.vnode;
        ge(
          S,
          Oe,
          Oe.scopeId,
          Oe.slotScopeIds,
          be.parent
        );
      }
    }
  }, Ue = (S, H, ue, he, be, ve, Oe, Ie, xe = 0) => {
    for (let ye = xe; ye < S.length; ye++) {
      const qe = S[ye] = Ie ? Br(S[ye]) : zn(S[ye]);
      P(
        null,
        qe,
        H,
        ue,
        he,
        be,
        ve,
        Oe,
        Ie
      );
    }
  }, Y = (S, H, ue, he, be, ve, Oe) => {
    const Ie = H.el = S.el;
    let { patchFlag: xe, dynamicChildren: ye, dirs: qe } = H;
    xe |= S.patchFlag & 16;
    const Ae = S.props || Nt, Ve = H.props || Nt;
    let Ge;
    if (ue && Co(ue, !1), (Ge = Ve.onVnodeBeforeUpdate) && Hn(Ge, ue, H, S), qe && Ro(H, S, ue, "beforeUpdate"), ue && Co(ue, !0), (Ae.innerHTML && Ve.innerHTML == null || Ae.textContent && Ve.textContent == null) && D(Ie, ""), ye ? oe(
      S.dynamicChildren,
      ye,
      Ie,
      ue,
      he,
      ms(H, be),
      ve
    ) : Oe || Fe(
      S,
      H,
      Ie,
      null,
      ue,
      he,
      ms(H, be),
      ve,
      !1
    ), xe > 0) {
      if (xe & 16)
        ce(Ie, Ae, Ve, ue, be);
      else if (xe & 2 && Ae.class !== Ve.class && f(Ie, "class", null, Ve.class, be), xe & 4 && f(Ie, "style", Ae.style, Ve.style, be), xe & 8) {
        const Je = H.dynamicProps;
        for (let at = 0; at < Je.length; at++) {
          const ut = Je[at], Rt = Ae[ut], Ft = Ve[ut];
          (Ft !== Rt || ut === "value") && f(Ie, ut, Rt, Ft, be, ue);
        }
      }
      xe & 1 && S.children !== H.children && D(Ie, H.children);
    } else !Oe && ye == null && ce(Ie, Ae, Ve, ue, be);
    ((Ge = Ve.onVnodeUpdated) || qe) && vn(() => {
      Ge && Hn(Ge, ue, H, S), qe && Ro(H, S, ue, "updated");
    }, he);
  }, oe = (S, H, ue, he, be, ve, Oe) => {
    for (let Ie = 0; Ie < H.length; Ie++) {
      const xe = S[Ie], ye = H[Ie], qe = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        xe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (xe.type === $e || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Ci(xe, ye) || // - In the case of a component, it could contain anything.
        xe.shapeFlag & 198) ? $(xe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          ue
        )
      );
      P(
        xe,
        ye,
        qe,
        null,
        he,
        be,
        ve,
        Oe,
        !0
      );
    }
  }, ce = (S, H, ue, he, be) => {
    if (H !== ue) {
      if (H !== Nt)
        for (const ve in H)
          !Ti(ve) && !(ve in ue) && f(
            S,
            ve,
            H[ve],
            null,
            be,
            he
          );
      for (const ve in ue) {
        if (Ti(ve)) continue;
        const Oe = ue[ve], Ie = H[ve];
        Oe !== Ie && ve !== "value" && f(S, ve, Ie, Oe, be, he);
      }
      "value" in ue && f(S, "value", H.value, ue.value, be);
    }
  }, fe = (S, H, ue, he, be, ve, Oe, Ie, xe) => {
    const ye = H.el = S ? S.el : p(""), qe = H.anchor = S ? S.anchor : p("");
    let { patchFlag: Ae, dynamicChildren: Ve, slotScopeIds: Ge } = H;
    Ge && (Ie = Ie ? Ie.concat(Ge) : Ge), S == null ? (s(ye, ue, he), s(qe, ue, he), Ue(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      H.children || [],
      ue,
      qe,
      be,
      ve,
      Oe,
      Ie,
      xe
    )) : Ae > 0 && Ae & 64 && Ve && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    S.dynamicChildren ? (oe(
      S.dynamicChildren,
      Ve,
      ue,
      be,
      ve,
      Oe,
      Ie
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (H.key != null || be && H === be.subTree) && nl(
      S,
      H,
      !0
      /* shallow */
    )) : Fe(
      S,
      H,
      ue,
      qe,
      be,
      ve,
      Oe,
      Ie,
      xe
    );
  }, me = (S, H, ue, he, be, ve, Oe, Ie, xe) => {
    H.slotScopeIds = Ie, S == null ? H.shapeFlag & 512 ? be.ctx.activate(
      H,
      ue,
      he,
      Oe,
      xe
    ) : Pe(
      H,
      ue,
      he,
      be,
      ve,
      Oe,
      xe
    ) : De(S, H, xe);
  }, Pe = (S, H, ue, he, be, ve, Oe) => {
    const Ie = S.component = Rf(
      S,
      he,
      be
    );
    if (Hu(S) && (Ie.ctx.renderer = Z), Of(Ie, !1, Oe), Ie.asyncDep) {
      if (be && be.registerDep(Ie, Se, Oe), !S.el) {
        const xe = Ie.subTree = ft(Lr);
        X(null, xe, H, ue);
      }
    } else
      Se(
        Ie,
        S,
        H,
        ue,
        be,
        ve,
        Oe
      );
  }, De = (S, H, ue) => {
    const he = H.component = S.component;
    if (vf(S, H, ue))
      if (he.asyncDep && !he.asyncResolved) {
        Ne(he, H, ue);
        return;
      } else
        he.next = H, he.update();
    else
      H.el = S.el, he.vnode = H;
  }, Se = (S, H, ue, he, be, ve, Oe) => {
    const Ie = () => {
      if (S.isMounted) {
        let { next: Ae, bu: Ve, u: Ge, parent: Je, vnode: at } = S;
        {
          const Ct = lc(S);
          if (Ct) {
            Ae && (Ae.el = at.el, Ne(S, Ae, Oe)), Ct.asyncDep.then(() => {
              S.isUnmounted || Ie();
            });
            return;
          }
        }
        let ut = Ae, Rt;
        Co(S, !1), Ae ? (Ae.el = at.el, Ne(S, Ae, Oe)) : Ae = at, Ve && na(Ve), (Rt = Ae.props && Ae.props.onVnodeBeforeUpdate) && Hn(Rt, Je, Ae, at), Co(S, !0);
        const Ft = Il(S), Ut = S.subTree;
        S.subTree = Ft, P(
          Ut,
          Ft,
          // parent may have changed if it's in a teleport
          $(Ut.el),
          // anchor may have changed if it's in a fragment
          L(Ut),
          S,
          be,
          ve
        ), Ae.el = Ft.el, ut === null && yf(S, Ft.el), Ge && vn(Ge, be), (Rt = Ae.props && Ae.props.onVnodeUpdated) && vn(
          () => Hn(Rt, Je, Ae, at),
          be
        );
      } else {
        let Ae;
        const { el: Ve, props: Ge } = H, { bm: Je, m: at, parent: ut, root: Rt, type: Ft } = S, Ut = Mo(H);
        Co(S, !1), Je && na(Je), !Ut && (Ae = Ge && Ge.onVnodeBeforeMount) && Hn(Ae, ut, H), Co(S, !0);
        {
          Rt.ce && // @ts-expect-error _def is private
          Rt.ce._def.shadowRoot !== !1 && Rt.ce._injectChildStyle(Ft);
          const Ct = S.subTree = Il(S);
          P(
            null,
            Ct,
            ue,
            he,
            S,
            be,
            ve
          ), H.el = Ct.el;
        }
        if (at && vn(at, be), !Ut && (Ae = Ge && Ge.onVnodeMounted)) {
          const Ct = H;
          vn(
            () => Hn(Ae, ut, Ct),
            be
          );
        }
        (H.shapeFlag & 256 || ut && Mo(ut.vnode) && ut.vnode.shapeFlag & 256) && S.a && vn(S.a, be), S.isMounted = !0, H = ue = he = null;
      }
    };
    S.scope.on();
    const xe = S.effect = new gu(Ie);
    S.scope.off();
    const ye = S.update = xe.run.bind(xe), qe = S.job = xe.runIfDirty.bind(xe);
    qe.i = S, qe.id = S.uid, xe.scheduler = () => Qs(qe), Co(S, !0), ye();
  }, Ne = (S, H, ue) => {
    H.component = S;
    const he = S.vnode.props;
    S.vnode = H, S.next = null, Zd(S, H.props, he, ue), rf(S, H.children, ue), Pr(), yl(S), Sr();
  }, Fe = (S, H, ue, he, be, ve, Oe, Ie, xe = !1) => {
    const ye = S && S.children, qe = S ? S.shapeFlag : 0, Ae = H.children, { patchFlag: Ve, shapeFlag: Ge } = H;
    if (Ve > 0) {
      if (Ve & 128) {
        Me(
          ye,
          Ae,
          ue,
          he,
          be,
          ve,
          Oe,
          Ie,
          xe
        );
        return;
      } else if (Ve & 256) {
        pt(
          ye,
          Ae,
          ue,
          he,
          be,
          ve,
          Oe,
          Ie,
          xe
        );
        return;
      }
    }
    Ge & 8 ? (qe & 16 && Mt(ye, be, ve), Ae !== ye && D(ue, Ae)) : qe & 16 ? Ge & 16 ? Me(
      ye,
      Ae,
      ue,
      he,
      be,
      ve,
      Oe,
      Ie,
      xe
    ) : Mt(ye, be, ve, !0) : (qe & 8 && D(ue, ""), Ge & 16 && Ue(
      Ae,
      ue,
      he,
      be,
      ve,
      Oe,
      Ie,
      xe
    ));
  }, pt = (S, H, ue, he, be, ve, Oe, Ie, xe) => {
    S = S || jo, H = H || jo;
    const ye = S.length, qe = H.length, Ae = Math.min(ye, qe);
    let Ve;
    for (Ve = 0; Ve < Ae; Ve++) {
      const Ge = H[Ve] = xe ? Br(H[Ve]) : zn(H[Ve]);
      P(
        S[Ve],
        Ge,
        ue,
        null,
        be,
        ve,
        Oe,
        Ie,
        xe
      );
    }
    ye > qe ? Mt(
      S,
      be,
      ve,
      !0,
      !1,
      Ae
    ) : Ue(
      H,
      ue,
      he,
      be,
      ve,
      Oe,
      Ie,
      xe,
      Ae
    );
  }, Me = (S, H, ue, he, be, ve, Oe, Ie, xe) => {
    let ye = 0;
    const qe = H.length;
    let Ae = S.length - 1, Ve = qe - 1;
    for (; ye <= Ae && ye <= Ve; ) {
      const Ge = S[ye], Je = H[ye] = xe ? Br(H[ye]) : zn(H[ye]);
      if (Ci(Ge, Je))
        P(
          Ge,
          Je,
          ue,
          null,
          be,
          ve,
          Oe,
          Ie,
          xe
        );
      else
        break;
      ye++;
    }
    for (; ye <= Ae && ye <= Ve; ) {
      const Ge = S[Ae], Je = H[Ve] = xe ? Br(H[Ve]) : zn(H[Ve]);
      if (Ci(Ge, Je))
        P(
          Ge,
          Je,
          ue,
          null,
          be,
          ve,
          Oe,
          Ie,
          xe
        );
      else
        break;
      Ae--, Ve--;
    }
    if (ye > Ae) {
      if (ye <= Ve) {
        const Ge = Ve + 1, Je = Ge < qe ? H[Ge].el : he;
        for (; ye <= Ve; )
          P(
            null,
            H[ye] = xe ? Br(H[ye]) : zn(H[ye]),
            ue,
            Je,
            be,
            ve,
            Oe,
            Ie,
            xe
          ), ye++;
      }
    } else if (ye > Ve)
      for (; ye <= Ae; )
        $t(S[ye], be, ve, !0), ye++;
    else {
      const Ge = ye, Je = ye, at = /* @__PURE__ */ new Map();
      for (ye = Je; ye <= Ve; ye++) {
        const gt = H[ye] = xe ? Br(H[ye]) : zn(H[ye]);
        gt.key != null && at.set(gt.key, ye);
      }
      let ut, Rt = 0;
      const Ft = Ve - Je + 1;
      let Ut = !1, Ct = 0;
      const sn = new Array(Ft);
      for (ye = 0; ye < Ft; ye++) sn[ye] = 0;
      for (ye = Ge; ye <= Ae; ye++) {
        const gt = S[ye];
        if (Rt >= Ft) {
          $t(gt, be, ve, !0);
          continue;
        }
        let pe;
        if (gt.key != null)
          pe = at.get(gt.key);
        else
          for (ut = Je; ut <= Ve; ut++)
            if (sn[ut - Je] === 0 && Ci(gt, H[ut])) {
              pe = ut;
              break;
            }
        pe === void 0 ? $t(gt, be, ve, !0) : (sn[pe - Je] = ye + 1, pe >= Ct ? Ct = pe : Ut = !0, P(
          gt,
          H[pe],
          ue,
          null,
          be,
          ve,
          Oe,
          Ie,
          xe
        ), Rt++);
      }
      const Gn = Ut ? lf(sn) : jo;
      for (ut = Gn.length - 1, ye = Ft - 1; ye >= 0; ye--) {
        const gt = Je + ye, pe = H[gt], wn = gt + 1 < qe ? H[gt + 1].el : he;
        sn[ye] === 0 ? P(
          null,
          pe,
          ue,
          wn,
          be,
          ve,
          Oe,
          Ie,
          xe
        ) : Ut && (ut < 0 || ye !== Gn[ut] ? Qe(pe, ue, wn, 2) : ut--);
      }
    }
  }, Qe = (S, H, ue, he, be = null) => {
    const { el: ve, type: Oe, transition: Ie, children: xe, shapeFlag: ye } = S;
    if (ye & 6) {
      Qe(S.component.subTree, H, ue, he);
      return;
    }
    if (ye & 128) {
      S.suspense.move(H, ue, he);
      return;
    }
    if (ye & 64) {
      Oe.move(S, H, ue, Z);
      return;
    }
    if (Oe === $e) {
      s(ve, H, ue);
      for (let Ae = 0; Ae < xe.length; Ae++)
        Qe(xe[Ae], H, ue, he);
      s(S.anchor, H, ue);
      return;
    }
    if (Oe === oa) {
      E(S, H, ue);
      return;
    }
    if (he !== 2 && ye & 1 && Ie)
      if (he === 0)
        Ie.beforeEnter(ve), s(ve, H, ue), vn(() => Ie.enter(ve), be);
      else {
        const { leave: Ae, delayLeave: Ve, afterLeave: Ge } = Ie, Je = () => {
          S.ctx.isUnmounted ? c(ve) : s(ve, H, ue);
        }, at = () => {
          Ae(ve, () => {
            Je(), Ge && Ge();
          });
        };
        Ve ? Ve(ve, Je, at) : at();
      }
    else
      s(ve, H, ue);
  }, $t = (S, H, ue, he = !1, be = !1) => {
    const {
      type: ve,
      props: Oe,
      ref: Ie,
      children: xe,
      dynamicChildren: ye,
      shapeFlag: qe,
      patchFlag: Ae,
      dirs: Ve,
      cacheIndex: Ge
    } = S;
    if (Ae === -2 && (be = !1), Ie != null && (Pr(), Di(Ie, null, ue, S, !0), Sr()), Ge != null && (H.renderCache[Ge] = void 0), qe & 256) {
      H.ctx.deactivate(S);
      return;
    }
    const Je = qe & 1 && Ve, at = !Mo(S);
    let ut;
    if (at && (ut = Oe && Oe.onVnodeBeforeUnmount) && Hn(ut, H, S), qe & 6)
      bn(S.component, ue, he);
    else {
      if (qe & 128) {
        S.suspense.unmount(ue, he);
        return;
      }
      Je && Ro(S, null, H, "beforeUnmount"), qe & 64 ? S.type.remove(
        S,
        H,
        ue,
        Z,
        he
      ) : ye && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ye.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (ve !== $e || Ae > 0 && Ae & 64) ? Mt(
        ye,
        H,
        ue,
        !1,
        !0
      ) : (ve === $e && Ae & 384 || !be && qe & 16) && Mt(xe, H, ue), he && it(S);
    }
    (at && (ut = Oe && Oe.onVnodeUnmounted) || Je) && vn(() => {
      ut && Hn(ut, H, S), Je && Ro(S, null, H, "unmounted");
    }, ue);
  }, it = (S) => {
    const { type: H, el: ue, anchor: he, transition: be } = S;
    if (H === $e) {
      Ht(ue, he);
      return;
    }
    if (H === oa) {
      K(S);
      return;
    }
    const ve = () => {
      c(ue), be && !be.persisted && be.afterLeave && be.afterLeave();
    };
    if (S.shapeFlag & 1 && be && !be.persisted) {
      const { leave: Oe, delayLeave: Ie } = be, xe = () => Oe(ue, ve);
      Ie ? Ie(S.el, ve, xe) : xe();
    } else
      ve();
  }, Ht = (S, H) => {
    let ue;
    for (; S !== H; )
      ue = U(S), c(S), S = ue;
    c(H);
  }, bn = (S, H, ue) => {
    const {
      bum: he,
      scope: be,
      job: ve,
      subTree: Oe,
      um: Ie,
      m: xe,
      a: ye,
      parent: qe,
      slots: { __: Ae }
    } = S;
    El(xe), El(ye), he && na(he), qe && Xe(Ae) && Ae.forEach((Ve) => {
      qe.renderCache[Ve] = void 0;
    }), be.stop(), ve && (ve.flags |= 8, $t(Oe, S, H, ue)), Ie && vn(Ie, H), vn(() => {
      S.isUnmounted = !0;
    }, H), H && H.pendingBranch && !H.isUnmounted && S.asyncDep && !S.asyncResolved && S.suspenseId === H.pendingId && (H.deps--, H.deps === 0 && H.resolve());
  }, Mt = (S, H, ue, he = !1, be = !1, ve = 0) => {
    for (let Oe = ve; Oe < S.length; Oe++)
      $t(S[Oe], H, ue, he, be);
  }, L = (S) => {
    if (S.shapeFlag & 6)
      return L(S.component.subTree);
    if (S.shapeFlag & 128)
      return S.suspense.next();
    const H = U(S.anchor || S.el), ue = H && H[Uu];
    return ue ? U(ue) : H;
  };
  let x = !1;
  const G = (S, H, ue) => {
    S == null ? H._vnode && $t(H._vnode, null, null, !0) : P(
      H._vnode || null,
      S,
      H,
      null,
      null,
      null,
      ue
    ), H._vnode = S, x || (x = !0, yl(), Bu(), x = !1);
  }, Z = {
    p: P,
    um: $t,
    m: Qe,
    r: it,
    mt: Pe,
    mc: Ue,
    pc: Fe,
    pbc: oe,
    n: L,
    o: t
  };
  return {
    render: G,
    hydrate: void 0,
    createApp: zd(G)
  };
}
function ms({ type: t, props: r }, i) {
  return i === "svg" && t === "foreignObject" || i === "mathml" && t === "annotation-xml" && r && r.encoding && r.encoding.includes("html") ? void 0 : i;
}
function Co({ effect: t, job: r }, i) {
  i ? (t.flags |= 32, r.flags |= 4) : (t.flags &= -33, r.flags &= -5);
}
function sf(t, r) {
  return (!t || t && !t.pendingBranch) && r && !r.persisted;
}
function nl(t, r, i = !1) {
  const s = t.children, c = r.children;
  if (Xe(s) && Xe(c))
    for (let f = 0; f < s.length; f++) {
      const u = s[f];
      let p = c[f];
      p.shapeFlag & 1 && !p.dynamicChildren && ((p.patchFlag <= 0 || p.patchFlag === 32) && (p = c[f] = Br(c[f]), p.el = u.el), !i && p.patchFlag !== -2 && nl(u, p)), p.type === Sa && (p.el = u.el), p.type === Lr && !p.el && (p.el = u.el);
    }
}
function lf(t) {
  const r = t.slice(), i = [0];
  let s, c, f, u, p;
  const v = t.length;
  for (s = 0; s < v; s++) {
    const k = t[s];
    if (k !== 0) {
      if (c = i[i.length - 1], t[c] < k) {
        r[s] = c, i.push(s);
        continue;
      }
      for (f = 0, u = i.length - 1; f < u; )
        p = f + u >> 1, t[i[p]] < k ? f = p + 1 : u = p;
      k < t[i[f]] && (f > 0 && (r[s] = i[f - 1]), i[f] = s);
    }
  }
  for (f = i.length, u = i[f - 1]; f-- > 0; )
    i[f] = u, u = r[u];
  return i;
}
function lc(t) {
  const r = t.subTree.component;
  if (r)
    return r.asyncDep && !r.asyncResolved ? r : lc(r);
}
function El(t) {
  if (t)
    for (let r = 0; r < t.length; r++)
      t[r].flags |= 8;
}
const uf = Symbol.for("v-scx"), cf = () => Si(uf);
function Da(t, r) {
  return rl(t, null, r);
}
function qt(t, r, i) {
  return rl(t, r, i);
}
function rl(t, r, i = Nt) {
  const { immediate: s, deep: c, flush: f, once: u } = i, p = an({}, i), v = r && s || !r && f !== "post";
  let k;
  if (Bi) {
    if (f === "sync") {
      const W = cf();
      k = W.__watcherHandles || (W.__watcherHandles = []);
    } else if (!v) {
      const W = () => {
      };
      return W.stop = Xn, W.resume = Xn, W.pause = Xn, W;
    }
  }
  const D = Yt;
  p.call = (W, A, P) => Qn(W, D, A, P);
  let $ = !1;
  f === "post" ? p.scheduler = (W) => {
    vn(W, D && D.suspense);
  } : f !== "sync" && ($ = !0, p.scheduler = (W, A) => {
    A ? W() : Qs(W);
  }), p.augmentJob = (W) => {
    r && (W.flags |= 4), $ && (W.flags |= 2, D && (W.id = D.uid, W.i = D));
  };
  const U = _d(t, r, p);
  return Bi && (k ? k.push(U) : v && U()), U;
}
function df(t, r, i) {
  const s = this.proxy, c = kt(t) ? t.includes(".") ? uc(s, t) : () => s[t] : t.bind(s, s);
  let f;
  nt(r) ? f = r : (f = r.handler, i = r);
  const u = Wi(this), p = rl(c, f.bind(s), i);
  return u(), p;
}
function uc(t, r) {
  const i = r.split(".");
  return () => {
    let s = t;
    for (let c = 0; c < i.length && s; c++)
      s = s[i[c]];
    return s;
  };
}
const ff = (t, r) => r === "modelValue" || r === "model-value" ? t.modelModifiers : t[`${r}Modifiers`] || t[`${Ln(r)}Modifiers`] || t[`${Do(r)}Modifiers`];
function pf(t, r, ...i) {
  if (t.isUnmounted) return;
  const s = t.vnode.props || Nt;
  let c = i;
  const f = r.startsWith("update:"), u = f && ff(s, r.slice(7));
  u && (u.trim && (c = i.map((D) => kt(D) ? D.trim() : D)), u.number && (c = i.map(ca)));
  let p, v = s[p = us(r)] || // also try camelCase event handler (#2249)
  s[p = us(Ln(r))];
  !v && f && (v = s[p = us(Do(r))]), v && Qn(
    v,
    t,
    6,
    c
  );
  const k = s[p + "Once"];
  if (k) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[p])
      return;
    t.emitted[p] = !0, Qn(
      k,
      t,
      6,
      c
    );
  }
}
function cc(t, r, i = !1) {
  const s = r.emitsCache, c = s.get(t);
  if (c !== void 0)
    return c;
  const f = t.emits;
  let u = {}, p = !1;
  if (!nt(t)) {
    const v = (k) => {
      const D = cc(k, r, !0);
      D && (p = !0, an(u, D));
    };
    !i && r.mixins.length && r.mixins.forEach(v), t.extends && v(t.extends), t.mixins && t.mixins.forEach(v);
  }
  return !f && !p ? (At(t) && s.set(t, null), null) : (Xe(f) ? f.forEach((v) => u[v] = null) : an(u, f), At(t) && s.set(t, u), u);
}
function Pa(t, r) {
  return !t || !_a(r) ? !1 : (r = r.slice(2).replace(/Once$/, ""), wt(t, r[0].toLowerCase() + r.slice(1)) || wt(t, Do(r)) || wt(t, r));
}
function Il(t) {
  const {
    type: r,
    vnode: i,
    proxy: s,
    withProxy: c,
    propsOptions: [f],
    slots: u,
    attrs: p,
    emit: v,
    render: k,
    renderCache: D,
    props: $,
    data: U,
    setupState: W,
    ctx: A,
    inheritAttrs: P
  } = t, B = ma(t);
  let X, F;
  try {
    if (i.shapeFlag & 4) {
      const K = c || s, we = K;
      X = zn(
        k.call(
          we,
          K,
          D,
          $,
          W,
          U,
          A
        )
      ), F = p;
    } else {
      const K = r;
      X = zn(
        K.length > 1 ? K(
          $,
          { attrs: p, slots: u, emit: v }
        ) : K(
          $,
          null
        )
      ), F = r.props ? p : hf(p);
    }
  } catch (K) {
    Li.length = 0, Ia(K, t, 1), X = ft(Lr);
  }
  let E = X;
  if (F && P !== !1) {
    const K = Object.keys(F), { shapeFlag: we } = E;
    K.length && we & 7 && (f && K.some(Bs) && (F = mf(
      F,
      f
    )), E = Ko(E, F, !1, !0));
  }
  return i.dirs && (E = Ko(E, null, !1, !0), E.dirs = E.dirs ? E.dirs.concat(i.dirs) : i.dirs), i.transition && Js(E, i.transition), X = E, ma(B), X;
}
const hf = (t) => {
  let r;
  for (const i in t)
    (i === "class" || i === "style" || _a(i)) && ((r || (r = {}))[i] = t[i]);
  return r;
}, mf = (t, r) => {
  const i = {};
  for (const s in t)
    (!Bs(s) || !(s.slice(9) in r)) && (i[s] = t[s]);
  return i;
};
function vf(t, r, i) {
  const { props: s, children: c, component: f } = t, { props: u, children: p, patchFlag: v } = r, k = f.emitsOptions;
  if (r.dirs || r.transition)
    return !0;
  if (i && v >= 0) {
    if (v & 1024)
      return !0;
    if (v & 16)
      return s ? Al(s, u, k) : !!u;
    if (v & 8) {
      const D = r.dynamicProps;
      for (let $ = 0; $ < D.length; $++) {
        const U = D[$];
        if (u[U] !== s[U] && !Pa(k, U))
          return !0;
      }
    }
  } else
    return (c || p) && (!p || !p.$stable) ? !0 : s === u ? !1 : s ? u ? Al(s, u, k) : !0 : !!u;
  return !1;
}
function Al(t, r, i) {
  const s = Object.keys(r);
  if (s.length !== Object.keys(t).length)
    return !0;
  for (let c = 0; c < s.length; c++) {
    const f = s[c];
    if (r[f] !== t[f] && !Pa(i, f))
      return !0;
  }
  return !1;
}
function yf({ vnode: t, parent: r }, i) {
  for (; r; ) {
    const s = r.subTree;
    if (s.suspense && s.suspense.activeBranch === t && (s.el = t.el), s === t)
      (t = r.vnode).el = i, r = r.parent;
    else
      break;
  }
}
const dc = (t) => t.__isSuspense;
function gf(t, r) {
  r && r.pendingBranch ? Xe(t) ? r.effects.push(...t) : r.effects.push(t) : Rd(t);
}
const $e = Symbol.for("v-fgt"), Sa = Symbol.for("v-txt"), Lr = Symbol.for("v-cmt"), oa = Symbol.for("v-stc"), Li = [];
let En = null;
function Q(t = !1) {
  Li.push(En = t ? null : []);
}
function bf() {
  Li.pop(), En = Li[Li.length - 1] || null;
}
let Mi = 1;
function Dl(t, r = !1) {
  Mi += t, t < 0 && En && r && (En.hasOnce = !0);
}
function fc(t) {
  return t.dynamicChildren = Mi > 0 ? En || jo : null, bf(), Mi > 0 && En && En.push(t), t;
}
function re(t, r, i, s, c, f) {
  return fc(
    h(
      t,
      r,
      i,
      s,
      c,
      f,
      !0
    )
  );
}
function Lt(t, r, i, s, c) {
  return fc(
    ft(
      t,
      r,
      i,
      s,
      c,
      !0
    )
  );
}
function ol(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function Ci(t, r) {
  return t.type === r.type && t.key === r.key;
}
const pc = ({ key: t }) => t ?? null, ia = ({
  ref: t,
  ref_key: r,
  ref_for: i
}) => (typeof t == "number" && (t = "" + t), t != null ? kt(t) || St(t) || nt(t) ? { i: Gt, r: t, k: r, f: !!i } : t : null);
function h(t, r = null, i = null, s = 0, c = null, f = t === $e ? 0 : 1, u = !1, p = !1) {
  const v = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: r,
    key: r && pc(r),
    ref: r && ia(r),
    scopeId: qu,
    slotScopeIds: null,
    children: i,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: f,
    patchFlag: s,
    dynamicProps: c,
    dynamicChildren: null,
    appContext: null,
    ctx: Gt
  };
  return p ? (al(v, i), f & 128 && t.normalize(v)) : i && (v.shapeFlag |= kt(i) ? 8 : 16), Mi > 0 && // avoid a block node from tracking itself
  !u && // has current parent block
  En && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (v.patchFlag > 0 || f & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  v.patchFlag !== 32 && En.push(v), v;
}
const ft = wf;
function wf(t, r = null, i = null, s = 0, c = null, f = !1) {
  if ((!t || t === zu) && (t = Lr), ol(t)) {
    const p = Ko(
      t,
      r,
      !0
      /* mergeRef: true */
    );
    return i && al(p, i), Mi > 0 && !f && En && (p.shapeFlag & 6 ? En[En.indexOf(t)] = p : En.push(p)), p.patchFlag = -2, p;
  }
  if (Df(t) && (t = t.__vccOpts), r) {
    r = _f(r);
    let { class: p, style: v } = r;
    p && !kt(p) && (r.class = Tt(p)), At(v) && (zs(v) && !Xe(v) && (v = an({}, v)), r.style = jr(v));
  }
  const u = kt(t) ? 1 : dc(t) ? 128 : Cd(t) ? 64 : At(t) ? 4 : nt(t) ? 2 : 0;
  return h(
    t,
    r,
    i,
    s,
    c,
    u,
    f,
    !0
  );
}
function _f(t) {
  return t ? zs(t) || nc(t) ? an({}, t) : t : null;
}
function Ko(t, r, i = !1, s = !1) {
  const { props: c, ref: f, patchFlag: u, children: p, transition: v } = t, k = r ? mc(c || {}, r) : c, D = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: k,
    key: k && pc(k),
    ref: r && r.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      i && f ? Xe(f) ? f.concat(ia(r)) : [f, ia(r)] : ia(r)
    ) : f,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: p,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: r && t.type !== $e ? u === -1 ? 16 : u | 16 : u,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: v,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Ko(t.ssContent),
    ssFallback: t.ssFallback && Ko(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return v && s && Js(
    D,
    v.clone(D)
  ), D;
}
function il(t = " ", r = 0) {
  return ft(Sa, null, t, r);
}
function hc(t, r) {
  const i = ft(oa, null, t);
  return i.staticCount = r, i;
}
function We(t = "", r = !1) {
  return r ? (Q(), Lt(Lr, null, t)) : ft(Lr, null, t);
}
function zn(t) {
  return t == null || typeof t == "boolean" ? ft(Lr) : Xe(t) ? ft(
    $e,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : ol(t) ? Br(t) : ft(Sa, null, String(t));
}
function Br(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Ko(t);
}
function al(t, r) {
  let i = 0;
  const { shapeFlag: s } = t;
  if (r == null)
    r = null;
  else if (Xe(r))
    i = 16;
  else if (typeof r == "object")
    if (s & 65) {
      const c = r.default;
      c && (c._c && (c._d = !1), al(t, c()), c._c && (c._d = !0));
      return;
    } else {
      i = 32;
      const c = r._;
      !c && !nc(r) ? r._ctx = Gt : c === 3 && Gt && (Gt.slots._ === 1 ? r._ = 1 : (r._ = 2, t.patchFlag |= 1024));
    }
  else nt(r) ? (r = { default: r, _ctx: Gt }, i = 32) : (r = String(r), s & 64 ? (i = 16, r = [il(r)]) : i = 8);
  t.children = r, t.shapeFlag |= i;
}
function mc(...t) {
  const r = {};
  for (let i = 0; i < t.length; i++) {
    const s = t[i];
    for (const c in s)
      if (c === "class")
        r.class !== s.class && (r.class = Tt([r.class, s.class]));
      else if (c === "style")
        r.style = jr([r.style, s.style]);
      else if (_a(c)) {
        const f = r[c], u = s[c];
        u && f !== u && !(Xe(f) && f.includes(u)) && (r[c] = f ? [].concat(f, u) : u);
      } else c !== "" && (r[c] = s[c]);
  }
  return r;
}
function Hn(t, r, i, s = null) {
  Qn(t, r, 7, [
    i,
    s
  ]);
}
const Nf = Zu();
let xf = 0;
function Rf(t, r, i) {
  const s = t.type, c = (r ? r.appContext : t.appContext) || Nf, f = {
    uid: xf++,
    vnode: t,
    type: s,
    parent: r,
    appContext: c,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new mu(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: r ? r.provides : Object.create(c.provides),
    ids: r ? r.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: oc(s, c),
    emitsOptions: cc(s, c),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Nt,
    // inheritAttrs
    inheritAttrs: s.inheritAttrs,
    // state
    ctx: Nt,
    data: Nt,
    props: Nt,
    attrs: Nt,
    slots: Nt,
    refs: Nt,
    setupState: Nt,
    setupContext: null,
    // suspense related
    suspense: i,
    suspenseId: i ? i.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return f.ctx = { _: f }, f.root = r ? r.root : f, f.emit = pf.bind(null, f), t.ce && t.ce(f), f;
}
let Yt = null;
const Cf = () => Yt || Gt;
let ya, Ds;
{
  const t = Ra(), r = (i, s) => {
    let c;
    return (c = t[i]) || (c = t[i] = []), c.push(s), (f) => {
      c.length > 1 ? c.forEach((u) => u(f)) : c[0](f);
    };
  };
  ya = r(
    "__VUE_INSTANCE_SETTERS__",
    (i) => Yt = i
  ), Ds = r(
    "__VUE_SSR_SETTERS__",
    (i) => Bi = i
  );
}
const Wi = (t) => {
  const r = Yt;
  return ya(t), t.scope.on(), () => {
    t.scope.off(), ya(r);
  };
}, Pl = () => {
  Yt && Yt.scope.off(), ya(null);
};
function vc(t) {
  return t.vnode.shapeFlag & 4;
}
let Bi = !1;
function Of(t, r = !1, i = !1) {
  r && Ds(r);
  const { props: s, children: c } = t.vnode, f = vc(t);
  Jd(t, s, f, r), nf(t, c, i || r);
  const u = f ? Tf(t, r) : void 0;
  return r && Ds(!1), u;
}
function Tf(t, r) {
  const i = t.type;
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, qd);
  const { setup: s } = i;
  if (s) {
    Pr();
    const c = t.setupContext = s.length > 1 ? If(t) : null, f = Wi(t), u = Vi(
      s,
      t,
      0,
      [
        t.props,
        c
      ]
    ), p = uu(u);
    if (Sr(), f(), (p || t.sp) && !Mo(t) && Gu(t), p) {
      if (u.then(Pl, Pl), r)
        return u.then((v) => {
          Sl(t, v);
        }).catch((v) => {
          Ia(v, t, 0);
        });
      t.asyncDep = u;
    } else
      Sl(t, u);
  } else
    yc(t);
}
function Sl(t, r, i) {
  nt(r) ? t.type.__ssrInlineRender ? t.ssrRender = r : t.render = r : At(r) && (t.setupState = ju(r)), yc(t);
}
function yc(t, r, i) {
  const s = t.type;
  t.render || (t.render = s.render || Xn);
  {
    const c = Wi(t);
    Pr();
    try {
      Ud(t);
    } finally {
      Sr(), c();
    }
  }
}
const Ef = {
  get(t, r) {
    return on(t, "get", ""), t[r];
  }
};
function If(t) {
  const r = (i) => {
    t.exposed = i || {};
  };
  return {
    attrs: new Proxy(t.attrs, Ef),
    slots: t.slots,
    emit: t.emit,
    expose: r
  };
}
function La(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(ju(Ea(t.exposed)), {
    get(r, i) {
      if (i in r)
        return r[i];
      if (i in Pi)
        return Pi[i](t);
    },
    has(r, i) {
      return i in r || i in Pi;
    }
  })) : t.proxy;
}
function Af(t, r = !0) {
  return nt(t) ? t.displayName || t.name : t.name || r && t.__name;
}
function Df(t) {
  return nt(t) && "__vccOpts" in t;
}
const He = (t, r) => bd(t, r, Bi), Pf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Ps;
const Ll = typeof window < "u" && window.trustedTypes;
if (Ll)
  try {
    Ps = /* @__PURE__ */ Ll.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch {
  }
const gc = Ps ? (t) => Ps.createHTML(t) : (t) => t, Sf = "http://www.w3.org/2000/svg", Lf = "http://www.w3.org/1998/Math/MathML", Cr = typeof document < "u" ? document : null, kl = Cr && /* @__PURE__ */ Cr.createElement("template"), kf = {
  insert: (t, r, i) => {
    r.insertBefore(t, i || null);
  },
  remove: (t) => {
    const r = t.parentNode;
    r && r.removeChild(t);
  },
  createElement: (t, r, i, s) => {
    const c = r === "svg" ? Cr.createElementNS(Sf, t) : r === "mathml" ? Cr.createElementNS(Lf, t) : i ? Cr.createElement(t, { is: i }) : Cr.createElement(t);
    return t === "select" && s && s.multiple != null && c.setAttribute("multiple", s.multiple), c;
  },
  createText: (t) => Cr.createTextNode(t),
  createComment: (t) => Cr.createComment(t),
  setText: (t, r) => {
    t.nodeValue = r;
  },
  setElementText: (t, r) => {
    t.textContent = r;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => Cr.querySelector(t),
  setScopeId(t, r) {
    t.setAttribute(r, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, r, i, s, c, f) {
    const u = i ? i.previousSibling : r.lastChild;
    if (c && (c === f || c.nextSibling))
      for (; r.insertBefore(c.cloneNode(!0), i), !(c === f || !(c = c.nextSibling)); )
        ;
    else {
      kl.innerHTML = gc(
        s === "svg" ? `<svg>${t}</svg>` : s === "mathml" ? `<math>${t}</math>` : t
      );
      const p = kl.content;
      if (s === "svg" || s === "mathml") {
        const v = p.firstChild;
        for (; v.firstChild; )
          p.appendChild(v.firstChild);
        p.removeChild(v);
      }
      r.insertBefore(p, i);
    }
    return [
      // first
      u ? u.nextSibling : r.firstChild,
      // last
      i ? i.previousSibling : r.lastChild
    ];
  }
}, jf = Symbol("_vtc");
function $f(t, r, i) {
  const s = t[jf];
  s && (r = (r ? [r, ...s] : [...s]).join(" ")), r == null ? t.removeAttribute("class") : i ? t.setAttribute("class", r) : t.className = r;
}
const jl = Symbol("_vod"), Ff = Symbol("_vsh"), Mf = Symbol(""), Bf = /(^|;)\s*display\s*:/;
function Kf(t, r, i) {
  const s = t.style, c = kt(i);
  let f = !1;
  if (i && !c) {
    if (r)
      if (kt(r))
        for (const u of r.split(";")) {
          const p = u.slice(0, u.indexOf(":")).trim();
          i[p] == null && aa(s, p, "");
        }
      else
        for (const u in r)
          i[u] == null && aa(s, u, "");
    for (const u in i)
      u === "display" && (f = !0), aa(s, u, i[u]);
  } else if (c) {
    if (r !== i) {
      const u = s[Mf];
      u && (i += ";" + u), s.cssText = i, f = Bf.test(i);
    }
  } else r && t.removeAttribute("style");
  jl in t && (t[jl] = f ? s.display : "", t[Ff] && (s.display = "none"));
}
const $l = /\s*!important$/;
function aa(t, r, i) {
  if (Xe(i))
    i.forEach((s) => aa(t, r, s));
  else if (i == null && (i = ""), r.startsWith("--"))
    t.setProperty(r, i);
  else {
    const s = qf(t, r);
    $l.test(i) ? t.setProperty(
      Do(s),
      i.replace($l, ""),
      "important"
    ) : t[s] = i;
  }
}
const Fl = ["Webkit", "Moz", "ms"], vs = {};
function qf(t, r) {
  const i = vs[r];
  if (i)
    return i;
  let s = Ln(r);
  if (s !== "filter" && s in t)
    return vs[r] = s;
  s = xa(s);
  for (let c = 0; c < Fl.length; c++) {
    const f = Fl[c] + s;
    if (f in t)
      return vs[r] = f;
  }
  return r;
}
const Ml = "http://www.w3.org/1999/xlink";
function Bl(t, r, i, s, c, f = qc(r)) {
  s && r.startsWith("xlink:") ? i == null ? t.removeAttributeNS(Ml, r.slice(6, r.length)) : t.setAttributeNS(Ml, r, i) : i == null || f && !fu(i) ? t.removeAttribute(r) : t.setAttribute(
    r,
    f ? "" : Wn(i) ? String(i) : i
  );
}
function Kl(t, r, i, s, c) {
  if (r === "innerHTML" || r === "textContent") {
    i != null && (t[r] = r === "innerHTML" ? gc(i) : i);
    return;
  }
  const f = t.tagName;
  if (r === "value" && f !== "PROGRESS" && // custom elements may use _value internally
  !f.includes("-")) {
    const p = f === "OPTION" ? t.getAttribute("value") || "" : t.value, v = i == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(i);
    (p !== v || !("_value" in t)) && (t.value = v), i == null && t.removeAttribute(r), t._value = i;
    return;
  }
  let u = !1;
  if (i === "" || i == null) {
    const p = typeof t[r];
    p === "boolean" ? i = fu(i) : i == null && p === "string" ? (i = "", u = !0) : p === "number" && (i = 0, u = !0);
  }
  try {
    t[r] = i;
  } catch {
  }
  u && t.removeAttribute(c || r);
}
function Ir(t, r, i, s) {
  t.addEventListener(r, i, s);
}
function Uf(t, r, i, s) {
  t.removeEventListener(r, i, s);
}
const ql = Symbol("_vei");
function Vf(t, r, i, s, c = null) {
  const f = t[ql] || (t[ql] = {}), u = f[r];
  if (s && u)
    u.value = s;
  else {
    const [p, v] = Wf(r);
    if (s) {
      const k = f[r] = Yf(
        s,
        c
      );
      Ir(t, p, k, v);
    } else u && (Uf(t, p, u, v), f[r] = void 0);
  }
}
const Ul = /(?:Once|Passive|Capture)$/;
function Wf(t) {
  let r;
  if (Ul.test(t)) {
    r = {};
    let s;
    for (; s = t.match(Ul); )
      t = t.slice(0, t.length - s[0].length), r[s[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Do(t.slice(2)), r];
}
let ys = 0;
const Gf = /* @__PURE__ */ Promise.resolve(), Hf = () => ys || (Gf.then(() => ys = 0), ys = Date.now());
function Yf(t, r) {
  const i = (s) => {
    if (!s._vts)
      s._vts = Date.now();
    else if (s._vts <= i.attached)
      return;
    Qn(
      zf(s, i.value),
      r,
      5,
      [s]
    );
  };
  return i.value = t, i.attached = Hf(), i;
}
function zf(t, r) {
  if (Xe(r)) {
    const i = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      i.call(t), t._stopped = !0;
    }, r.map(
      (s) => (c) => !c._stopped && s && s(c)
    );
  } else
    return r;
}
const Vl = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, Xf = (t, r, i, s, c, f) => {
  const u = c === "svg";
  r === "class" ? $f(t, s, u) : r === "style" ? Kf(t, i, s) : _a(r) ? Bs(r) || Vf(t, r, i, s, f) : (r[0] === "." ? (r = r.slice(1), !0) : r[0] === "^" ? (r = r.slice(1), !1) : Qf(t, r, s, u)) ? (Kl(t, r, s), !t.tagName.includes("-") && (r === "value" || r === "checked" || r === "selected") && Bl(t, r, s, u, f, r !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(r) || !kt(s)) ? Kl(t, Ln(r), s, f, r) : (r === "true-value" ? t._trueValue = s : r === "false-value" && (t._falseValue = s), Bl(t, r, s, u));
};
function Qf(t, r, i, s) {
  if (s)
    return !!(r === "innerHTML" || r === "textContent" || r in t && Vl(r) && nt(i));
  if (r === "spellcheck" || r === "draggable" || r === "translate" || r === "autocorrect" || r === "form" || r === "list" && t.tagName === "INPUT" || r === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (r === "width" || r === "height") {
    const c = t.tagName;
    if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE")
      return !1;
  }
  return Vl(r) && kt(i) ? !1 : r in t;
}
const Vr = (t) => {
  const r = t.props["onUpdate:modelValue"] || !1;
  return Xe(r) ? (i) => na(r, i) : r;
};
function Jf(t) {
  t.target.composing = !0;
}
function Wl(t) {
  const r = t.target;
  r.composing && (r.composing = !1, r.dispatchEvent(new Event("input")));
}
const Sn = Symbol("_assign"), Jn = {
  created(t, { modifiers: { lazy: r, trim: i, number: s } }, c) {
    t[Sn] = Vr(c);
    const f = s || c.props && c.props.type === "number";
    Ir(t, r ? "change" : "input", (u) => {
      if (u.target.composing) return;
      let p = t.value;
      i && (p = p.trim()), f && (p = ca(p)), t[Sn](p);
    }), i && Ir(t, "change", () => {
      t.value = t.value.trim();
    }), r || (Ir(t, "compositionstart", Jf), Ir(t, "compositionend", Wl), Ir(t, "change", Wl));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: r }) {
    t.value = r ?? "";
  },
  beforeUpdate(t, { value: r, oldValue: i, modifiers: { lazy: s, trim: c, number: f } }, u) {
    if (t[Sn] = Vr(u), t.composing) return;
    const p = (f || t.type === "number") && !/^0\d/.test(t.value) ? ca(t.value) : t.value, v = r ?? "";
    p !== v && (document.activeElement === t && t.type !== "range" && (s && r === i || c && t.value.trim() === v) || (t.value = v));
  }
}, Dr = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, r, i) {
    t[Sn] = Vr(i), Ir(t, "change", () => {
      const s = t._modelValue, c = qo(t), f = t.checked, u = t[Sn];
      if (Xe(s)) {
        const p = Us(s, c), v = p !== -1;
        if (f && !v)
          u(s.concat(c));
        else if (!f && v) {
          const k = [...s];
          k.splice(p, 1), u(k);
        }
      } else if (Wo(s)) {
        const p = new Set(s);
        f ? p.add(c) : p.delete(c), u(p);
      } else
        u(bc(t, f));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Gl,
  beforeUpdate(t, r, i) {
    t[Sn] = Vr(i), Gl(t, r, i);
  }
};
function Gl(t, { value: r, oldValue: i }, s) {
  t._modelValue = r;
  let c;
  if (Xe(r))
    c = Us(r, s.props.value) > -1;
  else if (Wo(r))
    c = r.has(s.props.value);
  else {
    if (r === i) return;
    c = Io(r, bc(t, !0));
  }
  t.checked !== c && (t.checked = c);
}
const Zn = {
  created(t, { value: r }, i) {
    t.checked = Io(r, i.props.value), t[Sn] = Vr(i), Ir(t, "change", () => {
      t[Sn](qo(t));
    });
  },
  beforeUpdate(t, { value: r, oldValue: i }, s) {
    t[Sn] = Vr(s), r !== i && (t.checked = Io(r, s.props.value));
  }
}, Pt = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: r, modifiers: { number: i } }, s) {
    const c = Wo(r);
    Ir(t, "change", () => {
      const f = Array.prototype.filter.call(t.options, (u) => u.selected).map(
        (u) => i ? ca(qo(u)) : qo(u)
      );
      t[Sn](
        t.multiple ? c ? new Set(f) : f : f[0]
      ), t._assigning = !0, Xs(() => {
        t._assigning = !1;
      });
    }), t[Sn] = Vr(s);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: r }) {
    Hl(t, r);
  },
  beforeUpdate(t, r, i) {
    t[Sn] = Vr(i);
  },
  updated(t, { value: r }) {
    t._assigning || Hl(t, r);
  }
};
function Hl(t, r) {
  const i = t.multiple, s = Xe(r);
  if (!(i && !s && !Wo(r))) {
    for (let c = 0, f = t.options.length; c < f; c++) {
      const u = t.options[c], p = qo(u);
      if (i)
        if (s) {
          const v = typeof p;
          v === "string" || v === "number" ? u.selected = r.some((k) => String(k) === String(p)) : u.selected = Us(r, p) > -1;
        } else
          u.selected = r.has(p);
      else if (Io(qo(u), r)) {
        t.selectedIndex !== c && (t.selectedIndex = c);
        return;
      }
    }
    !i && t.selectedIndex !== -1 && (t.selectedIndex = -1);
  }
}
function qo(t) {
  return "_value" in t ? t._value : t.value;
}
function bc(t, r) {
  const i = r ? "_trueValue" : "_falseValue";
  return i in t ? t[i] : r;
}
const Zf = ["ctrl", "shift", "alt", "meta"], ep = {
  stop: (t) => t.stopPropagation(),
  prevent: (t) => t.preventDefault(),
  self: (t) => t.target !== t.currentTarget,
  ctrl: (t) => !t.ctrlKey,
  shift: (t) => !t.shiftKey,
  alt: (t) => !t.altKey,
  meta: (t) => !t.metaKey,
  left: (t) => "button" in t && t.button !== 0,
  middle: (t) => "button" in t && t.button !== 1,
  right: (t) => "button" in t && t.button !== 2,
  exact: (t, r) => Zf.some((i) => t[`${i}Key`] && !r.includes(i))
}, ga = (t, r) => {
  const i = t._withMods || (t._withMods = {}), s = r.join(".");
  return i[s] || (i[s] = (c, ...f) => {
    for (let u = 0; u < r.length; u++) {
      const p = ep[r[u]];
      if (p && p(c, r)) return;
    }
    return t(c, ...f);
  });
}, tp = /* @__PURE__ */ an({ patchProp: Xf }, kf);
let Yl;
function np() {
  return Yl || (Yl = of(tp));
}
const rp = (...t) => {
  const r = np().createApp(...t), { mount: i } = r;
  return r.mount = (s) => {
    const c = ip(s);
    if (!c) return;
    const f = r._component;
    !nt(f) && !f.render && !f.template && (f.template = c.innerHTML), c.nodeType === 1 && (c.textContent = "");
    const u = i(c, !1, op(c));
    return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), u;
  }, r;
};
function op(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function ip(t) {
  return kt(t) ? document.querySelector(t) : t;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let wc;
const ka = (t) => wc = t, _c = (
  /* istanbul ignore next */
  Symbol()
);
function Ss(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var ki;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(ki || (ki = {}));
function ap() {
  const t = vu(!0), r = t.run(() => Ke({}));
  let i = [], s = [];
  const c = Ea({
    install(f) {
      ka(c), c._a = f, f.provide(_c, c), f.config.globalProperties.$pinia = c, s.forEach((u) => i.push(u)), s = [];
    },
    use(f) {
      return this._a ? i.push(f) : s.push(f), this;
    },
    _p: i,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: r
  });
  return c;
}
const Nc = () => {
};
function zl(t, r, i, s = Nc) {
  t.push(r);
  const c = () => {
    const f = t.indexOf(r);
    f > -1 && (t.splice(f, 1), s());
  };
  return !i && Vs() && yu(c), c;
}
function Lo(t, ...r) {
  t.slice().forEach((i) => {
    i(...r);
  });
}
const sp = (t) => t(), Xl = Symbol(), gs = Symbol();
function Ls(t, r) {
  t instanceof Map && r instanceof Map ? r.forEach((i, s) => t.set(s, i)) : t instanceof Set && r instanceof Set && r.forEach(t.add, t);
  for (const i in r) {
    if (!r.hasOwnProperty(i))
      continue;
    const s = r[i], c = t[i];
    Ss(c) && Ss(s) && t.hasOwnProperty(i) && !St(s) && !Ar(s) ? t[i] = Ls(c, s) : t[i] = s;
  }
  return t;
}
const lp = (
  /* istanbul ignore next */
  Symbol()
);
function up(t) {
  return !Ss(t) || !Object.prototype.hasOwnProperty.call(t, lp);
}
const { assign: Fr } = Object;
function cp(t) {
  return !!(St(t) && t.effect);
}
function dp(t, r, i, s) {
  const { state: c, actions: f, getters: u } = r, p = i.state.value[t];
  let v;
  function k() {
    p || (i.state.value[t] = c ? c() : {});
    const D = hd(i.state.value[t]);
    return Fr(D, f, Object.keys(u || {}).reduce(($, U) => ($[U] = Ea(He(() => {
      ka(i);
      const W = i._s.get(t);
      return u[U].call(W, W);
    })), $), {}));
  }
  return v = xc(t, k, r, i, s, !0), v;
}
function xc(t, r, i = {}, s, c, f) {
  let u;
  const p = Fr({ actions: {} }, i), v = { deep: !0 };
  let k, D, $ = [], U = [], W;
  const A = s.state.value[t];
  !f && !A && (s.state.value[t] = {}), Ke({});
  let P;
  function B(Ue) {
    let Y;
    k = D = !1, typeof Ue == "function" ? (Ue(s.state.value[t]), Y = {
      type: ki.patchFunction,
      storeId: t,
      events: W
    }) : (Ls(s.state.value[t], Ue), Y = {
      type: ki.patchObject,
      payload: Ue,
      storeId: t,
      events: W
    });
    const oe = P = Symbol();
    Xs().then(() => {
      P === oe && (k = !0);
    }), D = !0, Lo($, Y, s.state.value[t]);
  }
  const X = f ? function() {
    const { state: Y } = i, oe = Y ? Y() : {};
    this.$patch((ce) => {
      Fr(ce, oe);
    });
  } : (
    /* istanbul ignore next */
    Nc
  );
  function F() {
    u.stop(), $ = [], U = [], s._s.delete(t);
  }
  const E = (Ue, Y = "") => {
    if (Xl in Ue)
      return Ue[gs] = Y, Ue;
    const oe = function() {
      ka(s);
      const ce = Array.from(arguments), fe = [], me = [];
      function Pe(Ne) {
        fe.push(Ne);
      }
      function De(Ne) {
        me.push(Ne);
      }
      Lo(U, {
        args: ce,
        name: oe[gs],
        store: we,
        after: Pe,
        onError: De
      });
      let Se;
      try {
        Se = Ue.apply(this && this.$id === t ? this : we, ce);
      } catch (Ne) {
        throw Lo(me, Ne), Ne;
      }
      return Se instanceof Promise ? Se.then((Ne) => (Lo(fe, Ne), Ne)).catch((Ne) => (Lo(me, Ne), Promise.reject(Ne))) : (Lo(fe, Se), Se);
    };
    return oe[Xl] = !0, oe[gs] = Y, oe;
  }, K = {
    _p: s,
    // _s: scope,
    $id: t,
    $onAction: zl.bind(null, U),
    $patch: B,
    $reset: X,
    $subscribe(Ue, Y = {}) {
      const oe = zl($, Ue, Y.detached, () => ce()), ce = u.run(() => qt(() => s.state.value[t], (fe) => {
        (Y.flush === "sync" ? D : k) && Ue({
          storeId: t,
          type: ki.direct,
          events: W
        }, fe);
      }, Fr({}, v, Y)));
      return oe;
    },
    $dispose: F
  }, we = Ui(K);
  s._s.set(t, we);
  const ge = (s._a && s._a.runWithContext || sp)(() => s._e.run(() => (u = vu()).run(() => r({ action: E }))));
  for (const Ue in ge) {
    const Y = ge[Ue];
    if (St(Y) && !cp(Y) || Ar(Y))
      f || (A && up(Y) && (St(Y) ? Y.value = A[Ue] : Ls(Y, A[Ue])), s.state.value[t][Ue] = Y);
    else if (typeof Y == "function") {
      const oe = E(Y, Ue);
      ge[Ue] = oe, p.actions[Ue] = Y;
    }
  }
  return Fr(we, ge), Fr(yt(we), ge), Object.defineProperty(we, "$state", {
    get: () => s.state.value[t],
    set: (Ue) => {
      B((Y) => {
        Fr(Y, Ue);
      });
    }
  }), s._p.forEach((Ue) => {
    Fr(we, u.run(() => Ue({
      store: we,
      app: s._a,
      pinia: s,
      options: p
    })));
  }), A && f && i.hydrate && i.hydrate(we.$state, A), k = !0, D = !0, we;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function sl(t, r, i) {
  let s;
  const c = typeof r == "function";
  s = c ? i : r;
  function f(u, p) {
    const v = Qd();
    return u = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    u || (v ? Si(_c, null) : null), u && ka(u), u = wc, u._s.has(t) || (c ? xc(t, r, s, u) : dp(t, s, u)), u._s.get(t);
  }
  return f.$id = t, f;
}
function jt(t) {
  const r = yt(t), i = {};
  for (const s in r) {
    const c = r[s];
    c.effect ? i[s] = // ...
    He({
      get: () => t[s],
      set(f) {
        t[s] = f;
      }
    }) : (St(c) || Ar(c)) && (i[s] = // ---
    yd(t, s));
  }
  return i;
}
const Ki = ["q", "t"];
function ba(t) {
  return `${t.prefix}${t.lnClass}${t.lnInst}`;
}
var et = /* @__PURE__ */ ((t) => (t.GOOSE = "GOOSE", t.SMV = "SMV", t.REPORT = "Report", t.INTERNAL = "Internal", t.WIRED = "Wired", t.CONTROL = "Control", t))(et || {});
const Uo = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: [],
  Internal: []
}, ja = /* @__PURE__ */ sl("dataflow/sidebar", () => {
  const t = Ke(null);
  function r(s) {
    t.value = s;
  }
  function i(s) {
    const c = s === t.value ? null : s;
    r(c);
  }
  return {
    activeElement: t,
    setActiveElement: r,
    setOrResetActiveElement: i
  };
});
var fp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function pp(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var sa = { exports: {} }, hp = sa.exports, Ql;
function mp() {
  return Ql || (Ql = 1, function(t, r) {
    (function(i, s) {
      t.exports = s();
    })(hp, function() {
      var i = function(e, n) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {
          o.__proto__ = a;
        } || function(o, a) {
          for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = a[l]);
        })(e, n);
      }, s = function() {
        return (s = Object.assign || function(e) {
          for (var n, o = 1, a = arguments.length; o < a; o++) for (var l in n = arguments[o]) Object.prototype.hasOwnProperty.call(n, l) && (e[l] = n[l]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, n, o) {
        for (var a, l = 0, d = n.length; l < d; l++) !a && l in n || ((a = a || Array.prototype.slice.call(n, 0, l))[l] = n[l]);
        return e.concat(a || Array.prototype.slice.call(n));
      }
      var f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : fp, u = Object.keys, p = Array.isArray;
      function v(e, n) {
        return typeof n != "object" || u(n).forEach(function(o) {
          e[o] = n[o];
        }), e;
      }
      typeof Promise > "u" || f.Promise || (f.Promise = Promise);
      var k = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function $(e, n) {
        return D.call(e, n);
      }
      function U(e, n) {
        typeof n == "function" && (n = n(k(e))), (typeof Reflect > "u" ? u : Reflect.ownKeys)(n).forEach(function(o) {
          A(e, o, n[o]);
        });
      }
      var W = Object.defineProperty;
      function A(e, n, o, a) {
        W(e, n, v(o && $(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, a));
      }
      function P(e) {
        return { from: function(n) {
          return e.prototype = Object.create(n.prototype), A(e.prototype, "constructor", e), { extend: U.bind(null, e.prototype) };
        } };
      }
      var B = Object.getOwnPropertyDescriptor, X = [].slice;
      function F(e, n, o) {
        return X.call(e, n, o);
      }
      function E(e, n) {
        return n(e);
      }
      function K(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function we(e) {
        f.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function de(e, n) {
        if (typeof n == "string" && $(e, n)) return e[n];
        if (!n) return e;
        if (typeof n != "string") {
          for (var o = [], a = 0, l = n.length; a < l; ++a) {
            var d = de(e, n[a]);
            o.push(d);
          }
          return o;
        }
        var m = n.indexOf(".");
        if (m !== -1) {
          var y = e[n.substr(0, m)];
          return y == null ? void 0 : de(y, n.substr(m + 1));
        }
      }
      function ge(e, n, o) {
        if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof n != "string" && "length" in n) {
          K(typeof o != "string" && "length" in o);
          for (var a = 0, l = n.length; a < l; ++a) ge(e, n[a], o[a]);
        } else {
          var d, m, y = n.indexOf(".");
          y !== -1 ? (d = n.substr(0, y), (m = n.substr(y + 1)) === "" ? o === void 0 ? p(e) && !isNaN(parseInt(d)) ? e.splice(d, 1) : delete e[d] : e[d] = o : ge(y = !(y = e[d]) || !$(e, d) ? e[d] = {} : y, m, o)) : o === void 0 ? p(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = o;
        }
      }
      function Ue(e) {
        var n, o = {};
        for (n in e) $(e, n) && (o[n] = e[n]);
        return o;
      }
      var Y = [].concat;
      function oe(e) {
        return Y.apply([], e);
      }
      var Je = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(oe([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(n) {
          return n + e + "Array";
        });
      }))).filter(function(e) {
        return f[e];
      }), ce = new Set(Je.map(function(e) {
        return f[e];
      })), fe = null;
      function me(e) {
        return fe = /* @__PURE__ */ new WeakMap(), e = function n(o) {
          if (!o || typeof o != "object") return o;
          var a = fe.get(o);
          if (a) return a;
          if (p(o)) {
            a = [], fe.set(o, a);
            for (var l = 0, d = o.length; l < d; ++l) a.push(n(o[l]));
          } else if (ce.has(o.constructor)) a = o;
          else {
            var m, y = k(o);
            for (m in a = y === Object.prototype ? {} : Object.create(y), fe.set(o, a), o) $(o, m) && (a[m] = n(o[m]));
          }
          return a;
        }(e), fe = null, e;
      }
      var Pe = {}.toString;
      function De(e) {
        return Pe.call(e).slice(8, -1);
      }
      var Se = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ne = typeof Se == "symbol" ? function(e) {
        var n;
        return e != null && (n = e[Se]) && n.apply(e);
      } : function() {
        return null;
      };
      function Fe(e, n) {
        return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n;
      }
      var pt = {};
      function Me(e) {
        var n, o, a, l;
        if (arguments.length === 1) {
          if (p(e)) return e.slice();
          if (this === pt && typeof e == "string") return [e];
          if (l = Ne(e)) {
            for (o = []; !(a = l.next()).done; ) o.push(a.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (n = e.length) != "number") return [e];
          for (o = new Array(n); n--; ) o[n] = e[n];
          return o;
        }
        for (n = arguments.length, o = new Array(n); n--; ) o[n] = arguments[n];
        return o;
      }
      var Qe = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ge = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Dt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ge), $t = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function it(e, n) {
        this.name = e, this.message = n;
      }
      function Ht(e, n) {
        return e + ". Errors: " + Object.keys(n).map(function(o) {
          return n[o].toString();
        }).filter(function(o, a, l) {
          return l.indexOf(o) === a;
        }).join(`
`);
      }
      function bn(e, n, o, a) {
        this.failures = n, this.failedKeys = a, this.successCount = o, this.message = Ht(e, n);
      }
      function Mt(e, n) {
        this.name = "BulkError", this.failures = Object.keys(n).map(function(o) {
          return n[o];
        }), this.failuresByPos = n, this.message = Ht(e, this.failures);
      }
      P(it).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), P(bn).from(it), P(Mt).from(it);
      var L = Dt.reduce(function(e, n) {
        return e[n] = n + "Error", e;
      }, {}), x = it, G = Dt.reduce(function(e, n) {
        var o = n + "Error";
        function a(l, d) {
          this.name = o, l ? typeof l == "string" ? (this.message = "".concat(l).concat(d ? `
 ` + d : ""), this.inner = d || null) : typeof l == "object" && (this.message = "".concat(l.name, " ").concat(l.message), this.inner = l) : (this.message = $t[n] || o, this.inner = null);
        }
        return P(a).from(x), e[n] = a, e;
      }, {});
      G.Syntax = SyntaxError, G.Type = TypeError, G.Range = RangeError;
      var Z = Ge.reduce(function(e, n) {
        return e[n + "Error"] = G[n], e;
      }, {}), st = Dt.reduce(function(e, n) {
        return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = G[n]), e;
      }, {});
      function S() {
      }
      function H(e) {
        return e;
      }
      function ue(e, n) {
        return e == null || e === H ? n : function(o) {
          return n(e(o));
        };
      }
      function he(e, n) {
        return function() {
          e.apply(this, arguments), n.apply(this, arguments);
        };
      }
      function be(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var a = this.onsuccess, l = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var d = n.apply(this, arguments);
          return a && (this.onsuccess = this.onsuccess ? he(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? he(l, this.onerror) : l), d !== void 0 ? d : o;
        };
      }
      function ve(e, n) {
        return e === S ? n : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, a = this.onerror;
          this.onsuccess = this.onerror = null, n.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? he(o, this.onsuccess) : o), a && (this.onerror = this.onerror ? he(a, this.onerror) : a);
        };
      }
      function Oe(e, n) {
        return e === S ? n : function(o) {
          var a = e.apply(this, arguments);
          v(o, a);
          var l = this.onsuccess, d = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = n.apply(this, arguments), l && (this.onsuccess = this.onsuccess ? he(l, this.onsuccess) : l), d && (this.onerror = this.onerror ? he(d, this.onerror) : d), a === void 0 ? o === void 0 ? void 0 : o : v(a, o);
        };
      }
      function Ie(e, n) {
        return e === S ? n : function() {
          return n.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function xe(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var a = this, l = arguments.length, d = new Array(l); l--; ) d[l] = arguments[l];
            return o.then(function() {
              return n.apply(a, d);
            });
          }
          return n.apply(this, arguments);
        };
      }
      st.ModifyError = bn, st.DexieError = it, st.BulkError = Mt;
      var ye = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function qe(e) {
        ye = e;
      }
      var Ae = {}, Ve = 100, Je = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, k(e), e];
        var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [n, k(n), e];
      }(), Ge = Je[0], Dt = Je[1], Je = Je[2], Dt = Dt && Dt.then, at = Ge && Ge.constructor, ut = !!Je, Rt = function(e, n) {
        wn.push([e, n]), Ut && (queueMicrotask(Ma), Ut = !1);
      }, Ft = !0, Ut = !0, Ct = [], sn = [], Gn = H, gt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: S, pgp: !1, env: {}, finalize: S }, pe = gt, wn = [], ln = 0, er = [];
      function se(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var n = this._PSD = pe;
        if (typeof e != "function") {
          if (e !== Ae) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Hr(this, this._value));
        }
        this._state = null, this._value = null, ++n.ref, function o(a, l) {
          try {
            l(function(d) {
              if (a._state === null) {
                if (d === a) throw new TypeError("A promise cannot be resolved with itself.");
                var m = a._lib && _n();
                d && typeof d.then == "function" ? o(a, function(y, b) {
                  d instanceof se ? d._then(y, b) : d.then(y, b);
                }) : (a._state = !0, a._value = d, Ho(a)), m && Nn();
              }
            }, Hr.bind(null, a));
          } catch (d) {
            Hr(a, d);
          }
        }(this, e);
      }
      var Gr = { get: function() {
        var e = pe, n = or;
        function o(a, l) {
          var d = this, m = !e.global && (e !== pe || n !== or), y = m && !Qt(), b = new se(function(_, R) {
            Yr(d, new Go(zo(a, e, m, y), zo(l, e, m, y), _, R, e));
          });
          return this._consoleTask && (b._consoleTask = this._consoleTask), b;
        }
        return o.prototype = Ae, o;
      }, set: function(e) {
        A(this, "then", e && e.prototype === Ae ? Gr : { get: function() {
          return e;
        }, set: Gr.set });
      } };
      function Go(e, n, o, a, l) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = o, this.reject = a, this.psd = l;
      }
      function Hr(e, n) {
        var o, a;
        sn.push(n), e._state === null && (o = e._lib && _n(), n = Gn(n), e._state = !1, e._value = n, a = e, Ct.some(function(l) {
          return l._value === a._value;
        }) || Ct.push(a), Ho(e), o && Nn());
      }
      function Ho(e) {
        var n = e._listeners;
        e._listeners = [];
        for (var o = 0, a = n.length; o < a; ++o) Yr(e, n[o]);
        var l = e._PSD;
        --l.ref || l.finalize(), ln === 0 && (++ln, Rt(function() {
          --ln == 0 && zr();
        }, []));
      }
      function Yr(e, n) {
        if (e._state !== null) {
          var o = e._state ? n.onFulfilled : n.onRejected;
          if (o === null) return (e._state ? n.resolve : n.reject)(e._value);
          ++n.psd.ref, ++ln, Rt(Fa, [o, e, n]);
        } else e._listeners.push(n);
      }
      function Fa(e, n, o) {
        try {
          var a, l = n._value;
          !n._state && sn.length && (sn = []), a = ye && n._consoleTask ? n._consoleTask.run(function() {
            return e(l);
          }) : e(l), n._state || sn.indexOf(l) !== -1 || function(d) {
            for (var m = Ct.length; m; ) if (Ct[--m]._value === d._value) return Ct.splice(m, 1);
          }(n), o.resolve(a);
        } catch (d) {
          o.reject(d);
        } finally {
          --ln == 0 && zr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function Ma() {
        un(gt, function() {
          _n() && Nn();
        });
      }
      function _n() {
        var e = Ft;
        return Ut = Ft = !1, e;
      }
      function Nn() {
        var e, n, o;
        do
          for (; 0 < wn.length; ) for (e = wn, wn = [], o = e.length, n = 0; n < o; ++n) {
            var a = e[n];
            a[0].apply(null, a[1]);
          }
        while (0 < wn.length);
        Ut = Ft = !0;
      }
      function zr() {
        var e = Ct;
        Ct = [], e.forEach(function(a) {
          a._PSD.onunhandled.call(null, a._value, a);
        });
        for (var n = er.slice(0), o = n.length; o; ) n[--o]();
      }
      function tr(e) {
        return new se(Ae, !1, e);
      }
      function Ze(e, n) {
        var o = pe;
        return function() {
          var a = _n(), l = pe;
          try {
            return Jt(o, !0), e.apply(this, arguments);
          } catch (d) {
            n && n(d);
          } finally {
            Jt(l, !1), a && Nn();
          }
        };
      }
      U(se.prototype, { then: Gr, _then: function(e, n) {
        Yr(this, new Go(null, null, e, n, pe));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var n = e, o = arguments[1];
        return typeof n == "function" ? this.then(null, function(a) {
          return (a instanceof n ? o : tr)(a);
        }) : this.then(null, function(a) {
          return (a && a.name === n ? o : tr)(a);
        });
      }, finally: function(e) {
        return this.then(function(n) {
          return se.resolve(e()).then(function() {
            return n;
          });
        }, function(n) {
          return se.resolve(e()).then(function() {
            return tr(n);
          });
        });
      }, timeout: function(e, n) {
        var o = this;
        return e < 1 / 0 ? new se(function(a, l) {
          var d = setTimeout(function() {
            return l(new G.Timeout(n));
          }, e);
          o.then(a, l).finally(clearTimeout.bind(null, d));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && A(se.prototype, Symbol.toStringTag, "Dexie.Promise"), gt.env = Yo(), U(se, { all: function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n, o) {
          e.length === 0 && n([]);
          var a = e.length;
          e.forEach(function(l, d) {
            return se.resolve(l).then(function(m) {
              e[d] = m, --a || n(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof se ? e : e && typeof e.then == "function" ? new se(function(n, o) {
          e.then(n, o);
        }) : new se(Ae, !0, e);
      }, reject: tr, race: function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n, o) {
          e.map(function(a) {
            return se.resolve(a).then(n, o);
          });
        });
      }, PSD: { get: function() {
        return pe;
      }, set: function(e) {
        return pe = e;
      } }, totalEchoes: { get: function() {
        return or;
      } }, newPSD: Xt, usePSD: un, scheduler: { get: function() {
        return Rt;
      }, set: function(e) {
        Rt = e;
      } }, rejectionMapper: { get: function() {
        return Gn;
      }, set: function(e) {
        Gn = e;
      } }, follow: function(e, n) {
        return new se(function(o, a) {
          return Xt(function(l, d) {
            var m = pe;
            m.unhandleds = [], m.onunhandled = d, m.finalize = he(function() {
              var y, b = this;
              y = function() {
                b.unhandleds.length === 0 ? l() : d(b.unhandleds[0]);
              }, er.push(function _() {
                y(), er.splice(er.indexOf(_), 1);
              }), ++ln, Rt(function() {
                --ln == 0 && zr();
              }, []);
            }, m.finalize), e();
          }, n, o, a);
        });
      } }), at && (at.allSettled && A(se, "allSettled", function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n) {
          e.length === 0 && n([]);
          var o = e.length, a = new Array(o);
          e.forEach(function(l, d) {
            return se.resolve(l).then(function(m) {
              return a[d] = { status: "fulfilled", value: m };
            }, function(m) {
              return a[d] = { status: "rejected", reason: m };
            }).then(function() {
              return --o || n(a);
            });
          });
        });
      }), at.any && typeof AggregateError < "u" && A(se, "any", function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n, o) {
          e.length === 0 && o(new AggregateError([]));
          var a = e.length, l = new Array(a);
          e.forEach(function(d, m) {
            return se.resolve(d).then(function(y) {
              return n(y);
            }, function(y) {
              l[m] = y, --a || o(new AggregateError(l));
            });
          });
        });
      }), at.withResolvers && (se.withResolvers = at.withResolvers));
      var ct = { awaits: 0, echoes: 0, id: 0 }, Ba = 0, nr = [], rr = 0, or = 0, Ka = 0;
      function Xt(e, n, o, a) {
        var l = pe, d = Object.create(l);
        return d.parent = l, d.ref = 0, d.global = !1, d.id = ++Ka, gt.env, d.env = ut ? { Promise: se, PromiseProp: { value: se, configurable: !0, writable: !0 }, all: se.all, race: se.race, allSettled: se.allSettled, any: se.any, resolve: se.resolve, reject: se.reject } : {}, n && v(d, n), ++l.ref, d.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, a = un(d, e, o, a), d.ref === 0 && d.finalize(), a;
      }
      function xn() {
        return ct.id || (ct.id = ++Ba), ++ct.awaits, ct.echoes += Ve, ct.id;
      }
      function Qt() {
        return !!ct.awaits && (--ct.awaits == 0 && (ct.id = 0), ct.echoes = ct.awaits * Ve, !0);
      }
      function ir(e) {
        return ct.echoes && e && e.constructor === at ? (xn(), e.then(function(n) {
          return Qt(), n;
        }, function(n) {
          return Qt(), rt(n);
        })) : e;
      }
      function qa() {
        var e = nr[nr.length - 1];
        nr.pop(), Jt(e, !1);
      }
      function Jt(e, n) {
        var o, a = pe;
        (n ? !ct.echoes || rr++ && e === pe : !rr || --rr && e === pe) || queueMicrotask(n ? (function(l) {
          ++or, ct.echoes && --ct.echoes != 0 || (ct.echoes = ct.awaits = ct.id = 0), nr.push(pe), Jt(l, !0);
        }).bind(null, e) : qa), e !== pe && (pe = e, a === gt && (gt.env = Yo()), ut && (o = gt.env.Promise, n = e.env, (a.global || e.global) && (Object.defineProperty(f, "Promise", n.PromiseProp), o.all = n.all, o.race = n.race, o.resolve = n.resolve, o.reject = n.reject, n.allSettled && (o.allSettled = n.allSettled), n.any && (o.any = n.any))));
      }
      function Yo() {
        var e = f.Promise;
        return ut ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function un(e, n, o, a, l) {
        var d = pe;
        try {
          return Jt(e, !0), n(o, a, l);
        } finally {
          Jt(d, !1);
        }
      }
      function zo(e, n, o, a) {
        return typeof e != "function" ? e : function() {
          var l = pe;
          o && xn(), Jt(n, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Jt(l, !1), a && queueMicrotask(Qt);
          }
        };
      }
      function Xr(e) {
        Promise === at && ct.echoes === 0 ? rr === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + Dt).indexOf("[native code]") === -1 && (xn = Qt = S);
      var rt = se.reject, cn = "￿", Vt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Xo = "String expected.", Rn = [], ar = "__dbnames", Qr = "readonly", Jr = "readwrite";
      function dn(e, n) {
        return e ? n ? function() {
          return e.apply(this, arguments) && n.apply(this, arguments);
        } : e : n;
      }
      var Qo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function sr(e) {
        return typeof e != "string" || /\./.test(e) ? function(n) {
          return n;
        } : function(n) {
          return n[e] === void 0 && e in n && delete (n = me(n))[e], n;
        };
      }
      function Jo() {
        throw G.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function ke(e, n) {
        try {
          var o = Zo(e), a = Zo(n);
          if (o !== a) return o === "Array" ? 1 : a === "Array" ? -1 : o === "binary" ? 1 : a === "binary" ? -1 : o === "string" ? 1 : a === "string" ? -1 : o === "Date" ? 1 : a !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return n < e ? 1 : e < n ? -1 : 0;
            case "binary":
              return function(l, d) {
                for (var m = l.length, y = d.length, b = m < y ? m : y, _ = 0; _ < b; ++_) if (l[_] !== d[_]) return l[_] < d[_] ? -1 : 1;
                return m === y ? 0 : m < y ? -1 : 1;
              }(ei(e), ei(n));
            case "Array":
              return function(l, d) {
                for (var m = l.length, y = d.length, b = m < y ? m : y, _ = 0; _ < b; ++_) {
                  var R = ke(l[_], d[_]);
                  if (R !== 0) return R;
                }
                return m === y ? 0 : m < y ? -1 : 1;
              }(e, n);
          }
        } catch {
        }
        return NaN;
      }
      function Zo(e) {
        var n = typeof e;
        return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = De(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function ei(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function lr(e, n, o) {
        var a = e.schema.yProps;
        return a ? (n && 0 < o.numFailures && (n = n.filter(function(l, d) {
          return !o.failures[d];
        })), Promise.all(a.map(function(l) {
          return l = l.updatesTable, n ? e.db.table(l).where("k").anyOf(n).delete() : e.db.table(l).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var ti = (ze.prototype._trans = function(e, n, o) {
        var a = this._tx || pe.trans, l = this.name, d = ye && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function m(_, R, g) {
          if (!g.schema[l]) throw new G.NotFound("Table " + l + " not part of transaction");
          return n(g.idbtrans, g);
        }
        var y = _n();
        try {
          var b = a && a.db._novip === this.db._novip ? a === pe.trans ? a._promise(e, m, o) : Xt(function() {
            return a._promise(e, m, o);
          }, { trans: a, transless: pe.transless || pe }) : function _(R, g, T, w) {
            if (R.idbdb && (R._state.openComplete || pe.letThrough || R._vip)) {
              var N = R._createTransaction(g, T, R._dbSchema);
              try {
                N.create(), R._state.PR1398_maxLoop = 3;
              } catch (O) {
                return O.name === L.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                  return _(R, g, T, w);
                })) : rt(O);
              }
              return N._promise(g, function(O, C) {
                return Xt(function() {
                  return pe.trans = N, w(O, C, N);
                });
              }).then(function(O) {
                if (g === "readwrite") try {
                  N.idbtrans.commit();
                } catch {
                }
                return g === "readonly" ? O : N._completion.then(function() {
                  return O;
                });
              });
            }
            if (R._state.openComplete) return rt(new G.DatabaseClosed(R._state.dbOpenError));
            if (!R._state.isBeingOpened) {
              if (!R._state.autoOpen) return rt(new G.DatabaseClosed());
              R.open().catch(S);
            }
            return R._state.dbReadyPromise.then(function() {
              return _(R, g, T, w);
            });
          }(this.db, e, [this.name], m);
          return d && (b._consoleTask = d, b = b.catch(function(_) {
            return console.trace(_), rt(_);
          })), b;
        } finally {
          y && Nn();
        }
      }, ze.prototype.get = function(e, n) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(n) : e == null ? rt(new G.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(a) {
          return o.core.get({ trans: a, key: e }).then(function(l) {
            return o.hook.reading.fire(l);
          });
        }).then(n);
      }, ze.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (p(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var n = u(e);
        if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(y) {
          if (y.compound && n.every(function(_) {
            return 0 <= y.keyPath.indexOf(_);
          })) {
            for (var b = 0; b < n.length; ++b) if (n.indexOf(y.keyPath[b]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(y, b) {
          return y.keyPath.length - b.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== cn) {
          var d = o.keyPath.slice(0, n.length);
          return this.where(d).equals(d.map(function(b) {
            return e[b];
          }));
        }
        !o && ye && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
        var a = this.schema.idxByName;
        function l(y, b) {
          return ke(y, b) === 0;
        }
        var m = n.reduce(function(g, b) {
          var _ = g[0], R = g[1], g = a[b], T = e[b];
          return [_ || g, _ || !g ? dn(R, g && g.multi ? function(w) {
            return w = de(w, b), p(w) && w.some(function(N) {
              return l(T, N);
            });
          } : function(w) {
            return l(T, de(w, b));
          }) : R];
        }, [null, null]), d = m[0], m = m[1];
        return d ? this.where(d.name).equals(e[d.keyPath]).filter(m) : o ? this.filter(m) : this.where(n).equals("");
      }, ze.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, ze.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, ze.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, ze.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, ze.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, ze.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, ze.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, ze.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, p(e) ? "[".concat(e.join("+"), "]") : e));
      }, ze.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, ze.prototype.mapToClass = function(e) {
        var n, o = this.db, a = this.name;
        function l() {
          return n !== null && n.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Jo && (function(b, _) {
          if (typeof _ != "function" && _ !== null) throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
          function R() {
            this.constructor = b;
          }
          i(b, _), b.prototype = _ === null ? Object.create(_) : (R.prototype = _.prototype, new R());
        }(l, n = e), Object.defineProperty(l.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), l.prototype.table = function() {
          return a;
        }, e = l);
        for (var d = /* @__PURE__ */ new Set(), m = e.prototype; m; m = k(m)) Object.getOwnPropertyNames(m).forEach(function(b) {
          return d.add(b);
        });
        function y(b) {
          if (!b) return b;
          var _, R = Object.create(e.prototype);
          for (_ in b) if (!d.has(_)) try {
            R[_] = b[_];
          } catch {
          }
          return R;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = y, this.hook("reading", y), e;
      }, ze.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          v(this, e);
        });
      }, ze.prototype.add = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, d = a.keyPath, m = e;
        return d && l && (m = sr(d)(e)), this._trans("readwrite", function(y) {
          return o.core.mutate({ trans: y, type: "add", keys: n != null ? [n] : null, values: [m] });
        }).then(function(y) {
          return y.numFailures ? se.reject(y.failures[0]) : y.lastResult;
        }).then(function(y) {
          if (d) try {
            ge(e, d, y);
          } catch {
          }
          return y;
        });
      }, ze.prototype.update = function(e, n) {
        return typeof e != "object" || p(e) ? this.where(":id").equals(e).modify(n) : (e = de(e, this.schema.primKey.keyPath), e === void 0 ? rt(new G.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n));
      }, ze.prototype.put = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, d = a.keyPath, m = e;
        return d && l && (m = sr(d)(e)), this._trans("readwrite", function(y) {
          return o.core.mutate({ trans: y, type: "put", values: [m], keys: n != null ? [n] : null });
        }).then(function(y) {
          return y.numFailures ? se.reject(y.failures[0]) : y.lastResult;
        }).then(function(y) {
          if (d) try {
            ge(e, d, y);
          } catch {
          }
          return y;
        });
      }, ze.prototype.delete = function(e) {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(a) {
            return lr(n, [e], a);
          }).then(function(a) {
            return a.numFailures ? se.reject(a.failures[0]) : void 0;
          });
        });
      }, ze.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(n) {
          return e.core.mutate({ trans: n, type: "deleteRange", range: Qo }).then(function(o) {
            return lr(e, null, o);
          });
        }).then(function(n) {
          return n.numFailures ? se.reject(n.failures[0]) : void 0;
        });
      }, ze.prototype.bulkGet = function(e) {
        var n = this;
        return this._trans("readonly", function(o) {
          return n.core.getMany({ keys: e, trans: o }).then(function(a) {
            return a.map(function(l) {
              return n.hook.reading.fire(l);
            });
          });
        });
      }, ze.prototype.bulkAdd = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, d = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var _ = a.schema.primKey, y = _.auto, _ = _.keyPath;
          if (_ && l) throw new G.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new G.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && y ? e.map(sr(_)) : e;
          return a.core.mutate({ trans: m, type: "add", keys: l, values: _, wantResults: d }).then(function(N) {
            var g = N.numFailures, T = N.results, w = N.lastResult, N = N.failures;
            if (g === 0) return d ? T : w;
            throw new Mt("".concat(a.name, ".bulkAdd(): ").concat(g, " of ").concat(b, " operations failed"), N);
          });
        });
      }, ze.prototype.bulkPut = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, d = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var _ = a.schema.primKey, y = _.auto, _ = _.keyPath;
          if (_ && l) throw new G.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new G.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && y ? e.map(sr(_)) : e;
          return a.core.mutate({ trans: m, type: "put", keys: l, values: _, wantResults: d }).then(function(N) {
            var g = N.numFailures, T = N.results, w = N.lastResult, N = N.failures;
            if (g === 0) return d ? T : w;
            throw new Mt("".concat(a.name, ".bulkPut(): ").concat(g, " of ").concat(b, " operations failed"), N);
          });
        });
      }, ze.prototype.bulkUpdate = function(e) {
        var n = this, o = this.core, a = e.map(function(m) {
          return m.key;
        }), l = e.map(function(m) {
          return m.changes;
        }), d = [];
        return this._trans("readwrite", function(m) {
          return o.getMany({ trans: m, keys: a, cache: "clone" }).then(function(y) {
            var b = [], _ = [];
            e.forEach(function(g, T) {
              var w = g.key, N = g.changes, O = y[T];
              if (O) {
                for (var C = 0, I = Object.keys(N); C < I.length; C++) {
                  var j = I[C], M = N[j];
                  if (j === n.schema.primKey.keyPath) {
                    if (ke(M, w) !== 0) throw new G.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ge(O, j, M);
                }
                d.push(T), b.push(w), _.push(O);
              }
            });
            var R = b.length;
            return o.mutate({ trans: m, type: "put", keys: b, values: _, updates: { keys: a, changeSpecs: l } }).then(function(g) {
              var T = g.numFailures, w = g.failures;
              if (T === 0) return R;
              for (var N = 0, O = Object.keys(w); N < O.length; N++) {
                var C, I = O[N], j = d[Number(I)];
                j != null && (C = w[I], delete w[I], w[j] = C);
              }
              throw new Mt("".concat(n.name, ".bulkUpdate(): ").concat(T, " of ").concat(R, " operations failed"), w);
            });
          });
        });
      }, ze.prototype.bulkDelete = function(e) {
        var n = this, o = e.length;
        return this._trans("readwrite", function(a) {
          return n.core.mutate({ trans: a, type: "delete", keys: e }).then(function(l) {
            return lr(n, e, l);
          });
        }).then(function(m) {
          var l = m.numFailures, d = m.lastResult, m = m.failures;
          if (l === 0) return d;
          throw new Mt("".concat(n.name, ".bulkDelete(): ").concat(l, " of ").concat(o, " operations failed"), m);
        });
      }, ze);
      function ze() {
      }
      function kn(e) {
        function n(m, y) {
          if (y) {
            for (var b = arguments.length, _ = new Array(b - 1); --b; ) _[b - 1] = arguments[b];
            return o[m].subscribe.apply(null, _), e;
          }
          if (typeof m == "string") return o[m];
        }
        var o = {};
        n.addEventType = d;
        for (var a = 1, l = arguments.length; a < l; ++a) d(arguments[a]);
        return n;
        function d(m, y, b) {
          if (typeof m != "object") {
            var _;
            y = y || Ie;
            var R = { subscribers: [], fire: b = b || S, subscribe: function(g) {
              R.subscribers.indexOf(g) === -1 && (R.subscribers.push(g), R.fire = y(R.fire, g));
            }, unsubscribe: function(g) {
              R.subscribers = R.subscribers.filter(function(T) {
                return T !== g;
              }), R.fire = R.subscribers.reduce(y, b);
            } };
            return o[m] = n[m] = R;
          }
          u(_ = m).forEach(function(g) {
            var T = _[g];
            if (p(T)) d(g, _[g][0], _[g][1]);
            else {
              if (T !== "asap") throw new G.InvalidArgument("Invalid event config");
              var w = d(g, H, function() {
                for (var N = arguments.length, O = new Array(N); N--; ) O[N] = arguments[N];
                w.subscribers.forEach(function(C) {
                  we(function() {
                    C.apply(null, O);
                  });
                });
              });
            }
          });
        }
      }
      function jn(e, n) {
        return P(n).from({ prototype: e }), n;
      }
      function Cn(e, n) {
        return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter);
      }
      function Zr(e, n) {
        e.filter = dn(e.filter, n);
      }
      function eo(e, n, o) {
        var a = e.replayFilter;
        e.replayFilter = a ? function() {
          return dn(a(), n());
        } : n, e.justLimit = o && !a;
      }
      function ur(e, n) {
        if (e.isPrimKey) return n.primaryKey;
        var o = n.getIndexByKeyPath(e.index);
        if (!o) throw new G.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
        return o;
      }
      function ni(e, n, o) {
        var a = ur(e, n.schema);
        return n.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: a, range: e.range } });
      }
      function cr(e, n, o, a) {
        var l = e.replayFilter ? dn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var d = {}, m = function(y, b, _) {
            var R, g;
            l && !l(b, _, function(T) {
              return b.stop(T);
            }, function(T) {
              return b.fail(T);
            }) || ((g = "" + (R = b.primaryKey)) == "[object ArrayBuffer]" && (g = "" + new Uint8Array(R)), $(d, g) || (d[g] = !0, n(y, b, _)));
          };
          return Promise.all([e.or._iterate(m, o), ri(ni(e, a, o), e.algorithm, m, !e.keysOnly && e.valueMapper)]);
        }
        return ri(ni(e, a, o), dn(e.algorithm, l), n, !e.keysOnly && e.valueMapper);
      }
      function ri(e, n, o, a) {
        var l = Ze(a ? function(d, m, y) {
          return o(a(d), m, y);
        } : o);
        return e.then(function(d) {
          if (d) return d.start(function() {
            var m = function() {
              return d.continue();
            };
            n && !n(d, function(y) {
              return m = y;
            }, function(y) {
              d.stop(y), m = S;
            }, function(y) {
              d.fail(y), m = S;
            }) || l(d.value, d, function(y) {
              return m = y;
            }), m();
          });
        });
      }
      var $n = (oi.prototype.execute = function(e) {
        var n = this["@@propmod"];
        if (n.add !== void 0) {
          var o = n.add;
          if (p(o)) return c(c([], p(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (n.remove !== void 0) {
          var a = n.remove;
          if (p(a)) return p(e) ? e.filter(function(l) {
            return !a.includes(l);
          }).sort() : [];
          if (typeof a == "number") return Number(e) - a;
          if (typeof a == "bigint") try {
            return BigInt(e) - a;
          } catch {
            return BigInt(0) - a;
          }
          throw new TypeError("Invalid subtrahend ".concat(a));
        }
        return o = (o = n.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? n.replacePrefix[1] + e.substring(o.length) : e;
      }, oi);
      function oi(e) {
        this["@@propmod"] = e;
      }
      var Ua = (Be.prototype._read = function(e, n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, rt.bind(null, o.error)) : o.table._trans("readonly", e).then(n);
      }, Be.prototype._write = function(e) {
        var n = this._ctx;
        return n.error ? n.table._trans(null, rt.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
      }, Be.prototype._addAlgorithm = function(e) {
        var n = this._ctx;
        n.algorithm = dn(n.algorithm, e);
      }, Be.prototype._iterate = function(e, n) {
        return cr(this._ctx, e, n, this._ctx.table.core);
      }, Be.prototype.clone = function(e) {
        var n = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && v(o, e), n._ctx = o, n;
      }, Be.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Be.prototype.each = function(e) {
        var n = this._ctx;
        return this._read(function(o) {
          return cr(n, e, o, n.table.core);
        });
      }, Be.prototype.count = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx, l = a.table.core;
          if (Cn(a, !0)) return l.count({ trans: o, query: { index: ur(a, l.schema), range: a.range } }).then(function(m) {
            return Math.min(m, a.limit);
          });
          var d = 0;
          return cr(a, function() {
            return ++d, !1;
          }, o, l).then(function() {
            return d;
          });
        }).then(e);
      }, Be.prototype.sortBy = function(e, n) {
        var o = e.split(".").reverse(), a = o[0], l = o.length - 1;
        function d(b, _) {
          return _ ? d(b[o[_]], _ - 1) : b[a];
        }
        var m = this._ctx.dir === "next" ? 1 : -1;
        function y(b, _) {
          return ke(d(b, l), d(_, l)) * m;
        }
        return this.toArray(function(b) {
          return b.sort(y);
        }).then(n);
      }, Be.prototype.toArray = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx;
          if (a.dir === "next" && Cn(a, !0) && 0 < a.limit) {
            var l = a.valueMapper, d = ur(a, a.table.core.schema);
            return a.table.core.query({ trans: o, limit: a.limit, values: !0, query: { index: d, range: a.range } }).then(function(y) {
              return y = y.result, l ? y.map(l) : y;
            });
          }
          var m = [];
          return cr(a, function(y) {
            return m.push(y);
          }, o, a.table.core).then(function() {
            return m;
          });
        }, e);
      }, Be.prototype.offset = function(e) {
        var n = this._ctx;
        return e <= 0 || (n.offset += e, Cn(n) ? eo(n, function() {
          var o = e;
          return function(a, l) {
            return o === 0 || (o === 1 ? --o : l(function() {
              a.advance(o), o = 0;
            }), !1);
          };
        }) : eo(n, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Be.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), eo(this._ctx, function() {
          var n = e;
          return function(o, a, l) {
            return --n <= 0 && a(l), 0 <= n;
          };
        }, !0), this;
      }, Be.prototype.until = function(e, n) {
        return Zr(this._ctx, function(o, a, l) {
          return !e(o.value) || (a(l), n);
        }), this;
      }, Be.prototype.first = function(e) {
        return this.limit(1).toArray(function(n) {
          return n[0];
        }).then(e);
      }, Be.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Be.prototype.filter = function(e) {
        var n;
        return Zr(this._ctx, function(o) {
          return e(o.value);
        }), (n = this._ctx).isMatch = dn(n.isMatch, e), this;
      }, Be.prototype.and = function(e) {
        return this.filter(e);
      }, Be.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Be.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Be.prototype.desc = function() {
        return this.reverse();
      }, Be.prototype.eachKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.key, a);
        });
      }, Be.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Be.prototype.eachPrimaryKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.primaryKey, a);
        });
      }, Be.prototype.keys = function(e) {
        var n = this._ctx;
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Be.prototype.primaryKeys = function(e) {
        var n = this._ctx;
        if (n.dir === "next" && Cn(n, !0) && 0 < n.limit) return this._read(function(a) {
          var l = ur(n, n.table.core.schema);
          return n.table.core.query({ trans: a, values: !1, limit: n.limit, query: { index: l, range: n.range } });
        }).then(function(a) {
          return a.result;
        }).then(e);
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Be.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Be.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(n) {
          return n[0];
        }).then(e);
      }, Be.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Be.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var n = {};
        return Zr(this._ctx, function(l) {
          var a = l.primaryKey.toString(), l = $(n, a);
          return n[a] = !0, !l;
        }), this;
      }, Be.prototype.modify = function(e) {
        var n = this, o = this._ctx;
        return this._write(function(a) {
          var l, d, m;
          m = typeof e == "function" ? e : (l = u(e), d = l.length, function(I) {
            for (var j = !1, M = 0; M < d; ++M) {
              var q = l[M], z = e[q], te = de(I, q);
              z instanceof $n ? (ge(I, q, z.execute(te)), j = !0) : te !== z && (ge(I, q, z), j = !0);
            }
            return j;
          });
          var y = o.table.core, g = y.schema.primaryKey, b = g.outbound, _ = g.extractKey, R = 200, g = n.db._options.modifyChunkSize;
          g && (R = typeof g == "object" ? g[y.name] || g["*"] || 200 : g);
          function T(I, q) {
            var M = q.failures, q = q.numFailures;
            N += I - q;
            for (var z = 0, te = u(M); z < te.length; z++) {
              var J = te[z];
              w.push(M[J]);
            }
          }
          var w = [], N = 0, O = [], C = e === ii;
          return n.clone().primaryKeys().then(function(I) {
            function j(q) {
              var z = Math.min(R, I.length - q), te = I.slice(q, q + z);
              return (C ? Promise.resolve([]) : y.getMany({ trans: a, keys: te, cache: "immutable" })).then(function(J) {
                var ee = [], ae = [], ie = b ? [] : null, le = C ? te : [];
                if (!C) for (var Ee = 0; Ee < z; ++Ee) {
                  var je = J[Ee], Ce = { value: me(je), primKey: I[q + Ee] };
                  m.call(Ce, Ce.value, Ce) !== !1 && (Ce.value == null ? le.push(I[q + Ee]) : b || ke(_(je), _(Ce.value)) === 0 ? (ae.push(Ce.value), b && ie.push(I[q + Ee])) : (le.push(I[q + Ee]), ee.push(Ce.value)));
                }
                return Promise.resolve(0 < ee.length && y.mutate({ trans: a, type: "add", values: ee }).then(function(tt) {
                  for (var Re in tt.failures) le.splice(parseInt(Re), 1);
                  T(ee.length, tt);
                })).then(function() {
                  return (0 < ae.length || M && typeof e == "object") && y.mutate({ trans: a, type: "put", keys: ie, values: ae, criteria: M, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < q }).then(function(tt) {
                    return T(ae.length, tt);
                  });
                }).then(function() {
                  return (0 < le.length || M && C) && y.mutate({ trans: a, type: "delete", keys: le, criteria: M, isAdditionalChunk: 0 < q }).then(function(tt) {
                    return lr(o.table, le, tt);
                  }).then(function(tt) {
                    return T(le.length, tt);
                  });
                }).then(function() {
                  return I.length > q + z && j(q + R);
                });
              });
            }
            var M = Cn(o) && o.limit === 1 / 0 && (typeof e != "function" || C) && { index: o.index, range: o.range };
            return j(0).then(function() {
              if (0 < w.length) throw new bn("Error modifying one or more objects", w, N, O);
              return I.length;
            });
          });
        });
      }, Be.prototype.delete = function() {
        var e = this._ctx, n = e.range;
        return !Cn(e) || e.table.schema.yProps || !e.isPrimKey && n.type !== 3 ? this.modify(ii) : this._write(function(o) {
          var a = e.table.core.schema.primaryKey, l = n;
          return e.table.core.count({ trans: o, query: { index: a, range: l } }).then(function(d) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: l }).then(function(b) {
              var y = b.failures, b = b.numFailures;
              if (b) throw new bn("Could not delete some values", Object.keys(y).map(function(_) {
                return y[_];
              }), d - b);
              return d - b;
            });
          });
        });
      }, Be);
      function Be() {
      }
      var ii = function(e, n) {
        return n.value = null;
      };
      function Va(e, n) {
        return e < n ? -1 : e === n ? 0 : 1;
      }
      function Wa(e, n) {
        return n < e ? -1 : e === n ? 0 : 1;
      }
      function xt(e, n, o) {
        return e = e instanceof si ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(n), e;
      }
      function On(e) {
        return new e.Collection(e, function() {
          return ai("");
        }).limit(0);
      }
      function dr(e, n, o, a) {
        var l, d, m, y, b, _, R, g = o.length;
        if (!o.every(function(N) {
          return typeof N == "string";
        })) return xt(e, Xo);
        function T(N) {
          l = N === "next" ? function(C) {
            return C.toUpperCase();
          } : function(C) {
            return C.toLowerCase();
          }, d = N === "next" ? function(C) {
            return C.toLowerCase();
          } : function(C) {
            return C.toUpperCase();
          }, m = N === "next" ? Va : Wa;
          var O = o.map(function(C) {
            return { lower: d(C), upper: l(C) };
          }).sort(function(C, I) {
            return m(C.lower, I.lower);
          });
          y = O.map(function(C) {
            return C.upper;
          }), b = O.map(function(C) {
            return C.lower;
          }), R = (_ = N) === "next" ? "" : a;
        }
        T("next"), e = new e.Collection(e, function() {
          return Zt(y[0], b[g - 1] + a);
        }), e._ondirectionchange = function(N) {
          T(N);
        };
        var w = 0;
        return e._addAlgorithm(function(N, O, C) {
          var I = N.key;
          if (typeof I != "string") return !1;
          var j = d(I);
          if (n(j, b, w)) return !0;
          for (var M = null, q = w; q < g; ++q) {
            var z = function(te, J, ee, ae, ie, le) {
              for (var Ee = Math.min(te.length, ae.length), je = -1, Ce = 0; Ce < Ee; ++Ce) {
                var tt = J[Ce];
                if (tt !== ae[Ce]) return ie(te[Ce], ee[Ce]) < 0 ? te.substr(0, Ce) + ee[Ce] + ee.substr(Ce + 1) : ie(te[Ce], ae[Ce]) < 0 ? te.substr(0, Ce) + ae[Ce] + ee.substr(Ce + 1) : 0 <= je ? te.substr(0, je) + J[je] + ee.substr(je + 1) : null;
                ie(te[Ce], tt) < 0 && (je = Ce);
              }
              return Ee < ae.length && le === "next" ? te + ee.substr(te.length) : Ee < te.length && le === "prev" ? te.substr(0, ee.length) : je < 0 ? null : te.substr(0, je) + ae[je] + ee.substr(je + 1);
            }(I, j, y[q], b[q], m, _);
            z === null && M === null ? w = q + 1 : (M === null || 0 < m(M, z)) && (M = z);
          }
          return O(M !== null ? function() {
            N.continue(M + R);
          } : C), !1;
        }), e;
      }
      function Zt(e, n, o, a) {
        return { type: 2, lower: e, upper: n, lowerOpen: o, upperOpen: a };
      }
      function ai(e) {
        return { type: 1, lower: e, upper: e };
      }
      var si = (Object.defineProperty(dt.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), dt.prototype.between = function(e, n, o, a) {
        o = o !== !1, a = a === !0;
        try {
          return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (o || a) && (!o || !a) ? On(this) : new this.Collection(this, function() {
            return Zt(e, n, !o, !a);
          });
        } catch {
          return xt(this, Vt);
        }
      }, dt.prototype.equals = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return ai(e);
        });
      }, dt.prototype.above = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(e, void 0, !0);
        });
      }, dt.prototype.aboveOrEqual = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(e, void 0, !1);
        });
      }, dt.prototype.below = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(void 0, e, !1, !0);
        });
      }, dt.prototype.belowOrEqual = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(void 0, e);
        });
      }, dt.prototype.startsWith = function(e) {
        return typeof e != "string" ? xt(this, Xo) : this.between(e, e + cn, !0, !0);
      }, dt.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : dr(this, function(n, o) {
          return n.indexOf(o[0]) === 0;
        }, [e], cn);
      }, dt.prototype.equalsIgnoreCase = function(e) {
        return dr(this, function(n, o) {
          return n === o[0];
        }, [e], "");
      }, dt.prototype.anyOfIgnoreCase = function() {
        var e = Me.apply(pt, arguments);
        return e.length === 0 ? On(this) : dr(this, function(n, o) {
          return o.indexOf(n) !== -1;
        }, e, "");
      }, dt.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = Me.apply(pt, arguments);
        return e.length === 0 ? On(this) : dr(this, function(n, o) {
          return o.some(function(a) {
            return n.indexOf(a) === 0;
          });
        }, e, cn);
      }, dt.prototype.anyOf = function() {
        var e = this, n = Me.apply(pt, arguments), o = this._cmp;
        try {
          n.sort(o);
        } catch {
          return xt(this, Vt);
        }
        if (n.length === 0) return On(this);
        var a = new this.Collection(this, function() {
          return Zt(n[0], n[n.length - 1]);
        });
        a._ondirectionchange = function(d) {
          o = d === "next" ? e._ascending : e._descending, n.sort(o);
        };
        var l = 0;
        return a._addAlgorithm(function(d, m, y) {
          for (var b = d.key; 0 < o(b, n[l]); ) if (++l === n.length) return m(y), !1;
          return o(b, n[l]) === 0 || (m(function() {
            d.continue(n[l]);
          }), !1);
        }), a;
      }, dt.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, dt.prototype.noneOf = function() {
        var e = Me.apply(pt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return xt(this, Vt);
        }
        var n = e.reduce(function(o, a) {
          return o ? o.concat([[o[o.length - 1][1], a]]) : [[-1 / 0, a]];
        }, null);
        return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
      }, dt.prototype.inAnyRange = function(I, n) {
        var o = this, a = this._cmp, l = this._ascending, d = this._descending, m = this._min, y = this._max;
        if (I.length === 0) return On(this);
        if (!I.every(function(j) {
          return j[0] !== void 0 && j[1] !== void 0 && l(j[0], j[1]) <= 0;
        })) return xt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", G.InvalidArgument);
        var b = !n || n.includeLowers !== !1, _ = n && n.includeUppers === !0, R, g = l;
        function T(j, M) {
          return g(j[0], M[0]);
        }
        try {
          (R = I.reduce(function(j, M) {
            for (var q = 0, z = j.length; q < z; ++q) {
              var te = j[q];
              if (a(M[0], te[1]) < 0 && 0 < a(M[1], te[0])) {
                te[0] = m(te[0], M[0]), te[1] = y(te[1], M[1]);
                break;
              }
            }
            return q === z && j.push(M), j;
          }, [])).sort(T);
        } catch {
          return xt(this, Vt);
        }
        var w = 0, N = _ ? function(j) {
          return 0 < l(j, R[w][1]);
        } : function(j) {
          return 0 <= l(j, R[w][1]);
        }, O = b ? function(j) {
          return 0 < d(j, R[w][0]);
        } : function(j) {
          return 0 <= d(j, R[w][0]);
        }, C = N, I = new this.Collection(this, function() {
          return Zt(R[0][0], R[R.length - 1][1], !b, !_);
        });
        return I._ondirectionchange = function(j) {
          g = j === "next" ? (C = N, l) : (C = O, d), R.sort(T);
        }, I._addAlgorithm(function(j, M, q) {
          for (var z, te = j.key; C(te); ) if (++w === R.length) return M(q), !1;
          return !N(z = te) && !O(z) || (o._cmp(te, R[w][1]) === 0 || o._cmp(te, R[w][0]) === 0 || M(function() {
            g === l ? j.continue(R[w][0]) : j.continue(R[w][1]);
          }), !1);
        }), I;
      }, dt.prototype.startsWithAnyOf = function() {
        var e = Me.apply(pt, arguments);
        return e.every(function(n) {
          return typeof n == "string";
        }) ? e.length === 0 ? On(this) : this.inAnyRange(e.map(function(n) {
          return [n, n + cn];
        })) : xt(this, "startsWithAnyOf() only works with strings");
      }, dt);
      function dt() {
      }
      function Bt(e) {
        return Ze(function(n) {
          return Fn(n), e(n.target.error), !1;
        });
      }
      function Fn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Mn = "storagemutated", to = "x-storagemutated-1", en = kn(null, Mn), Ga = (Kt.prototype._lock = function() {
        return K(!pe.global), ++this._reculock, this._reculock !== 1 || pe.global || (pe.lockOwnerFor = this), this;
      }, Kt.prototype._unlock = function() {
        if (K(!pe.global), --this._reculock == 0) for (pe.global || (pe.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            un(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Kt.prototype._locked = function() {
        return this._reculock && pe.lockOwnerFor !== this;
      }, Kt.prototype.create = function(e) {
        var n = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, a = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !e && !o) switch (a && a.name) {
          case "DatabaseClosedError":
            throw new G.DatabaseClosed(a);
          case "MissingAPIError":
            throw new G.MissingAPI(a.message, a);
          default:
            throw new G.OpenFailed(a);
        }
        if (!this.active) throw new G.TransactionInactive();
        return K(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ze(function(l) {
          Fn(l), n._reject(e.error);
        }), e.onabort = Ze(function(l) {
          Fn(l), n.active && n._reject(new G.Abort(e.error)), n.active = !1, n.on("abort").fire(l);
        }), e.oncomplete = Ze(function() {
          n.active = !1, n._resolve(), "mutatedParts" in e && en.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Kt.prototype._promise = function(e, n, o) {
        var a = this;
        if (e === "readwrite" && this.mode !== "readwrite") return rt(new G.ReadOnly("Transaction is readonly"));
        if (!this.active) return rt(new G.TransactionInactive());
        if (this._locked()) return new se(function(d, m) {
          a._blockedFuncs.push([function() {
            a._promise(e, n, o).then(d, m);
          }, pe]);
        });
        if (o) return Xt(function() {
          var d = new se(function(m, y) {
            a._lock();
            var b = n(m, y, a);
            b && b.then && b.then(m, y);
          });
          return d.finally(function() {
            return a._unlock();
          }), d._lib = !0, d;
        });
        var l = new se(function(d, m) {
          var y = n(d, m, a);
          y && y.then && y.then(d, m);
        });
        return l._lib = !0, l;
      }, Kt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Kt.prototype.waitFor = function(e) {
        var n, o = this._root(), a = se.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return a;
        }) : (o._waitingFor = a, o._waitingQueue = [], n = o.idbtrans.objectStore(o.storeNames[0]), function d() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (n.get(-1 / 0).onsuccess = d);
        }());
        var l = o._waitingFor;
        return new se(function(d, m) {
          a.then(function(y) {
            return o._waitingQueue.push(Ze(d.bind(null, y)));
          }, function(y) {
            return o._waitingQueue.push(Ze(m.bind(null, y)));
          }).finally(function() {
            o._waitingFor === l && (o._waitingFor = null);
          });
        });
      }, Kt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new G.Abort()));
      }, Kt.prototype.table = function(e) {
        var n = this._memoizedTables || (this._memoizedTables = {});
        if ($(n, e)) return n[e];
        var o = this.schema[e];
        if (!o) throw new G.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), n[e] = o;
      }, Kt);
      function Kt() {
      }
      function no(e, n, o, a, l, d, m, y) {
        return { name: e, keyPath: n, unique: o, multi: a, auto: l, compound: d, src: (o && !m ? "&" : "") + (a ? "*" : "") + (l ? "++" : "") + li(n), type: y };
      }
      function li(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function ro(e, n, o) {
        return { name: e, primKey: n, indexes: o, mappedClass: null, idxByName: (a = function(l) {
          return [l.name, l];
        }, o.reduce(function(l, d, m) {
          return m = a(d, m), m && (l[m[0]] = m[1]), l;
        }, {})) };
        var a;
      }
      var Bn = function(e) {
        try {
          return e.only([[]]), Bn = function() {
            return [[]];
          }, [[]];
        } catch {
          return Bn = function() {
            return cn;
          }, cn;
        }
      };
      function oo(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (n = e).split(".").length === 1 ? function(o) {
          return o[n];
        } : function(o) {
          return de(o, n);
        } : function(o) {
          return de(o, e);
        };
        var n;
      }
      function ui(e) {
        return [].slice.call(e);
      }
      var Ha = 0;
      function Kn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Ya(e, n, b) {
        function a(C) {
          if (C.type === 3) return null;
          if (C.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var w = C.lower, N = C.upper, O = C.lowerOpen, C = C.upperOpen;
          return w === void 0 ? N === void 0 ? null : n.upperBound(N, !!C) : N === void 0 ? n.lowerBound(w, !!O) : n.bound(w, N, !!O, !!C);
        }
        function l(T) {
          var w, N = T.name;
          return { name: N, schema: T, mutate: function(O) {
            var C = O.trans, I = O.type, j = O.keys, M = O.values, q = O.range;
            return new Promise(function(z, te) {
              z = Ze(z);
              var J = C.objectStore(N), ee = J.keyPath == null, ae = I === "put" || I === "add";
              if (!ae && I !== "delete" && I !== "deleteRange") throw new Error("Invalid operation type: " + I);
              var ie, le = (j || M || { length: 1 }).length;
              if (j && M && j.length !== M.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return z({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Ee(bt) {
                ++tt, Fn(bt);
              }
              var je = [], Ce = [], tt = 0;
              if (I === "deleteRange") {
                if (q.type === 4) return z({ numFailures: tt, failures: Ce, results: [], lastResult: void 0 });
                q.type === 3 ? je.push(ie = J.clear()) : je.push(ie = J.delete(a(q)));
              } else {
                var ee = ae ? ee ? [M, j] : [M, null] : [j, null], Re = ee[0], mt = ee[1];
                if (ae) for (var vt = 0; vt < le; ++vt) je.push(ie = mt && mt[vt] !== void 0 ? J[I](Re[vt], mt[vt]) : J[I](Re[vt])), ie.onerror = Ee;
                else for (vt = 0; vt < le; ++vt) je.push(ie = J[I](Re[vt])), ie.onerror = Ee;
              }
              function xr(bt) {
                bt = bt.target.result, je.forEach(function(hn, xo) {
                  return hn.error != null && (Ce[xo] = hn.error);
                }), z({ numFailures: tt, failures: Ce, results: I === "delete" ? j : je.map(function(hn) {
                  return hn.result;
                }), lastResult: bt });
              }
              ie.onerror = function(bt) {
                Ee(bt), xr(bt);
              }, ie.onsuccess = xr;
            });
          }, getMany: function(O) {
            var C = O.trans, I = O.keys;
            return new Promise(function(j, M) {
              j = Ze(j);
              for (var q, z = C.objectStore(N), te = I.length, J = new Array(te), ee = 0, ae = 0, ie = function(je) {
                je = je.target, J[je._pos] = je.result, ++ae === ee && j(J);
              }, le = Bt(M), Ee = 0; Ee < te; ++Ee) I[Ee] != null && ((q = z.get(I[Ee]))._pos = Ee, q.onsuccess = ie, q.onerror = le, ++ee);
              ee === 0 && j(J);
            });
          }, get: function(O) {
            var C = O.trans, I = O.key;
            return new Promise(function(j, M) {
              j = Ze(j);
              var q = C.objectStore(N).get(I);
              q.onsuccess = function(z) {
                return j(z.target.result);
              }, q.onerror = Bt(M);
            });
          }, query: (w = _, function(O) {
            return new Promise(function(C, I) {
              C = Ze(C);
              var j, M, q, ee = O.trans, z = O.values, te = O.limit, ie = O.query, J = te === 1 / 0 ? void 0 : te, ae = ie.index, ie = ie.range, ee = ee.objectStore(N), ae = ae.isPrimaryKey ? ee : ee.index(ae.name), ie = a(ie);
              if (te === 0) return C({ result: [] });
              w ? ((J = z ? ae.getAll(ie, J) : ae.getAllKeys(ie, J)).onsuccess = function(le) {
                return C({ result: le.target.result });
              }, J.onerror = Bt(I)) : (j = 0, M = !z && "openKeyCursor" in ae ? ae.openKeyCursor(ie) : ae.openCursor(ie), q = [], M.onsuccess = function(le) {
                var Ee = M.result;
                return Ee ? (q.push(z ? Ee.value : Ee.primaryKey), ++j === te ? C({ result: q }) : void Ee.continue()) : C({ result: q });
              }, M.onerror = Bt(I));
            });
          }), openCursor: function(O) {
            var C = O.trans, I = O.values, j = O.query, M = O.reverse, q = O.unique;
            return new Promise(function(z, te) {
              z = Ze(z);
              var ae = j.index, J = j.range, ee = C.objectStore(N), ee = ae.isPrimaryKey ? ee : ee.index(ae.name), ae = M ? q ? "prevunique" : "prev" : q ? "nextunique" : "next", ie = !I && "openKeyCursor" in ee ? ee.openKeyCursor(a(J), ae) : ee.openCursor(a(J), ae);
              ie.onerror = Bt(te), ie.onsuccess = Ze(function(le) {
                var Ee, je, Ce, tt, Re = ie.result;
                Re ? (Re.___id = ++Ha, Re.done = !1, Ee = Re.continue.bind(Re), je = (je = Re.continuePrimaryKey) && je.bind(Re), Ce = Re.advance.bind(Re), tt = function() {
                  throw new Error("Cursor not stopped");
                }, Re.trans = C, Re.stop = Re.continue = Re.continuePrimaryKey = Re.advance = function() {
                  throw new Error("Cursor not started");
                }, Re.fail = Ze(te), Re.next = function() {
                  var mt = this, vt = 1;
                  return this.start(function() {
                    return vt-- ? mt.continue() : mt.stop();
                  }).then(function() {
                    return mt;
                  });
                }, Re.start = function(mt) {
                  function vt() {
                    if (ie.result) try {
                      mt();
                    } catch (bt) {
                      Re.fail(bt);
                    }
                    else Re.done = !0, Re.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, Re.stop();
                  }
                  var xr = new Promise(function(bt, hn) {
                    bt = Ze(bt), ie.onerror = Bt(hn), Re.fail = hn, Re.stop = function(xo) {
                      Re.stop = Re.continue = Re.continuePrimaryKey = Re.advance = tt, bt(xo);
                    };
                  });
                  return ie.onsuccess = Ze(function(bt) {
                    ie.onsuccess = vt, vt();
                  }), Re.continue = Ee, Re.continuePrimaryKey = je, Re.advance = Ce, vt(), xr;
                }, z(Re)) : z(null);
              }, te);
            });
          }, count: function(O) {
            var C = O.query, I = O.trans, j = C.index, M = C.range;
            return new Promise(function(q, z) {
              var te = I.objectStore(N), J = j.isPrimaryKey ? te : te.index(j.name), te = a(M), J = te ? J.count(te) : J.count();
              J.onsuccess = Ze(function(ee) {
                return q(ee.target.result);
              }), J.onerror = Bt(z);
            });
          } };
        }
        var d, m, y, R = (m = b, y = ui((d = e).objectStoreNames), { schema: { name: d.name, tables: y.map(function(T) {
          return m.objectStore(T);
        }).map(function(T) {
          var w = T.keyPath, C = T.autoIncrement, N = p(w), O = {}, C = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: w == null, compound: N, keyPath: w, autoIncrement: C, unique: !0, extractKey: oo(w) }, indexes: ui(T.indexNames).map(function(I) {
            return T.index(I);
          }).map(function(q) {
            var j = q.name, M = q.unique, z = q.multiEntry, q = q.keyPath, z = { name: j, compound: p(q), keyPath: q, unique: M, multiEntry: z, extractKey: oo(q) };
            return O[Kn(q)] = z;
          }), getIndexByKeyPath: function(I) {
            return O[Kn(I)];
          } };
          return O[":id"] = C.primaryKey, w != null && (O[Kn(w)] = C.primaryKey), C;
        }) }, hasGetAll: 0 < y.length && "getAll" in m.objectStore(y[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), b = R.schema, _ = R.hasGetAll, R = b.tables.map(l), g = {};
        return R.forEach(function(T) {
          return g[T.name] = T;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(T) {
          if (!g[T]) throw new Error("Table '".concat(T, "' not found"));
          return g[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Bn(n), schema: b };
      }
      function za(e, n, o, a) {
        var l = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (a = Ya(n, l, a), e.dbcore.reduce(function(d, m) {
          return m = m.create, s(s({}, d), m(d));
        }, a)) };
      }
      function fr(e, a) {
        var o = a.db, a = za(e._middlewares, o, e._deps, a);
        e.core = a.dbcore, e.tables.forEach(function(l) {
          var d = l.name;
          e.core.schema.tables.some(function(m) {
            return m.name === d;
          }) && (l.core = e.core.table(d), e[d] instanceof e.Table && (e[d].core = l.core));
        });
      }
      function pr(e, n, o, a) {
        o.forEach(function(l) {
          var d = a[l];
          n.forEach(function(m) {
            var y = function b(_, R) {
              return B(_, R) || (_ = k(_)) && b(_, R);
            }(m, l);
            (!y || "value" in y && y.value === void 0) && (m === e.Transaction.prototype || m instanceof e.Transaction ? A(m, l, { get: function() {
              return this.table(l);
            }, set: function(b) {
              W(this, l, { value: b, writable: !0, configurable: !0, enumerable: !0 });
            } }) : m[l] = new e.Table(l, d));
          });
        });
      }
      function io(e, n) {
        n.forEach(function(o) {
          for (var a in o) o[a] instanceof e.Table && delete o[a];
        });
      }
      function Xa(e, n) {
        return e._cfg.version - n._cfg.version;
      }
      function Qa(e, n, o, a) {
        var l = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !l.$meta && (l.$meta = ro("$meta", di("")[0], []), e._storeNames.push("$meta"));
        var d = e._createTransaction("readwrite", e._storeNames, l);
        d.create(o), d._completion.catch(a);
        var m = d._reject.bind(d), y = pe.transless || pe;
        Xt(function() {
          return pe.trans = d, pe.transless = y, n !== 0 ? (fr(e, o), _ = n, ((b = d).storeNames.includes("$meta") ? b.table("$meta").get("version").then(function(R) {
            return R ?? _;
          }) : se.resolve(_)).then(function(R) {
            return T = R, w = d, N = o, O = [], R = (g = e)._versions, C = g._dbSchema = mr(0, g.idbdb, N), (R = R.filter(function(I) {
              return I._cfg.version >= T;
            })).length !== 0 ? (R.forEach(function(I) {
              O.push(function() {
                var j = C, M = I._cfg.dbschema;
                vr(g, j, N), vr(g, M, N), C = g._dbSchema = M;
                var q = ao(j, M);
                q.add.forEach(function(ae) {
                  so(N, ae[0], ae[1].primKey, ae[1].indexes);
                }), q.change.forEach(function(ae) {
                  if (ae.recreate) throw new G.Upgrade("Not yet support for changing primary key");
                  var ie = N.objectStore(ae.name);
                  ae.add.forEach(function(le) {
                    return hr(ie, le);
                  }), ae.change.forEach(function(le) {
                    ie.deleteIndex(le.name), hr(ie, le);
                  }), ae.del.forEach(function(le) {
                    return ie.deleteIndex(le);
                  });
                });
                var z = I._cfg.contentUpgrade;
                if (z && I._cfg.version > T) {
                  fr(g, N), w._memoizedTables = {};
                  var te = Ue(M);
                  q.del.forEach(function(ae) {
                    te[ae] = j[ae];
                  }), io(g, [g.Transaction.prototype]), pr(g, [g.Transaction.prototype], u(te), te), w.schema = te;
                  var J, ee = Qe(z);
                  return ee && xn(), q = se.follow(function() {
                    var ae;
                    (J = z(w)) && ee && (ae = Qt.bind(null, null), J.then(ae, ae));
                  }), J && typeof J.then == "function" ? se.resolve(J) : q.then(function() {
                    return J;
                  });
                }
              }), O.push(function(j) {
                var M, q, z = I._cfg.dbschema;
                M = z, q = j, [].slice.call(q.db.objectStoreNames).forEach(function(te) {
                  return M[te] == null && q.db.deleteObjectStore(te);
                }), io(g, [g.Transaction.prototype]), pr(g, [g.Transaction.prototype], g._storeNames, g._dbSchema), w.schema = g._dbSchema;
              }), O.push(function(j) {
                g.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(g.idbdb.version / 10) === I._cfg.version ? (g.idbdb.deleteObjectStore("$meta"), delete g._dbSchema.$meta, g._storeNames = g._storeNames.filter(function(M) {
                  return M !== "$meta";
                })) : j.objectStore("$meta").put(I._cfg.version, "version"));
              });
            }), function I() {
              return O.length ? se.resolve(O.shift()(w.idbtrans)).then(I) : se.resolve();
            }().then(function() {
              ci(C, N);
            })) : se.resolve();
            var g, T, w, N, O, C;
          }).catch(m)) : (u(l).forEach(function(R) {
            so(o, R, l[R].primKey, l[R].indexes);
          }), fr(e, o), void se.follow(function() {
            return e.on.populate.fire(d);
          }).catch(m));
          var b, _;
        });
      }
      function Ja(e, n) {
        ci(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
        var o = mr(0, e.idbdb, n);
        vr(e, e._dbSchema, n);
        for (var a = 0, l = ao(o, e._dbSchema).change; a < l.length; a++) {
          var d = function(m) {
            if (m.change.length || m.recreate) return console.warn("Unable to patch indexes of table ".concat(m.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var y = n.objectStore(m.name);
            m.add.forEach(function(b) {
              ye && console.debug("Dexie upgrade patch: Creating missing index ".concat(m.name, ".").concat(b.src)), hr(y, b);
            });
          }(l[a]);
          if (typeof d == "object") return d.value;
        }
      }
      function ao(e, n) {
        var o, a = { del: [], add: [], change: [] };
        for (o in e) n[o] || a.del.push(o);
        for (o in n) {
          var l = e[o], d = n[o];
          if (l) {
            var m = { name: o, def: d, recreate: !1, del: [], add: [], change: [] };
            if ("" + (l.primKey.keyPath || "") != "" + (d.primKey.keyPath || "") || l.primKey.auto !== d.primKey.auto) m.recreate = !0, a.change.push(m);
            else {
              var y = l.idxByName, b = d.idxByName, _ = void 0;
              for (_ in y) b[_] || m.del.push(_);
              for (_ in b) {
                var R = y[_], g = b[_];
                R ? R.src !== g.src && m.change.push(g) : m.add.push(g);
              }
              (0 < m.del.length || 0 < m.add.length || 0 < m.change.length) && a.change.push(m);
            }
          } else a.add.push([o, d]);
        }
        return a;
      }
      function so(e, n, o, a) {
        var l = e.db.createObjectStore(n, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return a.forEach(function(d) {
          return hr(l, d);
        }), l;
      }
      function ci(e, n) {
        u(e).forEach(function(o) {
          n.db.objectStoreNames.contains(o) || (ye && console.debug("Dexie: Creating missing table", o), so(n, o, e[o].primKey, e[o].indexes));
        });
      }
      function hr(e, n) {
        e.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi });
      }
      function mr(e, n, o) {
        var a = {};
        return F(n.objectStoreNames, 0).forEach(function(l) {
          for (var d = o.objectStore(l), m = no(li(_ = d.keyPath), _ || "", !0, !1, !!d.autoIncrement, _ && typeof _ != "string", !0), y = [], b = 0; b < d.indexNames.length; ++b) {
            var R = d.index(d.indexNames[b]), _ = R.keyPath, R = no(R.name, _, !!R.unique, !!R.multiEntry, !1, _ && typeof _ != "string", !1);
            y.push(R);
          }
          a[l] = ro(l, m, y);
        }), a;
      }
      function vr(e, n, o) {
        for (var a = o.db.objectStoreNames, l = 0; l < a.length; ++l) {
          var d = a[l], m = o.objectStore(d);
          e._hasGetAll = "getAll" in m;
          for (var y = 0; y < m.indexNames.length; ++y) {
            var b = m.indexNames[y], _ = m.index(b).keyPath, R = typeof _ == "string" ? _ : "[" + F(_).join("+") + "]";
            !n[d] || (_ = n[d].idxByName[R]) && (_.name = b, delete n[d].idxByName[R], n[d].idxByName[b] = _);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function di(e) {
        return e.split(",").map(function(n, o) {
          var d = n.split(":"), a = (l = d[1]) === null || l === void 0 ? void 0 : l.trim(), l = (n = d[0].trim()).replace(/([&*]|\+\+)/g, ""), d = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return no(l, d || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), p(d), o === 0, a);
        });
      }
      var Za = (Tn.prototype._createTableSchema = ro, Tn.prototype._parseIndexSyntax = di, Tn.prototype._parseStoresSpec = function(e, n) {
        var o = this;
        u(e).forEach(function(a) {
          if (e[a] !== null) {
            var l = o._parseIndexSyntax(e[a]), d = l.shift();
            if (!d) throw new G.Schema("Invalid schema for table " + a + ": " + e[a]);
            if (d.unique = !0, d.multi) throw new G.Schema("Primary key cannot be multiEntry*");
            l.forEach(function(m) {
              if (m.auto) throw new G.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!m.keyPath) throw new G.Schema("Index must have a name and cannot be an empty string");
            }), l = o._createTableSchema(a, d, l), n[a] = l;
          }
        });
      }, Tn.prototype.stores = function(o) {
        var n = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? v(this._cfg.storesSource, o) : o;
        var o = n._versions, a = {}, l = {};
        return o.forEach(function(d) {
          v(a, d._cfg.storesSource), l = d._cfg.dbschema = {}, d._parseStoresSpec(a, l);
        }), n._dbSchema = l, io(n, [n._allTables, n, n.Transaction.prototype]), pr(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], u(l), l), n._storeNames = u(l), this;
      }, Tn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = xe(this._cfg.contentUpgrade || S, e), this;
      }, Tn);
      function Tn() {
      }
      function lo(e, n) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Wt(ar, { addons: [], indexedDB: e, IDBKeyRange: n })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function uo(e) {
        return e && typeof e.databases == "function";
      }
      function co(e) {
        return Xt(function() {
          return pe.letThrough = !0, e();
        });
      }
      function fo(e) {
        return !("from" in e);
      }
      var ht = function(e, n) {
        if (!this) {
          var o = new ht();
          return e && "d" in e && v(o, e), o;
        }
        v(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? n : e } : { d: 0 });
      };
      function qn(e, n, o) {
        var a = ke(n, o);
        if (!isNaN(a)) {
          if (0 < a) throw RangeError();
          if (fo(e)) return v(e, { from: n, to: o, d: 1 });
          var l = e.l, a = e.r;
          if (ke(o, e.from) < 0) return l ? qn(l, n, o) : e.l = { from: n, to: o, d: 1, l: null, r: null }, pi(e);
          if (0 < ke(n, e.to)) return a ? qn(a, n, o) : e.r = { from: n, to: o, d: 1, l: null, r: null }, pi(e);
          ke(n, e.from) < 0 && (e.from = n, e.l = null, e.d = a ? a.d + 1 : 1), 0 < ke(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, l && !e.l && Un(e, l), a && o && Un(e, a);
        }
      }
      function Un(e, n) {
        fo(n) || function o(a, b) {
          var d = b.from, m = b.to, y = b.l, b = b.r;
          qn(a, d, m), y && o(a, y), b && o(a, b);
        }(e, n);
      }
      function fi(e, n) {
        var o = yr(n), a = o.next();
        if (a.done) return !1;
        for (var l = a.value, d = yr(e), m = d.next(l.from), y = m.value; !a.done && !m.done; ) {
          if (ke(y.from, l.to) <= 0 && 0 <= ke(y.to, l.from)) return !0;
          ke(l.from, y.from) < 0 ? l = (a = o.next(y.from)).value : y = (m = d.next(l.from)).value;
        }
        return !1;
      }
      function yr(e) {
        var n = fo(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var a = 0 < arguments.length; n; ) switch (n.s) {
            case 0:
              if (n.s = 1, a) for (; n.n.l && ke(o, n.n.from) < 0; ) n = { up: n, n: n.n.l, s: 1 };
              else for (; n.n.l; ) n = { up: n, n: n.n.l, s: 1 };
            case 1:
              if (n.s = 2, !a || ke(o, n.n.to) <= 0) return { value: n.n, done: !1 };
            case 2:
              if (n.n.r) {
                n.s = 3, n = { up: n, n: n.n.r, s: 0 };
                continue;
              }
            case 3:
              n = n.up;
          }
          return { done: !0 };
        } };
      }
      function pi(e) {
        var n, o, a = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), l = 1 < a ? "r" : a < -1 ? "l" : "";
        l && (n = l == "r" ? "l" : "r", o = s({}, e), a = e[l], e.from = a.from, e.to = a.to, e[l] = a[l], o[l] = a[n], (e[n] = o).d = hi(o)), e.d = hi(e);
      }
      function hi(o) {
        var n = o.r, o = o.l;
        return (n ? o ? Math.max(n.d, o.d) : n.d : o ? o.d : 0) + 1;
      }
      function gr(e, n) {
        return u(n).forEach(function(o) {
          e[o] ? Un(e[o], n[o]) : e[o] = function a(l) {
            var d, m, y = {};
            for (d in l) $(l, d) && (m = l[d], y[d] = !m || typeof m != "object" || ce.has(m.constructor) ? m : a(m));
            return y;
          }(n[o]);
        }), e;
      }
      function po(e, n) {
        return e.all || n.all || Object.keys(e).some(function(o) {
          return n[o] && fi(n[o], e[o]);
        });
      }
      U(ht.prototype, ((Dt = { add: function(e) {
        return Un(this, e), this;
      }, addKey: function(e) {
        return qn(this, e, e), this;
      }, addKeys: function(e) {
        var n = this;
        return e.forEach(function(o) {
          return qn(n, o, o);
        }), this;
      }, hasKey: function(e) {
        var n = yr(this).next(e).value;
        return n && ke(n.from, e) <= 0 && 0 <= ke(n.to, e);
      } })[Se] = function() {
        return yr(this);
      }, Dt));
      var fn = {}, ho = {}, mo = !1;
      function br(e) {
        gr(ho, e), mo || (mo = !0, setTimeout(function() {
          mo = !1, vo(ho, !(ho = {}));
        }, 0));
      }
      function vo(e, n) {
        n === void 0 && (n = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var a = 0, l = Object.values(fn); a < l.length; a++) mi(m = l[a], e, o, n);
        else for (var d in e) {
          var m, y = /^idb\:\/\/(.*)\/(.*)\//.exec(d);
          y && (d = y[1], y = y[2], (m = fn["idb://".concat(d, "/").concat(y)]) && mi(m, e, o, n));
        }
        o.forEach(function(b) {
          return b();
        });
      }
      function mi(e, n, o, a) {
        for (var l = [], d = 0, m = Object.entries(e.queries.query); d < m.length; d++) {
          for (var y = m[d], b = y[0], _ = [], R = 0, g = y[1]; R < g.length; R++) {
            var T = g[R];
            po(n, T.obsSet) ? T.subscribers.forEach(function(C) {
              return o.add(C);
            }) : a && _.push(T);
          }
          a && l.push([b, _]);
        }
        if (a) for (var w = 0, N = l; w < N.length; w++) {
          var O = N[w], b = O[0], _ = O[1];
          e.queries.query[b] = _;
        }
      }
      function es(e) {
        var n = e._state, o = e._deps.indexedDB;
        if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
          return n.dbOpenError ? rt(n.dbOpenError) : e;
        });
        n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
        var a = n.openCanceller, l = Math.round(10 * e.verno), d = !1;
        function m() {
          if (n.openCanceller !== a) throw new G.DatabaseClosed("db.open() was cancelled");
        }
        function y() {
          return new se(function(T, w) {
            if (m(), !o) throw new G.MissingAPI();
            var N = e.name, O = n.autoSchema || !l ? o.open(N) : o.open(N, l);
            if (!O) throw new G.MissingAPI();
            O.onerror = Bt(w), O.onblocked = Ze(e._fireOnBlocked), O.onupgradeneeded = Ze(function(C) {
              var I;
              R = O.transaction, n.autoSchema && !e._options.allowEmptyDB ? (O.onerror = Fn, R.abort(), O.result.close(), (I = o.deleteDatabase(N)).onsuccess = I.onerror = Ze(function() {
                w(new G.NoSuchDatabase("Database ".concat(N, " doesnt exist")));
              })) : (R.onerror = Bt(w), C = C.oldVersion > Math.pow(2, 62) ? 0 : C.oldVersion, g = C < 1, e.idbdb = O.result, d && Ja(e, R), Qa(e, C / 10, R, w));
            }, w), O.onsuccess = Ze(function() {
              R = null;
              var C, I, j, M, q, z = e.idbdb = O.result, te = F(z.objectStoreNames);
              if (0 < te.length) try {
                var J = z.transaction((M = te).length === 1 ? M[0] : M, "readonly");
                if (n.autoSchema) I = z, j = J, (C = e).verno = I.version / 10, j = C._dbSchema = mr(0, I, j), C._storeNames = F(I.objectStoreNames, 0), pr(C, [C._allTables], u(j), j);
                else if (vr(e, e._dbSchema, J), ((q = ao(mr(0, (q = e).idbdb, J), q._dbSchema)).add.length || q.change.some(function(ee) {
                  return ee.add.length || ee.change.length;
                })) && !d) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), z.close(), l = z.version + 1, d = !0, T(y());
                fr(e, J);
              } catch {
              }
              Rn.push(e), z.onversionchange = Ze(function(ee) {
                n.vcFired = !0, e.on("versionchange").fire(ee);
              }), z.onclose = Ze(function(ee) {
                e.on("close").fire(ee);
              }), g && (q = e._deps, J = N, z = q.indexedDB, q = q.IDBKeyRange, uo(z) || J === ar || lo(z, q).put({ name: J }).catch(S)), T();
            }, w);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y();
                break;
              case "VersionError":
                if (0 < l) return l = 0, y();
            }
            return se.reject(T);
          });
        }
        var b, _ = n.dbReadyResolve, R = null, g = !1;
        return se.race([a, (typeof navigator > "u" ? se.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function w() {
            return indexedDB.databases().finally(T);
          }
          b = setInterval(w, 100), w();
        }).finally(function() {
          return clearInterval(b);
        }) : Promise.resolve()).then(y)]).then(function() {
          return m(), n.onReadyBeingFired = [], se.resolve(co(function() {
            return e.on.ready.fire(e.vip);
          })).then(function T() {
            if (0 < n.onReadyBeingFired.length) {
              var w = n.onReadyBeingFired.reduce(xe, S);
              return n.onReadyBeingFired = [], se.resolve(co(function() {
                return w(e.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          n.openCanceller === a && (n.onReadyBeingFired = null, n.isBeingOpened = !1);
        }).catch(function(T) {
          n.dbOpenError = T;
          try {
            R && R.abort();
          } catch {
          }
          return a === n.openCanceller && e._close(), rt(T);
        }).finally(function() {
          n.openComplete = !0, _();
        }).then(function() {
          var T;
          return g && (T = {}, e.tables.forEach(function(w) {
            w.schema.indexes.forEach(function(N) {
              N.name && (T["idb://".concat(e.name, "/").concat(w.name, "/").concat(N.name)] = new ht(-1 / 0, [[[]]]));
            }), T["idb://".concat(e.name, "/").concat(w.name, "/")] = T["idb://".concat(e.name, "/").concat(w.name, "/:dels")] = new ht(-1 / 0, [[[]]]);
          }), en(Mn).fire(T), vo(T, !0)), e;
        });
      }
      function yo(e) {
        function n(d) {
          return e.next(d);
        }
        var o = l(n), a = l(function(d) {
          return e.throw(d);
        });
        function l(d) {
          return function(b) {
            var y = d(b), b = y.value;
            return y.done ? b : b && typeof b.then == "function" ? b.then(o, a) : p(b) ? Promise.all(b).then(o, a) : o(b);
          };
        }
        return l(n)();
      }
      function wr(e, n, o) {
        for (var a = p(e) ? e.slice() : [e], l = 0; l < o; ++l) a.push(n);
        return a;
      }
      var ts = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema, l = {}, d = [];
          function m(g, T, w) {
            var N = Kn(g), O = l[N] = l[N] || [], C = g == null ? 0 : typeof g == "string" ? 1 : g.length, I = 0 < T, I = s(s({}, w), { name: I ? "".concat(N, "(virtual-from:").concat(w.name, ")") : w.name, lowLevelIndex: w, isVirtual: I, keyTail: T, keyLength: C, extractKey: oo(g), unique: !I && w.unique });
            return O.push(I), I.isPrimaryKey || d.push(I), 1 < C && m(C === 2 ? g[0] : g.slice(0, C - 1), T + 1, w), O.sort(function(j, M) {
              return j.keyTail - M.keyTail;
            }), I;
          }
          n = m(a.primaryKey.keyPath, 0, a.primaryKey), l[":id"] = [n];
          for (var y = 0, b = a.indexes; y < b.length; y++) {
            var _ = b[y];
            m(_.keyPath, 0, _);
          }
          function R(g) {
            var T, w = g.query.index;
            return w.isVirtual ? s(s({}, g), { query: { index: w.lowLevelIndex, range: (T = g.query.range, w = w.keyTail, { type: T.type === 1 ? 2 : T.type, lower: wr(T.lower, T.lowerOpen ? e.MAX_KEY : e.MIN_KEY, w), lowerOpen: !0, upper: wr(T.upper, T.upperOpen ? e.MIN_KEY : e.MAX_KEY, w), upperOpen: !0 }) } }) : g;
          }
          return s(s({}, o), { schema: s(s({}, a), { primaryKey: n, indexes: d, getIndexByKeyPath: function(g) {
            return (g = l[Kn(g)]) && g[0];
          } }), count: function(g) {
            return o.count(R(g));
          }, query: function(g) {
            return o.query(R(g));
          }, openCursor: function(g) {
            var T = g.query.index, w = T.keyTail, N = T.isVirtual, O = T.keyLength;
            return N ? o.openCursor(R(g)).then(function(I) {
              return I && C(I);
            }) : o.openCursor(g);
            function C(I) {
              return Object.create(I, { continue: { value: function(j) {
                j != null ? I.continue(wr(j, g.reverse ? e.MAX_KEY : e.MIN_KEY, w)) : g.unique ? I.continue(I.key.slice(0, O).concat(g.reverse ? e.MIN_KEY : e.MAX_KEY, w)) : I.continue();
              } }, continuePrimaryKey: { value: function(j, M) {
                I.continuePrimaryKey(wr(j, e.MAX_KEY, w), M);
              } }, primaryKey: { get: function() {
                return I.primaryKey;
              } }, key: { get: function() {
                var j = I.key;
                return O === 1 ? j[0] : j.slice(0, O);
              } }, value: { get: function() {
                return I.value;
              } } });
            }
          } });
        } });
      } };
      function go(e, n, o, a) {
        return o = o || {}, a = a || "", u(e).forEach(function(l) {
          var d, m, y;
          $(n, l) ? (d = e[l], m = n[l], typeof d == "object" && typeof m == "object" && d && m ? (y = De(d)) !== De(m) ? o[a + l] = n[l] : y === "Object" ? go(d, m, o, a + l + ".") : d !== m && (o[a + l] = n[l]) : d !== m && (o[a + l] = n[l])) : o[a + l] = void 0;
        }), u(n).forEach(function(l) {
          $(e, l) || (o[a + l] = n[l]);
        }), o;
      }
      function bo(e, n) {
        return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey);
      }
      var ns = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema.primaryKey;
          return s(s({}, o), { mutate: function(l) {
            var d = pe.trans, m = d.table(n).hook, y = m.deleting, b = m.creating, _ = m.updating;
            switch (l.type) {
              case "add":
                if (b.fire === S) break;
                return d._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "put":
                if (b.fire === S && _.fire === S) break;
                return d._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "delete":
                if (y.fire === S) break;
                return d._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "deleteRange":
                if (y.fire === S) break;
                return d._promise("readwrite", function() {
                  return function g(T, w, N) {
                    return o.query({ trans: T, values: !1, query: { index: a, range: w }, limit: N }).then(function(O) {
                      var C = O.result;
                      return R({ type: "delete", keys: C, trans: T }).then(function(I) {
                        return 0 < I.numFailures ? Promise.reject(I.failures[0]) : C.length < N ? { failures: [], numFailures: 0, lastResult: void 0 } : g(T, s(s({}, w), { lower: C[C.length - 1], lowerOpen: !0 }), N);
                      });
                    });
                  }(l.trans, l.range, 1e4);
                }, !0);
            }
            return o.mutate(l);
            function R(g) {
              var T, w, N, O = pe.trans, C = g.keys || bo(a, g);
              if (!C) throw new Error("Keys missing");
              return (g = g.type === "add" || g.type === "put" ? s(s({}, g), { keys: C }) : s({}, g)).type !== "delete" && (g.values = c([], g.values)), g.keys && (g.keys = c([], g.keys)), T = o, N = C, ((w = g).type === "add" ? Promise.resolve([]) : T.getMany({ trans: w.trans, keys: N, cache: "immutable" })).then(function(I) {
                var j = C.map(function(M, q) {
                  var z, te, J, ee = I[q], ae = { onerror: null, onsuccess: null };
                  return g.type === "delete" ? y.fire.call(ae, M, ee, O) : g.type === "add" || ee === void 0 ? (z = b.fire.call(ae, M, g.values[q], O), M == null && z != null && (g.keys[q] = M = z, a.outbound || ge(g.values[q], a.keyPath, M))) : (z = go(ee, g.values[q]), (te = _.fire.call(ae, z, M, ee, O)) && (J = g.values[q], Object.keys(te).forEach(function(ie) {
                    $(J, ie) ? J[ie] = te[ie] : ge(J, ie, te[ie]);
                  }))), ae;
                });
                return o.mutate(g).then(function(M) {
                  for (var q = M.failures, z = M.results, te = M.numFailures, M = M.lastResult, J = 0; J < C.length; ++J) {
                    var ee = (z || C)[J], ae = j[J];
                    ee == null ? ae.onerror && ae.onerror(q[J]) : ae.onsuccess && ae.onsuccess(g.type === "put" && I[J] ? g.values[J] : ee);
                  }
                  return { failures: q, results: z, numFailures: te, lastResult: M };
                }).catch(function(M) {
                  return j.forEach(function(q) {
                    return q.onerror && q.onerror(M);
                  }), Promise.reject(M);
                });
              });
            }
          } });
        } });
      } };
      function vi(e, n, o) {
        try {
          if (!n || n.keys.length < e.length) return null;
          for (var a = [], l = 0, d = 0; l < n.keys.length && d < e.length; ++l) ke(n.keys[l], e[d]) === 0 && (a.push(o ? me(n.values[l]) : n.values[l]), ++d);
          return a.length === e.length ? a : null;
        } catch {
          return null;
        }
      }
      var rs = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(n) {
          var o = e.table(n);
          return s(s({}, o), { getMany: function(a) {
            if (!a.cache) return o.getMany(a);
            var l = vi(a.keys, a.trans._cache, a.cache === "clone");
            return l ? se.resolve(l) : o.getMany(a).then(function(d) {
              return a.trans._cache = { keys: a.keys, values: a.cache === "clone" ? me(d) : d }, d;
            });
          }, mutate: function(a) {
            return a.type !== "add" && (a.trans._cache = null), o.mutate(a);
          } });
        } };
      } };
      function yi(e, n) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound;
      }
      function gi(e, n) {
        switch (e) {
          case "query":
            return n.values && !n.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var os = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var n = e.schema.name, o = new ht(e.MIN_KEY, e.MAX_KEY);
        return s(s({}, e), { transaction: function(a, l, d) {
          if (pe.subscr && l !== "readonly") throw new G.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(pe.querier));
          return e.transaction(a, l, d);
        }, table: function(a) {
          var l = e.table(a), d = l.schema, m = d.primaryKey, g = d.indexes, y = m.extractKey, b = m.outbound, _ = m.autoIncrement && g.filter(function(w) {
            return w.compound && w.keyPath.includes(m.keyPath);
          }), R = s(s({}, l), { mutate: function(w) {
            function N(ie) {
              return ie = "idb://".concat(n, "/").concat(a, "/").concat(ie), M[ie] || (M[ie] = new ht());
            }
            var O, C, I, j = w.trans, M = w.mutatedParts || (w.mutatedParts = {}), q = N(""), z = N(":dels"), te = w.type, ae = w.type === "deleteRange" ? [w.range] : w.type === "delete" ? [w.keys] : w.values.length < 50 ? [bo(m, w).filter(function(ie) {
              return ie;
            }), w.values] : [], J = ae[0], ee = ae[1], ae = w.trans._cache;
            return p(J) ? (q.addKeys(J), (ae = te === "delete" || J.length === ee.length ? vi(J, ae) : null) || z.addKeys(J), (ae || ee) && (O = N, C = ae, I = ee, d.indexes.forEach(function(ie) {
              var le = O(ie.name || "");
              function Ee(Ce) {
                return Ce != null ? ie.extractKey(Ce) : null;
              }
              function je(Ce) {
                return ie.multiEntry && p(Ce) ? Ce.forEach(function(tt) {
                  return le.addKey(tt);
                }) : le.addKey(Ce);
              }
              (C || I).forEach(function(Ce, mt) {
                var Re = C && Ee(C[mt]), mt = I && Ee(I[mt]);
                ke(Re, mt) !== 0 && (Re != null && je(Re), mt != null && je(mt));
              });
            }))) : J ? (ee = { from: (ee = J.lower) !== null && ee !== void 0 ? ee : e.MIN_KEY, to: (ee = J.upper) !== null && ee !== void 0 ? ee : e.MAX_KEY }, z.add(ee), q.add(ee)) : (q.add(o), z.add(o), d.indexes.forEach(function(ie) {
              return N(ie.name).add(o);
            })), l.mutate(w).then(function(ie) {
              return !J || w.type !== "add" && w.type !== "put" || (q.addKeys(ie.results), _ && _.forEach(function(le) {
                for (var Ee = w.values.map(function(Re) {
                  return le.extractKey(Re);
                }), je = le.keyPath.findIndex(function(Re) {
                  return Re === m.keyPath;
                }), Ce = 0, tt = ie.results.length; Ce < tt; ++Ce) Ee[Ce][je] = ie.results[Ce];
                N(le.name).addKeys(Ee);
              })), j.mutatedParts = gr(j.mutatedParts || {}, M), ie;
            });
          } }), g = function(N) {
            var O = N.query, N = O.index, O = O.range;
            return [N, new ht((N = O.lower) !== null && N !== void 0 ? N : e.MIN_KEY, (O = O.upper) !== null && O !== void 0 ? O : e.MAX_KEY)];
          }, T = { get: function(w) {
            return [m, new ht(w.key)];
          }, getMany: function(w) {
            return [m, new ht().addKeys(w.keys)];
          }, count: g, query: g, openCursor: g };
          return u(T).forEach(function(w) {
            R[w] = function(N) {
              var O = pe.subscr, C = !!O, I = yi(pe, l) && gi(w, N) ? N.obsSet = {} : O;
              if (C) {
                var j = function(ee) {
                  return ee = "idb://".concat(n, "/").concat(a, "/").concat(ee), I[ee] || (I[ee] = new ht());
                }, M = j(""), q = j(":dels"), O = T[w](N), C = O[0], O = O[1];
                if ((w === "query" && C.isPrimaryKey && !N.values ? q : j(C.name || "")).add(O), !C.isPrimaryKey) {
                  if (w !== "count") {
                    var z = w === "query" && b && N.values && l.query(s(s({}, N), { values: !1 }));
                    return l[w].apply(this, arguments).then(function(ee) {
                      if (w === "query") {
                        if (b && N.values) return z.then(function(Ee) {
                          return Ee = Ee.result, M.addKeys(Ee), ee;
                        });
                        var ae = N.values ? ee.result.map(y) : ee.result;
                        (N.values ? M : q).addKeys(ae);
                      } else if (w === "openCursor") {
                        var ie = ee, le = N.values;
                        return ie && Object.create(ie, { key: { get: function() {
                          return q.addKey(ie.primaryKey), ie.key;
                        } }, primaryKey: { get: function() {
                          var Ee = ie.primaryKey;
                          return q.addKey(Ee), Ee;
                        } }, value: { get: function() {
                          return le && M.addKey(ie.primaryKey), ie.value;
                        } } });
                      }
                      return ee;
                    });
                  }
                  q.add(o);
                }
              }
              return l[w].apply(this, arguments);
            };
          }), R;
        } });
      } };
      function bi(e, n, o) {
        if (o.numFailures === 0) return n;
        if (n.type === "deleteRange") return null;
        var a = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
        return o.numFailures === a ? null : (n = s({}, n), p(n.keys) && (n.keys = n.keys.filter(function(l, d) {
          return !(d in o.failures);
        })), "values" in n && p(n.values) && (n.values = n.values.filter(function(l, d) {
          return !(d in o.failures);
        })), n);
      }
      function wo(e, n) {
        return o = e, ((a = n).lower === void 0 || (a.lowerOpen ? 0 < ke(o, a.lower) : 0 <= ke(o, a.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? ke(e, n.upper) < 0 : ke(e, n.upper) <= 0));
        var o, a;
      }
      function wi(e, n, T, a, l, d) {
        if (!T || T.length === 0) return e;
        var m = n.query.index, y = m.multiEntry, b = n.query.range, _ = a.schema.primaryKey.extractKey, R = m.extractKey, g = (m.lowLevelIndex || m).extractKey, T = T.reduce(function(w, N) {
          var O = w, C = [];
          if (N.type === "add" || N.type === "put") for (var I = new ht(), j = N.values.length - 1; 0 <= j; --j) {
            var M, q = N.values[j], z = _(q);
            I.hasKey(z) || (M = R(q), (y && p(M) ? M.some(function(ie) {
              return wo(ie, b);
            }) : wo(M, b)) && (I.addKey(z), C.push(q)));
          }
          switch (N.type) {
            case "add":
              var te = new ht().addKeys(n.values ? w.map(function(le) {
                return _(le);
              }) : w), O = w.concat(n.values ? C.filter(function(le) {
                return le = _(le), !te.hasKey(le) && (te.addKey(le), !0);
              }) : C.map(function(le) {
                return _(le);
              }).filter(function(le) {
                return !te.hasKey(le) && (te.addKey(le), !0);
              }));
              break;
            case "put":
              var J = new ht().addKeys(N.values.map(function(le) {
                return _(le);
              }));
              O = w.filter(function(le) {
                return !J.hasKey(n.values ? _(le) : le);
              }).concat(n.values ? C : C.map(function(le) {
                return _(le);
              }));
              break;
            case "delete":
              var ee = new ht().addKeys(N.keys);
              O = w.filter(function(le) {
                return !ee.hasKey(n.values ? _(le) : le);
              });
              break;
            case "deleteRange":
              var ae = N.range;
              O = w.filter(function(le) {
                return !wo(_(le), ae);
              });
          }
          return O;
        }, e);
        return T === e ? e : (T.sort(function(w, N) {
          return ke(g(w), g(N)) || ke(_(w), _(N));
        }), n.limit && n.limit < 1 / 0 && (T.length > n.limit ? T.length = n.limit : e.length === n.limit && T.length < n.limit && (l.dirty = !0)), d ? Object.freeze(T) : T);
      }
      function _i(e, n) {
        return ke(e.lower, n.lower) === 0 && ke(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen;
      }
      function is(e, n) {
        return function(o, a, l, d) {
          if (o === void 0) return a !== void 0 ? -1 : 0;
          if (a === void 0) return 1;
          if ((a = ke(o, a)) === 0) {
            if (l && d) return 0;
            if (l) return 1;
            if (d) return -1;
          }
          return a;
        }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(o, a, l, d) {
          if (o === void 0) return a !== void 0 ? 1 : 0;
          if (a === void 0) return -1;
          if ((a = ke(o, a)) === 0) {
            if (l && d) return 0;
            if (l) return -1;
            if (d) return 1;
          }
          return a;
        }(e.upper, n.upper, e.upperOpen, n.upperOpen);
      }
      function as(e, n, o, a) {
        e.subscribers.add(o), a.addEventListener("abort", function() {
          var l, d;
          e.subscribers.delete(o), e.subscribers.size === 0 && (l = e, d = n, setTimeout(function() {
            l.subscribers.size === 0 && Fe(d, l);
          }, 3e3));
        });
      }
      var ss = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var n = e.schema.name;
        return s(s({}, e), { transaction: function(o, a, l) {
          var d, m, y = e.transaction(o, a, l);
          return a === "readwrite" && (m = (d = new AbortController()).signal, l = function(b) {
            return function() {
              if (d.abort(), a === "readwrite") {
                for (var _ = /* @__PURE__ */ new Set(), R = 0, g = o; R < g.length; R++) {
                  var T = g[R], w = fn["idb://".concat(n, "/").concat(T)];
                  if (w) {
                    var N = e.table(T), O = w.optimisticOps.filter(function(le) {
                      return le.trans === y;
                    });
                    if (y._explicit && b && y.mutatedParts) for (var C = 0, I = Object.values(w.queries.query); C < I.length; C++) for (var j = 0, M = (te = I[C]).slice(); j < M.length; j++) po((J = M[j]).obsSet, y.mutatedParts) && (Fe(te, J), J.subscribers.forEach(function(le) {
                      return _.add(le);
                    }));
                    else if (0 < O.length) {
                      w.optimisticOps = w.optimisticOps.filter(function(le) {
                        return le.trans !== y;
                      });
                      for (var q = 0, z = Object.values(w.queries.query); q < z.length; q++) for (var te, J, ee, ae = 0, ie = (te = z[q]).slice(); ae < ie.length; ae++) (J = ie[ae]).res != null && y.mutatedParts && (b && !J.dirty ? (ee = Object.isFrozen(J.res), ee = wi(J.res, J.req, O, N, J, ee), J.dirty ? (Fe(te, J), J.subscribers.forEach(function(le) {
                        return _.add(le);
                      })) : ee !== J.res && (J.res = ee, J.promise = se.resolve({ result: ee }))) : (J.dirty && Fe(te, J), J.subscribers.forEach(function(le) {
                        return _.add(le);
                      })));
                    }
                  }
                }
                _.forEach(function(le) {
                  return le();
                });
              }
            };
          }, y.addEventListener("abort", l(!1), { signal: m }), y.addEventListener("error", l(!1), { signal: m }), y.addEventListener("complete", l(!0), { signal: m })), y;
        }, table: function(o) {
          var a = e.table(o), l = a.schema.primaryKey;
          return s(s({}, a), { mutate: function(d) {
            var m = pe.trans;
            if (l.outbound || m.db._options.cache === "disabled" || m.explicit || m.idbtrans.mode !== "readwrite") return a.mutate(d);
            var y = fn["idb://".concat(n, "/").concat(o)];
            return y ? (m = a.mutate(d), d.type !== "add" && d.type !== "put" || !(50 <= d.values.length || bo(l, d).some(function(b) {
              return b == null;
            })) ? (y.optimisticOps.push(d), d.mutatedParts && br(d.mutatedParts), m.then(function(b) {
              0 < b.numFailures && (Fe(y.optimisticOps, d), (b = bi(0, d, b)) && y.optimisticOps.push(b), d.mutatedParts && br(d.mutatedParts));
            }), m.catch(function() {
              Fe(y.optimisticOps, d), d.mutatedParts && br(d.mutatedParts);
            })) : m.then(function(b) {
              var _ = bi(0, s(s({}, d), { values: d.values.map(function(R, g) {
                var T;
                return b.failures[g] ? R : (R = (T = l.keyPath) !== null && T !== void 0 && T.includes(".") ? me(R) : s({}, R), ge(R, l.keyPath, b.results[g]), R);
              }) }), b);
              y.optimisticOps.push(_), queueMicrotask(function() {
                return d.mutatedParts && br(d.mutatedParts);
              });
            }), m) : a.mutate(d);
          }, query: function(d) {
            if (!yi(pe, a) || !gi("query", d)) return a.query(d);
            var m = ((_ = pe.trans) === null || _ === void 0 ? void 0 : _.db._options.cache) === "immutable", g = pe, y = g.requery, b = g.signal, _ = function(N, O, C, I) {
              var j = fn["idb://".concat(N, "/").concat(O)];
              if (!j) return [];
              if (!(O = j.queries[C])) return [null, !1, j, null];
              var M = O[(I.query ? I.query.index.name : null) || ""];
              if (!M) return [null, !1, j, null];
              switch (C) {
                case "query":
                  var q = M.find(function(z) {
                    return z.req.limit === I.limit && z.req.values === I.values && _i(z.req.query.range, I.query.range);
                  });
                  return q ? [q, !0, j, M] : [M.find(function(z) {
                    return ("limit" in z.req ? z.req.limit : 1 / 0) >= I.limit && (!I.values || z.req.values) && is(z.req.query.range, I.query.range);
                  }), !1, j, M];
                case "count":
                  return q = M.find(function(z) {
                    return _i(z.req.query.range, I.query.range);
                  }), [q, !!q, j, M];
              }
            }(n, o, "query", d), R = _[0], g = _[1], T = _[2], w = _[3];
            return R && g ? R.obsSet = d.obsSet : (g = a.query(d).then(function(N) {
              var O = N.result;
              if (R && (R.res = O), m) {
                for (var C = 0, I = O.length; C < I; ++C) Object.freeze(O[C]);
                Object.freeze(O);
              } else N.result = me(O);
              return N;
            }).catch(function(N) {
              return w && R && Fe(w, R), Promise.reject(N);
            }), R = { obsSet: d.obsSet, promise: g, subscribers: /* @__PURE__ */ new Set(), type: "query", req: d, dirty: !1 }, w ? w.push(R) : (w = [R], (T = T || (fn["idb://".concat(n, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[d.query.index.name || ""] = w)), as(R, w, y, b), R.promise.then(function(N) {
              return { result: wi(N.result, d, T?.optimisticOps, a, R, m) };
            });
          } });
        } });
      } };
      function _r(e, n) {
        return new Proxy(e, { get: function(o, a, l) {
          return a === "db" ? n : Reflect.get(o, a, l);
        } });
      }
      var Wt = (ot.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new G.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new G.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var n = this._versions, o = n.filter(function(a) {
          return a._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), n.push(o), n.sort(Xa), o.stores({}), this._state.autoSchema = !1, o);
      }, ot.prototype._whenReady = function(e) {
        var n = this;
        return this.idbdb && (this._state.openComplete || pe.letThrough || this._vip) ? e() : new se(function(o, a) {
          if (n._state.openComplete) return a(new G.DatabaseClosed(n._state.dbOpenError));
          if (!n._state.isBeingOpened) {
            if (!n._state.autoOpen) return void a(new G.DatabaseClosed());
            n.open().catch(S);
          }
          n._state.dbReadyPromise.then(o, a);
        }).then(e);
      }, ot.prototype.use = function(e) {
        var n = e.stack, o = e.create, a = e.level, l = e.name;
        return l && this.unuse({ stack: n, name: l }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({ stack: n, create: o, level: a ?? 10, name: l }), e.sort(function(d, m) {
          return d.level - m.level;
        }), this;
      }, ot.prototype.unuse = function(e) {
        var n = e.stack, o = e.name, a = e.create;
        return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(l) {
          return a ? l.create !== a : !!o && l.name !== o;
        })), this;
      }, ot.prototype.open = function() {
        var e = this;
        return un(gt, function() {
          return es(e);
        });
      }, ot.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, n = Rn.indexOf(this);
        if (0 <= n && Rn.splice(n, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new se(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new se(function(o, a) {
          e.cancelOpen = a;
        }));
      }, ot.prototype.close = function(o) {
        var n = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        n ? (o.isBeingOpened && o.cancelOpen(new G.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new G.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, ot.prototype.delete = function(e) {
        var n = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", a = this._state;
        return new se(function(l, d) {
          function m() {
            n.close(e);
            var y = n._deps.indexedDB.deleteDatabase(n.name);
            y.onsuccess = Ze(function() {
              var b, _, R;
              b = n._deps, _ = n.name, R = b.indexedDB, b = b.IDBKeyRange, uo(R) || _ === ar || lo(R, b).delete(_).catch(S), l();
            }), y.onerror = Bt(d), y.onblocked = n._fireOnBlocked;
          }
          if (o) throw new G.InvalidArgument("Invalid closeOptions argument to db.delete()");
          a.isBeingOpened ? a.dbReadyPromise.then(m) : m();
        });
      }, ot.prototype.backendDB = function() {
        return this.idbdb;
      }, ot.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, ot.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, ot.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, ot.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(ot.prototype, "tables", { get: function() {
        var e = this;
        return u(this._allTables).map(function(n) {
          return e._allTables[n];
        });
      }, enumerable: !1, configurable: !0 }), ot.prototype.transaction = function() {
        var e = (function(n, o, a) {
          var l = arguments.length;
          if (l < 2) throw new G.InvalidArgument("Too few arguments");
          for (var d = new Array(l - 1); --l; ) d[l - 1] = arguments[l];
          return a = d.pop(), [n, oe(d), a];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, ot.prototype._transaction = function(e, n, o) {
        var a = this, l = pe.trans;
        l && l.db === this && e.indexOf("!") === -1 || (l = null);
        var d, m, y = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (m = n.map(function(_) {
            if (_ = _ instanceof a.Table ? _.name : _, typeof _ != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return _;
          }), e == "r" || e === Qr) d = Qr;
          else {
            if (e != "rw" && e != Jr) throw new G.InvalidArgument("Invalid transaction mode: " + e);
            d = Jr;
          }
          if (l) {
            if (l.mode === Qr && d === Jr) {
              if (!y) throw new G.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              l = null;
            }
            l && m.forEach(function(_) {
              if (l && l.storeNames.indexOf(_) === -1) {
                if (!y) throw new G.SubTransaction("Table " + _ + " not included in parent transaction.");
                l = null;
              }
            }), y && l && !l.active && (l = null);
          }
        } catch (_) {
          return l ? l._promise(null, function(R, g) {
            g(_);
          }) : rt(_);
        }
        var b = (function _(R, g, T, w, N) {
          return se.resolve().then(function() {
            var O = pe.transless || pe, C = R._createTransaction(g, T, R._dbSchema, w);
            if (C.explicit = !0, O = { trans: C, transless: O }, w) C.idbtrans = w.idbtrans;
            else try {
              C.create(), C.idbtrans._explicit = !0, R._state.PR1398_maxLoop = 3;
            } catch (M) {
              return M.name === L.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                return _(R, g, T, null, N);
              })) : rt(M);
            }
            var I, j = Qe(N);
            return j && xn(), O = se.follow(function() {
              var M;
              (I = N.call(C, C)) && (j ? (M = Qt.bind(null, null), I.then(M, M)) : typeof I.next == "function" && typeof I.throw == "function" && (I = yo(I)));
            }, O), (I && typeof I.then == "function" ? se.resolve(I).then(function(M) {
              return C.active ? M : rt(new G.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : O.then(function() {
              return I;
            })).then(function(M) {
              return w && C._resolve(), C._completion.then(function() {
                return M;
              });
            }).catch(function(M) {
              return C._reject(M), rt(M);
            });
          });
        }).bind(null, this, d, m, l, o);
        return l ? l._promise(d, b, "lock") : pe.trans ? un(pe.transless, function() {
          return a._whenReady(b);
        }) : this._whenReady(b);
      }, ot.prototype.table = function(e) {
        if (!$(this._allTables, e)) throw new G.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, ot);
      function ot(e, n) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var a = ot.dependencies;
        this._options = n = s({ addons: ot.addons, autoOpen: !0, indexedDB: a.indexedDB, IDBKeyRange: a.IDBKeyRange, cache: "cloned" }, n), this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange }, a = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var l, d, m, y, b, _ = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: S, dbReadyPromise: null, cancelOpen: S, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: n.autoOpen };
        _.dbReadyPromise = new se(function(g) {
          _.dbReadyResolve = g;
        }), _.openCanceller = new se(function(g, T) {
          _.cancelOpen = T;
        }), this._state = _, this.name = e, this.on = kn(this, "populate", "blocked", "versionchange", "close", { ready: [xe, S] }), this.once = function(g, T) {
          var w = function() {
            for (var N = [], O = 0; O < arguments.length; O++) N[O] = arguments[O];
            o.on(g).unsubscribe(w), T.apply(o, N);
          };
          return o.on(g, w);
        }, this.on.ready.subscribe = E(this.on.ready.subscribe, function(g) {
          return function(T, w) {
            ot.vip(function() {
              var N, O = o._state;
              O.openComplete ? (O.dbOpenError || se.resolve().then(T), w && g(T)) : O.onReadyBeingFired ? (O.onReadyBeingFired.push(T), w && g(T)) : (g(T), N = o, w || g(function C() {
                N.on.ready.unsubscribe(T), N.on.ready.unsubscribe(C);
              }));
            });
          };
        }), this.Collection = (l = this, jn(Ua.prototype, function(I, C) {
          this.db = l;
          var w = Qo, N = null;
          if (C) try {
            w = C();
          } catch (j) {
            N = j;
          }
          var O = I._ctx, C = O.table, I = C.hook.reading.fire;
          this._ctx = { table: C, index: O.index, isPrimKey: !O.index || C.schema.primKey.keyPath && O.index === C.schema.primKey.name, range: w, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: N, or: O.or, valueMapper: I !== H ? I : null };
        })), this.Table = (d = this, jn(ti.prototype, function(g, T, w) {
          this.db = d, this._tx = w, this.name = g, this.schema = T, this.hook = d._allTables[g] ? d._allTables[g].hook : kn(null, { creating: [be, S], reading: [ue, H], updating: [Oe, S], deleting: [ve, S] });
        })), this.Transaction = (m = this, jn(Ga.prototype, function(g, T, w, N, O) {
          var C = this;
          g !== "readonly" && T.forEach(function(I) {
            I = (I = w[I]) === null || I === void 0 ? void 0 : I.yProps, I && (T = T.concat(I.map(function(j) {
              return j.updatesTable;
            })));
          }), this.db = m, this.mode = g, this.storeNames = T, this.schema = w, this.chromeTransactionDurability = N, this.idbtrans = null, this.on = kn(this, "complete", "error", "abort"), this.parent = O || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new se(function(I, j) {
            C._resolve = I, C._reject = j;
          }), this._completion.then(function() {
            C.active = !1, C.on.complete.fire();
          }, function(I) {
            var j = C.active;
            return C.active = !1, C.on.error.fire(I), C.parent ? C.parent._reject(I) : j && C.idbtrans && C.idbtrans.abort(), rt(I);
          });
        })), this.Version = (y = this, jn(Za.prototype, function(g) {
          this.db = y, this._cfg = { version: g, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (b = this, jn(si.prototype, function(g, T, w) {
          if (this.db = b, this._ctx = { table: g, index: T === ":id" ? null : T, or: w }, this._cmp = this._ascending = ke, this._descending = function(N, O) {
            return ke(O, N);
          }, this._max = function(N, O) {
            return 0 < ke(N, O) ? N : O;
          }, this._min = function(N, O) {
            return ke(N, O) < 0 ? N : O;
          }, this._IDBKeyRange = b._deps.IDBKeyRange, !this._IDBKeyRange) throw new G.MissingAPI();
        })), this.on("versionchange", function(g) {
          0 < g.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(g) {
          !g.newVersion || g.newVersion < g.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(g.oldVersion / 10));
        }), this._maxKey = Bn(n.IDBKeyRange), this._createTransaction = function(g, T, w, N) {
          return new o.Transaction(g, T, w, o._options.chromeTransactionDurability, N);
        }, this._fireOnBlocked = function(g) {
          o.on("blocked").fire(g), Rn.filter(function(T) {
            return T.name === o.name && T !== o && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(g);
          });
        }, this.use(rs), this.use(ss), this.use(os), this.use(ts), this.use(ns);
        var R = new Proxy(this, { get: function(g, T, w) {
          if (T === "_vip") return !0;
          if (T === "table") return function(O) {
            return _r(o.table(O), R);
          };
          var N = Reflect.get(g, T, w);
          return N instanceof ti ? _r(N, R) : T === "tables" ? N.map(function(O) {
            return _r(O, R);
          }) : T === "_createTransaction" ? function() {
            return _r(N.apply(this, arguments), R);
          } : N;
        } });
        this.vip = R, a.forEach(function(g) {
          return g(o);
        });
      }
      var Nr, Dt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", ls = (_o.prototype.subscribe = function(e, n, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: o });
      }, _o.prototype[Dt] = function() {
        return this;
      }, _o);
      function _o(e) {
        this._subscribe = e;
      }
      try {
        Nr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
      } catch {
        Nr = { indexedDB: null, IDBKeyRange: null };
      }
      function Ni(e) {
        var n, o = !1, a = new ls(function(l) {
          var d = Qe(e), m, y = !1, b = {}, _ = {}, R = { get closed() {
            return y;
          }, unsubscribe: function() {
            y || (y = !0, m && m.abort(), g && en.storagemutated.unsubscribe(w));
          } };
          l.start && l.start(R);
          var g = !1, T = function() {
            return Xr(N);
          }, w = function(O) {
            gr(b, O), po(_, b) && T();
          }, N = function() {
            var O, C, I;
            !y && Nr.indexedDB && (b = {}, O = {}, m && m.abort(), m = new AbortController(), I = function(j) {
              var M = _n();
              try {
                d && xn();
                var q = Xt(e, j);
                return q = d ? q.finally(Qt) : q;
              } finally {
                M && Nn();
              }
            }(C = { subscr: O, signal: m.signal, requery: T, querier: e, trans: null }), Promise.resolve(I).then(function(j) {
              o = !0, n = j, y || C.signal.aborted || (b = {}, function(M) {
                for (var q in M) if ($(M, q)) return;
                return 1;
              }(_ = O) || g || (en(Mn, w), g = !0), Xr(function() {
                return !y && l.next && l.next(j);
              }));
            }, function(j) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(j?.name) || y || Xr(function() {
                y || l.error && l.error(j);
              });
            }));
          };
          return setTimeout(T, 0), R;
        });
        return a.hasValue = function() {
          return o;
        }, a.getValue = function() {
          return n;
        }, a;
      }
      var pn = Wt;
      function No(e) {
        var n = tn;
        try {
          tn = !0, en.storagemutated.fire(e), vo(e, !0);
        } finally {
          tn = n;
        }
      }
      U(pn, s(s({}, st), { delete: function(e) {
        return new pn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new pn(e, { addons: [] }).open().then(function(n) {
          return n.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return n = pn.dependencies, o = n.indexedDB, n = n.IDBKeyRange, (uo(o) ? Promise.resolve(o.databases()).then(function(a) {
            return a.map(function(l) {
              return l.name;
            }).filter(function(l) {
              return l !== ar;
            });
          }) : lo(o, n).toCollection().primaryKeys()).then(e);
        } catch {
          return rt(new G.MissingAPI());
        }
        var n, o;
      }, defineClass: function() {
        return function(e) {
          v(this, e);
        };
      }, ignoreTransaction: function(e) {
        return pe.trans ? un(pe.transless, e) : e();
      }, vip: co, async: function(e) {
        return function() {
          try {
            var n = yo(e.apply(this, arguments));
            return n && typeof n.then == "function" ? n : se.resolve(n);
          } catch (o) {
            return rt(o);
          }
        };
      }, spawn: function(e, n, o) {
        try {
          var a = yo(e.apply(o, n || []));
          return a && typeof a.then == "function" ? a : se.resolve(a);
        } catch (l) {
          return rt(l);
        }
      }, currentTransaction: { get: function() {
        return pe.trans || null;
      } }, waitFor: function(e, n) {
        return n = se.resolve(typeof e == "function" ? pn.ignoreTransaction(e) : e).timeout(n || 6e4), pe.trans ? pe.trans.waitFor(n) : n;
      }, Promise: se, debug: { get: function() {
        return ye;
      }, set: function(e) {
        qe(e);
      } }, derive: P, extend: v, props: U, override: E, Events: kn, on: en, liveQuery: Ni, extendObservabilitySet: gr, getByKeyPath: de, setByKeyPath: ge, delByKeyPath: function(e, n) {
        typeof n == "string" ? ge(e, n, void 0) : "length" in n && [].map.call(n, function(o) {
          ge(e, o, void 0);
        });
      }, shallowClone: Ue, deepClone: me, getObjectDiff: go, cmp: ke, asap: we, minKey: -1 / 0, addons: [], connections: Rn, errnames: L, dependencies: Nr, cache: fn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, n, o) {
        return e + n / Math.pow(10, 2 * o);
      }) })), pn.maxKey = Bn(pn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (en(Mn, function(e) {
        tn || (e = new CustomEvent(to, { detail: e }), tn = !0, dispatchEvent(e), tn = !1);
      }), addEventListener(to, function(e) {
        e = e.detail, tn || No(e);
      }));
      var An, tn = !1, xi = function() {
      };
      return typeof BroadcastChannel < "u" && ((xi = function() {
        (An = new BroadcastChannel(to)).onmessage = function(e) {
          return e.data && No(e.data);
        };
      })(), typeof An.unref == "function" && An.unref(), en(Mn, function(e) {
        tn || An.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Wt.disableBfCache && e.persisted) {
          ye && console.debug("Dexie: handling persisted pagehide"), An?.close();
          for (var n = 0, o = Rn; n < o.length; n++) o[n].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Wt.disableBfCache && e.persisted && (ye && console.debug("Dexie: handling persisted pageshow"), xi(), No({ all: new ht(-1 / 0, [[]]) }));
      })), se.rejectionMapper = function(e, n) {
        return !e || e instanceof it || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Z[e.name] ? e : (n = new Z[e.name](n || e.message, e), "stack" in e && A(n, "stack", { get: function() {
          return this.inner.stack;
        } }), n);
      }, qe(ye), s(Wt, Object.freeze({ __proto__: null, Dexie: Wt, liveQuery: Ni, Entity: Jo, cmp: ke, PropModification: $n, replacePrefix: function(e, n) {
        return new $n({ replacePrefix: [e, n] });
      }, add: function(e) {
        return new $n({ add: e });
      }, remove: function(e) {
        return new $n({ remove: e });
      }, default: Wt, RangeSet: ht, mergeRanges: Un, rangesOverlap: fi }), { default: Wt }), Wt;
    });
  }(sa)), sa.exports;
}
var vp = mp();
const ks = /* @__PURE__ */ pp(vp), Jl = Symbol.for("Dexie"), wa = globalThis[Jl] || (globalThis[Jl] = ks);
if (ks.semVer !== wa.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${ks.semVer} and ${wa.semVer}`);
const {
  liveQuery: Ab,
  mergeRanges: Db,
  rangesOverlap: Pb,
  RangeSet: Sb,
  cmp: Lb,
  Entity: kb,
  PropModification: jb,
  replacePrefix: $b,
  add: Fb,
  remove: Mb,
  DexieYProvider: Bb
} = wa;
var yp = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function gp(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function bp(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var r = t.default;
  if (typeof r == "function") {
    var i = function s() {
      var c = !1;
      try {
        c = this instanceof s;
      } catch {
      }
      return c ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    i.prototype = r.prototype;
  } else i = {};
  return Object.defineProperty(i, "__esModule", { value: !0 }), Object.keys(t).forEach(function(s) {
    var c = Object.getOwnPropertyDescriptor(t, s);
    Object.defineProperty(i, s, c.get ? c : {
      enumerable: !0,
      get: function() {
        return t[s];
      }
    });
  }), i;
}
var Zl = {};
const wp = {}, _p = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: wp
}, Symbol.toStringTag, { value: "Module" })), eu = /* @__PURE__ */ bp(_p);
var tu;
function Np() {
  return tu || (tu = 1, function(t) {
    (function(r) {
      r.parser = function(L, x) {
        return new s(L, x);
      }, r.SAXParser = s, r.SAXStream = D, r.createStream = k, r.MAX_BUFFER_LENGTH = 64 * 1024;
      var i = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      r.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function s(L, x) {
        if (!(this instanceof s))
          return new s(L, x);
        var G = this;
        f(G), G.q = G.c = "", G.bufferCheckPosition = r.MAX_BUFFER_LENGTH, G.opt = x || {}, G.opt.lowercase = G.opt.lowercase || G.opt.lowercasetags, G.looseCase = G.opt.lowercase ? "toLowerCase" : "toUpperCase", G.tags = [], G.closed = G.closedRoot = G.sawRoot = !1, G.tag = G.error = null, G.strict = !!L, G.noscript = !!(L || G.opt.noscript), G.state = Y.BEGIN, G.strictEntities = G.opt.strictEntities, G.ENTITIES = G.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), G.attribList = [], G.opt.xmlns && (G.ns = Object.create(P)), G.opt.unquotedAttributeValues === void 0 && (G.opt.unquotedAttributeValues = !L), G.trackPosition = G.opt.position !== !1, G.trackPosition && (G.position = G.line = G.column = 0), ce(G, "onready");
      }
      Object.create || (Object.create = function(L) {
        function x() {
        }
        x.prototype = L;
        var G = new x();
        return G;
      }), Object.keys || (Object.keys = function(L) {
        var x = [];
        for (var G in L) L.hasOwnProperty(G) && x.push(G);
        return x;
      });
      function c(L) {
        for (var x = Math.max(r.MAX_BUFFER_LENGTH, 10), G = 0, Z = 0, st = i.length; Z < st; Z++) {
          var S = L[i[Z]].length;
          if (S > x)
            switch (i[Z]) {
              case "textNode":
                me(L);
                break;
              case "cdata":
                fe(L, "oncdata", L.cdata), L.cdata = "";
                break;
              case "script":
                fe(L, "onscript", L.script), L.script = "";
                break;
              default:
                De(L, "Max buffer length exceeded: " + i[Z]);
            }
          G = Math.max(G, S);
        }
        var H = r.MAX_BUFFER_LENGTH - G;
        L.bufferCheckPosition = H + L.position;
      }
      function f(L) {
        for (var x = 0, G = i.length; x < G; x++)
          L[i[x]] = "";
      }
      function u(L) {
        me(L), L.cdata !== "" && (fe(L, "oncdata", L.cdata), L.cdata = ""), L.script !== "" && (fe(L, "onscript", L.script), L.script = "");
      }
      s.prototype = {
        end: function() {
          Se(this);
        },
        write: Mt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          u(this);
        }
      };
      var p;
      try {
        p = eu.Stream;
      } catch {
        p = function() {
        };
      }
      p || (p = function() {
      });
      var v = r.EVENTS.filter(function(L) {
        return L !== "error" && L !== "end";
      });
      function k(L, x) {
        return new D(L, x);
      }
      function D(L, x) {
        if (!(this instanceof D))
          return new D(L, x);
        p.apply(this), this._parser = new s(L, x), this.writable = !0, this.readable = !0;
        var G = this;
        this._parser.onend = function() {
          G.emit("end");
        }, this._parser.onerror = function(Z) {
          G.emit("error", Z), G._parser.error = null;
        }, this._decoder = null, v.forEach(function(Z) {
          Object.defineProperty(G, "on" + Z, {
            get: function() {
              return G._parser["on" + Z];
            },
            set: function(st) {
              if (!st)
                return G.removeAllListeners(Z), G._parser["on" + Z] = st, st;
              G.on(Z, st);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      D.prototype = Object.create(p.prototype, {
        constructor: {
          value: D
        }
      }), D.prototype.write = function(L) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(L)) {
          if (!this._decoder) {
            var x = eu.StringDecoder;
            this._decoder = new x("utf8");
          }
          L = this._decoder.write(L);
        }
        return this._parser.write(L.toString()), this.emit("data", L), !0;
      }, D.prototype.end = function(L) {
        return L && L.length && this.write(L), this._parser.end(), !0;
      }, D.prototype.on = function(L, x) {
        var G = this;
        return !G._parser["on" + L] && v.indexOf(L) !== -1 && (G._parser["on" + L] = function() {
          var Z = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          Z.splice(0, 0, L), G.emit.apply(G, Z);
        }), p.prototype.on.call(G, L, x);
      };
      var $ = "[CDATA[", U = "DOCTYPE", W = "http://www.w3.org/XML/1998/namespace", A = "http://www.w3.org/2000/xmlns/", P = { xml: W, xmlns: A }, B = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, X = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, F = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, E = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function K(L) {
        return L === " " || L === `
` || L === "\r" || L === "	";
      }
      function we(L) {
        return L === '"' || L === "'";
      }
      function de(L) {
        return L === ">" || K(L);
      }
      function ge(L, x) {
        return L.test(x);
      }
      function Ue(L, x) {
        return !ge(L, x);
      }
      var Y = 0;
      r.STATE = {
        BEGIN: Y++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: Y++,
        // leading whitespace
        TEXT: Y++,
        // general stuff
        TEXT_ENTITY: Y++,
        // &amp and such.
        OPEN_WAKA: Y++,
        // <
        SGML_DECL: Y++,
        // <!BLARG
        SGML_DECL_QUOTED: Y++,
        // <!BLARG foo "bar
        DOCTYPE: Y++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: Y++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: Y++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: Y++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: Y++,
        // <!-
        COMMENT: Y++,
        // <!--
        COMMENT_ENDING: Y++,
        // <!-- blah -
        COMMENT_ENDED: Y++,
        // <!-- blah --
        CDATA: Y++,
        // <![CDATA[ something
        CDATA_ENDING: Y++,
        // ]
        CDATA_ENDING_2: Y++,
        // ]]
        PROC_INST: Y++,
        // <?hi
        PROC_INST_BODY: Y++,
        // <?hi there
        PROC_INST_ENDING: Y++,
        // <?hi "there" ?
        OPEN_TAG: Y++,
        // <strong
        OPEN_TAG_SLASH: Y++,
        // <strong /
        ATTRIB: Y++,
        // <a
        ATTRIB_NAME: Y++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: Y++,
        // <a foo _
        ATTRIB_VALUE: Y++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: Y++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: Y++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: Y++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: Y++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: Y++,
        // <foo bar=&quot
        CLOSE_TAG: Y++,
        // </a
        CLOSE_TAG_SAW_WHITE: Y++,
        // </a   >
        SCRIPT: Y++,
        // <script> ...
        SCRIPT_ENDING: Y++
        // <script> ... <
      }, r.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, r.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(r.ENTITIES).forEach(function(L) {
        var x = r.ENTITIES[L], G = typeof x == "number" ? String.fromCharCode(x) : x;
        r.ENTITIES[L] = G;
      });
      for (var oe in r.STATE)
        r.STATE[r.STATE[oe]] = oe;
      Y = r.STATE;
      function ce(L, x, G) {
        L[x] && L[x](G);
      }
      function fe(L, x, G) {
        L.textNode && me(L), ce(L, x, G);
      }
      function me(L) {
        L.textNode = Pe(L.opt, L.textNode), L.textNode && ce(L, "ontext", L.textNode), L.textNode = "";
      }
      function Pe(L, x) {
        return L.trim && (x = x.trim()), L.normalize && (x = x.replace(/\s+/g, " ")), x;
      }
      function De(L, x) {
        return me(L), L.trackPosition && (x += `
Line: ` + L.line + `
Column: ` + L.column + `
Char: ` + L.c), x = new Error(x), L.error = x, ce(L, "onerror", x), L;
      }
      function Se(L) {
        return L.sawRoot && !L.closedRoot && Ne(L, "Unclosed root tag"), L.state !== Y.BEGIN && L.state !== Y.BEGIN_WHITESPACE && L.state !== Y.TEXT && De(L, "Unexpected end"), me(L), L.c = "", L.closed = !0, ce(L, "onend"), s.call(L, L.strict, L.opt), L;
      }
      function Ne(L, x) {
        if (typeof L != "object" || !(L instanceof s))
          throw new Error("bad call to strictFail");
        L.strict && De(L, x);
      }
      function Fe(L) {
        L.strict || (L.tagName = L.tagName[L.looseCase]());
        var x = L.tags[L.tags.length - 1] || L, G = L.tag = { name: L.tagName, attributes: {} };
        L.opt.xmlns && (G.ns = x.ns), L.attribList.length = 0, fe(L, "onopentagstart", G);
      }
      function pt(L, x) {
        var G = L.indexOf(":"), Z = G < 0 ? ["", L] : L.split(":"), st = Z[0], S = Z[1];
        return x && L === "xmlns" && (st = "xmlns", S = ""), { prefix: st, local: S };
      }
      function Me(L) {
        if (L.strict || (L.attribName = L.attribName[L.looseCase]()), L.attribList.indexOf(L.attribName) !== -1 || L.tag.attributes.hasOwnProperty(L.attribName)) {
          L.attribName = L.attribValue = "";
          return;
        }
        if (L.opt.xmlns) {
          var x = pt(L.attribName, !0), G = x.prefix, Z = x.local;
          if (G === "xmlns")
            if (Z === "xml" && L.attribValue !== W)
              Ne(
                L,
                "xml: prefix must be bound to " + W + `
Actual: ` + L.attribValue
              );
            else if (Z === "xmlns" && L.attribValue !== A)
              Ne(
                L,
                "xmlns: prefix must be bound to " + A + `
Actual: ` + L.attribValue
              );
            else {
              var st = L.tag, S = L.tags[L.tags.length - 1] || L;
              st.ns === S.ns && (st.ns = Object.create(S.ns)), st.ns[Z] = L.attribValue;
            }
          L.attribList.push([L.attribName, L.attribValue]);
        } else
          L.tag.attributes[L.attribName] = L.attribValue, fe(L, "onattribute", {
            name: L.attribName,
            value: L.attribValue
          });
        L.attribName = L.attribValue = "";
      }
      function Qe(L, x) {
        if (L.opt.xmlns) {
          var G = L.tag, Z = pt(L.tagName);
          G.prefix = Z.prefix, G.local = Z.local, G.uri = G.ns[Z.prefix] || "", G.prefix && !G.uri && (Ne(L, "Unbound namespace prefix: " + JSON.stringify(L.tagName)), G.uri = Z.prefix);
          var st = L.tags[L.tags.length - 1] || L;
          G.ns && st.ns !== G.ns && Object.keys(G.ns).forEach(function(qe) {
            fe(L, "onopennamespace", {
              prefix: qe,
              uri: G.ns[qe]
            });
          });
          for (var S = 0, H = L.attribList.length; S < H; S++) {
            var ue = L.attribList[S], he = ue[0], be = ue[1], ve = pt(he, !0), Oe = ve.prefix, Ie = ve.local, xe = Oe === "" ? "" : G.ns[Oe] || "", ye = {
              name: he,
              value: be,
              prefix: Oe,
              local: Ie,
              uri: xe
            };
            Oe && Oe !== "xmlns" && !xe && (Ne(L, "Unbound namespace prefix: " + JSON.stringify(Oe)), ye.uri = Oe), L.tag.attributes[he] = ye, fe(L, "onattribute", ye);
          }
          L.attribList.length = 0;
        }
        L.tag.isSelfClosing = !!x, L.sawRoot = !0, L.tags.push(L.tag), fe(L, "onopentag", L.tag), x || (!L.noscript && L.tagName.toLowerCase() === "script" ? L.state = Y.SCRIPT : L.state = Y.TEXT, L.tag = null, L.tagName = ""), L.attribName = L.attribValue = "", L.attribList.length = 0;
      }
      function $t(L) {
        if (!L.tagName) {
          Ne(L, "Weird empty close tag."), L.textNode += "</>", L.state = Y.TEXT;
          return;
        }
        if (L.script) {
          if (L.tagName !== "script") {
            L.script += "</" + L.tagName + ">", L.tagName = "", L.state = Y.SCRIPT;
            return;
          }
          fe(L, "onscript", L.script), L.script = "";
        }
        var x = L.tags.length, G = L.tagName;
        L.strict || (G = G[L.looseCase]());
        for (var Z = G; x--; ) {
          var st = L.tags[x];
          if (st.name !== Z)
            Ne(L, "Unexpected close tag");
          else
            break;
        }
        if (x < 0) {
          Ne(L, "Unmatched closing tag: " + L.tagName), L.textNode += "</" + L.tagName + ">", L.state = Y.TEXT;
          return;
        }
        L.tagName = G;
        for (var S = L.tags.length; S-- > x; ) {
          var H = L.tag = L.tags.pop();
          L.tagName = L.tag.name, fe(L, "onclosetag", L.tagName);
          var ue = {};
          for (var he in H.ns)
            ue[he] = H.ns[he];
          var be = L.tags[L.tags.length - 1] || L;
          L.opt.xmlns && H.ns !== be.ns && Object.keys(H.ns).forEach(function(ve) {
            var Oe = H.ns[ve];
            fe(L, "onclosenamespace", { prefix: ve, uri: Oe });
          });
        }
        x === 0 && (L.closedRoot = !0), L.tagName = L.attribValue = L.attribName = "", L.attribList.length = 0, L.state = Y.TEXT;
      }
      function it(L) {
        var x = L.entity, G = x.toLowerCase(), Z, st = "";
        return L.ENTITIES[x] ? L.ENTITIES[x] : L.ENTITIES[G] ? L.ENTITIES[G] : (x = G, x.charAt(0) === "#" && (x.charAt(1) === "x" ? (x = x.slice(2), Z = parseInt(x, 16), st = Z.toString(16)) : (x = x.slice(1), Z = parseInt(x, 10), st = Z.toString(10))), x = x.replace(/^0+/, ""), isNaN(Z) || st.toLowerCase() !== x ? (Ne(L, "Invalid character entity"), "&" + L.entity + ";") : String.fromCodePoint(Z));
      }
      function Ht(L, x) {
        x === "<" ? (L.state = Y.OPEN_WAKA, L.startTagPosition = L.position) : K(x) || (Ne(L, "Non-whitespace before first tag."), L.textNode = x, L.state = Y.TEXT);
      }
      function bn(L, x) {
        var G = "";
        return x < L.length && (G = L.charAt(x)), G;
      }
      function Mt(L) {
        var x = this;
        if (this.error)
          throw this.error;
        if (x.closed)
          return De(
            x,
            "Cannot write after close. Assign an onready handler."
          );
        if (L === null)
          return Se(x);
        typeof L == "object" && (L = L.toString());
        for (var G = 0, Z = ""; Z = bn(L, G++), x.c = Z, !!Z; )
          switch (x.trackPosition && (x.position++, Z === `
` ? (x.line++, x.column = 0) : x.column++), x.state) {
            case Y.BEGIN:
              if (x.state = Y.BEGIN_WHITESPACE, Z === "\uFEFF")
                continue;
              Ht(x, Z);
              continue;
            case Y.BEGIN_WHITESPACE:
              Ht(x, Z);
              continue;
            case Y.TEXT:
              if (x.sawRoot && !x.closedRoot) {
                for (var st = G - 1; Z && Z !== "<" && Z !== "&"; )
                  Z = bn(L, G++), Z && x.trackPosition && (x.position++, Z === `
` ? (x.line++, x.column = 0) : x.column++);
                x.textNode += L.substring(st, G - 1);
              }
              Z === "<" && !(x.sawRoot && x.closedRoot && !x.strict) ? (x.state = Y.OPEN_WAKA, x.startTagPosition = x.position) : (!K(Z) && (!x.sawRoot || x.closedRoot) && Ne(x, "Text data outside of root node."), Z === "&" ? x.state = Y.TEXT_ENTITY : x.textNode += Z);
              continue;
            case Y.SCRIPT:
              Z === "<" ? x.state = Y.SCRIPT_ENDING : x.script += Z;
              continue;
            case Y.SCRIPT_ENDING:
              Z === "/" ? x.state = Y.CLOSE_TAG : (x.script += "<" + Z, x.state = Y.SCRIPT);
              continue;
            case Y.OPEN_WAKA:
              if (Z === "!")
                x.state = Y.SGML_DECL, x.sgmlDecl = "";
              else if (!K(Z)) if (ge(B, Z))
                x.state = Y.OPEN_TAG, x.tagName = Z;
              else if (Z === "/")
                x.state = Y.CLOSE_TAG, x.tagName = "";
              else if (Z === "?")
                x.state = Y.PROC_INST, x.procInstName = x.procInstBody = "";
              else {
                if (Ne(x, "Unencoded <"), x.startTagPosition + 1 < x.position) {
                  var S = x.position - x.startTagPosition;
                  Z = new Array(S).join(" ") + Z;
                }
                x.textNode += "<" + Z, x.state = Y.TEXT;
              }
              continue;
            case Y.SGML_DECL:
              if (x.sgmlDecl + Z === "--") {
                x.state = Y.COMMENT, x.comment = "", x.sgmlDecl = "";
                continue;
              }
              x.doctype && x.doctype !== !0 && x.sgmlDecl ? (x.state = Y.DOCTYPE_DTD, x.doctype += "<!" + x.sgmlDecl + Z, x.sgmlDecl = "") : (x.sgmlDecl + Z).toUpperCase() === $ ? (fe(x, "onopencdata"), x.state = Y.CDATA, x.sgmlDecl = "", x.cdata = "") : (x.sgmlDecl + Z).toUpperCase() === U ? (x.state = Y.DOCTYPE, (x.doctype || x.sawRoot) && Ne(
                x,
                "Inappropriately located doctype declaration"
              ), x.doctype = "", x.sgmlDecl = "") : Z === ">" ? (fe(x, "onsgmldeclaration", x.sgmlDecl), x.sgmlDecl = "", x.state = Y.TEXT) : (we(Z) && (x.state = Y.SGML_DECL_QUOTED), x.sgmlDecl += Z);
              continue;
            case Y.SGML_DECL_QUOTED:
              Z === x.q && (x.state = Y.SGML_DECL, x.q = ""), x.sgmlDecl += Z;
              continue;
            case Y.DOCTYPE:
              Z === ">" ? (x.state = Y.TEXT, fe(x, "ondoctype", x.doctype), x.doctype = !0) : (x.doctype += Z, Z === "[" ? x.state = Y.DOCTYPE_DTD : we(Z) && (x.state = Y.DOCTYPE_QUOTED, x.q = Z));
              continue;
            case Y.DOCTYPE_QUOTED:
              x.doctype += Z, Z === x.q && (x.q = "", x.state = Y.DOCTYPE);
              continue;
            case Y.DOCTYPE_DTD:
              Z === "]" ? (x.doctype += Z, x.state = Y.DOCTYPE) : Z === "<" ? (x.state = Y.OPEN_WAKA, x.startTagPosition = x.position) : we(Z) ? (x.doctype += Z, x.state = Y.DOCTYPE_DTD_QUOTED, x.q = Z) : x.doctype += Z;
              continue;
            case Y.DOCTYPE_DTD_QUOTED:
              x.doctype += Z, Z === x.q && (x.state = Y.DOCTYPE_DTD, x.q = "");
              continue;
            case Y.COMMENT:
              Z === "-" ? x.state = Y.COMMENT_ENDING : x.comment += Z;
              continue;
            case Y.COMMENT_ENDING:
              Z === "-" ? (x.state = Y.COMMENT_ENDED, x.comment = Pe(x.opt, x.comment), x.comment && fe(x, "oncomment", x.comment), x.comment = "") : (x.comment += "-" + Z, x.state = Y.COMMENT);
              continue;
            case Y.COMMENT_ENDED:
              Z !== ">" ? (Ne(x, "Malformed comment"), x.comment += "--" + Z, x.state = Y.COMMENT) : x.doctype && x.doctype !== !0 ? x.state = Y.DOCTYPE_DTD : x.state = Y.TEXT;
              continue;
            case Y.CDATA:
              Z === "]" ? x.state = Y.CDATA_ENDING : x.cdata += Z;
              continue;
            case Y.CDATA_ENDING:
              Z === "]" ? x.state = Y.CDATA_ENDING_2 : (x.cdata += "]" + Z, x.state = Y.CDATA);
              continue;
            case Y.CDATA_ENDING_2:
              Z === ">" ? (x.cdata && fe(x, "oncdata", x.cdata), fe(x, "onclosecdata"), x.cdata = "", x.state = Y.TEXT) : Z === "]" ? x.cdata += "]" : (x.cdata += "]]" + Z, x.state = Y.CDATA);
              continue;
            case Y.PROC_INST:
              Z === "?" ? x.state = Y.PROC_INST_ENDING : K(Z) ? x.state = Y.PROC_INST_BODY : x.procInstName += Z;
              continue;
            case Y.PROC_INST_BODY:
              if (!x.procInstBody && K(Z))
                continue;
              Z === "?" ? x.state = Y.PROC_INST_ENDING : x.procInstBody += Z;
              continue;
            case Y.PROC_INST_ENDING:
              Z === ">" ? (fe(x, "onprocessinginstruction", {
                name: x.procInstName,
                body: x.procInstBody
              }), x.procInstName = x.procInstBody = "", x.state = Y.TEXT) : (x.procInstBody += "?" + Z, x.state = Y.PROC_INST_BODY);
              continue;
            case Y.OPEN_TAG:
              ge(X, Z) ? x.tagName += Z : (Fe(x), Z === ">" ? Qe(x) : Z === "/" ? x.state = Y.OPEN_TAG_SLASH : (K(Z) || Ne(x, "Invalid character in tag name"), x.state = Y.ATTRIB));
              continue;
            case Y.OPEN_TAG_SLASH:
              Z === ">" ? (Qe(x, !0), $t(x)) : (Ne(x, "Forward-slash in opening tag not followed by >"), x.state = Y.ATTRIB);
              continue;
            case Y.ATTRIB:
              if (K(Z))
                continue;
              Z === ">" ? Qe(x) : Z === "/" ? x.state = Y.OPEN_TAG_SLASH : ge(B, Z) ? (x.attribName = Z, x.attribValue = "", x.state = Y.ATTRIB_NAME) : Ne(x, "Invalid attribute name");
              continue;
            case Y.ATTRIB_NAME:
              Z === "=" ? x.state = Y.ATTRIB_VALUE : Z === ">" ? (Ne(x, "Attribute without value"), x.attribValue = x.attribName, Me(x), Qe(x)) : K(Z) ? x.state = Y.ATTRIB_NAME_SAW_WHITE : ge(X, Z) ? x.attribName += Z : Ne(x, "Invalid attribute name");
              continue;
            case Y.ATTRIB_NAME_SAW_WHITE:
              if (Z === "=")
                x.state = Y.ATTRIB_VALUE;
              else {
                if (K(Z))
                  continue;
                Ne(x, "Attribute without value"), x.tag.attributes[x.attribName] = "", x.attribValue = "", fe(x, "onattribute", {
                  name: x.attribName,
                  value: ""
                }), x.attribName = "", Z === ">" ? Qe(x) : ge(B, Z) ? (x.attribName = Z, x.state = Y.ATTRIB_NAME) : (Ne(x, "Invalid attribute name"), x.state = Y.ATTRIB);
              }
              continue;
            case Y.ATTRIB_VALUE:
              if (K(Z))
                continue;
              we(Z) ? (x.q = Z, x.state = Y.ATTRIB_VALUE_QUOTED) : (x.opt.unquotedAttributeValues || De(x, "Unquoted attribute value"), x.state = Y.ATTRIB_VALUE_UNQUOTED, x.attribValue = Z);
              continue;
            case Y.ATTRIB_VALUE_QUOTED:
              if (Z !== x.q) {
                Z === "&" ? x.state = Y.ATTRIB_VALUE_ENTITY_Q : x.attribValue += Z;
                continue;
              }
              Me(x), x.q = "", x.state = Y.ATTRIB_VALUE_CLOSED;
              continue;
            case Y.ATTRIB_VALUE_CLOSED:
              K(Z) ? x.state = Y.ATTRIB : Z === ">" ? Qe(x) : Z === "/" ? x.state = Y.OPEN_TAG_SLASH : ge(B, Z) ? (Ne(x, "No whitespace between attributes"), x.attribName = Z, x.attribValue = "", x.state = Y.ATTRIB_NAME) : Ne(x, "Invalid attribute name");
              continue;
            case Y.ATTRIB_VALUE_UNQUOTED:
              if (!de(Z)) {
                Z === "&" ? x.state = Y.ATTRIB_VALUE_ENTITY_U : x.attribValue += Z;
                continue;
              }
              Me(x), Z === ">" ? Qe(x) : x.state = Y.ATTRIB;
              continue;
            case Y.CLOSE_TAG:
              if (x.tagName)
                Z === ">" ? $t(x) : ge(X, Z) ? x.tagName += Z : x.script ? (x.script += "</" + x.tagName, x.tagName = "", x.state = Y.SCRIPT) : (K(Z) || Ne(x, "Invalid tagname in closing tag"), x.state = Y.CLOSE_TAG_SAW_WHITE);
              else {
                if (K(Z))
                  continue;
                Ue(B, Z) ? x.script ? (x.script += "</" + Z, x.state = Y.SCRIPT) : Ne(x, "Invalid tagname in closing tag.") : x.tagName = Z;
              }
              continue;
            case Y.CLOSE_TAG_SAW_WHITE:
              if (K(Z))
                continue;
              Z === ">" ? $t(x) : Ne(x, "Invalid characters in closing tag");
              continue;
            case Y.TEXT_ENTITY:
            case Y.ATTRIB_VALUE_ENTITY_Q:
            case Y.ATTRIB_VALUE_ENTITY_U:
              var H, ue;
              switch (x.state) {
                case Y.TEXT_ENTITY:
                  H = Y.TEXT, ue = "textNode";
                  break;
                case Y.ATTRIB_VALUE_ENTITY_Q:
                  H = Y.ATTRIB_VALUE_QUOTED, ue = "attribValue";
                  break;
                case Y.ATTRIB_VALUE_ENTITY_U:
                  H = Y.ATTRIB_VALUE_UNQUOTED, ue = "attribValue";
                  break;
              }
              if (Z === ";") {
                var he = it(x);
                x.opt.unparsedEntities && !Object.values(r.XML_ENTITIES).includes(he) ? (x.entity = "", x.state = H, x.write(he)) : (x[ue] += he, x.entity = "", x.state = H);
              } else ge(x.entity.length ? E : F, Z) ? x.entity += Z : (Ne(x, "Invalid character in entity name"), x[ue] += "&" + x.entity + Z, x.entity = "", x.state = H);
              continue;
            default:
              throw new Error(x, "Unknown state: " + x.state);
          }
        return x.position >= x.bufferCheckPosition && c(x), x;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var L = String.fromCharCode, x = Math.floor, G = function() {
          var Z = 16384, st = [], S, H, ue = -1, he = arguments.length;
          if (!he)
            return "";
          for (var be = ""; ++ue < he; ) {
            var ve = Number(arguments[ue]);
            if (!isFinite(ve) || // `NaN`, `+Infinity`, or `-Infinity`
            ve < 0 || // not a valid Unicode code point
            ve > 1114111 || // not a valid Unicode code point
            x(ve) !== ve)
              throw RangeError("Invalid code point: " + ve);
            ve <= 65535 ? st.push(ve) : (ve -= 65536, S = (ve >> 10) + 55296, H = ve % 1024 + 56320, st.push(S, H)), (ue + 1 === he || st.length > Z) && (be += L.apply(null, st), st.length = 0);
          }
          return be;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: G,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = G;
      }();
    })(t);
  }(Zl)), Zl;
}
Np();
const Le = "sclElements", Et = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
var js = { exports: {} }, xp = js.exports, nu;
function Rp() {
  return nu || (nu = 1, function(t, r) {
    (function(i, s) {
      t.exports = s();
    })(xp, function() {
      var i = function(e, n) {
        return (i = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, a) {
          o.__proto__ = a;
        } || function(o, a) {
          for (var l in a) Object.prototype.hasOwnProperty.call(a, l) && (o[l] = a[l]);
        })(e, n);
      }, s = function() {
        return (s = Object.assign || function(e) {
          for (var n, o = 1, a = arguments.length; o < a; o++) for (var l in n = arguments[o]) Object.prototype.hasOwnProperty.call(n, l) && (e[l] = n[l]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, n, o) {
        for (var a, l = 0, d = n.length; l < d; l++) !a && l in n || ((a = a || Array.prototype.slice.call(n, 0, l))[l] = n[l]);
        return e.concat(a || Array.prototype.slice.call(n));
      }
      var f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : yp, u = Object.keys, p = Array.isArray;
      function v(e, n) {
        return typeof n != "object" || u(n).forEach(function(o) {
          e[o] = n[o];
        }), e;
      }
      typeof Promise > "u" || f.Promise || (f.Promise = Promise);
      var k = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function $(e, n) {
        return D.call(e, n);
      }
      function U(e, n) {
        typeof n == "function" && (n = n(k(e))), (typeof Reflect > "u" ? u : Reflect.ownKeys)(n).forEach(function(o) {
          A(e, o, n[o]);
        });
      }
      var W = Object.defineProperty;
      function A(e, n, o, a) {
        W(e, n, v(o && $(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, a));
      }
      function P(e) {
        return { from: function(n) {
          return e.prototype = Object.create(n.prototype), A(e.prototype, "constructor", e), { extend: U.bind(null, e.prototype) };
        } };
      }
      var B = Object.getOwnPropertyDescriptor, X = [].slice;
      function F(e, n, o) {
        return X.call(e, n, o);
      }
      function E(e, n) {
        return n(e);
      }
      function K(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function we(e) {
        f.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function de(e, n) {
        if (typeof n == "string" && $(e, n)) return e[n];
        if (!n) return e;
        if (typeof n != "string") {
          for (var o = [], a = 0, l = n.length; a < l; ++a) {
            var d = de(e, n[a]);
            o.push(d);
          }
          return o;
        }
        var m = n.indexOf(".");
        if (m !== -1) {
          var y = e[n.substr(0, m)];
          return y == null ? void 0 : de(y, n.substr(m + 1));
        }
      }
      function ge(e, n, o) {
        if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof n != "string" && "length" in n) {
          K(typeof o != "string" && "length" in o);
          for (var a = 0, l = n.length; a < l; ++a) ge(e, n[a], o[a]);
        } else {
          var d, m, y = n.indexOf(".");
          y !== -1 ? (d = n.substr(0, y), (m = n.substr(y + 1)) === "" ? o === void 0 ? p(e) && !isNaN(parseInt(d)) ? e.splice(d, 1) : delete e[d] : e[d] = o : ge(y = !(y = e[d]) || !$(e, d) ? e[d] = {} : y, m, o)) : o === void 0 ? p(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = o;
        }
      }
      function Ue(e) {
        var n, o = {};
        for (n in e) $(e, n) && (o[n] = e[n]);
        return o;
      }
      var Y = [].concat;
      function oe(e) {
        return Y.apply([], e);
      }
      var Je = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(oe([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(n) {
          return n + e + "Array";
        });
      }))).filter(function(e) {
        return f[e];
      }), ce = new Set(Je.map(function(e) {
        return f[e];
      })), fe = null;
      function me(e) {
        return fe = /* @__PURE__ */ new WeakMap(), e = function n(o) {
          if (!o || typeof o != "object") return o;
          var a = fe.get(o);
          if (a) return a;
          if (p(o)) {
            a = [], fe.set(o, a);
            for (var l = 0, d = o.length; l < d; ++l) a.push(n(o[l]));
          } else if (ce.has(o.constructor)) a = o;
          else {
            var m, y = k(o);
            for (m in a = y === Object.prototype ? {} : Object.create(y), fe.set(o, a), o) $(o, m) && (a[m] = n(o[m]));
          }
          return a;
        }(e), fe = null, e;
      }
      var Pe = {}.toString;
      function De(e) {
        return Pe.call(e).slice(8, -1);
      }
      var Se = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ne = typeof Se == "symbol" ? function(e) {
        var n;
        return e != null && (n = e[Se]) && n.apply(e);
      } : function() {
        return null;
      };
      function Fe(e, n) {
        return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n;
      }
      var pt = {};
      function Me(e) {
        var n, o, a, l;
        if (arguments.length === 1) {
          if (p(e)) return e.slice();
          if (this === pt && typeof e == "string") return [e];
          if (l = Ne(e)) {
            for (o = []; !(a = l.next()).done; ) o.push(a.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (n = e.length) != "number") return [e];
          for (o = new Array(n); n--; ) o[n] = e[n];
          return o;
        }
        for (n = arguments.length, o = new Array(n); n--; ) o[n] = arguments[n];
        return o;
      }
      var Qe = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Ge = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Dt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Ge), $t = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function it(e, n) {
        this.name = e, this.message = n;
      }
      function Ht(e, n) {
        return e + ". Errors: " + Object.keys(n).map(function(o) {
          return n[o].toString();
        }).filter(function(o, a, l) {
          return l.indexOf(o) === a;
        }).join(`
`);
      }
      function bn(e, n, o, a) {
        this.failures = n, this.failedKeys = a, this.successCount = o, this.message = Ht(e, n);
      }
      function Mt(e, n) {
        this.name = "BulkError", this.failures = Object.keys(n).map(function(o) {
          return n[o];
        }), this.failuresByPos = n, this.message = Ht(e, this.failures);
      }
      P(it).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), P(bn).from(it), P(Mt).from(it);
      var L = Dt.reduce(function(e, n) {
        return e[n] = n + "Error", e;
      }, {}), x = it, G = Dt.reduce(function(e, n) {
        var o = n + "Error";
        function a(l, d) {
          this.name = o, l ? typeof l == "string" ? (this.message = "".concat(l).concat(d ? `
 ` + d : ""), this.inner = d || null) : typeof l == "object" && (this.message = "".concat(l.name, " ").concat(l.message), this.inner = l) : (this.message = $t[n] || o, this.inner = null);
        }
        return P(a).from(x), e[n] = a, e;
      }, {});
      G.Syntax = SyntaxError, G.Type = TypeError, G.Range = RangeError;
      var Z = Ge.reduce(function(e, n) {
        return e[n + "Error"] = G[n], e;
      }, {}), st = Dt.reduce(function(e, n) {
        return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = G[n]), e;
      }, {});
      function S() {
      }
      function H(e) {
        return e;
      }
      function ue(e, n) {
        return e == null || e === H ? n : function(o) {
          return n(e(o));
        };
      }
      function he(e, n) {
        return function() {
          e.apply(this, arguments), n.apply(this, arguments);
        };
      }
      function be(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var a = this.onsuccess, l = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var d = n.apply(this, arguments);
          return a && (this.onsuccess = this.onsuccess ? he(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? he(l, this.onerror) : l), d !== void 0 ? d : o;
        };
      }
      function ve(e, n) {
        return e === S ? n : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, a = this.onerror;
          this.onsuccess = this.onerror = null, n.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? he(o, this.onsuccess) : o), a && (this.onerror = this.onerror ? he(a, this.onerror) : a);
        };
      }
      function Oe(e, n) {
        return e === S ? n : function(o) {
          var a = e.apply(this, arguments);
          v(o, a);
          var l = this.onsuccess, d = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = n.apply(this, arguments), l && (this.onsuccess = this.onsuccess ? he(l, this.onsuccess) : l), d && (this.onerror = this.onerror ? he(d, this.onerror) : d), a === void 0 ? o === void 0 ? void 0 : o : v(a, o);
        };
      }
      function Ie(e, n) {
        return e === S ? n : function() {
          return n.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function xe(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var a = this, l = arguments.length, d = new Array(l); l--; ) d[l] = arguments[l];
            return o.then(function() {
              return n.apply(a, d);
            });
          }
          return n.apply(this, arguments);
        };
      }
      st.ModifyError = bn, st.DexieError = it, st.BulkError = Mt;
      var ye = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function qe(e) {
        ye = e;
      }
      var Ae = {}, Ve = 100, Je = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, k(e), e];
        var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [n, k(n), e];
      }(), Ge = Je[0], Dt = Je[1], Je = Je[2], Dt = Dt && Dt.then, at = Ge && Ge.constructor, ut = !!Je, Rt = function(e, n) {
        wn.push([e, n]), Ut && (queueMicrotask(Ma), Ut = !1);
      }, Ft = !0, Ut = !0, Ct = [], sn = [], Gn = H, gt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: S, pgp: !1, env: {}, finalize: S }, pe = gt, wn = [], ln = 0, er = [];
      function se(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var n = this._PSD = pe;
        if (typeof e != "function") {
          if (e !== Ae) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Hr(this, this._value));
        }
        this._state = null, this._value = null, ++n.ref, function o(a, l) {
          try {
            l(function(d) {
              if (a._state === null) {
                if (d === a) throw new TypeError("A promise cannot be resolved with itself.");
                var m = a._lib && _n();
                d && typeof d.then == "function" ? o(a, function(y, b) {
                  d instanceof se ? d._then(y, b) : d.then(y, b);
                }) : (a._state = !0, a._value = d, Ho(a)), m && Nn();
              }
            }, Hr.bind(null, a));
          } catch (d) {
            Hr(a, d);
          }
        }(this, e);
      }
      var Gr = { get: function() {
        var e = pe, n = or;
        function o(a, l) {
          var d = this, m = !e.global && (e !== pe || n !== or), y = m && !Qt(), b = new se(function(_, R) {
            Yr(d, new Go(zo(a, e, m, y), zo(l, e, m, y), _, R, e));
          });
          return this._consoleTask && (b._consoleTask = this._consoleTask), b;
        }
        return o.prototype = Ae, o;
      }, set: function(e) {
        A(this, "then", e && e.prototype === Ae ? Gr : { get: function() {
          return e;
        }, set: Gr.set });
      } };
      function Go(e, n, o, a, l) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = o, this.reject = a, this.psd = l;
      }
      function Hr(e, n) {
        var o, a;
        sn.push(n), e._state === null && (o = e._lib && _n(), n = Gn(n), e._state = !1, e._value = n, a = e, Ct.some(function(l) {
          return l._value === a._value;
        }) || Ct.push(a), Ho(e), o && Nn());
      }
      function Ho(e) {
        var n = e._listeners;
        e._listeners = [];
        for (var o = 0, a = n.length; o < a; ++o) Yr(e, n[o]);
        var l = e._PSD;
        --l.ref || l.finalize(), ln === 0 && (++ln, Rt(function() {
          --ln == 0 && zr();
        }, []));
      }
      function Yr(e, n) {
        if (e._state !== null) {
          var o = e._state ? n.onFulfilled : n.onRejected;
          if (o === null) return (e._state ? n.resolve : n.reject)(e._value);
          ++n.psd.ref, ++ln, Rt(Fa, [o, e, n]);
        } else e._listeners.push(n);
      }
      function Fa(e, n, o) {
        try {
          var a, l = n._value;
          !n._state && sn.length && (sn = []), a = ye && n._consoleTask ? n._consoleTask.run(function() {
            return e(l);
          }) : e(l), n._state || sn.indexOf(l) !== -1 || function(d) {
            for (var m = Ct.length; m; ) if (Ct[--m]._value === d._value) return Ct.splice(m, 1);
          }(n), o.resolve(a);
        } catch (d) {
          o.reject(d);
        } finally {
          --ln == 0 && zr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function Ma() {
        un(gt, function() {
          _n() && Nn();
        });
      }
      function _n() {
        var e = Ft;
        return Ut = Ft = !1, e;
      }
      function Nn() {
        var e, n, o;
        do
          for (; 0 < wn.length; ) for (e = wn, wn = [], o = e.length, n = 0; n < o; ++n) {
            var a = e[n];
            a[0].apply(null, a[1]);
          }
        while (0 < wn.length);
        Ut = Ft = !0;
      }
      function zr() {
        var e = Ct;
        Ct = [], e.forEach(function(a) {
          a._PSD.onunhandled.call(null, a._value, a);
        });
        for (var n = er.slice(0), o = n.length; o; ) n[--o]();
      }
      function tr(e) {
        return new se(Ae, !1, e);
      }
      function Ze(e, n) {
        var o = pe;
        return function() {
          var a = _n(), l = pe;
          try {
            return Jt(o, !0), e.apply(this, arguments);
          } catch (d) {
            n && n(d);
          } finally {
            Jt(l, !1), a && Nn();
          }
        };
      }
      U(se.prototype, { then: Gr, _then: function(e, n) {
        Yr(this, new Go(null, null, e, n, pe));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var n = e, o = arguments[1];
        return typeof n == "function" ? this.then(null, function(a) {
          return (a instanceof n ? o : tr)(a);
        }) : this.then(null, function(a) {
          return (a && a.name === n ? o : tr)(a);
        });
      }, finally: function(e) {
        return this.then(function(n) {
          return se.resolve(e()).then(function() {
            return n;
          });
        }, function(n) {
          return se.resolve(e()).then(function() {
            return tr(n);
          });
        });
      }, timeout: function(e, n) {
        var o = this;
        return e < 1 / 0 ? new se(function(a, l) {
          var d = setTimeout(function() {
            return l(new G.Timeout(n));
          }, e);
          o.then(a, l).finally(clearTimeout.bind(null, d));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && A(se.prototype, Symbol.toStringTag, "Dexie.Promise"), gt.env = Yo(), U(se, { all: function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n, o) {
          e.length === 0 && n([]);
          var a = e.length;
          e.forEach(function(l, d) {
            return se.resolve(l).then(function(m) {
              e[d] = m, --a || n(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof se ? e : e && typeof e.then == "function" ? new se(function(n, o) {
          e.then(n, o);
        }) : new se(Ae, !0, e);
      }, reject: tr, race: function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n, o) {
          e.map(function(a) {
            return se.resolve(a).then(n, o);
          });
        });
      }, PSD: { get: function() {
        return pe;
      }, set: function(e) {
        return pe = e;
      } }, totalEchoes: { get: function() {
        return or;
      } }, newPSD: Xt, usePSD: un, scheduler: { get: function() {
        return Rt;
      }, set: function(e) {
        Rt = e;
      } }, rejectionMapper: { get: function() {
        return Gn;
      }, set: function(e) {
        Gn = e;
      } }, follow: function(e, n) {
        return new se(function(o, a) {
          return Xt(function(l, d) {
            var m = pe;
            m.unhandleds = [], m.onunhandled = d, m.finalize = he(function() {
              var y, b = this;
              y = function() {
                b.unhandleds.length === 0 ? l() : d(b.unhandleds[0]);
              }, er.push(function _() {
                y(), er.splice(er.indexOf(_), 1);
              }), ++ln, Rt(function() {
                --ln == 0 && zr();
              }, []);
            }, m.finalize), e();
          }, n, o, a);
        });
      } }), at && (at.allSettled && A(se, "allSettled", function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n) {
          e.length === 0 && n([]);
          var o = e.length, a = new Array(o);
          e.forEach(function(l, d) {
            return se.resolve(l).then(function(m) {
              return a[d] = { status: "fulfilled", value: m };
            }, function(m) {
              return a[d] = { status: "rejected", reason: m };
            }).then(function() {
              return --o || n(a);
            });
          });
        });
      }), at.any && typeof AggregateError < "u" && A(se, "any", function() {
        var e = Me.apply(null, arguments).map(ir);
        return new se(function(n, o) {
          e.length === 0 && o(new AggregateError([]));
          var a = e.length, l = new Array(a);
          e.forEach(function(d, m) {
            return se.resolve(d).then(function(y) {
              return n(y);
            }, function(y) {
              l[m] = y, --a || o(new AggregateError(l));
            });
          });
        });
      }), at.withResolvers && (se.withResolvers = at.withResolvers));
      var ct = { awaits: 0, echoes: 0, id: 0 }, Ba = 0, nr = [], rr = 0, or = 0, Ka = 0;
      function Xt(e, n, o, a) {
        var l = pe, d = Object.create(l);
        return d.parent = l, d.ref = 0, d.global = !1, d.id = ++Ka, gt.env, d.env = ut ? { Promise: se, PromiseProp: { value: se, configurable: !0, writable: !0 }, all: se.all, race: se.race, allSettled: se.allSettled, any: se.any, resolve: se.resolve, reject: se.reject } : {}, n && v(d, n), ++l.ref, d.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, a = un(d, e, o, a), d.ref === 0 && d.finalize(), a;
      }
      function xn() {
        return ct.id || (ct.id = ++Ba), ++ct.awaits, ct.echoes += Ve, ct.id;
      }
      function Qt() {
        return !!ct.awaits && (--ct.awaits == 0 && (ct.id = 0), ct.echoes = ct.awaits * Ve, !0);
      }
      function ir(e) {
        return ct.echoes && e && e.constructor === at ? (xn(), e.then(function(n) {
          return Qt(), n;
        }, function(n) {
          return Qt(), rt(n);
        })) : e;
      }
      function qa() {
        var e = nr[nr.length - 1];
        nr.pop(), Jt(e, !1);
      }
      function Jt(e, n) {
        var o, a = pe;
        (n ? !ct.echoes || rr++ && e === pe : !rr || --rr && e === pe) || queueMicrotask(n ? (function(l) {
          ++or, ct.echoes && --ct.echoes != 0 || (ct.echoes = ct.awaits = ct.id = 0), nr.push(pe), Jt(l, !0);
        }).bind(null, e) : qa), e !== pe && (pe = e, a === gt && (gt.env = Yo()), ut && (o = gt.env.Promise, n = e.env, (a.global || e.global) && (Object.defineProperty(f, "Promise", n.PromiseProp), o.all = n.all, o.race = n.race, o.resolve = n.resolve, o.reject = n.reject, n.allSettled && (o.allSettled = n.allSettled), n.any && (o.any = n.any))));
      }
      function Yo() {
        var e = f.Promise;
        return ut ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function un(e, n, o, a, l) {
        var d = pe;
        try {
          return Jt(e, !0), n(o, a, l);
        } finally {
          Jt(d, !1);
        }
      }
      function zo(e, n, o, a) {
        return typeof e != "function" ? e : function() {
          var l = pe;
          o && xn(), Jt(n, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Jt(l, !1), a && queueMicrotask(Qt);
          }
        };
      }
      function Xr(e) {
        Promise === at && ct.echoes === 0 ? rr === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + Dt).indexOf("[native code]") === -1 && (xn = Qt = S);
      var rt = se.reject, cn = "￿", Vt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Xo = "String expected.", Rn = [], ar = "__dbnames", Qr = "readonly", Jr = "readwrite";
      function dn(e, n) {
        return e ? n ? function() {
          return e.apply(this, arguments) && n.apply(this, arguments);
        } : e : n;
      }
      var Qo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function sr(e) {
        return typeof e != "string" || /\./.test(e) ? function(n) {
          return n;
        } : function(n) {
          return n[e] === void 0 && e in n && delete (n = me(n))[e], n;
        };
      }
      function Jo() {
        throw G.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function ke(e, n) {
        try {
          var o = Zo(e), a = Zo(n);
          if (o !== a) return o === "Array" ? 1 : a === "Array" ? -1 : o === "binary" ? 1 : a === "binary" ? -1 : o === "string" ? 1 : a === "string" ? -1 : o === "Date" ? 1 : a !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return n < e ? 1 : e < n ? -1 : 0;
            case "binary":
              return function(l, d) {
                for (var m = l.length, y = d.length, b = m < y ? m : y, _ = 0; _ < b; ++_) if (l[_] !== d[_]) return l[_] < d[_] ? -1 : 1;
                return m === y ? 0 : m < y ? -1 : 1;
              }(ei(e), ei(n));
            case "Array":
              return function(l, d) {
                for (var m = l.length, y = d.length, b = m < y ? m : y, _ = 0; _ < b; ++_) {
                  var R = ke(l[_], d[_]);
                  if (R !== 0) return R;
                }
                return m === y ? 0 : m < y ? -1 : 1;
              }(e, n);
          }
        } catch {
        }
        return NaN;
      }
      function Zo(e) {
        var n = typeof e;
        return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = De(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function ei(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function lr(e, n, o) {
        var a = e.schema.yProps;
        return a ? (n && 0 < o.numFailures && (n = n.filter(function(l, d) {
          return !o.failures[d];
        })), Promise.all(a.map(function(l) {
          return l = l.updatesTable, n ? e.db.table(l).where("k").anyOf(n).delete() : e.db.table(l).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var ti = (ze.prototype._trans = function(e, n, o) {
        var a = this._tx || pe.trans, l = this.name, d = ye && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function m(_, R, g) {
          if (!g.schema[l]) throw new G.NotFound("Table " + l + " not part of transaction");
          return n(g.idbtrans, g);
        }
        var y = _n();
        try {
          var b = a && a.db._novip === this.db._novip ? a === pe.trans ? a._promise(e, m, o) : Xt(function() {
            return a._promise(e, m, o);
          }, { trans: a, transless: pe.transless || pe }) : function _(R, g, T, w) {
            if (R.idbdb && (R._state.openComplete || pe.letThrough || R._vip)) {
              var N = R._createTransaction(g, T, R._dbSchema);
              try {
                N.create(), R._state.PR1398_maxLoop = 3;
              } catch (O) {
                return O.name === L.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                  return _(R, g, T, w);
                })) : rt(O);
              }
              return N._promise(g, function(O, C) {
                return Xt(function() {
                  return pe.trans = N, w(O, C, N);
                });
              }).then(function(O) {
                if (g === "readwrite") try {
                  N.idbtrans.commit();
                } catch {
                }
                return g === "readonly" ? O : N._completion.then(function() {
                  return O;
                });
              });
            }
            if (R._state.openComplete) return rt(new G.DatabaseClosed(R._state.dbOpenError));
            if (!R._state.isBeingOpened) {
              if (!R._state.autoOpen) return rt(new G.DatabaseClosed());
              R.open().catch(S);
            }
            return R._state.dbReadyPromise.then(function() {
              return _(R, g, T, w);
            });
          }(this.db, e, [this.name], m);
          return d && (b._consoleTask = d, b = b.catch(function(_) {
            return console.trace(_), rt(_);
          })), b;
        } finally {
          y && Nn();
        }
      }, ze.prototype.get = function(e, n) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(n) : e == null ? rt(new G.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(a) {
          return o.core.get({ trans: a, key: e }).then(function(l) {
            return o.hook.reading.fire(l);
          });
        }).then(n);
      }, ze.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (p(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var n = u(e);
        if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(y) {
          if (y.compound && n.every(function(_) {
            return 0 <= y.keyPath.indexOf(_);
          })) {
            for (var b = 0; b < n.length; ++b) if (n.indexOf(y.keyPath[b]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(y, b) {
          return y.keyPath.length - b.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== cn) {
          var d = o.keyPath.slice(0, n.length);
          return this.where(d).equals(d.map(function(b) {
            return e[b];
          }));
        }
        !o && ye && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
        var a = this.schema.idxByName;
        function l(y, b) {
          return ke(y, b) === 0;
        }
        var m = n.reduce(function(g, b) {
          var _ = g[0], R = g[1], g = a[b], T = e[b];
          return [_ || g, _ || !g ? dn(R, g && g.multi ? function(w) {
            return w = de(w, b), p(w) && w.some(function(N) {
              return l(T, N);
            });
          } : function(w) {
            return l(T, de(w, b));
          }) : R];
        }, [null, null]), d = m[0], m = m[1];
        return d ? this.where(d.name).equals(e[d.keyPath]).filter(m) : o ? this.filter(m) : this.where(n).equals("");
      }, ze.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, ze.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, ze.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, ze.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, ze.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, ze.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, ze.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, ze.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, p(e) ? "[".concat(e.join("+"), "]") : e));
      }, ze.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, ze.prototype.mapToClass = function(e) {
        var n, o = this.db, a = this.name;
        function l() {
          return n !== null && n.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Jo && (function(b, _) {
          if (typeof _ != "function" && _ !== null) throw new TypeError("Class extends value " + String(_) + " is not a constructor or null");
          function R() {
            this.constructor = b;
          }
          i(b, _), b.prototype = _ === null ? Object.create(_) : (R.prototype = _.prototype, new R());
        }(l, n = e), Object.defineProperty(l.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), l.prototype.table = function() {
          return a;
        }, e = l);
        for (var d = /* @__PURE__ */ new Set(), m = e.prototype; m; m = k(m)) Object.getOwnPropertyNames(m).forEach(function(b) {
          return d.add(b);
        });
        function y(b) {
          if (!b) return b;
          var _, R = Object.create(e.prototype);
          for (_ in b) if (!d.has(_)) try {
            R[_] = b[_];
          } catch {
          }
          return R;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = y, this.hook("reading", y), e;
      }, ze.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          v(this, e);
        });
      }, ze.prototype.add = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, d = a.keyPath, m = e;
        return d && l && (m = sr(d)(e)), this._trans("readwrite", function(y) {
          return o.core.mutate({ trans: y, type: "add", keys: n != null ? [n] : null, values: [m] });
        }).then(function(y) {
          return y.numFailures ? se.reject(y.failures[0]) : y.lastResult;
        }).then(function(y) {
          if (d) try {
            ge(e, d, y);
          } catch {
          }
          return y;
        });
      }, ze.prototype.update = function(e, n) {
        return typeof e != "object" || p(e) ? this.where(":id").equals(e).modify(n) : (e = de(e, this.schema.primKey.keyPath), e === void 0 ? rt(new G.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n));
      }, ze.prototype.put = function(e, n) {
        var o = this, a = this.schema.primKey, l = a.auto, d = a.keyPath, m = e;
        return d && l && (m = sr(d)(e)), this._trans("readwrite", function(y) {
          return o.core.mutate({ trans: y, type: "put", values: [m], keys: n != null ? [n] : null });
        }).then(function(y) {
          return y.numFailures ? se.reject(y.failures[0]) : y.lastResult;
        }).then(function(y) {
          if (d) try {
            ge(e, d, y);
          } catch {
          }
          return y;
        });
      }, ze.prototype.delete = function(e) {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(a) {
            return lr(n, [e], a);
          }).then(function(a) {
            return a.numFailures ? se.reject(a.failures[0]) : void 0;
          });
        });
      }, ze.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(n) {
          return e.core.mutate({ trans: n, type: "deleteRange", range: Qo }).then(function(o) {
            return lr(e, null, o);
          });
        }).then(function(n) {
          return n.numFailures ? se.reject(n.failures[0]) : void 0;
        });
      }, ze.prototype.bulkGet = function(e) {
        var n = this;
        return this._trans("readonly", function(o) {
          return n.core.getMany({ keys: e, trans: o }).then(function(a) {
            return a.map(function(l) {
              return n.hook.reading.fire(l);
            });
          });
        });
      }, ze.prototype.bulkAdd = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, d = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var _ = a.schema.primKey, y = _.auto, _ = _.keyPath;
          if (_ && l) throw new G.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new G.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && y ? e.map(sr(_)) : e;
          return a.core.mutate({ trans: m, type: "add", keys: l, values: _, wantResults: d }).then(function(N) {
            var g = N.numFailures, T = N.results, w = N.lastResult, N = N.failures;
            if (g === 0) return d ? T : w;
            throw new Mt("".concat(a.name, ".bulkAdd(): ").concat(g, " of ").concat(b, " operations failed"), N);
          });
        });
      }, ze.prototype.bulkPut = function(e, n, o) {
        var a = this, l = Array.isArray(n) ? n : void 0, d = (o = o || (l ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(m) {
          var _ = a.schema.primKey, y = _.auto, _ = _.keyPath;
          if (_ && l) throw new G.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (l && l.length !== e.length) throw new G.InvalidArgument("Arguments objects and keys must have the same length");
          var b = e.length, _ = _ && y ? e.map(sr(_)) : e;
          return a.core.mutate({ trans: m, type: "put", keys: l, values: _, wantResults: d }).then(function(N) {
            var g = N.numFailures, T = N.results, w = N.lastResult, N = N.failures;
            if (g === 0) return d ? T : w;
            throw new Mt("".concat(a.name, ".bulkPut(): ").concat(g, " of ").concat(b, " operations failed"), N);
          });
        });
      }, ze.prototype.bulkUpdate = function(e) {
        var n = this, o = this.core, a = e.map(function(m) {
          return m.key;
        }), l = e.map(function(m) {
          return m.changes;
        }), d = [];
        return this._trans("readwrite", function(m) {
          return o.getMany({ trans: m, keys: a, cache: "clone" }).then(function(y) {
            var b = [], _ = [];
            e.forEach(function(g, T) {
              var w = g.key, N = g.changes, O = y[T];
              if (O) {
                for (var C = 0, I = Object.keys(N); C < I.length; C++) {
                  var j = I[C], M = N[j];
                  if (j === n.schema.primKey.keyPath) {
                    if (ke(M, w) !== 0) throw new G.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ge(O, j, M);
                }
                d.push(T), b.push(w), _.push(O);
              }
            });
            var R = b.length;
            return o.mutate({ trans: m, type: "put", keys: b, values: _, updates: { keys: a, changeSpecs: l } }).then(function(g) {
              var T = g.numFailures, w = g.failures;
              if (T === 0) return R;
              for (var N = 0, O = Object.keys(w); N < O.length; N++) {
                var C, I = O[N], j = d[Number(I)];
                j != null && (C = w[I], delete w[I], w[j] = C);
              }
              throw new Mt("".concat(n.name, ".bulkUpdate(): ").concat(T, " of ").concat(R, " operations failed"), w);
            });
          });
        });
      }, ze.prototype.bulkDelete = function(e) {
        var n = this, o = e.length;
        return this._trans("readwrite", function(a) {
          return n.core.mutate({ trans: a, type: "delete", keys: e }).then(function(l) {
            return lr(n, e, l);
          });
        }).then(function(m) {
          var l = m.numFailures, d = m.lastResult, m = m.failures;
          if (l === 0) return d;
          throw new Mt("".concat(n.name, ".bulkDelete(): ").concat(l, " of ").concat(o, " operations failed"), m);
        });
      }, ze);
      function ze() {
      }
      function kn(e) {
        function n(m, y) {
          if (y) {
            for (var b = arguments.length, _ = new Array(b - 1); --b; ) _[b - 1] = arguments[b];
            return o[m].subscribe.apply(null, _), e;
          }
          if (typeof m == "string") return o[m];
        }
        var o = {};
        n.addEventType = d;
        for (var a = 1, l = arguments.length; a < l; ++a) d(arguments[a]);
        return n;
        function d(m, y, b) {
          if (typeof m != "object") {
            var _;
            y = y || Ie;
            var R = { subscribers: [], fire: b = b || S, subscribe: function(g) {
              R.subscribers.indexOf(g) === -1 && (R.subscribers.push(g), R.fire = y(R.fire, g));
            }, unsubscribe: function(g) {
              R.subscribers = R.subscribers.filter(function(T) {
                return T !== g;
              }), R.fire = R.subscribers.reduce(y, b);
            } };
            return o[m] = n[m] = R;
          }
          u(_ = m).forEach(function(g) {
            var T = _[g];
            if (p(T)) d(g, _[g][0], _[g][1]);
            else {
              if (T !== "asap") throw new G.InvalidArgument("Invalid event config");
              var w = d(g, H, function() {
                for (var N = arguments.length, O = new Array(N); N--; ) O[N] = arguments[N];
                w.subscribers.forEach(function(C) {
                  we(function() {
                    C.apply(null, O);
                  });
                });
              });
            }
          });
        }
      }
      function jn(e, n) {
        return P(n).from({ prototype: e }), n;
      }
      function Cn(e, n) {
        return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter);
      }
      function Zr(e, n) {
        e.filter = dn(e.filter, n);
      }
      function eo(e, n, o) {
        var a = e.replayFilter;
        e.replayFilter = a ? function() {
          return dn(a(), n());
        } : n, e.justLimit = o && !a;
      }
      function ur(e, n) {
        if (e.isPrimKey) return n.primaryKey;
        var o = n.getIndexByKeyPath(e.index);
        if (!o) throw new G.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
        return o;
      }
      function ni(e, n, o) {
        var a = ur(e, n.schema);
        return n.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: a, range: e.range } });
      }
      function cr(e, n, o, a) {
        var l = e.replayFilter ? dn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var d = {}, m = function(y, b, _) {
            var R, g;
            l && !l(b, _, function(T) {
              return b.stop(T);
            }, function(T) {
              return b.fail(T);
            }) || ((g = "" + (R = b.primaryKey)) == "[object ArrayBuffer]" && (g = "" + new Uint8Array(R)), $(d, g) || (d[g] = !0, n(y, b, _)));
          };
          return Promise.all([e.or._iterate(m, o), ri(ni(e, a, o), e.algorithm, m, !e.keysOnly && e.valueMapper)]);
        }
        return ri(ni(e, a, o), dn(e.algorithm, l), n, !e.keysOnly && e.valueMapper);
      }
      function ri(e, n, o, a) {
        var l = Ze(a ? function(d, m, y) {
          return o(a(d), m, y);
        } : o);
        return e.then(function(d) {
          if (d) return d.start(function() {
            var m = function() {
              return d.continue();
            };
            n && !n(d, function(y) {
              return m = y;
            }, function(y) {
              d.stop(y), m = S;
            }, function(y) {
              d.fail(y), m = S;
            }) || l(d.value, d, function(y) {
              return m = y;
            }), m();
          });
        });
      }
      var $n = (oi.prototype.execute = function(e) {
        var n = this["@@propmod"];
        if (n.add !== void 0) {
          var o = n.add;
          if (p(o)) return c(c([], p(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (n.remove !== void 0) {
          var a = n.remove;
          if (p(a)) return p(e) ? e.filter(function(l) {
            return !a.includes(l);
          }).sort() : [];
          if (typeof a == "number") return Number(e) - a;
          if (typeof a == "bigint") try {
            return BigInt(e) - a;
          } catch {
            return BigInt(0) - a;
          }
          throw new TypeError("Invalid subtrahend ".concat(a));
        }
        return o = (o = n.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? n.replacePrefix[1] + e.substring(o.length) : e;
      }, oi);
      function oi(e) {
        this["@@propmod"] = e;
      }
      var Ua = (Be.prototype._read = function(e, n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, rt.bind(null, o.error)) : o.table._trans("readonly", e).then(n);
      }, Be.prototype._write = function(e) {
        var n = this._ctx;
        return n.error ? n.table._trans(null, rt.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
      }, Be.prototype._addAlgorithm = function(e) {
        var n = this._ctx;
        n.algorithm = dn(n.algorithm, e);
      }, Be.prototype._iterate = function(e, n) {
        return cr(this._ctx, e, n, this._ctx.table.core);
      }, Be.prototype.clone = function(e) {
        var n = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && v(o, e), n._ctx = o, n;
      }, Be.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Be.prototype.each = function(e) {
        var n = this._ctx;
        return this._read(function(o) {
          return cr(n, e, o, n.table.core);
        });
      }, Be.prototype.count = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx, l = a.table.core;
          if (Cn(a, !0)) return l.count({ trans: o, query: { index: ur(a, l.schema), range: a.range } }).then(function(m) {
            return Math.min(m, a.limit);
          });
          var d = 0;
          return cr(a, function() {
            return ++d, !1;
          }, o, l).then(function() {
            return d;
          });
        }).then(e);
      }, Be.prototype.sortBy = function(e, n) {
        var o = e.split(".").reverse(), a = o[0], l = o.length - 1;
        function d(b, _) {
          return _ ? d(b[o[_]], _ - 1) : b[a];
        }
        var m = this._ctx.dir === "next" ? 1 : -1;
        function y(b, _) {
          return ke(d(b, l), d(_, l)) * m;
        }
        return this.toArray(function(b) {
          return b.sort(y);
        }).then(n);
      }, Be.prototype.toArray = function(e) {
        var n = this;
        return this._read(function(o) {
          var a = n._ctx;
          if (a.dir === "next" && Cn(a, !0) && 0 < a.limit) {
            var l = a.valueMapper, d = ur(a, a.table.core.schema);
            return a.table.core.query({ trans: o, limit: a.limit, values: !0, query: { index: d, range: a.range } }).then(function(y) {
              return y = y.result, l ? y.map(l) : y;
            });
          }
          var m = [];
          return cr(a, function(y) {
            return m.push(y);
          }, o, a.table.core).then(function() {
            return m;
          });
        }, e);
      }, Be.prototype.offset = function(e) {
        var n = this._ctx;
        return e <= 0 || (n.offset += e, Cn(n) ? eo(n, function() {
          var o = e;
          return function(a, l) {
            return o === 0 || (o === 1 ? --o : l(function() {
              a.advance(o), o = 0;
            }), !1);
          };
        }) : eo(n, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Be.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), eo(this._ctx, function() {
          var n = e;
          return function(o, a, l) {
            return --n <= 0 && a(l), 0 <= n;
          };
        }, !0), this;
      }, Be.prototype.until = function(e, n) {
        return Zr(this._ctx, function(o, a, l) {
          return !e(o.value) || (a(l), n);
        }), this;
      }, Be.prototype.first = function(e) {
        return this.limit(1).toArray(function(n) {
          return n[0];
        }).then(e);
      }, Be.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Be.prototype.filter = function(e) {
        var n;
        return Zr(this._ctx, function(o) {
          return e(o.value);
        }), (n = this._ctx).isMatch = dn(n.isMatch, e), this;
      }, Be.prototype.and = function(e) {
        return this.filter(e);
      }, Be.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Be.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Be.prototype.desc = function() {
        return this.reverse();
      }, Be.prototype.eachKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.key, a);
        });
      }, Be.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Be.prototype.eachPrimaryKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, a) {
          e(a.primaryKey, a);
        });
      }, Be.prototype.keys = function(e) {
        var n = this._ctx;
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Be.prototype.primaryKeys = function(e) {
        var n = this._ctx;
        if (n.dir === "next" && Cn(n, !0) && 0 < n.limit) return this._read(function(a) {
          var l = ur(n, n.table.core.schema);
          return n.table.core.query({ trans: a, values: !1, limit: n.limit, query: { index: l, range: n.range } });
        }).then(function(a) {
          return a.result;
        }).then(e);
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(a, l) {
          o.push(l.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Be.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Be.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(n) {
          return n[0];
        }).then(e);
      }, Be.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Be.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var n = {};
        return Zr(this._ctx, function(l) {
          var a = l.primaryKey.toString(), l = $(n, a);
          return n[a] = !0, !l;
        }), this;
      }, Be.prototype.modify = function(e) {
        var n = this, o = this._ctx;
        return this._write(function(a) {
          var l, d, m;
          m = typeof e == "function" ? e : (l = u(e), d = l.length, function(I) {
            for (var j = !1, M = 0; M < d; ++M) {
              var q = l[M], z = e[q], te = de(I, q);
              z instanceof $n ? (ge(I, q, z.execute(te)), j = !0) : te !== z && (ge(I, q, z), j = !0);
            }
            return j;
          });
          var y = o.table.core, g = y.schema.primaryKey, b = g.outbound, _ = g.extractKey, R = 200, g = n.db._options.modifyChunkSize;
          g && (R = typeof g == "object" ? g[y.name] || g["*"] || 200 : g);
          function T(I, q) {
            var M = q.failures, q = q.numFailures;
            N += I - q;
            for (var z = 0, te = u(M); z < te.length; z++) {
              var J = te[z];
              w.push(M[J]);
            }
          }
          var w = [], N = 0, O = [], C = e === ii;
          return n.clone().primaryKeys().then(function(I) {
            function j(q) {
              var z = Math.min(R, I.length - q), te = I.slice(q, q + z);
              return (C ? Promise.resolve([]) : y.getMany({ trans: a, keys: te, cache: "immutable" })).then(function(J) {
                var ee = [], ae = [], ie = b ? [] : null, le = C ? te : [];
                if (!C) for (var Ee = 0; Ee < z; ++Ee) {
                  var je = J[Ee], Ce = { value: me(je), primKey: I[q + Ee] };
                  m.call(Ce, Ce.value, Ce) !== !1 && (Ce.value == null ? le.push(I[q + Ee]) : b || ke(_(je), _(Ce.value)) === 0 ? (ae.push(Ce.value), b && ie.push(I[q + Ee])) : (le.push(I[q + Ee]), ee.push(Ce.value)));
                }
                return Promise.resolve(0 < ee.length && y.mutate({ trans: a, type: "add", values: ee }).then(function(tt) {
                  for (var Re in tt.failures) le.splice(parseInt(Re), 1);
                  T(ee.length, tt);
                })).then(function() {
                  return (0 < ae.length || M && typeof e == "object") && y.mutate({ trans: a, type: "put", keys: ie, values: ae, criteria: M, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < q }).then(function(tt) {
                    return T(ae.length, tt);
                  });
                }).then(function() {
                  return (0 < le.length || M && C) && y.mutate({ trans: a, type: "delete", keys: le, criteria: M, isAdditionalChunk: 0 < q }).then(function(tt) {
                    return lr(o.table, le, tt);
                  }).then(function(tt) {
                    return T(le.length, tt);
                  });
                }).then(function() {
                  return I.length > q + z && j(q + R);
                });
              });
            }
            var M = Cn(o) && o.limit === 1 / 0 && (typeof e != "function" || C) && { index: o.index, range: o.range };
            return j(0).then(function() {
              if (0 < w.length) throw new bn("Error modifying one or more objects", w, N, O);
              return I.length;
            });
          });
        });
      }, Be.prototype.delete = function() {
        var e = this._ctx, n = e.range;
        return !Cn(e) || e.table.schema.yProps || !e.isPrimKey && n.type !== 3 ? this.modify(ii) : this._write(function(o) {
          var a = e.table.core.schema.primaryKey, l = n;
          return e.table.core.count({ trans: o, query: { index: a, range: l } }).then(function(d) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: l }).then(function(b) {
              var y = b.failures, b = b.numFailures;
              if (b) throw new bn("Could not delete some values", Object.keys(y).map(function(_) {
                return y[_];
              }), d - b);
              return d - b;
            });
          });
        });
      }, Be);
      function Be() {
      }
      var ii = function(e, n) {
        return n.value = null;
      };
      function Va(e, n) {
        return e < n ? -1 : e === n ? 0 : 1;
      }
      function Wa(e, n) {
        return n < e ? -1 : e === n ? 0 : 1;
      }
      function xt(e, n, o) {
        return e = e instanceof si ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(n), e;
      }
      function On(e) {
        return new e.Collection(e, function() {
          return ai("");
        }).limit(0);
      }
      function dr(e, n, o, a) {
        var l, d, m, y, b, _, R, g = o.length;
        if (!o.every(function(N) {
          return typeof N == "string";
        })) return xt(e, Xo);
        function T(N) {
          l = N === "next" ? function(C) {
            return C.toUpperCase();
          } : function(C) {
            return C.toLowerCase();
          }, d = N === "next" ? function(C) {
            return C.toLowerCase();
          } : function(C) {
            return C.toUpperCase();
          }, m = N === "next" ? Va : Wa;
          var O = o.map(function(C) {
            return { lower: d(C), upper: l(C) };
          }).sort(function(C, I) {
            return m(C.lower, I.lower);
          });
          y = O.map(function(C) {
            return C.upper;
          }), b = O.map(function(C) {
            return C.lower;
          }), R = (_ = N) === "next" ? "" : a;
        }
        T("next"), e = new e.Collection(e, function() {
          return Zt(y[0], b[g - 1] + a);
        }), e._ondirectionchange = function(N) {
          T(N);
        };
        var w = 0;
        return e._addAlgorithm(function(N, O, C) {
          var I = N.key;
          if (typeof I != "string") return !1;
          var j = d(I);
          if (n(j, b, w)) return !0;
          for (var M = null, q = w; q < g; ++q) {
            var z = function(te, J, ee, ae, ie, le) {
              for (var Ee = Math.min(te.length, ae.length), je = -1, Ce = 0; Ce < Ee; ++Ce) {
                var tt = J[Ce];
                if (tt !== ae[Ce]) return ie(te[Ce], ee[Ce]) < 0 ? te.substr(0, Ce) + ee[Ce] + ee.substr(Ce + 1) : ie(te[Ce], ae[Ce]) < 0 ? te.substr(0, Ce) + ae[Ce] + ee.substr(Ce + 1) : 0 <= je ? te.substr(0, je) + J[je] + ee.substr(je + 1) : null;
                ie(te[Ce], tt) < 0 && (je = Ce);
              }
              return Ee < ae.length && le === "next" ? te + ee.substr(te.length) : Ee < te.length && le === "prev" ? te.substr(0, ee.length) : je < 0 ? null : te.substr(0, je) + ae[je] + ee.substr(je + 1);
            }(I, j, y[q], b[q], m, _);
            z === null && M === null ? w = q + 1 : (M === null || 0 < m(M, z)) && (M = z);
          }
          return O(M !== null ? function() {
            N.continue(M + R);
          } : C), !1;
        }), e;
      }
      function Zt(e, n, o, a) {
        return { type: 2, lower: e, upper: n, lowerOpen: o, upperOpen: a };
      }
      function ai(e) {
        return { type: 1, lower: e, upper: e };
      }
      var si = (Object.defineProperty(dt.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), dt.prototype.between = function(e, n, o, a) {
        o = o !== !1, a = a === !0;
        try {
          return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (o || a) && (!o || !a) ? On(this) : new this.Collection(this, function() {
            return Zt(e, n, !o, !a);
          });
        } catch {
          return xt(this, Vt);
        }
      }, dt.prototype.equals = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return ai(e);
        });
      }, dt.prototype.above = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(e, void 0, !0);
        });
      }, dt.prototype.aboveOrEqual = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(e, void 0, !1);
        });
      }, dt.prototype.below = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(void 0, e, !1, !0);
        });
      }, dt.prototype.belowOrEqual = function(e) {
        return e == null ? xt(this, Vt) : new this.Collection(this, function() {
          return Zt(void 0, e);
        });
      }, dt.prototype.startsWith = function(e) {
        return typeof e != "string" ? xt(this, Xo) : this.between(e, e + cn, !0, !0);
      }, dt.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : dr(this, function(n, o) {
          return n.indexOf(o[0]) === 0;
        }, [e], cn);
      }, dt.prototype.equalsIgnoreCase = function(e) {
        return dr(this, function(n, o) {
          return n === o[0];
        }, [e], "");
      }, dt.prototype.anyOfIgnoreCase = function() {
        var e = Me.apply(pt, arguments);
        return e.length === 0 ? On(this) : dr(this, function(n, o) {
          return o.indexOf(n) !== -1;
        }, e, "");
      }, dt.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = Me.apply(pt, arguments);
        return e.length === 0 ? On(this) : dr(this, function(n, o) {
          return o.some(function(a) {
            return n.indexOf(a) === 0;
          });
        }, e, cn);
      }, dt.prototype.anyOf = function() {
        var e = this, n = Me.apply(pt, arguments), o = this._cmp;
        try {
          n.sort(o);
        } catch {
          return xt(this, Vt);
        }
        if (n.length === 0) return On(this);
        var a = new this.Collection(this, function() {
          return Zt(n[0], n[n.length - 1]);
        });
        a._ondirectionchange = function(d) {
          o = d === "next" ? e._ascending : e._descending, n.sort(o);
        };
        var l = 0;
        return a._addAlgorithm(function(d, m, y) {
          for (var b = d.key; 0 < o(b, n[l]); ) if (++l === n.length) return m(y), !1;
          return o(b, n[l]) === 0 || (m(function() {
            d.continue(n[l]);
          }), !1);
        }), a;
      }, dt.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, dt.prototype.noneOf = function() {
        var e = Me.apply(pt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return xt(this, Vt);
        }
        var n = e.reduce(function(o, a) {
          return o ? o.concat([[o[o.length - 1][1], a]]) : [[-1 / 0, a]];
        }, null);
        return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
      }, dt.prototype.inAnyRange = function(I, n) {
        var o = this, a = this._cmp, l = this._ascending, d = this._descending, m = this._min, y = this._max;
        if (I.length === 0) return On(this);
        if (!I.every(function(j) {
          return j[0] !== void 0 && j[1] !== void 0 && l(j[0], j[1]) <= 0;
        })) return xt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", G.InvalidArgument);
        var b = !n || n.includeLowers !== !1, _ = n && n.includeUppers === !0, R, g = l;
        function T(j, M) {
          return g(j[0], M[0]);
        }
        try {
          (R = I.reduce(function(j, M) {
            for (var q = 0, z = j.length; q < z; ++q) {
              var te = j[q];
              if (a(M[0], te[1]) < 0 && 0 < a(M[1], te[0])) {
                te[0] = m(te[0], M[0]), te[1] = y(te[1], M[1]);
                break;
              }
            }
            return q === z && j.push(M), j;
          }, [])).sort(T);
        } catch {
          return xt(this, Vt);
        }
        var w = 0, N = _ ? function(j) {
          return 0 < l(j, R[w][1]);
        } : function(j) {
          return 0 <= l(j, R[w][1]);
        }, O = b ? function(j) {
          return 0 < d(j, R[w][0]);
        } : function(j) {
          return 0 <= d(j, R[w][0]);
        }, C = N, I = new this.Collection(this, function() {
          return Zt(R[0][0], R[R.length - 1][1], !b, !_);
        });
        return I._ondirectionchange = function(j) {
          g = j === "next" ? (C = N, l) : (C = O, d), R.sort(T);
        }, I._addAlgorithm(function(j, M, q) {
          for (var z, te = j.key; C(te); ) if (++w === R.length) return M(q), !1;
          return !N(z = te) && !O(z) || (o._cmp(te, R[w][1]) === 0 || o._cmp(te, R[w][0]) === 0 || M(function() {
            g === l ? j.continue(R[w][0]) : j.continue(R[w][1]);
          }), !1);
        }), I;
      }, dt.prototype.startsWithAnyOf = function() {
        var e = Me.apply(pt, arguments);
        return e.every(function(n) {
          return typeof n == "string";
        }) ? e.length === 0 ? On(this) : this.inAnyRange(e.map(function(n) {
          return [n, n + cn];
        })) : xt(this, "startsWithAnyOf() only works with strings");
      }, dt);
      function dt() {
      }
      function Bt(e) {
        return Ze(function(n) {
          return Fn(n), e(n.target.error), !1;
        });
      }
      function Fn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Mn = "storagemutated", to = "x-storagemutated-1", en = kn(null, Mn), Ga = (Kt.prototype._lock = function() {
        return K(!pe.global), ++this._reculock, this._reculock !== 1 || pe.global || (pe.lockOwnerFor = this), this;
      }, Kt.prototype._unlock = function() {
        if (K(!pe.global), --this._reculock == 0) for (pe.global || (pe.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            un(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Kt.prototype._locked = function() {
        return this._reculock && pe.lockOwnerFor !== this;
      }, Kt.prototype.create = function(e) {
        var n = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, a = this.db._state.dbOpenError;
        if (K(!this.idbtrans), !e && !o) switch (a && a.name) {
          case "DatabaseClosedError":
            throw new G.DatabaseClosed(a);
          case "MissingAPIError":
            throw new G.MissingAPI(a.message, a);
          default:
            throw new G.OpenFailed(a);
        }
        if (!this.active) throw new G.TransactionInactive();
        return K(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Ze(function(l) {
          Fn(l), n._reject(e.error);
        }), e.onabort = Ze(function(l) {
          Fn(l), n.active && n._reject(new G.Abort(e.error)), n.active = !1, n.on("abort").fire(l);
        }), e.oncomplete = Ze(function() {
          n.active = !1, n._resolve(), "mutatedParts" in e && en.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Kt.prototype._promise = function(e, n, o) {
        var a = this;
        if (e === "readwrite" && this.mode !== "readwrite") return rt(new G.ReadOnly("Transaction is readonly"));
        if (!this.active) return rt(new G.TransactionInactive());
        if (this._locked()) return new se(function(d, m) {
          a._blockedFuncs.push([function() {
            a._promise(e, n, o).then(d, m);
          }, pe]);
        });
        if (o) return Xt(function() {
          var d = new se(function(m, y) {
            a._lock();
            var b = n(m, y, a);
            b && b.then && b.then(m, y);
          });
          return d.finally(function() {
            return a._unlock();
          }), d._lib = !0, d;
        });
        var l = new se(function(d, m) {
          var y = n(d, m, a);
          y && y.then && y.then(d, m);
        });
        return l._lib = !0, l;
      }, Kt.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Kt.prototype.waitFor = function(e) {
        var n, o = this._root(), a = se.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return a;
        }) : (o._waitingFor = a, o._waitingQueue = [], n = o.idbtrans.objectStore(o.storeNames[0]), function d() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (n.get(-1 / 0).onsuccess = d);
        }());
        var l = o._waitingFor;
        return new se(function(d, m) {
          a.then(function(y) {
            return o._waitingQueue.push(Ze(d.bind(null, y)));
          }, function(y) {
            return o._waitingQueue.push(Ze(m.bind(null, y)));
          }).finally(function() {
            o._waitingFor === l && (o._waitingFor = null);
          });
        });
      }, Kt.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new G.Abort()));
      }, Kt.prototype.table = function(e) {
        var n = this._memoizedTables || (this._memoizedTables = {});
        if ($(n, e)) return n[e];
        var o = this.schema[e];
        if (!o) throw new G.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), n[e] = o;
      }, Kt);
      function Kt() {
      }
      function no(e, n, o, a, l, d, m, y) {
        return { name: e, keyPath: n, unique: o, multi: a, auto: l, compound: d, src: (o && !m ? "&" : "") + (a ? "*" : "") + (l ? "++" : "") + li(n), type: y };
      }
      function li(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function ro(e, n, o) {
        return { name: e, primKey: n, indexes: o, mappedClass: null, idxByName: (a = function(l) {
          return [l.name, l];
        }, o.reduce(function(l, d, m) {
          return m = a(d, m), m && (l[m[0]] = m[1]), l;
        }, {})) };
        var a;
      }
      var Bn = function(e) {
        try {
          return e.only([[]]), Bn = function() {
            return [[]];
          }, [[]];
        } catch {
          return Bn = function() {
            return cn;
          }, cn;
        }
      };
      function oo(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (n = e).split(".").length === 1 ? function(o) {
          return o[n];
        } : function(o) {
          return de(o, n);
        } : function(o) {
          return de(o, e);
        };
        var n;
      }
      function ui(e) {
        return [].slice.call(e);
      }
      var Ha = 0;
      function Kn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Ya(e, n, b) {
        function a(C) {
          if (C.type === 3) return null;
          if (C.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var w = C.lower, N = C.upper, O = C.lowerOpen, C = C.upperOpen;
          return w === void 0 ? N === void 0 ? null : n.upperBound(N, !!C) : N === void 0 ? n.lowerBound(w, !!O) : n.bound(w, N, !!O, !!C);
        }
        function l(T) {
          var w, N = T.name;
          return { name: N, schema: T, mutate: function(O) {
            var C = O.trans, I = O.type, j = O.keys, M = O.values, q = O.range;
            return new Promise(function(z, te) {
              z = Ze(z);
              var J = C.objectStore(N), ee = J.keyPath == null, ae = I === "put" || I === "add";
              if (!ae && I !== "delete" && I !== "deleteRange") throw new Error("Invalid operation type: " + I);
              var ie, le = (j || M || { length: 1 }).length;
              if (j && M && j.length !== M.length) throw new Error("Given keys array must have same length as given values array.");
              if (le === 0) return z({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function Ee(bt) {
                ++tt, Fn(bt);
              }
              var je = [], Ce = [], tt = 0;
              if (I === "deleteRange") {
                if (q.type === 4) return z({ numFailures: tt, failures: Ce, results: [], lastResult: void 0 });
                q.type === 3 ? je.push(ie = J.clear()) : je.push(ie = J.delete(a(q)));
              } else {
                var ee = ae ? ee ? [M, j] : [M, null] : [j, null], Re = ee[0], mt = ee[1];
                if (ae) for (var vt = 0; vt < le; ++vt) je.push(ie = mt && mt[vt] !== void 0 ? J[I](Re[vt], mt[vt]) : J[I](Re[vt])), ie.onerror = Ee;
                else for (vt = 0; vt < le; ++vt) je.push(ie = J[I](Re[vt])), ie.onerror = Ee;
              }
              function xr(bt) {
                bt = bt.target.result, je.forEach(function(hn, xo) {
                  return hn.error != null && (Ce[xo] = hn.error);
                }), z({ numFailures: tt, failures: Ce, results: I === "delete" ? j : je.map(function(hn) {
                  return hn.result;
                }), lastResult: bt });
              }
              ie.onerror = function(bt) {
                Ee(bt), xr(bt);
              }, ie.onsuccess = xr;
            });
          }, getMany: function(O) {
            var C = O.trans, I = O.keys;
            return new Promise(function(j, M) {
              j = Ze(j);
              for (var q, z = C.objectStore(N), te = I.length, J = new Array(te), ee = 0, ae = 0, ie = function(je) {
                je = je.target, J[je._pos] = je.result, ++ae === ee && j(J);
              }, le = Bt(M), Ee = 0; Ee < te; ++Ee) I[Ee] != null && ((q = z.get(I[Ee]))._pos = Ee, q.onsuccess = ie, q.onerror = le, ++ee);
              ee === 0 && j(J);
            });
          }, get: function(O) {
            var C = O.trans, I = O.key;
            return new Promise(function(j, M) {
              j = Ze(j);
              var q = C.objectStore(N).get(I);
              q.onsuccess = function(z) {
                return j(z.target.result);
              }, q.onerror = Bt(M);
            });
          }, query: (w = _, function(O) {
            return new Promise(function(C, I) {
              C = Ze(C);
              var j, M, q, ee = O.trans, z = O.values, te = O.limit, ie = O.query, J = te === 1 / 0 ? void 0 : te, ae = ie.index, ie = ie.range, ee = ee.objectStore(N), ae = ae.isPrimaryKey ? ee : ee.index(ae.name), ie = a(ie);
              if (te === 0) return C({ result: [] });
              w ? ((J = z ? ae.getAll(ie, J) : ae.getAllKeys(ie, J)).onsuccess = function(le) {
                return C({ result: le.target.result });
              }, J.onerror = Bt(I)) : (j = 0, M = !z && "openKeyCursor" in ae ? ae.openKeyCursor(ie) : ae.openCursor(ie), q = [], M.onsuccess = function(le) {
                var Ee = M.result;
                return Ee ? (q.push(z ? Ee.value : Ee.primaryKey), ++j === te ? C({ result: q }) : void Ee.continue()) : C({ result: q });
              }, M.onerror = Bt(I));
            });
          }), openCursor: function(O) {
            var C = O.trans, I = O.values, j = O.query, M = O.reverse, q = O.unique;
            return new Promise(function(z, te) {
              z = Ze(z);
              var ae = j.index, J = j.range, ee = C.objectStore(N), ee = ae.isPrimaryKey ? ee : ee.index(ae.name), ae = M ? q ? "prevunique" : "prev" : q ? "nextunique" : "next", ie = !I && "openKeyCursor" in ee ? ee.openKeyCursor(a(J), ae) : ee.openCursor(a(J), ae);
              ie.onerror = Bt(te), ie.onsuccess = Ze(function(le) {
                var Ee, je, Ce, tt, Re = ie.result;
                Re ? (Re.___id = ++Ha, Re.done = !1, Ee = Re.continue.bind(Re), je = (je = Re.continuePrimaryKey) && je.bind(Re), Ce = Re.advance.bind(Re), tt = function() {
                  throw new Error("Cursor not stopped");
                }, Re.trans = C, Re.stop = Re.continue = Re.continuePrimaryKey = Re.advance = function() {
                  throw new Error("Cursor not started");
                }, Re.fail = Ze(te), Re.next = function() {
                  var mt = this, vt = 1;
                  return this.start(function() {
                    return vt-- ? mt.continue() : mt.stop();
                  }).then(function() {
                    return mt;
                  });
                }, Re.start = function(mt) {
                  function vt() {
                    if (ie.result) try {
                      mt();
                    } catch (bt) {
                      Re.fail(bt);
                    }
                    else Re.done = !0, Re.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, Re.stop();
                  }
                  var xr = new Promise(function(bt, hn) {
                    bt = Ze(bt), ie.onerror = Bt(hn), Re.fail = hn, Re.stop = function(xo) {
                      Re.stop = Re.continue = Re.continuePrimaryKey = Re.advance = tt, bt(xo);
                    };
                  });
                  return ie.onsuccess = Ze(function(bt) {
                    ie.onsuccess = vt, vt();
                  }), Re.continue = Ee, Re.continuePrimaryKey = je, Re.advance = Ce, vt(), xr;
                }, z(Re)) : z(null);
              }, te);
            });
          }, count: function(O) {
            var C = O.query, I = O.trans, j = C.index, M = C.range;
            return new Promise(function(q, z) {
              var te = I.objectStore(N), J = j.isPrimaryKey ? te : te.index(j.name), te = a(M), J = te ? J.count(te) : J.count();
              J.onsuccess = Ze(function(ee) {
                return q(ee.target.result);
              }), J.onerror = Bt(z);
            });
          } };
        }
        var d, m, y, R = (m = b, y = ui((d = e).objectStoreNames), { schema: { name: d.name, tables: y.map(function(T) {
          return m.objectStore(T);
        }).map(function(T) {
          var w = T.keyPath, C = T.autoIncrement, N = p(w), O = {}, C = { name: T.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: w == null, compound: N, keyPath: w, autoIncrement: C, unique: !0, extractKey: oo(w) }, indexes: ui(T.indexNames).map(function(I) {
            return T.index(I);
          }).map(function(q) {
            var j = q.name, M = q.unique, z = q.multiEntry, q = q.keyPath, z = { name: j, compound: p(q), keyPath: q, unique: M, multiEntry: z, extractKey: oo(q) };
            return O[Kn(q)] = z;
          }), getIndexByKeyPath: function(I) {
            return O[Kn(I)];
          } };
          return O[":id"] = C.primaryKey, w != null && (O[Kn(w)] = C.primaryKey), C;
        }) }, hasGetAll: 0 < y.length && "getAll" in m.objectStore(y[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), b = R.schema, _ = R.hasGetAll, R = b.tables.map(l), g = {};
        return R.forEach(function(T) {
          return g[T.name] = T;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(T) {
          if (!g[T]) throw new Error("Table '".concat(T, "' not found"));
          return g[T];
        }, MIN_KEY: -1 / 0, MAX_KEY: Bn(n), schema: b };
      }
      function za(e, n, o, a) {
        var l = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (a = Ya(n, l, a), e.dbcore.reduce(function(d, m) {
          return m = m.create, s(s({}, d), m(d));
        }, a)) };
      }
      function fr(e, a) {
        var o = a.db, a = za(e._middlewares, o, e._deps, a);
        e.core = a.dbcore, e.tables.forEach(function(l) {
          var d = l.name;
          e.core.schema.tables.some(function(m) {
            return m.name === d;
          }) && (l.core = e.core.table(d), e[d] instanceof e.Table && (e[d].core = l.core));
        });
      }
      function pr(e, n, o, a) {
        o.forEach(function(l) {
          var d = a[l];
          n.forEach(function(m) {
            var y = function b(_, R) {
              return B(_, R) || (_ = k(_)) && b(_, R);
            }(m, l);
            (!y || "value" in y && y.value === void 0) && (m === e.Transaction.prototype || m instanceof e.Transaction ? A(m, l, { get: function() {
              return this.table(l);
            }, set: function(b) {
              W(this, l, { value: b, writable: !0, configurable: !0, enumerable: !0 });
            } }) : m[l] = new e.Table(l, d));
          });
        });
      }
      function io(e, n) {
        n.forEach(function(o) {
          for (var a in o) o[a] instanceof e.Table && delete o[a];
        });
      }
      function Xa(e, n) {
        return e._cfg.version - n._cfg.version;
      }
      function Qa(e, n, o, a) {
        var l = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !l.$meta && (l.$meta = ro("$meta", di("")[0], []), e._storeNames.push("$meta"));
        var d = e._createTransaction("readwrite", e._storeNames, l);
        d.create(o), d._completion.catch(a);
        var m = d._reject.bind(d), y = pe.transless || pe;
        Xt(function() {
          return pe.trans = d, pe.transless = y, n !== 0 ? (fr(e, o), _ = n, ((b = d).storeNames.includes("$meta") ? b.table("$meta").get("version").then(function(R) {
            return R ?? _;
          }) : se.resolve(_)).then(function(R) {
            return T = R, w = d, N = o, O = [], R = (g = e)._versions, C = g._dbSchema = mr(0, g.idbdb, N), (R = R.filter(function(I) {
              return I._cfg.version >= T;
            })).length !== 0 ? (R.forEach(function(I) {
              O.push(function() {
                var j = C, M = I._cfg.dbschema;
                vr(g, j, N), vr(g, M, N), C = g._dbSchema = M;
                var q = ao(j, M);
                q.add.forEach(function(ae) {
                  so(N, ae[0], ae[1].primKey, ae[1].indexes);
                }), q.change.forEach(function(ae) {
                  if (ae.recreate) throw new G.Upgrade("Not yet support for changing primary key");
                  var ie = N.objectStore(ae.name);
                  ae.add.forEach(function(le) {
                    return hr(ie, le);
                  }), ae.change.forEach(function(le) {
                    ie.deleteIndex(le.name), hr(ie, le);
                  }), ae.del.forEach(function(le) {
                    return ie.deleteIndex(le);
                  });
                });
                var z = I._cfg.contentUpgrade;
                if (z && I._cfg.version > T) {
                  fr(g, N), w._memoizedTables = {};
                  var te = Ue(M);
                  q.del.forEach(function(ae) {
                    te[ae] = j[ae];
                  }), io(g, [g.Transaction.prototype]), pr(g, [g.Transaction.prototype], u(te), te), w.schema = te;
                  var J, ee = Qe(z);
                  return ee && xn(), q = se.follow(function() {
                    var ae;
                    (J = z(w)) && ee && (ae = Qt.bind(null, null), J.then(ae, ae));
                  }), J && typeof J.then == "function" ? se.resolve(J) : q.then(function() {
                    return J;
                  });
                }
              }), O.push(function(j) {
                var M, q, z = I._cfg.dbschema;
                M = z, q = j, [].slice.call(q.db.objectStoreNames).forEach(function(te) {
                  return M[te] == null && q.db.deleteObjectStore(te);
                }), io(g, [g.Transaction.prototype]), pr(g, [g.Transaction.prototype], g._storeNames, g._dbSchema), w.schema = g._dbSchema;
              }), O.push(function(j) {
                g.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(g.idbdb.version / 10) === I._cfg.version ? (g.idbdb.deleteObjectStore("$meta"), delete g._dbSchema.$meta, g._storeNames = g._storeNames.filter(function(M) {
                  return M !== "$meta";
                })) : j.objectStore("$meta").put(I._cfg.version, "version"));
              });
            }), function I() {
              return O.length ? se.resolve(O.shift()(w.idbtrans)).then(I) : se.resolve();
            }().then(function() {
              ci(C, N);
            })) : se.resolve();
            var g, T, w, N, O, C;
          }).catch(m)) : (u(l).forEach(function(R) {
            so(o, R, l[R].primKey, l[R].indexes);
          }), fr(e, o), void se.follow(function() {
            return e.on.populate.fire(d);
          }).catch(m));
          var b, _;
        });
      }
      function Ja(e, n) {
        ci(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
        var o = mr(0, e.idbdb, n);
        vr(e, e._dbSchema, n);
        for (var a = 0, l = ao(o, e._dbSchema).change; a < l.length; a++) {
          var d = function(m) {
            if (m.change.length || m.recreate) return console.warn("Unable to patch indexes of table ".concat(m.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var y = n.objectStore(m.name);
            m.add.forEach(function(b) {
              ye && console.debug("Dexie upgrade patch: Creating missing index ".concat(m.name, ".").concat(b.src)), hr(y, b);
            });
          }(l[a]);
          if (typeof d == "object") return d.value;
        }
      }
      function ao(e, n) {
        var o, a = { del: [], add: [], change: [] };
        for (o in e) n[o] || a.del.push(o);
        for (o in n) {
          var l = e[o], d = n[o];
          if (l) {
            var m = { name: o, def: d, recreate: !1, del: [], add: [], change: [] };
            if ("" + (l.primKey.keyPath || "") != "" + (d.primKey.keyPath || "") || l.primKey.auto !== d.primKey.auto) m.recreate = !0, a.change.push(m);
            else {
              var y = l.idxByName, b = d.idxByName, _ = void 0;
              for (_ in y) b[_] || m.del.push(_);
              for (_ in b) {
                var R = y[_], g = b[_];
                R ? R.src !== g.src && m.change.push(g) : m.add.push(g);
              }
              (0 < m.del.length || 0 < m.add.length || 0 < m.change.length) && a.change.push(m);
            }
          } else a.add.push([o, d]);
        }
        return a;
      }
      function so(e, n, o, a) {
        var l = e.db.createObjectStore(n, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return a.forEach(function(d) {
          return hr(l, d);
        }), l;
      }
      function ci(e, n) {
        u(e).forEach(function(o) {
          n.db.objectStoreNames.contains(o) || (ye && console.debug("Dexie: Creating missing table", o), so(n, o, e[o].primKey, e[o].indexes));
        });
      }
      function hr(e, n) {
        e.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi });
      }
      function mr(e, n, o) {
        var a = {};
        return F(n.objectStoreNames, 0).forEach(function(l) {
          for (var d = o.objectStore(l), m = no(li(_ = d.keyPath), _ || "", !0, !1, !!d.autoIncrement, _ && typeof _ != "string", !0), y = [], b = 0; b < d.indexNames.length; ++b) {
            var R = d.index(d.indexNames[b]), _ = R.keyPath, R = no(R.name, _, !!R.unique, !!R.multiEntry, !1, _ && typeof _ != "string", !1);
            y.push(R);
          }
          a[l] = ro(l, m, y);
        }), a;
      }
      function vr(e, n, o) {
        for (var a = o.db.objectStoreNames, l = 0; l < a.length; ++l) {
          var d = a[l], m = o.objectStore(d);
          e._hasGetAll = "getAll" in m;
          for (var y = 0; y < m.indexNames.length; ++y) {
            var b = m.indexNames[y], _ = m.index(b).keyPath, R = typeof _ == "string" ? _ : "[" + F(_).join("+") + "]";
            !n[d] || (_ = n[d].idxByName[R]) && (_.name = b, delete n[d].idxByName[R], n[d].idxByName[b] = _);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function di(e) {
        return e.split(",").map(function(n, o) {
          var d = n.split(":"), a = (l = d[1]) === null || l === void 0 ? void 0 : l.trim(), l = (n = d[0].trim()).replace(/([&*]|\+\+)/g, ""), d = /^\[/.test(l) ? l.match(/^\[(.*)\]$/)[1].split("+") : l;
          return no(l, d || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), p(d), o === 0, a);
        });
      }
      var Za = (Tn.prototype._createTableSchema = ro, Tn.prototype._parseIndexSyntax = di, Tn.prototype._parseStoresSpec = function(e, n) {
        var o = this;
        u(e).forEach(function(a) {
          if (e[a] !== null) {
            var l = o._parseIndexSyntax(e[a]), d = l.shift();
            if (!d) throw new G.Schema("Invalid schema for table " + a + ": " + e[a]);
            if (d.unique = !0, d.multi) throw new G.Schema("Primary key cannot be multiEntry*");
            l.forEach(function(m) {
              if (m.auto) throw new G.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!m.keyPath) throw new G.Schema("Index must have a name and cannot be an empty string");
            }), l = o._createTableSchema(a, d, l), n[a] = l;
          }
        });
      }, Tn.prototype.stores = function(o) {
        var n = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? v(this._cfg.storesSource, o) : o;
        var o = n._versions, a = {}, l = {};
        return o.forEach(function(d) {
          v(a, d._cfg.storesSource), l = d._cfg.dbschema = {}, d._parseStoresSpec(a, l);
        }), n._dbSchema = l, io(n, [n._allTables, n, n.Transaction.prototype]), pr(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], u(l), l), n._storeNames = u(l), this;
      }, Tn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = xe(this._cfg.contentUpgrade || S, e), this;
      }, Tn);
      function Tn() {
      }
      function lo(e, n) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Wt(ar, { addons: [], indexedDB: e, IDBKeyRange: n })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function uo(e) {
        return e && typeof e.databases == "function";
      }
      function co(e) {
        return Xt(function() {
          return pe.letThrough = !0, e();
        });
      }
      function fo(e) {
        return !("from" in e);
      }
      var ht = function(e, n) {
        if (!this) {
          var o = new ht();
          return e && "d" in e && v(o, e), o;
        }
        v(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? n : e } : { d: 0 });
      };
      function qn(e, n, o) {
        var a = ke(n, o);
        if (!isNaN(a)) {
          if (0 < a) throw RangeError();
          if (fo(e)) return v(e, { from: n, to: o, d: 1 });
          var l = e.l, a = e.r;
          if (ke(o, e.from) < 0) return l ? qn(l, n, o) : e.l = { from: n, to: o, d: 1, l: null, r: null }, pi(e);
          if (0 < ke(n, e.to)) return a ? qn(a, n, o) : e.r = { from: n, to: o, d: 1, l: null, r: null }, pi(e);
          ke(n, e.from) < 0 && (e.from = n, e.l = null, e.d = a ? a.d + 1 : 1), 0 < ke(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, l && !e.l && Un(e, l), a && o && Un(e, a);
        }
      }
      function Un(e, n) {
        fo(n) || function o(a, b) {
          var d = b.from, m = b.to, y = b.l, b = b.r;
          qn(a, d, m), y && o(a, y), b && o(a, b);
        }(e, n);
      }
      function fi(e, n) {
        var o = yr(n), a = o.next();
        if (a.done) return !1;
        for (var l = a.value, d = yr(e), m = d.next(l.from), y = m.value; !a.done && !m.done; ) {
          if (ke(y.from, l.to) <= 0 && 0 <= ke(y.to, l.from)) return !0;
          ke(l.from, y.from) < 0 ? l = (a = o.next(y.from)).value : y = (m = d.next(l.from)).value;
        }
        return !1;
      }
      function yr(e) {
        var n = fo(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var a = 0 < arguments.length; n; ) switch (n.s) {
            case 0:
              if (n.s = 1, a) for (; n.n.l && ke(o, n.n.from) < 0; ) n = { up: n, n: n.n.l, s: 1 };
              else for (; n.n.l; ) n = { up: n, n: n.n.l, s: 1 };
            case 1:
              if (n.s = 2, !a || ke(o, n.n.to) <= 0) return { value: n.n, done: !1 };
            case 2:
              if (n.n.r) {
                n.s = 3, n = { up: n, n: n.n.r, s: 0 };
                continue;
              }
            case 3:
              n = n.up;
          }
          return { done: !0 };
        } };
      }
      function pi(e) {
        var n, o, a = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), l = 1 < a ? "r" : a < -1 ? "l" : "";
        l && (n = l == "r" ? "l" : "r", o = s({}, e), a = e[l], e.from = a.from, e.to = a.to, e[l] = a[l], o[l] = a[n], (e[n] = o).d = hi(o)), e.d = hi(e);
      }
      function hi(o) {
        var n = o.r, o = o.l;
        return (n ? o ? Math.max(n.d, o.d) : n.d : o ? o.d : 0) + 1;
      }
      function gr(e, n) {
        return u(n).forEach(function(o) {
          e[o] ? Un(e[o], n[o]) : e[o] = function a(l) {
            var d, m, y = {};
            for (d in l) $(l, d) && (m = l[d], y[d] = !m || typeof m != "object" || ce.has(m.constructor) ? m : a(m));
            return y;
          }(n[o]);
        }), e;
      }
      function po(e, n) {
        return e.all || n.all || Object.keys(e).some(function(o) {
          return n[o] && fi(n[o], e[o]);
        });
      }
      U(ht.prototype, ((Dt = { add: function(e) {
        return Un(this, e), this;
      }, addKey: function(e) {
        return qn(this, e, e), this;
      }, addKeys: function(e) {
        var n = this;
        return e.forEach(function(o) {
          return qn(n, o, o);
        }), this;
      }, hasKey: function(e) {
        var n = yr(this).next(e).value;
        return n && ke(n.from, e) <= 0 && 0 <= ke(n.to, e);
      } })[Se] = function() {
        return yr(this);
      }, Dt));
      var fn = {}, ho = {}, mo = !1;
      function br(e) {
        gr(ho, e), mo || (mo = !0, setTimeout(function() {
          mo = !1, vo(ho, !(ho = {}));
        }, 0));
      }
      function vo(e, n) {
        n === void 0 && (n = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var a = 0, l = Object.values(fn); a < l.length; a++) mi(m = l[a], e, o, n);
        else for (var d in e) {
          var m, y = /^idb\:\/\/(.*)\/(.*)\//.exec(d);
          y && (d = y[1], y = y[2], (m = fn["idb://".concat(d, "/").concat(y)]) && mi(m, e, o, n));
        }
        o.forEach(function(b) {
          return b();
        });
      }
      function mi(e, n, o, a) {
        for (var l = [], d = 0, m = Object.entries(e.queries.query); d < m.length; d++) {
          for (var y = m[d], b = y[0], _ = [], R = 0, g = y[1]; R < g.length; R++) {
            var T = g[R];
            po(n, T.obsSet) ? T.subscribers.forEach(function(C) {
              return o.add(C);
            }) : a && _.push(T);
          }
          a && l.push([b, _]);
        }
        if (a) for (var w = 0, N = l; w < N.length; w++) {
          var O = N[w], b = O[0], _ = O[1];
          e.queries.query[b] = _;
        }
      }
      function es(e) {
        var n = e._state, o = e._deps.indexedDB;
        if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
          return n.dbOpenError ? rt(n.dbOpenError) : e;
        });
        n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
        var a = n.openCanceller, l = Math.round(10 * e.verno), d = !1;
        function m() {
          if (n.openCanceller !== a) throw new G.DatabaseClosed("db.open() was cancelled");
        }
        function y() {
          return new se(function(T, w) {
            if (m(), !o) throw new G.MissingAPI();
            var N = e.name, O = n.autoSchema || !l ? o.open(N) : o.open(N, l);
            if (!O) throw new G.MissingAPI();
            O.onerror = Bt(w), O.onblocked = Ze(e._fireOnBlocked), O.onupgradeneeded = Ze(function(C) {
              var I;
              R = O.transaction, n.autoSchema && !e._options.allowEmptyDB ? (O.onerror = Fn, R.abort(), O.result.close(), (I = o.deleteDatabase(N)).onsuccess = I.onerror = Ze(function() {
                w(new G.NoSuchDatabase("Database ".concat(N, " doesnt exist")));
              })) : (R.onerror = Bt(w), C = C.oldVersion > Math.pow(2, 62) ? 0 : C.oldVersion, g = C < 1, e.idbdb = O.result, d && Ja(e, R), Qa(e, C / 10, R, w));
            }, w), O.onsuccess = Ze(function() {
              R = null;
              var C, I, j, M, q, z = e.idbdb = O.result, te = F(z.objectStoreNames);
              if (0 < te.length) try {
                var J = z.transaction((M = te).length === 1 ? M[0] : M, "readonly");
                if (n.autoSchema) I = z, j = J, (C = e).verno = I.version / 10, j = C._dbSchema = mr(0, I, j), C._storeNames = F(I.objectStoreNames, 0), pr(C, [C._allTables], u(j), j);
                else if (vr(e, e._dbSchema, J), ((q = ao(mr(0, (q = e).idbdb, J), q._dbSchema)).add.length || q.change.some(function(ee) {
                  return ee.add.length || ee.change.length;
                })) && !d) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), z.close(), l = z.version + 1, d = !0, T(y());
                fr(e, J);
              } catch {
              }
              Rn.push(e), z.onversionchange = Ze(function(ee) {
                n.vcFired = !0, e.on("versionchange").fire(ee);
              }), z.onclose = Ze(function(ee) {
                e.on("close").fire(ee);
              }), g && (q = e._deps, J = N, z = q.indexedDB, q = q.IDBKeyRange, uo(z) || J === ar || lo(z, q).put({ name: J }).catch(S)), T();
            }, w);
          }).catch(function(T) {
            switch (T?.name) {
              case "UnknownError":
                if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), y();
                break;
              case "VersionError":
                if (0 < l) return l = 0, y();
            }
            return se.reject(T);
          });
        }
        var b, _ = n.dbReadyResolve, R = null, g = !1;
        return se.race([a, (typeof navigator > "u" ? se.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(T) {
          function w() {
            return indexedDB.databases().finally(T);
          }
          b = setInterval(w, 100), w();
        }).finally(function() {
          return clearInterval(b);
        }) : Promise.resolve()).then(y)]).then(function() {
          return m(), n.onReadyBeingFired = [], se.resolve(co(function() {
            return e.on.ready.fire(e.vip);
          })).then(function T() {
            if (0 < n.onReadyBeingFired.length) {
              var w = n.onReadyBeingFired.reduce(xe, S);
              return n.onReadyBeingFired = [], se.resolve(co(function() {
                return w(e.vip);
              })).then(T);
            }
          });
        }).finally(function() {
          n.openCanceller === a && (n.onReadyBeingFired = null, n.isBeingOpened = !1);
        }).catch(function(T) {
          n.dbOpenError = T;
          try {
            R && R.abort();
          } catch {
          }
          return a === n.openCanceller && e._close(), rt(T);
        }).finally(function() {
          n.openComplete = !0, _();
        }).then(function() {
          var T;
          return g && (T = {}, e.tables.forEach(function(w) {
            w.schema.indexes.forEach(function(N) {
              N.name && (T["idb://".concat(e.name, "/").concat(w.name, "/").concat(N.name)] = new ht(-1 / 0, [[[]]]));
            }), T["idb://".concat(e.name, "/").concat(w.name, "/")] = T["idb://".concat(e.name, "/").concat(w.name, "/:dels")] = new ht(-1 / 0, [[[]]]);
          }), en(Mn).fire(T), vo(T, !0)), e;
        });
      }
      function yo(e) {
        function n(d) {
          return e.next(d);
        }
        var o = l(n), a = l(function(d) {
          return e.throw(d);
        });
        function l(d) {
          return function(b) {
            var y = d(b), b = y.value;
            return y.done ? b : b && typeof b.then == "function" ? b.then(o, a) : p(b) ? Promise.all(b).then(o, a) : o(b);
          };
        }
        return l(n)();
      }
      function wr(e, n, o) {
        for (var a = p(e) ? e.slice() : [e], l = 0; l < o; ++l) a.push(n);
        return a;
      }
      var ts = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema, l = {}, d = [];
          function m(g, T, w) {
            var N = Kn(g), O = l[N] = l[N] || [], C = g == null ? 0 : typeof g == "string" ? 1 : g.length, I = 0 < T, I = s(s({}, w), { name: I ? "".concat(N, "(virtual-from:").concat(w.name, ")") : w.name, lowLevelIndex: w, isVirtual: I, keyTail: T, keyLength: C, extractKey: oo(g), unique: !I && w.unique });
            return O.push(I), I.isPrimaryKey || d.push(I), 1 < C && m(C === 2 ? g[0] : g.slice(0, C - 1), T + 1, w), O.sort(function(j, M) {
              return j.keyTail - M.keyTail;
            }), I;
          }
          n = m(a.primaryKey.keyPath, 0, a.primaryKey), l[":id"] = [n];
          for (var y = 0, b = a.indexes; y < b.length; y++) {
            var _ = b[y];
            m(_.keyPath, 0, _);
          }
          function R(g) {
            var T, w = g.query.index;
            return w.isVirtual ? s(s({}, g), { query: { index: w.lowLevelIndex, range: (T = g.query.range, w = w.keyTail, { type: T.type === 1 ? 2 : T.type, lower: wr(T.lower, T.lowerOpen ? e.MAX_KEY : e.MIN_KEY, w), lowerOpen: !0, upper: wr(T.upper, T.upperOpen ? e.MIN_KEY : e.MAX_KEY, w), upperOpen: !0 }) } }) : g;
          }
          return s(s({}, o), { schema: s(s({}, a), { primaryKey: n, indexes: d, getIndexByKeyPath: function(g) {
            return (g = l[Kn(g)]) && g[0];
          } }), count: function(g) {
            return o.count(R(g));
          }, query: function(g) {
            return o.query(R(g));
          }, openCursor: function(g) {
            var T = g.query.index, w = T.keyTail, N = T.isVirtual, O = T.keyLength;
            return N ? o.openCursor(R(g)).then(function(I) {
              return I && C(I);
            }) : o.openCursor(g);
            function C(I) {
              return Object.create(I, { continue: { value: function(j) {
                j != null ? I.continue(wr(j, g.reverse ? e.MAX_KEY : e.MIN_KEY, w)) : g.unique ? I.continue(I.key.slice(0, O).concat(g.reverse ? e.MIN_KEY : e.MAX_KEY, w)) : I.continue();
              } }, continuePrimaryKey: { value: function(j, M) {
                I.continuePrimaryKey(wr(j, e.MAX_KEY, w), M);
              } }, primaryKey: { get: function() {
                return I.primaryKey;
              } }, key: { get: function() {
                var j = I.key;
                return O === 1 ? j[0] : j.slice(0, O);
              } }, value: { get: function() {
                return I.value;
              } } });
            }
          } });
        } });
      } };
      function go(e, n, o, a) {
        return o = o || {}, a = a || "", u(e).forEach(function(l) {
          var d, m, y;
          $(n, l) ? (d = e[l], m = n[l], typeof d == "object" && typeof m == "object" && d && m ? (y = De(d)) !== De(m) ? o[a + l] = n[l] : y === "Object" ? go(d, m, o, a + l + ".") : d !== m && (o[a + l] = n[l]) : d !== m && (o[a + l] = n[l])) : o[a + l] = void 0;
        }), u(n).forEach(function(l) {
          $(e, l) || (o[a + l] = n[l]);
        }), o;
      }
      function bo(e, n) {
        return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey);
      }
      var ns = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return s(s({}, e), { table: function(n) {
          var o = e.table(n), a = o.schema.primaryKey;
          return s(s({}, o), { mutate: function(l) {
            var d = pe.trans, m = d.table(n).hook, y = m.deleting, b = m.creating, _ = m.updating;
            switch (l.type) {
              case "add":
                if (b.fire === S) break;
                return d._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "put":
                if (b.fire === S && _.fire === S) break;
                return d._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "delete":
                if (y.fire === S) break;
                return d._promise("readwrite", function() {
                  return R(l);
                }, !0);
              case "deleteRange":
                if (y.fire === S) break;
                return d._promise("readwrite", function() {
                  return function g(T, w, N) {
                    return o.query({ trans: T, values: !1, query: { index: a, range: w }, limit: N }).then(function(O) {
                      var C = O.result;
                      return R({ type: "delete", keys: C, trans: T }).then(function(I) {
                        return 0 < I.numFailures ? Promise.reject(I.failures[0]) : C.length < N ? { failures: [], numFailures: 0, lastResult: void 0 } : g(T, s(s({}, w), { lower: C[C.length - 1], lowerOpen: !0 }), N);
                      });
                    });
                  }(l.trans, l.range, 1e4);
                }, !0);
            }
            return o.mutate(l);
            function R(g) {
              var T, w, N, O = pe.trans, C = g.keys || bo(a, g);
              if (!C) throw new Error("Keys missing");
              return (g = g.type === "add" || g.type === "put" ? s(s({}, g), { keys: C }) : s({}, g)).type !== "delete" && (g.values = c([], g.values)), g.keys && (g.keys = c([], g.keys)), T = o, N = C, ((w = g).type === "add" ? Promise.resolve([]) : T.getMany({ trans: w.trans, keys: N, cache: "immutable" })).then(function(I) {
                var j = C.map(function(M, q) {
                  var z, te, J, ee = I[q], ae = { onerror: null, onsuccess: null };
                  return g.type === "delete" ? y.fire.call(ae, M, ee, O) : g.type === "add" || ee === void 0 ? (z = b.fire.call(ae, M, g.values[q], O), M == null && z != null && (g.keys[q] = M = z, a.outbound || ge(g.values[q], a.keyPath, M))) : (z = go(ee, g.values[q]), (te = _.fire.call(ae, z, M, ee, O)) && (J = g.values[q], Object.keys(te).forEach(function(ie) {
                    $(J, ie) ? J[ie] = te[ie] : ge(J, ie, te[ie]);
                  }))), ae;
                });
                return o.mutate(g).then(function(M) {
                  for (var q = M.failures, z = M.results, te = M.numFailures, M = M.lastResult, J = 0; J < C.length; ++J) {
                    var ee = (z || C)[J], ae = j[J];
                    ee == null ? ae.onerror && ae.onerror(q[J]) : ae.onsuccess && ae.onsuccess(g.type === "put" && I[J] ? g.values[J] : ee);
                  }
                  return { failures: q, results: z, numFailures: te, lastResult: M };
                }).catch(function(M) {
                  return j.forEach(function(q) {
                    return q.onerror && q.onerror(M);
                  }), Promise.reject(M);
                });
              });
            }
          } });
        } });
      } };
      function vi(e, n, o) {
        try {
          if (!n || n.keys.length < e.length) return null;
          for (var a = [], l = 0, d = 0; l < n.keys.length && d < e.length; ++l) ke(n.keys[l], e[d]) === 0 && (a.push(o ? me(n.values[l]) : n.values[l]), ++d);
          return a.length === e.length ? a : null;
        } catch {
          return null;
        }
      }
      var rs = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(n) {
          var o = e.table(n);
          return s(s({}, o), { getMany: function(a) {
            if (!a.cache) return o.getMany(a);
            var l = vi(a.keys, a.trans._cache, a.cache === "clone");
            return l ? se.resolve(l) : o.getMany(a).then(function(d) {
              return a.trans._cache = { keys: a.keys, values: a.cache === "clone" ? me(d) : d }, d;
            });
          }, mutate: function(a) {
            return a.type !== "add" && (a.trans._cache = null), o.mutate(a);
          } });
        } };
      } };
      function yi(e, n) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound;
      }
      function gi(e, n) {
        switch (e) {
          case "query":
            return n.values && !n.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var os = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var n = e.schema.name, o = new ht(e.MIN_KEY, e.MAX_KEY);
        return s(s({}, e), { transaction: function(a, l, d) {
          if (pe.subscr && l !== "readonly") throw new G.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(pe.querier));
          return e.transaction(a, l, d);
        }, table: function(a) {
          var l = e.table(a), d = l.schema, m = d.primaryKey, g = d.indexes, y = m.extractKey, b = m.outbound, _ = m.autoIncrement && g.filter(function(w) {
            return w.compound && w.keyPath.includes(m.keyPath);
          }), R = s(s({}, l), { mutate: function(w) {
            function N(ie) {
              return ie = "idb://".concat(n, "/").concat(a, "/").concat(ie), M[ie] || (M[ie] = new ht());
            }
            var O, C, I, j = w.trans, M = w.mutatedParts || (w.mutatedParts = {}), q = N(""), z = N(":dels"), te = w.type, ae = w.type === "deleteRange" ? [w.range] : w.type === "delete" ? [w.keys] : w.values.length < 50 ? [bo(m, w).filter(function(ie) {
              return ie;
            }), w.values] : [], J = ae[0], ee = ae[1], ae = w.trans._cache;
            return p(J) ? (q.addKeys(J), (ae = te === "delete" || J.length === ee.length ? vi(J, ae) : null) || z.addKeys(J), (ae || ee) && (O = N, C = ae, I = ee, d.indexes.forEach(function(ie) {
              var le = O(ie.name || "");
              function Ee(Ce) {
                return Ce != null ? ie.extractKey(Ce) : null;
              }
              function je(Ce) {
                return ie.multiEntry && p(Ce) ? Ce.forEach(function(tt) {
                  return le.addKey(tt);
                }) : le.addKey(Ce);
              }
              (C || I).forEach(function(Ce, mt) {
                var Re = C && Ee(C[mt]), mt = I && Ee(I[mt]);
                ke(Re, mt) !== 0 && (Re != null && je(Re), mt != null && je(mt));
              });
            }))) : J ? (ee = { from: (ee = J.lower) !== null && ee !== void 0 ? ee : e.MIN_KEY, to: (ee = J.upper) !== null && ee !== void 0 ? ee : e.MAX_KEY }, z.add(ee), q.add(ee)) : (q.add(o), z.add(o), d.indexes.forEach(function(ie) {
              return N(ie.name).add(o);
            })), l.mutate(w).then(function(ie) {
              return !J || w.type !== "add" && w.type !== "put" || (q.addKeys(ie.results), _ && _.forEach(function(le) {
                for (var Ee = w.values.map(function(Re) {
                  return le.extractKey(Re);
                }), je = le.keyPath.findIndex(function(Re) {
                  return Re === m.keyPath;
                }), Ce = 0, tt = ie.results.length; Ce < tt; ++Ce) Ee[Ce][je] = ie.results[Ce];
                N(le.name).addKeys(Ee);
              })), j.mutatedParts = gr(j.mutatedParts || {}, M), ie;
            });
          } }), g = function(N) {
            var O = N.query, N = O.index, O = O.range;
            return [N, new ht((N = O.lower) !== null && N !== void 0 ? N : e.MIN_KEY, (O = O.upper) !== null && O !== void 0 ? O : e.MAX_KEY)];
          }, T = { get: function(w) {
            return [m, new ht(w.key)];
          }, getMany: function(w) {
            return [m, new ht().addKeys(w.keys)];
          }, count: g, query: g, openCursor: g };
          return u(T).forEach(function(w) {
            R[w] = function(N) {
              var O = pe.subscr, C = !!O, I = yi(pe, l) && gi(w, N) ? N.obsSet = {} : O;
              if (C) {
                var j = function(ee) {
                  return ee = "idb://".concat(n, "/").concat(a, "/").concat(ee), I[ee] || (I[ee] = new ht());
                }, M = j(""), q = j(":dels"), O = T[w](N), C = O[0], O = O[1];
                if ((w === "query" && C.isPrimaryKey && !N.values ? q : j(C.name || "")).add(O), !C.isPrimaryKey) {
                  if (w !== "count") {
                    var z = w === "query" && b && N.values && l.query(s(s({}, N), { values: !1 }));
                    return l[w].apply(this, arguments).then(function(ee) {
                      if (w === "query") {
                        if (b && N.values) return z.then(function(Ee) {
                          return Ee = Ee.result, M.addKeys(Ee), ee;
                        });
                        var ae = N.values ? ee.result.map(y) : ee.result;
                        (N.values ? M : q).addKeys(ae);
                      } else if (w === "openCursor") {
                        var ie = ee, le = N.values;
                        return ie && Object.create(ie, { key: { get: function() {
                          return q.addKey(ie.primaryKey), ie.key;
                        } }, primaryKey: { get: function() {
                          var Ee = ie.primaryKey;
                          return q.addKey(Ee), Ee;
                        } }, value: { get: function() {
                          return le && M.addKey(ie.primaryKey), ie.value;
                        } } });
                      }
                      return ee;
                    });
                  }
                  q.add(o);
                }
              }
              return l[w].apply(this, arguments);
            };
          }), R;
        } });
      } };
      function bi(e, n, o) {
        if (o.numFailures === 0) return n;
        if (n.type === "deleteRange") return null;
        var a = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
        return o.numFailures === a ? null : (n = s({}, n), p(n.keys) && (n.keys = n.keys.filter(function(l, d) {
          return !(d in o.failures);
        })), "values" in n && p(n.values) && (n.values = n.values.filter(function(l, d) {
          return !(d in o.failures);
        })), n);
      }
      function wo(e, n) {
        return o = e, ((a = n).lower === void 0 || (a.lowerOpen ? 0 < ke(o, a.lower) : 0 <= ke(o, a.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? ke(e, n.upper) < 0 : ke(e, n.upper) <= 0));
        var o, a;
      }
      function wi(e, n, T, a, l, d) {
        if (!T || T.length === 0) return e;
        var m = n.query.index, y = m.multiEntry, b = n.query.range, _ = a.schema.primaryKey.extractKey, R = m.extractKey, g = (m.lowLevelIndex || m).extractKey, T = T.reduce(function(w, N) {
          var O = w, C = [];
          if (N.type === "add" || N.type === "put") for (var I = new ht(), j = N.values.length - 1; 0 <= j; --j) {
            var M, q = N.values[j], z = _(q);
            I.hasKey(z) || (M = R(q), (y && p(M) ? M.some(function(ie) {
              return wo(ie, b);
            }) : wo(M, b)) && (I.addKey(z), C.push(q)));
          }
          switch (N.type) {
            case "add":
              var te = new ht().addKeys(n.values ? w.map(function(le) {
                return _(le);
              }) : w), O = w.concat(n.values ? C.filter(function(le) {
                return le = _(le), !te.hasKey(le) && (te.addKey(le), !0);
              }) : C.map(function(le) {
                return _(le);
              }).filter(function(le) {
                return !te.hasKey(le) && (te.addKey(le), !0);
              }));
              break;
            case "put":
              var J = new ht().addKeys(N.values.map(function(le) {
                return _(le);
              }));
              O = w.filter(function(le) {
                return !J.hasKey(n.values ? _(le) : le);
              }).concat(n.values ? C : C.map(function(le) {
                return _(le);
              }));
              break;
            case "delete":
              var ee = new ht().addKeys(N.keys);
              O = w.filter(function(le) {
                return !ee.hasKey(n.values ? _(le) : le);
              });
              break;
            case "deleteRange":
              var ae = N.range;
              O = w.filter(function(le) {
                return !wo(_(le), ae);
              });
          }
          return O;
        }, e);
        return T === e ? e : (T.sort(function(w, N) {
          return ke(g(w), g(N)) || ke(_(w), _(N));
        }), n.limit && n.limit < 1 / 0 && (T.length > n.limit ? T.length = n.limit : e.length === n.limit && T.length < n.limit && (l.dirty = !0)), d ? Object.freeze(T) : T);
      }
      function _i(e, n) {
        return ke(e.lower, n.lower) === 0 && ke(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen;
      }
      function is(e, n) {
        return function(o, a, l, d) {
          if (o === void 0) return a !== void 0 ? -1 : 0;
          if (a === void 0) return 1;
          if ((a = ke(o, a)) === 0) {
            if (l && d) return 0;
            if (l) return 1;
            if (d) return -1;
          }
          return a;
        }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(o, a, l, d) {
          if (o === void 0) return a !== void 0 ? 1 : 0;
          if (a === void 0) return -1;
          if ((a = ke(o, a)) === 0) {
            if (l && d) return 0;
            if (l) return -1;
            if (d) return 1;
          }
          return a;
        }(e.upper, n.upper, e.upperOpen, n.upperOpen);
      }
      function as(e, n, o, a) {
        e.subscribers.add(o), a.addEventListener("abort", function() {
          var l, d;
          e.subscribers.delete(o), e.subscribers.size === 0 && (l = e, d = n, setTimeout(function() {
            l.subscribers.size === 0 && Fe(d, l);
          }, 3e3));
        });
      }
      var ss = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var n = e.schema.name;
        return s(s({}, e), { transaction: function(o, a, l) {
          var d, m, y = e.transaction(o, a, l);
          return a === "readwrite" && (m = (d = new AbortController()).signal, l = function(b) {
            return function() {
              if (d.abort(), a === "readwrite") {
                for (var _ = /* @__PURE__ */ new Set(), R = 0, g = o; R < g.length; R++) {
                  var T = g[R], w = fn["idb://".concat(n, "/").concat(T)];
                  if (w) {
                    var N = e.table(T), O = w.optimisticOps.filter(function(le) {
                      return le.trans === y;
                    });
                    if (y._explicit && b && y.mutatedParts) for (var C = 0, I = Object.values(w.queries.query); C < I.length; C++) for (var j = 0, M = (te = I[C]).slice(); j < M.length; j++) po((J = M[j]).obsSet, y.mutatedParts) && (Fe(te, J), J.subscribers.forEach(function(le) {
                      return _.add(le);
                    }));
                    else if (0 < O.length) {
                      w.optimisticOps = w.optimisticOps.filter(function(le) {
                        return le.trans !== y;
                      });
                      for (var q = 0, z = Object.values(w.queries.query); q < z.length; q++) for (var te, J, ee, ae = 0, ie = (te = z[q]).slice(); ae < ie.length; ae++) (J = ie[ae]).res != null && y.mutatedParts && (b && !J.dirty ? (ee = Object.isFrozen(J.res), ee = wi(J.res, J.req, O, N, J, ee), J.dirty ? (Fe(te, J), J.subscribers.forEach(function(le) {
                        return _.add(le);
                      })) : ee !== J.res && (J.res = ee, J.promise = se.resolve({ result: ee }))) : (J.dirty && Fe(te, J), J.subscribers.forEach(function(le) {
                        return _.add(le);
                      })));
                    }
                  }
                }
                _.forEach(function(le) {
                  return le();
                });
              }
            };
          }, y.addEventListener("abort", l(!1), { signal: m }), y.addEventListener("error", l(!1), { signal: m }), y.addEventListener("complete", l(!0), { signal: m })), y;
        }, table: function(o) {
          var a = e.table(o), l = a.schema.primaryKey;
          return s(s({}, a), { mutate: function(d) {
            var m = pe.trans;
            if (l.outbound || m.db._options.cache === "disabled" || m.explicit || m.idbtrans.mode !== "readwrite") return a.mutate(d);
            var y = fn["idb://".concat(n, "/").concat(o)];
            return y ? (m = a.mutate(d), d.type !== "add" && d.type !== "put" || !(50 <= d.values.length || bo(l, d).some(function(b) {
              return b == null;
            })) ? (y.optimisticOps.push(d), d.mutatedParts && br(d.mutatedParts), m.then(function(b) {
              0 < b.numFailures && (Fe(y.optimisticOps, d), (b = bi(0, d, b)) && y.optimisticOps.push(b), d.mutatedParts && br(d.mutatedParts));
            }), m.catch(function() {
              Fe(y.optimisticOps, d), d.mutatedParts && br(d.mutatedParts);
            })) : m.then(function(b) {
              var _ = bi(0, s(s({}, d), { values: d.values.map(function(R, g) {
                var T;
                return b.failures[g] || (R = (T = l.keyPath) !== null && T !== void 0 && T.includes(".") ? me(R) : s({}, R), ge(R, l.keyPath, b.results[g])), R;
              }) }), b);
              y.optimisticOps.push(_), queueMicrotask(function() {
                return d.mutatedParts && br(d.mutatedParts);
              });
            }), m) : a.mutate(d);
          }, query: function(d) {
            if (!yi(pe, a) || !gi("query", d)) return a.query(d);
            var m = ((_ = pe.trans) === null || _ === void 0 ? void 0 : _.db._options.cache) === "immutable", g = pe, y = g.requery, b = g.signal, _ = function(N, O, C, I) {
              var j = fn["idb://".concat(N, "/").concat(O)];
              if (!j) return [];
              if (!(O = j.queries[C])) return [null, !1, j, null];
              var M = O[(I.query ? I.query.index.name : null) || ""];
              if (!M) return [null, !1, j, null];
              switch (C) {
                case "query":
                  var q = M.find(function(z) {
                    return z.req.limit === I.limit && z.req.values === I.values && _i(z.req.query.range, I.query.range);
                  });
                  return q ? [q, !0, j, M] : [M.find(function(z) {
                    return ("limit" in z.req ? z.req.limit : 1 / 0) >= I.limit && (!I.values || z.req.values) && is(z.req.query.range, I.query.range);
                  }), !1, j, M];
                case "count":
                  return q = M.find(function(z) {
                    return _i(z.req.query.range, I.query.range);
                  }), [q, !!q, j, M];
              }
            }(n, o, "query", d), R = _[0], g = _[1], T = _[2], w = _[3];
            return R && g ? R.obsSet = d.obsSet : (g = a.query(d).then(function(N) {
              var O = N.result;
              if (R && (R.res = O), m) {
                for (var C = 0, I = O.length; C < I; ++C) Object.freeze(O[C]);
                Object.freeze(O);
              } else N.result = me(O);
              return N;
            }).catch(function(N) {
              return w && R && Fe(w, R), Promise.reject(N);
            }), R = { obsSet: d.obsSet, promise: g, subscribers: /* @__PURE__ */ new Set(), type: "query", req: d, dirty: !1 }, w ? w.push(R) : (w = [R], (T = T || (fn["idb://".concat(n, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[d.query.index.name || ""] = w)), as(R, w, y, b), R.promise.then(function(N) {
              return { result: wi(N.result, d, T?.optimisticOps, a, R, m) };
            });
          } });
        } });
      } };
      function _r(e, n) {
        return new Proxy(e, { get: function(o, a, l) {
          return a === "db" ? n : Reflect.get(o, a, l);
        } });
      }
      var Wt = (ot.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new G.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new G.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var n = this._versions, o = n.filter(function(a) {
          return a._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), n.push(o), n.sort(Xa), o.stores({}), this._state.autoSchema = !1, o);
      }, ot.prototype._whenReady = function(e) {
        var n = this;
        return this.idbdb && (this._state.openComplete || pe.letThrough || this._vip) ? e() : new se(function(o, a) {
          if (n._state.openComplete) return a(new G.DatabaseClosed(n._state.dbOpenError));
          if (!n._state.isBeingOpened) {
            if (!n._state.autoOpen) return void a(new G.DatabaseClosed());
            n.open().catch(S);
          }
          n._state.dbReadyPromise.then(o, a);
        }).then(e);
      }, ot.prototype.use = function(e) {
        var n = e.stack, o = e.create, a = e.level, l = e.name;
        return l && this.unuse({ stack: n, name: l }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({ stack: n, create: o, level: a ?? 10, name: l }), e.sort(function(d, m) {
          return d.level - m.level;
        }), this;
      }, ot.prototype.unuse = function(e) {
        var n = e.stack, o = e.name, a = e.create;
        return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(l) {
          return a ? l.create !== a : !!o && l.name !== o;
        })), this;
      }, ot.prototype.open = function() {
        var e = this;
        return un(gt, function() {
          return es(e);
        });
      }, ot.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, n = Rn.indexOf(this);
        if (0 <= n && Rn.splice(n, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new se(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new se(function(o, a) {
          e.cancelOpen = a;
        }));
      }, ot.prototype.close = function(o) {
        var n = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        n ? (o.isBeingOpened && o.cancelOpen(new G.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new G.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, ot.prototype.delete = function(e) {
        var n = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", a = this._state;
        return new se(function(l, d) {
          function m() {
            n.close(e);
            var y = n._deps.indexedDB.deleteDatabase(n.name);
            y.onsuccess = Ze(function() {
              var b, _, R;
              b = n._deps, _ = n.name, R = b.indexedDB, b = b.IDBKeyRange, uo(R) || _ === ar || lo(R, b).delete(_).catch(S), l();
            }), y.onerror = Bt(d), y.onblocked = n._fireOnBlocked;
          }
          if (o) throw new G.InvalidArgument("Invalid closeOptions argument to db.delete()");
          a.isBeingOpened ? a.dbReadyPromise.then(m) : m();
        });
      }, ot.prototype.backendDB = function() {
        return this.idbdb;
      }, ot.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, ot.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, ot.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, ot.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(ot.prototype, "tables", { get: function() {
        var e = this;
        return u(this._allTables).map(function(n) {
          return e._allTables[n];
        });
      }, enumerable: !1, configurable: !0 }), ot.prototype.transaction = function() {
        var e = (function(n, o, a) {
          var l = arguments.length;
          if (l < 2) throw new G.InvalidArgument("Too few arguments");
          for (var d = new Array(l - 1); --l; ) d[l - 1] = arguments[l];
          return a = d.pop(), [n, oe(d), a];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, ot.prototype._transaction = function(e, n, o) {
        var a = this, l = pe.trans;
        l && l.db === this && e.indexOf("!") === -1 || (l = null);
        var d, m, y = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (m = n.map(function(_) {
            if (_ = _ instanceof a.Table ? _.name : _, typeof _ != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return _;
          }), e == "r" || e === Qr) d = Qr;
          else {
            if (e != "rw" && e != Jr) throw new G.InvalidArgument("Invalid transaction mode: " + e);
            d = Jr;
          }
          if (l) {
            if (l.mode === Qr && d === Jr) {
              if (!y) throw new G.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              l = null;
            }
            l && m.forEach(function(_) {
              if (l && l.storeNames.indexOf(_) === -1) {
                if (!y) throw new G.SubTransaction("Table " + _ + " not included in parent transaction.");
                l = null;
              }
            }), y && l && !l.active && (l = null);
          }
        } catch (_) {
          return l ? l._promise(null, function(R, g) {
            g(_);
          }) : rt(_);
        }
        var b = (function _(R, g, T, w, N) {
          return se.resolve().then(function() {
            var O = pe.transless || pe, C = R._createTransaction(g, T, R._dbSchema, w);
            if (C.explicit = !0, O = { trans: C, transless: O }, w) C.idbtrans = w.idbtrans;
            else try {
              C.create(), C.idbtrans._explicit = !0, R._state.PR1398_maxLoop = 3;
            } catch (M) {
              return M.name === L.InvalidState && R.isOpen() && 0 < --R._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), R.close({ disableAutoOpen: !1 }), R.open().then(function() {
                return _(R, g, T, null, N);
              })) : rt(M);
            }
            var I, j = Qe(N);
            return j && xn(), O = se.follow(function() {
              var M;
              (I = N.call(C, C)) && (j ? (M = Qt.bind(null, null), I.then(M, M)) : typeof I.next == "function" && typeof I.throw == "function" && (I = yo(I)));
            }, O), (I && typeof I.then == "function" ? se.resolve(I).then(function(M) {
              return C.active ? M : rt(new G.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : O.then(function() {
              return I;
            })).then(function(M) {
              return w && C._resolve(), C._completion.then(function() {
                return M;
              });
            }).catch(function(M) {
              return C._reject(M), rt(M);
            });
          });
        }).bind(null, this, d, m, l, o);
        return l ? l._promise(d, b, "lock") : pe.trans ? un(pe.transless, function() {
          return a._whenReady(b);
        }) : this._whenReady(b);
      }, ot.prototype.table = function(e) {
        if (!$(this._allTables, e)) throw new G.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, ot);
      function ot(e, n) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var a = ot.dependencies;
        this._options = n = s({ addons: ot.addons, autoOpen: !0, indexedDB: a.indexedDB, IDBKeyRange: a.IDBKeyRange, cache: "cloned" }, n), this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange }, a = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var l, d, m, y, b, _ = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: S, dbReadyPromise: null, cancelOpen: S, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: n.autoOpen };
        _.dbReadyPromise = new se(function(g) {
          _.dbReadyResolve = g;
        }), _.openCanceller = new se(function(g, T) {
          _.cancelOpen = T;
        }), this._state = _, this.name = e, this.on = kn(this, "populate", "blocked", "versionchange", "close", { ready: [xe, S] }), this.once = function(g, T) {
          var w = function() {
            for (var N = [], O = 0; O < arguments.length; O++) N[O] = arguments[O];
            o.on(g).unsubscribe(w), T.apply(o, N);
          };
          return o.on(g, w);
        }, this.on.ready.subscribe = E(this.on.ready.subscribe, function(g) {
          return function(T, w) {
            ot.vip(function() {
              var N, O = o._state;
              O.openComplete ? (O.dbOpenError || se.resolve().then(T), w && g(T)) : O.onReadyBeingFired ? (O.onReadyBeingFired.push(T), w && g(T)) : (g(T), N = o, w || g(function C() {
                N.on.ready.unsubscribe(T), N.on.ready.unsubscribe(C);
              }));
            });
          };
        }), this.Collection = (l = this, jn(Ua.prototype, function(I, C) {
          this.db = l;
          var w = Qo, N = null;
          if (C) try {
            w = C();
          } catch (j) {
            N = j;
          }
          var O = I._ctx, C = O.table, I = C.hook.reading.fire;
          this._ctx = { table: C, index: O.index, isPrimKey: !O.index || C.schema.primKey.keyPath && O.index === C.schema.primKey.name, range: w, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: N, or: O.or, valueMapper: I !== H ? I : null };
        })), this.Table = (d = this, jn(ti.prototype, function(g, T, w) {
          this.db = d, this._tx = w, this.name = g, this.schema = T, this.hook = d._allTables[g] ? d._allTables[g].hook : kn(null, { creating: [be, S], reading: [ue, H], updating: [Oe, S], deleting: [ve, S] });
        })), this.Transaction = (m = this, jn(Ga.prototype, function(g, T, w, N, O) {
          var C = this;
          g !== "readonly" && T.forEach(function(I) {
            I = (I = w[I]) === null || I === void 0 ? void 0 : I.yProps, I && (T = T.concat(I.map(function(j) {
              return j.updatesTable;
            })));
          }), this.db = m, this.mode = g, this.storeNames = T, this.schema = w, this.chromeTransactionDurability = N, this.idbtrans = null, this.on = kn(this, "complete", "error", "abort"), this.parent = O || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new se(function(I, j) {
            C._resolve = I, C._reject = j;
          }), this._completion.then(function() {
            C.active = !1, C.on.complete.fire();
          }, function(I) {
            var j = C.active;
            return C.active = !1, C.on.error.fire(I), C.parent ? C.parent._reject(I) : j && C.idbtrans && C.idbtrans.abort(), rt(I);
          });
        })), this.Version = (y = this, jn(Za.prototype, function(g) {
          this.db = y, this._cfg = { version: g, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (b = this, jn(si.prototype, function(g, T, w) {
          if (this.db = b, this._ctx = { table: g, index: T === ":id" ? null : T, or: w }, this._cmp = this._ascending = ke, this._descending = function(N, O) {
            return ke(O, N);
          }, this._max = function(N, O) {
            return 0 < ke(N, O) ? N : O;
          }, this._min = function(N, O) {
            return ke(N, O) < 0 ? N : O;
          }, this._IDBKeyRange = b._deps.IDBKeyRange, !this._IDBKeyRange) throw new G.MissingAPI();
        })), this.on("versionchange", function(g) {
          0 < g.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(g) {
          !g.newVersion || g.newVersion < g.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(g.oldVersion / 10));
        }), this._maxKey = Bn(n.IDBKeyRange), this._createTransaction = function(g, T, w, N) {
          return new o.Transaction(g, T, w, o._options.chromeTransactionDurability, N);
        }, this._fireOnBlocked = function(g) {
          o.on("blocked").fire(g), Rn.filter(function(T) {
            return T.name === o.name && T !== o && !T._state.vcFired;
          }).map(function(T) {
            return T.on("versionchange").fire(g);
          });
        }, this.use(rs), this.use(ss), this.use(os), this.use(ts), this.use(ns);
        var R = new Proxy(this, { get: function(g, T, w) {
          if (T === "_vip") return !0;
          if (T === "table") return function(O) {
            return _r(o.table(O), R);
          };
          var N = Reflect.get(g, T, w);
          return N instanceof ti ? _r(N, R) : T === "tables" ? N.map(function(O) {
            return _r(O, R);
          }) : T === "_createTransaction" ? function() {
            return _r(N.apply(this, arguments), R);
          } : N;
        } });
        this.vip = R, a.forEach(function(g) {
          return g(o);
        });
      }
      var Nr, Dt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", ls = (_o.prototype.subscribe = function(e, n, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: o });
      }, _o.prototype[Dt] = function() {
        return this;
      }, _o);
      function _o(e) {
        this._subscribe = e;
      }
      try {
        Nr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
      } catch {
        Nr = { indexedDB: null, IDBKeyRange: null };
      }
      function Ni(e) {
        var n, o = !1, a = new ls(function(l) {
          var d = Qe(e), m, y = !1, b = {}, _ = {}, R = { get closed() {
            return y;
          }, unsubscribe: function() {
            y || (y = !0, m && m.abort(), g && en.storagemutated.unsubscribe(w));
          } };
          l.start && l.start(R);
          var g = !1, T = function() {
            return Xr(N);
          }, w = function(O) {
            gr(b, O), po(_, b) && T();
          }, N = function() {
            var O, C, I;
            !y && Nr.indexedDB && (b = {}, O = {}, m && m.abort(), m = new AbortController(), I = function(j) {
              var M = _n();
              try {
                d && xn();
                var q = Xt(e, j);
                return q = d ? q.finally(Qt) : q;
              } finally {
                M && Nn();
              }
            }(C = { subscr: O, signal: m.signal, requery: T, querier: e, trans: null }), Promise.resolve(I).then(function(j) {
              o = !0, n = j, y || C.signal.aborted || (b = {}, function(M) {
                for (var q in M) if ($(M, q)) return;
                return 1;
              }(_ = O) || g || (en(Mn, w), g = !0), Xr(function() {
                return !y && l.next && l.next(j);
              }));
            }, function(j) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(j?.name) || y || Xr(function() {
                y || l.error && l.error(j);
              });
            }));
          };
          return setTimeout(T, 0), R;
        });
        return a.hasValue = function() {
          return o;
        }, a.getValue = function() {
          return n;
        }, a;
      }
      var pn = Wt;
      function No(e) {
        var n = tn;
        try {
          tn = !0, en.storagemutated.fire(e), vo(e, !0);
        } finally {
          tn = n;
        }
      }
      U(pn, s(s({}, st), { delete: function(e) {
        return new pn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new pn(e, { addons: [] }).open().then(function(n) {
          return n.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return n = pn.dependencies, o = n.indexedDB, n = n.IDBKeyRange, (uo(o) ? Promise.resolve(o.databases()).then(function(a) {
            return a.map(function(l) {
              return l.name;
            }).filter(function(l) {
              return l !== ar;
            });
          }) : lo(o, n).toCollection().primaryKeys()).then(e);
        } catch {
          return rt(new G.MissingAPI());
        }
        var n, o;
      }, defineClass: function() {
        return function(e) {
          v(this, e);
        };
      }, ignoreTransaction: function(e) {
        return pe.trans ? un(pe.transless, e) : e();
      }, vip: co, async: function(e) {
        return function() {
          try {
            var n = yo(e.apply(this, arguments));
            return n && typeof n.then == "function" ? n : se.resolve(n);
          } catch (o) {
            return rt(o);
          }
        };
      }, spawn: function(e, n, o) {
        try {
          var a = yo(e.apply(o, n || []));
          return a && typeof a.then == "function" ? a : se.resolve(a);
        } catch (l) {
          return rt(l);
        }
      }, currentTransaction: { get: function() {
        return pe.trans || null;
      } }, waitFor: function(e, n) {
        return n = se.resolve(typeof e == "function" ? pn.ignoreTransaction(e) : e).timeout(n || 6e4), pe.trans ? pe.trans.waitFor(n) : n;
      }, Promise: se, debug: { get: function() {
        return ye;
      }, set: function(e) {
        qe(e);
      } }, derive: P, extend: v, props: U, override: E, Events: kn, on: en, liveQuery: Ni, extendObservabilitySet: gr, getByKeyPath: de, setByKeyPath: ge, delByKeyPath: function(e, n) {
        typeof n == "string" ? ge(e, n, void 0) : "length" in n && [].map.call(n, function(o) {
          ge(e, o, void 0);
        });
      }, shallowClone: Ue, deepClone: me, getObjectDiff: go, cmp: ke, asap: we, minKey: -1 / 0, addons: [], connections: Rn, errnames: L, dependencies: Nr, cache: fn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, n, o) {
        return e + n / Math.pow(10, 2 * o);
      }) })), pn.maxKey = Bn(pn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (en(Mn, function(e) {
        tn || (e = new CustomEvent(to, { detail: e }), tn = !0, dispatchEvent(e), tn = !1);
      }), addEventListener(to, function(e) {
        e = e.detail, tn || No(e);
      }));
      var An, tn = !1, xi = function() {
      };
      return typeof BroadcastChannel < "u" && ((xi = function() {
        (An = new BroadcastChannel(to)).onmessage = function(e) {
          return e.data && No(e.data);
        };
      })(), typeof An.unref == "function" && An.unref(), en(Mn, function(e) {
        tn || An.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Wt.disableBfCache && e.persisted) {
          ye && console.debug("Dexie: handling persisted pagehide"), An?.close();
          for (var n = 0, o = Rn; n < o.length; n++) o[n].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Wt.disableBfCache && e.persisted && (ye && console.debug("Dexie: handling persisted pageshow"), xi(), No({ all: new ht(-1 / 0, [[]]) }));
      })), se.rejectionMapper = function(e, n) {
        return !e || e instanceof it || e instanceof TypeError || e instanceof SyntaxError || !e.name || !Z[e.name] ? e : (n = new Z[e.name](n || e.message, e), "stack" in e && A(n, "stack", { get: function() {
          return this.inner.stack;
        } }), n);
      }, qe(ye), s(Wt, Object.freeze({ __proto__: null, Dexie: Wt, liveQuery: Ni, Entity: Jo, cmp: ke, PropModification: $n, replacePrefix: function(e, n) {
        return new $n({ replacePrefix: [e, n] });
      }, add: function(e) {
        return new $n({ add: e });
      }, remove: function(e) {
        return new $n({ remove: e });
      }, default: Wt, RangeSet: ht, mergeRanges: Un, rangesOverlap: fi }), { default: Wt }), Wt;
    });
  }(js)), js.exports;
}
var Cp = Rp();
const $s = /* @__PURE__ */ gp(Cp), ru = Symbol.for("Dexie"), Fs = globalThis[ru] || (globalThis[ru] = $s);
if ($s.semVer !== Fs.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${$s.semVer} and ${Fs.semVer}`);
const {
  liveQuery: Kb,
  mergeRanges: qb,
  rangesOverlap: Ub,
  RangeSet: Vb,
  cmp: Wb,
  Entity: Gb,
  PropModification: Hb,
  replacePrefix: Yb,
  add: zb,
  remove: Xb,
  DexieYProvider: Qb
} = Fs;
function Te(t, r) {
  if (t) return;
  const i = "Invariant failed", s = r ? `${i}: ${r}` : i;
  throw console.error(s), new Error("Unexpected Error!");
}
function Op(t) {
  const r = {}, i = Object.keys(t).sort((s, c) => s.localeCompare(c));
  for (const s of i)
    r[s] = t[s];
  return r;
}
function ll(t) {
  return {
    addRecord: s,
    updateRecord: c,
    findChildRecords: p,
    findChildRecordsByTagName: v,
    findChildRecordsWithinDepthAndGivenTagName: k,
    ensureRelationship: f,
    removeRelationship: u,
    findParentRecordsWithinDepthAndGivenTagName: D,
    findRecord: $,
    findAncestors: i,
    generatePath: r,
    db: t
  };
  async function r(W) {
    const P = (await i(W)).filter((E) => !!Tp(E, "name")), B = kr(W, "name"), X = P.reverse().map((E) => kr(E, "name"));
    return X.push(B), X.join("/");
  }
  async function i(W, A = {}) {
    const { depth: P = 1 / 0, tagNames: B = [] } = A, X = B.length === 0, F = [];
    let E = W;
    for (let we = 0; we < P && E.parent?.id; we++) {
      const de = await t.table(Le).get(E.parent.id);
      if (!de)
        break;
      F.push(de), E = de;
    }
    return X ? F : F.filter((we) => B.includes(we.tagName));
  }
  async function s(W) {
    const A = { ...W, id: crypto.randomUUID() };
    try {
      return await t.table(Le).add(A), A;
    } catch (P) {
      const B = {
        msg: "could not add record",
        db: t.name,
        newRecord: A,
        err: P
      };
      throw console.error(B), new Error(JSON.stringify(B));
    }
  }
  async function c(W) {
    try {
      if (await t.table(Le).update(W.id, W) < 1) {
        const P = { msg: "nothing has been updated", record: W };
        throw console.error(P), new Error(JSON.stringify(P));
      }
    } catch (A) {
      console.error(A);
    }
  }
  async function f(W, A) {
    const P = W.children?.some((X) => X.id === A.id), B = A.parent?.id === W.id;
    if (P || (W.children.push({ id: A.id, tagName: A.tagName }), await c(W)), !B) {
      const X = {
        id: W.id,
        tagName: W.tagName
      };
      A.parent = X, await c(A);
    }
  }
  async function u(W, A) {
    A.parent = null, await c(A), W.children && (W.children = W.children.filter((P) => P.id !== A.id), await c(W));
  }
  async function p(W, A) {
    if (!W.children?.length)
      return [];
    let P = (await t.table(Le).bulkGet(W.children.map((B) => B.id))).filter(Boolean);
    return A?.tagNames && A.tagNames.length > 0 && (P = P.filter((B) => A?.tagNames?.includes(B.tagName))), A?.attrs && A.attrs.length > 0 && (P = P.filter(
      (B) => A.attrs.every(
        (X) => B.attributes.some(
          (F) => F.name === X.name && F.value === X.value
        )
      )
    )), P;
  }
  async function v(W, A) {
    return (await p(W)).filter((B) => A.includes(B.tagName));
  }
  async function k(W, A, P) {
    const B = [];
    let X = [W];
    for (let F = 0; F < A; F++) {
      const E = [];
      if (X.length === 0)
        break;
      for (const K of X) {
        const we = await p(K);
        we.length !== 0 && (E.push(...we), B.push(...we.filter((de) => P.includes(de.tagName))));
      }
      X = [...E];
    }
    return B;
  }
  async function D(W, A, P = []) {
    const B = [];
    let X = W;
    for (let F = 0; F < A; F++) {
      if (!X.parent)
        return B;
      const E = await t.table(Le).get(X.parent.id);
      if (!E)
        break;
      (P.length == 0 || P.length > 0 && P.includes(E.tagName)) && B.push(E), X = E;
    }
    return B;
  }
  async function $(W) {
    const [A] = await U(W);
    return A;
  }
  async function U(W) {
    try {
      const A = t.table(Le);
      let P = W.tagNames && W.tagNames.length > 0 ? A.where("tagName").anyOf(W.tagNames) : A.toCollection();
      return W.parent && (P = P.filter((X) => X.parent?.id === W.parent?.id)), W.attr && (P = P.filter((X) => X.attributes?.some(
        (E) => E.name === W.attr.name && E.value === W.attr.value
      ))), await P.toArray();
    } catch (A) {
      return console.error({ msg: "could not find records by options", options: W, err: A }), [];
    }
  }
}
function Tp(t, r) {
  return t.attributes?.find((i) => i.name === r);
}
function V(t, r) {
  return t?.attributes?.find((i) => i.name === r)?.value;
}
function kr(t, r) {
  const i = t.attributes.find((s) => s.name === r)?.value;
  return Te(i, `Attribute ${r} not found on record ${t.id}`), i;
}
const zt = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
}, Rc = { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" };
function Ep(t) {
  const r = ll(t), i = It();
  return {
    createControlledConnection: c,
    createConnection: s,
    createDestinationPlaceholder: f,
    createControlDestinationPlaceholder: u,
    createSourcePlaceholder: v,
    createControlSourcePlaceholder: p,
    calculateNextInputInstance: k,
    calculateNextOutputInstance: D,
    findExistingInputs: $,
    findExistingOutputs: U,
    findMatchingExtRef: W,
    implementDataflow: A,
    findExtRefByUuid: P,
    findControlBlock: B,
    findDataSet: X,
    findFcdasForDataSet: F,
    findPathToLnode: K,
    findPathToExtRef: E,
    findGseControlBlockDetails: we,
    findSmvControlBlockDetails: de,
    findReportControlBlockDetails: ge,
    findLnodeFunction: Ue,
    findProcessResourcesForLnode: Y
  };
  async function s(oe, ce, fe, me) {
    const Pe = await Ji(r, fe), De = await Up(
      r,
      ce,
      Pe,
      oe
    );
    await Vp(r, ce, oe), me && (await au(
      r,
      fe,
      De
    ), await ea(
      r,
      ce,
      fe,
      oe.type,
      oe.signal,
      oe.attribute
    ), oe.includeQuality && await ea(
      r,
      ce,
      fe,
      oe.type,
      oe.signal,
      "q"
    ), oe.includeTimestamp && await ea(
      r,
      ce,
      fe,
      oe.type,
      oe.signal,
      "t"
    )), await i.refreshConnections(), await i.refreshLNode(ce.id), await i.refreshPlaceholders();
  }
  async function c(oe, ce, fe, me) {
    const Pe = await Zi(r, ce), De = th(
      oe,
      fe
    ), Se = await ou(r, De);
    if (await r.ensureRelationship(Pe, Se), !fe.dataObjectSpecifications?.find(
      (Fe) => Fe.name === oe.controlledSignal
    )) {
      const Me = It().lnodeTypes.find(
        (Ht) => Ht.lnClass === fe.lnClass
      )?.dataObjects.find(
        (Ht) => Ht.name === oe.controlledSignal
      );
      let Qe = await Bo(
        r,
        fe,
        zt.prefix
      );
      const $t = {
        name: oe.controlledSignal,
        desc: Me?.desc || ""
      }, it = await ua(r, $t);
      await r.ensureRelationship(Qe, it);
    }
    me && (await su(r, ce, Se), await ea(
      r,
      ce,
      fe,
      oe.type,
      oe.controlledSignal
    )), await i.refreshConnections(), await i.refreshLNode(fe.id);
  }
  async function f(oe, ce, fe) {
    const me = await Ji(r, ce), Pe = await nh(oe), De = await la(r, Pe);
    await r.ensureRelationship(me, De), fe && await au(r, ce, [
      De
    ]), await i.refreshPlaceholders();
  }
  async function u(oe, ce, fe) {
    let me = [{ name: "outputName", value: oe.outputName }];
    if (oe.preferredLNode && me.push({ name: "pLN", value: oe.preferredLNode }), oe.processResourceId) {
      const Me = await r.db.table(Le).get(oe.processResourceId);
      Te(Me, "ProcessResource record not found");
      const Qe = await r.generatePath(Me);
      me.push({
        name: "resourceName",
        value: Qe
      }), me.push({
        name: "resourceUuid",
        value: kr(Me, "uuid")
      });
    }
    const Pe = ce.dataObjectSpecifications?.find(
      (Me) => Me.name === oe.dataObject
    ), De = It(), Ne = De.lnodeTypes.find(
      (Me) => Me.lnClass === ce.lnClass
    )?.dataObjects.find((Me) => Me.name === oe.dataObject);
    let Fe;
    if (Pe)
      Fe = await r.db.table(Le).get(Pe.id);
    else {
      const Me = await Bo(
        r,
        ce,
        zt.prefix
      ), Qe = {
        name: oe.dataObject,
        desc: Ne?.desc || ""
      };
      Fe = await ua(r, Qe), await r.ensureRelationship(Me, Fe);
    }
    if (!Fe) {
      const Me = "DOS element could not be found or created for destination placeholder";
      throw new Error(JSON.stringify(Me));
    }
    const pt = await r.addRecord({
      tagName: "ControllingLNode",
      attributes: me,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(Fe, pt), fe && await Yp(
      r,
      ce,
      oe.dataObject
    ), await De.refreshLNode(ce.id), await De.refreshPlaceholders();
  }
  async function p(oe, ce, fe) {
    const me = await Zi(r, ce), Pe = eh(oe), De = await ou(r, Pe);
    await r.ensureRelationship(me, De), fe && await su(r, ce, De), await i.refreshPlaceholders(), await i.refreshConnections();
  }
  async function v(oe, ce, fe) {
    let me = [{ name: "inputName", value: ce.inputName }];
    if (ce.preferredLNode && me.push({ name: "pLN", value: ce.preferredLNode }), ce.dataflowType && me.push({ name: "service", value: ce.dataflowType }), ce.processResourceId) {
      const it = await r.db.table(Le).get(ce.processResourceId);
      Te(it, "ProcessResource record not found");
      const Ht = await r.generatePath(it);
      me.push({
        name: "resourceName",
        value: Ht
      }), me.push({
        name: "resourceUuid",
        value: kr(it, "uuid")
      });
    }
    const Pe = oe.dataObjectSpecifications?.find(
      (it) => it.name === ce.dataObject
    ), De = Pe?.dataAttributeSpecifications.find(
      (it) => it.name === ce.dataAttribute
    ), Se = It(), Fe = Se.lnodeTypes.find((it) => it.lnClass === oe.lnClass)?.dataObjects.find((it) => it.name === ce.dataObject), pt = Fe?.dataAttributes.find((it) => it.name === ce.dataAttribute);
    let Me, Qe;
    if (Pe)
      Me = await r.db.table(Le).get(Pe.id);
    else {
      const it = await Bo(
        r,
        oe,
        zt.prefix
      ), Ht = {
        name: ce.dataObject,
        desc: Fe?.desc || ""
      };
      Me = await ua(r, Ht), await r.ensureRelationship(it, Me);
    }
    if (!Me) {
      const it = "DOS element could not be found or created for source placeholder";
      throw new Error(JSON.stringify(it));
    }
    if (De)
      Qe = await r.db.table(Le).get(De.id);
    else {
      const it = {
        name: ce.dataAttribute,
        desc: pt?.desc || ""
      };
      Qe = await Ic(
        r,
        it
      ), await r.ensureRelationship(Me, Qe);
    }
    if (!Qe) {
      const it = "DAS element could not be found or created for source placeholder";
      throw new Error(JSON.stringify(it));
    }
    const $t = await r.addRecord({
      tagName: "SubscriberLNode",
      attributes: me,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(Qe, $t), fe && await Hp(
      r,
      oe,
      ce.dataObject,
      ce.dataAttribute,
      ce.dataflowType || void 0
    ), await Se.refreshLNode(oe.id), await Se.refreshPlaceholders();
  }
  async function k(oe, ce, fe) {
    const me = await Ji(r, fe), Se = (await r.findChildRecordsByTagName(me, [
      "SourceRef"
    ])).map((Ne) => ({
      input: V(Ne, "input"),
      pDA: V(Ne, "pDA")
    })).filter(
      (Ne) => Ne.input === oe && Ne.pDA === ce
    );
    return Se.length === 0 ? 1 : Se.length + 1;
  }
  async function D(oe, ce) {
    const fe = await Zi(r, ce), De = (await r.findChildRecordsByTagName(fe, [
      "ControlRef"
    ])).map((Se) => V(Se, "output")).filter((Se) => !!Se).filter(
      (Se) => Se === oe
    );
    return De.length === 0 ? 1 : De.length + 1;
  }
  async function $(oe) {
    const ce = await Ji(r, oe), me = (await r.findChildRecordsByTagName(ce, [
      "SourceRef"
    ])).map((De) => V(De, "input")).filter((De) => !!De);
    return Array.from(new Set(me));
  }
  async function U(oe) {
    const ce = await Zi(r, oe), me = (await r.findChildRecordsByTagName(ce, [
      "ControlRef"
    ])).map((De) => V(De, "output")).filter((De) => !!De);
    return Array.from(new Set(me));
  }
  async function W(oe) {
    const ce = await r.db.table(Le).get(oe.id);
    Te(ce, "SourceRef record not found");
    const fe = V(ce, "extRefUuid");
    let me;
    if (fe) {
      if (me = await r.db.table(Le).where({ tagName: "ExtRef" }).and((Pe) => V(Pe, "uuid") === fe).first(), !me)
        throw new Error(`ExtRef with uuid ${fe} not found`);
    } else {
      const Pe = await Kp(r, oe);
      if (!Pe)
        return null;
      me = Pe;
    }
    return lu(me);
  }
  async function A(oe, ce) {
    if (Te(
      oe.sourceLNodeId && oe.destinationLNodeId,
      "Connection must have both source and destination LNode IDs to implement"
    ), Te(oe.dataflowType, "Connection must have a dataflow type to implement"), ce.srcCbName)
      throw new Error("Dataflow is already implemented (srcCBName exists in ExtRef)");
    if (![et.GOOSE, et.REPORT, et.SMV].includes(oe.dataflowType))
      throw new Error(
        `Dataflow type ${oe.dataflowType} is not supported for automatic implementation`
      );
    const me = await r.db.table(Le).get(oe.sourceLNodeId);
    Te(me, "Sending LNode record not found");
    const Pe = await r.db.table(Le).get(oe.destinationLNodeId);
    Te(Pe, "Receiving LNode record not found");
    const De = await dl(
      r,
      oe.sourceLNodeId
    );
    Te(De, "LDevice of sending LNode not found");
    const Se = (await r.findChildRecords(De, { tagNames: ["LN0"] }))[0];
    Te(Se, "LN0 record not found for LDevice");
    const Ne = await Lp(
      r,
      oe,
      me,
      Pe,
      De,
      Se
    ), Fe = await Sp(
      r,
      oe.dataflowType,
      V(Ne, "name") || "",
      Se
    );
    yn(
      Ne,
      "datSet",
      V(Fe, "name") || ""
    ), await r.updateRecord(Ne), await Pp(
      r,
      oe,
      me,
      Fe
    ), await Ip(
      r,
      oe.dataflowType,
      De,
      Ne
    ), await Mp(
      r,
      oe,
      ce,
      V(Ne, "name") || ""
    ), await Bp(
      r,
      oe,
      Pe,
      ce
    ), await i.refreshConnections();
  }
  async function P(oe) {
    const ce = await r.findRecord({
      tagNames: ["ExtRef"],
      attr: { name: "uuid", value: oe }
    });
    return Te(ce, `ExtRef record not found for uuid: ${oe}`), lu(ce);
  }
  async function B(oe, ce, fe) {
    const me = await r.findRecord({
      tagNames: ["IED"],
      attr: { name: "name", value: oe }
    });
    Te(me, "IED record not found");
    const Pe = await r.findChildRecordsWithinDepthAndGivenTagName(me, 3, ["LDevice"]).then((Ne) => Ne.find((Fe) => V(Fe, "inst") === ce));
    Te(Pe, "LDevice record not found");
    const [De] = await r.findChildRecordsByTagName(Pe, ["LN0"]);
    Te(De, "LN0 record not found for LDevice");
    const [Se] = await r.findChildRecords(De, {
      tagNames: ["GSEControl", "SampledValueControl", "ReportControl"],
      attrs: [{ name: "name", value: fe }]
    });
    return Te(Se, "Control Block record not found"), Qp(Se);
  }
  async function X(oe, ce, fe) {
    const me = await r.findRecord({
      tagNames: ["IED"],
      attr: { name: "name", value: oe }
    });
    Te(me, "IED record not found");
    const Pe = await r.findChildRecordsWithinDepthAndGivenTagName(me, 3, ["LDevice"]).then((Ne) => Ne.find((Fe) => V(Fe, "inst") === ce));
    Te(Pe, "LDevice record not found");
    const [De] = await r.findChildRecordsByTagName(Pe, ["LN0"]);
    Te(De, "LN0 record not found for LDevice");
    const [Se] = await r.findChildRecords(De, {
      tagNames: ["DataSet"],
      attrs: [{ name: "name", value: fe }]
    });
    return Te(Se, "DataSet record not found"), Jp(Se);
  }
  async function F(oe) {
    const ce = await r.db.table(Le).get(oe);
    return Te(ce, "DataSet record not found"), (await r.findChildRecordsByTagName(ce, ["FCDA"])).map(Zp);
  }
  async function E(oe) {
    const ce = await r.db.table(Le).get(oe);
    Te(ce, "ExtRef record not found");
    let fe = V(ce, "intAddr") || "";
    const me = ["LN", "LDevice", "IED"];
    let Pe = ce;
    for (; Pe.parent; ) {
      const De = await r.db.table(Le).get(Pe.parent.id);
      if (Te(De, "Parent record not found"), me.includes(De.tagName)) {
        let Se = "";
        De.tagName === "LN" ? Se = `${V(De, "prefix") ?? ""}${V(De, "lnClass")}${V(De, "inst") ?? ""}` : De.tagName === "LDevice" ? Se = V(De, "inst") || "" : Se = V(De, "name") || "", fe = `${Se}/${fe}`;
      }
      Pe = De;
    }
    return fe;
  }
  async function K(oe) {
    const ce = await r.db.table(Le).get(oe);
    Te(ce, "LNode record not found");
    let me = `${V(ce, "prefix") ?? ""}${V(ce, "lnClass")}${V(ce, "lnInst") ?? ""}`;
    const Pe = ["SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
    let De = ce;
    for (; De.parent; ) {
      const Se = await r.db.table(Le).get(De.parent.id);
      Te(Se, "Parent record not found"), Pe.includes(Se.tagName) && (me = `${V(Se, "name")}/${me}`), De = Se;
    }
    return me;
  }
  async function we(oe, ce) {
    const fe = await r.db.table(Le).get(oe);
    Te(fe, "Control Block record not found");
    const me = await r.db.table(Le).where({ tagName: "GSE" }).and(
      (Qe) => V(Qe, "cbName") === V(fe, "name") && V(Qe, "ldInst") === ce
    ).first();
    Te(me, "GSE Communication record not found for Control Block");
    const [Pe] = await r.findChildRecordsByTagName(me, [
      "MinTime"
    ]), [De] = await r.findChildRecordsByTagName(me, [
      "MaxTime"
    ]), Se = await r.findChildRecordsWithinDepthAndGivenTagName(
      me,
      2,
      ["P"]
    ), Ne = Se.find(
      (Qe) => V(Qe, "type") === "VLAN-ID" || V(Qe, "type") === "tP_VLAN-ID"
    ), Fe = Se.find(
      (Qe) => V(Qe, "type") === "VLAN-PRIORITY" || V(Qe, "type") === "tP_VLAN-PRIORITY"
    ), pt = Se.find(
      (Qe) => V(Qe, "type") === "MAC-Address" || V(Qe, "type") === "tP_MAC-Address"
    ), Me = Se.find(
      (Qe) => V(Qe, "type") === "APPID" || V(Qe, "type") === "tP_APPID"
    );
    return {
      appId: V(fe, "appID") || "",
      communicationDetails: {
        macAddress: pt?.value || "",
        appId: Me?.value || "",
        vlanId: Ne?.value || "",
        vlanPriority: Fe?.value || "",
        minTime: Pe?.value || "",
        maxTime: De?.value || ""
      }
    };
  }
  async function de(oe, ce) {
    const fe = await r.db.table(Le).get(oe);
    Te(fe, "Control Block record not found");
    const [me] = await r.findChildRecordsByTagName(fe, [
      "SmvOpts"
    ]);
    Te(me, "SmvOpts record not found for Control Block");
    const Pe = await r.db.table(Le).where({ tagName: "SMV" }).and(
      (Me) => V(Me, "cbName") === V(fe, "name") && V(Me, "ldInst") === ce
    ).first();
    Te(Pe, "SMV Communication record not found for Control Block");
    const De = await r.findChildRecordsWithinDepthAndGivenTagName(
      Pe,
      2,
      ["P"]
    ), Se = De.find(
      (Me) => V(Me, "type") === "VLAN-ID" || V(Me, "type") === "tP_VLAN-ID"
    ), Ne = De.find(
      (Me) => V(Me, "type") === "VLAN-PRIORITY" || V(Me, "type") === "tP_VLAN-PRIORITY"
    ), Fe = De.find(
      (Me) => V(Me, "type") === "MAC-Address" || V(Me, "type") === "tP_MAC-Address"
    ), pt = De.find(
      (Me) => V(Me, "type") === "APPID" || V(Me, "type") === "tP_APPID"
    );
    return {
      smvId: V(fe, "smvID") || "",
      multicast: V(fe, "multicast") || "",
      nofAsdu: V(fe, "nofASDU") || "",
      smpMod: V(fe, "smpMod") || "",
      smpRate: V(fe, "smpRate") || "",
      communicationDetails: {
        macAddress: Fe?.value || "",
        appId: pt?.value || "",
        vlanId: Se?.value || "",
        vlanPriority: Ne?.value || ""
      },
      smvOpts: {
        refreshTime: V(me, "refreshTime") || "",
        sampleSynchronized: V(me, "sampleSynchronized") || "",
        sampleRate: V(me, "sampleRate") || "",
        dataSet: V(me, "dataSet") || "",
        security: V(me, "security") || "",
        synchSourceId: V(me, "synchSourceId") || ""
      }
    };
  }
  async function ge(oe) {
    const ce = await r.db.table(Le).get(oe);
    Te(ce, "Control Block record not found");
    const [fe] = await r.findChildRecordsByTagName(ce, [
      "TrgOps"
    ]);
    Te(fe, "TrgOps record not found for Control Block");
    const [me] = await r.findChildRecordsByTagName(ce, [
      "OptFields"
    ]);
    return Te(me, "OptFields record not found for Control Block"), {
      rptId: V(ce, "rptID") || "",
      buffered: V(ce, "buffered") || "",
      trgOps: {
        dchg: V(fe, "dchg") || "",
        dupd: V(fe, "dupd") || "",
        gi: V(fe, "gi") || "",
        period: V(fe, "period") || "",
        qchg: V(fe, "qchg") || ""
      },
      optFields: {
        bufOvfl: V(me, "bufOvfl") || "",
        configRef: V(me, "configRef") || "",
        dataRef: V(me, "dataRef") || "",
        dataSet: V(me, "dataSet") || "",
        entryId: V(me, "entryID") || "",
        reasonCode: V(me, "reasonCode") || "",
        seqNum: V(me, "seqNum") || "",
        timeStamp: V(me, "timeStamp") || ""
      }
    };
  }
  async function Ue(oe) {
    const ce = await r.db.table(Le).get(oe);
    Te(ce, "LNode record not found"), Te(ce.parent, "LNode has no parent");
    const fe = await r.db.table(Le).get(ce.parent.id);
    return Te(fe, "Function record not found for LNode"), V(fe, "name") ?? "";
  }
  async function Y(oe) {
    const ce = await r.db.table(Le).get(oe);
    Te(ce, "LNode record not found");
    const fe = [];
    let me = ce;
    for (; me.parent && (me.parent.tagName == "Function" || me.parent.tagName == "SubFunction"); ) {
      const Pe = await r.db.table(Le).get(me.parent.id);
      Te(Pe, "Parent record not found");
      const De = await r.findChildRecordsWithinDepthAndGivenTagName(
        Pe,
        3,
        // Expected hierarchy: Private, ProcessResources, ProcessResource
        ["ProcessResource"]
      );
      fe.push(...De), me = Pe;
    }
    return fe;
  }
}
async function Ip(t, r, i, s) {
  const c = await t.db.table(Le).where({ tagName: "Communication" }).first();
  Te(c, "Communication record not found in SCL");
  const f = await t.findChildRecordsWithinDepthAndGivenTagName(
    c,
    2,
    ["ConnectedAP"]
  ), [u] = await t.findParentRecordsWithinDepthAndGivenTagName(
    s,
    4,
    ["AccessPoint"]
  );
  Te(u, "AccessPoint record not found"), Te(u.parent, "AccessPoint has no parent");
  const p = await t.db.table(Le).get(u.parent.id);
  Te(p, "IED record not found");
  const v = f.find(
    (D) => V(D, "iedName") === V(p, "name") && V(D, "apName") === V(u, "name")
  );
  Te(v, "ConnectedAP record for sending IED not found");
  const k = V(s, "name") || "";
  r === et.GOOSE && await Dp(
    t,
    i,
    k,
    v
  ), r === et.SMV && await Ap(
    t,
    i,
    k,
    v
  );
}
async function Ap(t, r, i, s) {
  if ((await t.findChildRecords(s, {
    tagNames: ["SMV"],
    attrs: [
      { name: "cbName", value: i },
      {
        name: "ldInst",
        value: V(r, "inst") || ""
      }
    ]
  }))[0])
    return;
  const f = await t.db.table(Le).where({ tagName: "SMV" }).toArray(), u = await t.addRecord({
    tagName: "SMV",
    attributes: [
      { name: "cbName", value: i },
      { name: "ldInst", value: V(r, "inst") || "" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(s, u);
  const p = await t.addRecord({
    tagName: "Address",
    attributes: [],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(u, p);
  const v = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-ID",
        namespace: Rc
      },
      { name: "type", value: "VLAN-ID" }
    ],
    parent: null,
    namespace: Et.default,
    value: "000",
    children: []
  });
  await t.ensureRelationship(p, v);
  const k = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-PRIORITY",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "VLAN-PRIORITY" }
    ],
    parent: null,
    namespace: Et.default,
    value: "7",
    children: []
  });
  await t.ensureRelationship(p, k);
  const D = [], $ = [];
  for (const B of f) {
    const X = await t.findChildRecords(B, {
      tagNames: ["Address"]
    });
    Te(X[0], "Address record not found in SMV communication");
    const F = await t.findChildRecords(X[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "MAC-Address" }]
    });
    if (F[0]) {
      const K = F[0].value;
      D.push(K);
    }
    const E = await t.findChildRecords(X[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "APPID" }]
    });
    if (E[0]) {
      const K = E[0].value;
      $.push(K);
    }
  }
  const U = Cc(
    262144,
    262655,
    D
  ), W = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_MAC-Address",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "MAC-Address" }
    ],
    parent: null,
    namespace: Et.default,
    value: U,
    children: []
  });
  await t.ensureRelationship(p, W);
  const A = Oc(16384, 32767, $), P = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_APPID",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "APPID" }
    ],
    parent: null,
    namespace: Et.default,
    value: A,
    children: []
  });
  await t.ensureRelationship(p, P);
}
async function Dp(t, r, i, s) {
  if ((await t.findChildRecords(s, {
    tagNames: ["GSE"],
    attrs: [
      { name: "cbName", value: i },
      {
        name: "ldInst",
        value: V(r, "inst") || ""
      }
    ]
  }))[0])
    return;
  const f = await t.db.table(Le).where({ tagName: "GSE" }).toArray(), u = await t.addRecord({
    tagName: "GSE",
    attributes: [
      { name: "cbName", value: i },
      { name: "ldInst", value: V(r, "inst") || "" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(s, u);
  const p = await t.addRecord({
    tagName: "Address",
    attributes: [],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(u, p);
  const v = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-ID",
        namespace: Rc
      },
      { name: "type", value: "VLAN-ID" }
    ],
    parent: null,
    namespace: Et.default,
    value: "000",
    children: []
  });
  await t.ensureRelationship(p, v);
  const k = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_VLAN-PRIORITY",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "VLAN-PRIORITY" }
    ],
    parent: null,
    namespace: Et.default,
    value: "4",
    children: []
  });
  await t.ensureRelationship(p, k);
  const D = [], $ = [];
  for (const F of f) {
    const E = await t.findChildRecords(F, {
      tagNames: ["Address"]
    });
    Te(E[0], "Address record not found in SMV communication");
    const K = await t.findChildRecords(E[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "MAC-Address" }]
    });
    if (K[0]) {
      const de = K[0].value;
      D.push(de);
    }
    const we = await t.findChildRecords(E[0], {
      tagNames: ["P"],
      attrs: [{ name: "type", value: "APPID" }]
    });
    if (we[0]) {
      const de = we[0].value;
      $.push(de);
    }
  }
  const U = Cc(
    65536,
    66047,
    D
  ), W = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_MAC-Address",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "MAC-Address" }
    ],
    parent: null,
    namespace: Et.default,
    value: U,
    children: []
  });
  await t.ensureRelationship(p, W);
  const A = Oc(1, 16383, $), P = await t.addRecord({
    tagName: "P",
    attributes: [
      {
        name: "type",
        value: "tP_APPID",
        namespace: { prefix: "xsi", uri: "http://www.w3.org/2001/XMLSchema-instance" }
      },
      { name: "type", value: "APPID" }
    ],
    parent: null,
    namespace: Et.default,
    value: A,
    children: []
  });
  await t.ensureRelationship(p, P);
  const B = await t.addRecord({
    tagName: "MinTime",
    attributes: [
      { name: "multiplier", value: "m" },
      { name: "unit", value: "s" }
    ],
    parent: null,
    namespace: Et.default,
    value: "5",
    children: []
  });
  await t.ensureRelationship(u, B);
  const X = await t.addRecord({
    tagName: "MaxTime",
    attributes: [
      { name: "multiplier", value: "m" },
      { name: "unit", value: "s" }
    ],
    parent: null,
    namespace: Et.default,
    value: "10000",
    children: []
  });
  await t.ensureRelationship(u, X);
}
function Cc(t, r, i) {
  const s = "01-0C-CD";
  for (let c = t; c <= r; c++) {
    const f = c.toString(16).toUpperCase().padStart(6, "0"), u = `${f.slice(0, 2)}-${f.slice(2, 4)}-${f.slice(4, 6)}`, p = s + "-" + u;
    if (!i.includes(p))
      return p;
  }
  throw new Error("No available MAC Address found in the specified range");
}
function Oc(t, r, i) {
  for (let s = t; s <= r; s++) {
    const c = s.toString(16).toUpperCase().padStart(4, "0");
    if (!i.includes(c))
      return c;
  }
  throw new Error("No available APPID found in the specified range");
}
async function Pp(t, r, i, s) {
  const p = It().lnodeTypes.find(
    (D) => D.typeId === V(i, "lnType") && D.lnClass === V(i, "lnClass")
  )?.dataObjects.find((D) => D.name === r.sourceDataObject)?.dataAttributes?.find((D) => D.name === r.sourceDataAttribute), v = (await t.findChildRecords(s, {
    tagNames: ["FCDA"],
    attrs: [
      { name: "daName", value: r.sourceDataAttribute },
      { name: "doName", value: r.sourceDataObject },
      { name: "fc", value: p?.fc || "" },
      { name: "ldInst", value: V(i, "ldInst") || "" },
      { name: "lnClass", value: V(i, "lnClass") || "" },
      { name: "lnInst", value: V(i, "lnInst") || "" },
      { name: "prefix", value: V(i, "prefix") || "" }
    ]
  }))[0];
  if (v)
    return v;
  const k = await t.addRecord({
    tagName: "FCDA",
    attributes: [
      { name: "daName", value: r.sourceDataAttribute },
      { name: "doName", value: r.sourceDataObject },
      { name: "fc", value: p?.fc || "" },
      { name: "ldInst", value: V(i, "ldInst") || "" },
      { name: "lnClass", value: V(i, "lnClass") || "" },
      { name: "lnInst", value: V(i, "lnInst") || "" },
      { name: "prefix", value: V(i, "prefix") || "" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(s, k), k;
}
async function Sp(t, r, i, s) {
  let c;
  if (r === et.SMV) {
    const p = i.slice(i.length - 2);
    c = "PhsMeas" + parseInt(p, 10);
  } else
    c = i + "_DS";
  const f = (await t.findChildRecords(s, {
    tagNames: ["DataSet"],
    attrs: [{ name: "name", value: c }]
  }))[0];
  if (f)
    return f;
  const u = await t.addRecord({
    tagName: "DataSet",
    attributes: [{ name: "name", value: c }],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(s, u), u;
}
async function Lp(t, r, i, s, c, f) {
  const u = (await t.findParentRecordsWithinDepthAndGivenTagName(i, 1 / 0, [
    "Function"
  ]))[0];
  Te(u, "Parent Function of sending LNode not found when implementing dataflow");
  let p;
  if (r.dataflowType === et.GOOSE && (p = await Fp(
    t,
    i,
    s,
    u,
    c,
    f
  )), r.dataflowType === et.SMV && (p = await jp(
    t,
    i,
    s,
    c,
    f
  )), r.dataflowType === et.REPORT) {
    const k = V(i, "lnClass") === "MMXU";
    p = await kp(
      t,
      i,
      s,
      u,
      c,
      f,
      k
    );
  }
  return Te(p, "Control Block record could not be created"), p;
}
async function kp(t, r, i, s, c, f, u) {
  const p = (V(s, "name") + "_RPT").replace(" ", "_"), v = V(i, "iedName");
  Te(v, "iedName of receiving LNode not found");
  const k = await t.findChildRecordsByTagName(f, [
    "ReportControl"
  ]);
  for (const K of k) {
    const de = V(K, "name")?.startsWith(p), ge = (await t.findChildRecordsWithinDepthAndGivenTagName(K, 2, [
      "ClientLN"
    ]))[0];
    Te(ge, "ClientLN record inside ReportControl not found");
    const Ue = V(ge, "iedName") === v;
    if (de && Ue)
      return ul(t, K), K;
  }
  const $ = k.filter(
    (K) => V(K, "name")?.startsWith(p) ?? !1
  ).length + 1, U = p + $, W = cl(
    r,
    c,
    U
  ), A = {
    tagName: "ReportControl",
    attributes: [
      { name: "name", value: U },
      { name: "confRev", value: "1" },
      { name: "rptID", value: W }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  };
  u ? A.attributes.push({ name: "buffered", value: "false" }) : (A.attributes.push({ name: "buffered", value: "true" }), A.attributes.push({ name: "bufTime", value: "100" }));
  const P = await t.addRecord(A);
  await t.ensureRelationship(f, P);
  const B = {
    tagName: "TrgOps",
    attributes: [
      { name: "dchg", value: "true" },
      { name: "dupd", value: "false" },
      { name: "gi", value: "true" },
      { name: "period", value: "false" },
      { name: "qchg", value: "true" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  };
  u ? B.attributes.push({ name: "dupd", value: "true" }) : B.attributes.push({ name: "dupd", value: "false" });
  const X = await t.addRecord(B);
  await t.ensureRelationship(P, X);
  const F = await t.addRecord({
    tagName: "OptFields",
    attributes: [
      { name: "bufOvfl", value: "false" },
      { name: "configRef", value: "true" },
      { name: "dataRef", value: "true" },
      { name: "dataSet", value: "true" },
      { name: "entryID", value: "true" },
      { name: "reasonCode", value: "true" },
      { name: "seqNum", value: "true" },
      { name: "timeStamp", value: "true" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(P, F);
  const E = await t.addRecord({
    tagName: "RptEnabled",
    attributes: [{ name: "max", value: "5" }],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(P, E), await $p(t, E, i), P;
}
async function ul(t, r) {
  const i = V(r, "confRev"), s = i ? parseInt(i, 10) + 1 : 1;
  yn(r, "confRev", s.toString()), await t.updateRecord(r);
}
async function jp(t, r, i, s, c) {
  const f = V(i, "iedName");
  Te(f, "iedName of receiving LNode not found");
  const u = await t.findChildRecordsByTagName(c, [
    "SampledValueControl"
  ]);
  for (const W of u) {
    const A = (await t.findChildRecordsByTagName(W, ["IEDName"]))[0];
    if (Te(A, "IEDName record inside SampledValueControl not found"), A.value === f)
      return ul(t, W), W;
  }
  const p = "MSVCB", v = u.length + 1;
  if (v > 99)
    throw new Error("Maximum number of SampledValueControl elements (99) exceeded");
  const k = p + v.toString().padStart(2, "0"), D = cl(
    r,
    s,
    k
  ), $ = await t.addRecord({
    tagName: "SampledValueControl",
    attributes: [
      { name: "name", value: k },
      { name: "confRev", value: "1" },
      { name: "smvID", value: D },
      { name: "multicast", value: "true" },
      { name: "nofASDU", value: "2" },
      { name: "smpMod", value: "SmpPerSec" },
      { name: "smpRate", value: "80" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(c, $), await Tc(t, $, f);
  const U = await t.addRecord({
    tagName: "SmvOpts",
    attributes: [
      { name: "refreshTime", value: "false" },
      { name: "sampleSynchronized", value: "true" },
      { name: "sampleRate", value: "false" },
      { name: "dataSet", value: "false" },
      { name: "security", value: "false" },
      { name: "synchSourceId", value: "true" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship($, U), $;
}
async function Tc(t, r, i) {
  const s = await t.db.table(Le).where({ tagName: "IED" }).and((u) => V(u, "name") === i).first();
  Te(s, "IED record of receiving LNode not found");
  const c = (await t.findChildRecordsByTagName(s, ["AccessPoint"]))[0];
  Te(c, "AccessPoint record of receiving IED not found");
  const f = await t.addRecord({
    tagName: "IEDName",
    attributes: [
      {
        name: "apRef",
        value: V(c, "name") || ""
      }
    ],
    parent: null,
    namespace: Et.default,
    value: i || "",
    children: []
  });
  await t.ensureRelationship(r, f);
}
async function $p(t, r, i) {
  const s = V(i, "iedName"), c = await t.db.table(Le).where({ tagName: "IED" }).and((p) => V(p, "name") === s).first();
  Te(c, "IED record of receiving LNode not found");
  const f = (await t.findChildRecordsByTagName(c, ["AccessPoint"]))[0];
  Te(f, "AccessPoint record of receiving IED not found");
  const u = await t.addRecord({
    tagName: "ClientLN",
    attributes: [
      {
        name: "apRef",
        value: V(f, "name") || ""
      },
      { name: "iedName", value: s || "" },
      { name: "ldInst", value: V(i, "ldInst") || "" },
      { name: "prefix", value: V(i, "prefix") || "" },
      { name: "lnClass", value: V(i, "lnClass") || "" },
      { name: "lnInst", value: V(i, "lnInst") || "" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  await t.ensureRelationship(r, u);
}
function cl(t, r, i) {
  const s = V(t, "iedName"), c = V(r, "inst");
  return `${s}${c}/LN0.${i}`;
}
async function Fp(t, r, i, s, c, f) {
  const u = (V(s, "name") + "_GSE").replace(" ", "_"), p = V(i, "iedName");
  Te(p, "iedName of receiving LNode not found");
  const v = await t.findChildRecordsByTagName(f, [
    "GSEControl"
  ]);
  for (const A of v) {
    const B = V(A, "name")?.startsWith(u), X = (await t.findChildRecordsByTagName(A, ["IEDName"]))[0];
    Te(X, "IEDName record inside GSEControl not found");
    const F = X.value === p;
    if (B && F)
      return ul(t, A), A;
  }
  const D = v.filter(
    (A) => V(A, "name")?.startsWith(u) ?? !1
  ).length + 1, $ = u + D, U = cl(
    r,
    c,
    $
  ), W = await t.addRecord({
    tagName: "GSEControl",
    attributes: [
      { name: "name", value: $ },
      { name: "confRev", value: "1" },
      { name: "appID", value: U },
      { name: "type", value: "GOOSE" }
    ],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(f, W), await Tc(t, W, p), W;
}
async function Mp(t, r, i, s) {
  Te(
    r.sourceLNodeId,
    "Source LNode ID not set for dataflow connection to implement"
  ), Te(r.dataflowType, "Dataflow type not set for dataflow connection to implement");
  const c = await t.db.table(Le).get(i.id);
  Te(c, "ExtRef record not found"), yn(c, "doName", r.sourceDataObject), yn(c, "daName", r.sourceDataAttribute), yn(c, "serviceType", r.dataflowType);
  const f = await t.db.table(Le).get(r.sourceLNodeId);
  Te(f, "Sending LNode record not found"), yn(
    c,
    "iedName",
    V(f, "iedName") || ""
  ), yn(
    c,
    "ldInst",
    V(f, "ldInst") || ""
  ), yn(
    c,
    "lnClass",
    V(f, "lnClass") || ""
  ), yn(
    c,
    "lnInst",
    V(f, "lnInst") || ""
  ), yn(
    c,
    "prefix",
    V(f, "prefix") || ""
  ), yn(c, "srcCBName", s);
  const u = await dl(t, r.sourceLNodeId);
  Te(u, "LDevice for sending LNode not found");
  const p = (await t.findChildRecords(u, { tagNames: ["LN0"] }))[0];
  Te(p, "LN0 record not found"), yn(
    c,
    "srcLDInst",
    V(u, "inst") || ""
  ), yn(
    c,
    "srcLNClass",
    V(p, "lnClass") || ""
  ), await t.updateRecord(c);
}
async function Bp(t, r, i, s) {
  Te(
    r.destinationLNodeId,
    "Destination LNode ID not set for dataflow connection to implement"
  );
  const c = await t.db.table(Le).get(r.id);
  Te(c, "SourceRef record not found");
  const f = V(i, "iedName"), u = V(i, "ldInst");
  Te(f, "iedName of receiving LNode not found"), Te(u, "ldInst of receiving LNode not found");
  const p = await Ec(t, r.destinationLNodeId);
  Te(p, "LN record for receiving LNode not found");
  const v = V(p, "prefix"), k = V(p, "lnClass");
  Te(k, "lnClass of receiving LN record not found");
  const D = V(p, "inst");
  if (s.intAddr) {
    const $ = `${f}${u}/${v ?? ""}${k}${D ?? ""}.${s.intAddr}`;
    yn(c, "extRefAddr", $);
  }
  Te(s.uuid, "ExtRef UUID not found when updating SourceRef"), yn(c, "extRefUuid", s.uuid), await t.updateRecord(c);
}
function yn(t, r, i) {
  const s = t.attributes.find((c) => c.name === r);
  s ? s.value = i : t.attributes.push({ name: r, value: i });
}
async function dl(t, r) {
  const i = await t.db.table(Le).get(r), s = await t.db.table(Le).where({ tagName: "IED" }).and(
    (u) => V(u, "name") === V(i, "iedName")
  ).first();
  Te(s, "IED record not found for receiving LNode");
  const f = (await t.findChildRecordsWithinDepthAndGivenTagName(
    s,
    3,
    ["LDevice"]
  )).find((u) => V(u, "inst") === V(i, "ldInst"));
  return Te(f, "LDevice record not found for receiving LNode"), f;
}
async function Ec(t, r) {
  const i = await t.db.table(Le).get(r), s = await dl(t, r);
  if (!s)
    return;
  const f = (await t.findChildRecordsWithinDepthAndGivenTagName(s, 1, [
    "LN"
  ])).find((u) => V(u, "inst") === V(i, "lnInst") && V(u, "lnClass") === V(i, "lnClass") && V(u, "prefix") === V(i, "prefix"));
  return Te(f, "LN record not found for receiving LNode"), f;
}
async function Kp(t, r) {
  if (!qp(r))
    return;
  const i = await Ec(t, r.destinationLNodeId);
  if (!i)
    return;
  const c = (await t.findChildRecordsWithinDepthAndGivenTagName(i, 2, [
    "ExtRef"
  ])).filter((u) => {
    const p = V(u, "pLN") === r.preferredLNode && V(u, "pDO") === r.preferredDataObject && V(u, "pDA") === r.preferredDataAttribute;
    Te(r.dataflowType, "Dataflow type not set for dataflow connection to implement");
    const v = V(u, "pServT"), k = v === void 0 || v === r.dataflowType, D = V(u, "srcCBName");
    return p && k && !(D !== void 0 && D !== "");
  }), f = [];
  for (const u of c) {
    if (!V(u, "uuid")) {
      f.push(u);
      continue;
    }
    await t.db.table(Le).where({ tagName: "SourceRef" }).and(
      (v) => (!!V(v, "extRefUuid") && V(v, "extRefUuid")) === V(u, "uuid")
    ).first() || f.push(u);
  }
  return f[0];
}
function qp(t) {
  return t.preferredLNode.trim() !== "" && t.preferredDataObject.trim() !== "" && t.preferredDataAttribute.trim() !== "";
}
async function Ji(t, r) {
  const i = await Bo(
    t,
    r,
    zt.prefix
  ), s = await t.findChildRecordsByTagName(i, [
    "LNodeInputs"
  ]);
  if (s.length == 1)
    return s[0];
  if (s.length == 0) {
    const f = await t.addRecord({
      tagName: "LNodeInputs",
      attributes: [],
      parent: null,
      namespace: zt,
      value: "",
      children: []
    });
    return await t.ensureRelationship(i, f), f;
  }
  const c = {
    msg: `More than one LNodeInputs element found in LNode with uuid ${r.uuid}`
  };
  throw new Error(JSON.stringify(c));
}
async function Zi(t, r) {
  const i = await Bo(
    t,
    r,
    zt.prefix
  ), s = await t.findChildRecordsByTagName(i, [
    "LNodeOutputs"
  ]);
  if (s.length == 1)
    return s[0];
  if (s.length == 0) {
    const f = await t.addRecord({
      tagName: "LNodeOutputs",
      attributes: [],
      parent: null,
      namespace: zt,
      value: "",
      children: []
    });
    return await t.ensureRelationship(i, f), f;
  }
  const c = {
    msg: `More than one LNodeOutputs element found in LNode with uuid ${r.uuid}`
  };
  throw new Error(JSON.stringify(c));
}
async function Up(t, r, i, s) {
  const c = [], f = await la(
    t,
    ws(s, r)
  );
  if (c.push(f), await t.ensureRelationship(i, f), s.includeQuality) {
    const u = {
      ...s,
      attribute: "q"
      // Set to 'q' for Quality
    }, p = await la(
      t,
      ws(u, r)
    );
    c.push(p), await t.ensureRelationship(i, p);
  }
  if (s.includeTimestamp) {
    const u = {
      ...s,
      attribute: "t"
      // Set to 't' for Timestamp
    }, p = await la(
      t,
      ws(u, r)
    );
    c.push(p), await t.ensureRelationship(i, p);
  }
  return c;
}
async function Bo(t, r, i) {
  const s = await t.db.table(Le).where({ "parent.id": r.id, tagName: "Private" }).and((u) => V(u, "type") === i).first();
  if (s)
    return s;
  const c = await t.db.table(Le).get(r.id);
  if (!c) {
    const u = {
      msg: `LNode element with uuid ${r.uuid} not found`
    };
    throw new Error(JSON.stringify(u));
  }
  const f = await t.addRecord({
    tagName: "Private",
    attributes: [{ name: "type", value: i }],
    parent: null,
    namespace: Et.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(c, f), f;
}
async function la(t, r) {
  let i;
  r.processResourceId && (i = await t.db.table(Le).get(r.processResourceId), Te(i, "ProcessResource record not found"));
  const s = {
    tagName: "SourceRef",
    namespace: zt,
    attributes: [
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pDA",
        value: r.pDA
      },
      {
        name: "input",
        value: r.inputName
      },
      {
        name: "inputInst",
        value: r.inputInstance
      },
      {
        name: "service",
        value: r.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: r.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: r.sourceDoName
      },
      {
        name: "sourceDaName",
        value: r.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "source",
        value: await Wr(
          t.db,
          r.sourceLNodeUuid,
          r.sourceDoName,
          r.sourceDaName
        )
      },
      {
        name: "resourceUuid",
        value: V(i, "uuid") || ""
      },
      {
        name: "resourceName",
        value: i ? await t.generatePath(i) : ""
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(s);
}
async function Vp(t, r, i) {
  const s = r.dataObjectSpecifications?.find(
    (D) => D.name === i.signal
  ), c = s?.dataAttributeSpecifications.find(
    (D) => D.name === i.attribute
  ), u = It().lnodeTypes.find((D) => D.lnClass === r.lnClass), p = u?.dataObjects.find((D) => D.name === i.signal), v = p?.dataAttributes.find((D) => D.name === i.attribute);
  if (!u || !p || !v) {
    const D = `LNodeType, DO type or DA type not found for LNode class ${r.lnClass}, DO ${i.signal}, DA ${i.attribute}`;
    throw console.error(D), new Error(D);
  }
  let k;
  if (!s) {
    const D = await Bo(
      t,
      r,
      zt.prefix
    ), $ = {
      name: i.signal,
      desc: p.desc
    };
    k = await ua(t, $), await t.ensureRelationship(D, k);
  }
  if (!k && (k = await t.db.table(Le).get(s.id), !k))
    throw new Error(`DOS element with id ${s.id} not found`);
  if (c || await bs(t, k, i.attribute, v.desc), i.includeQuality) {
    const D = p?.dataAttributes.find((U) => U.name === "q");
    if (!D)
      throw new Error(`DA type 'q' not allowed for DO ${i.signal}`);
    s?.dataAttributeSpecifications.find(
      (U) => U.name === D.name
    ) || await bs(t, k, D.name, D.desc);
  }
  if (i.includeTimestamp) {
    const D = p?.dataAttributes.find((U) => U.name === "t");
    if (!D)
      throw new Error(`DA type 't' not allowed for DO ${i.signal}`);
    s?.dataAttributeSpecifications.find(
      (U) => U.name === D.name
    ) || await bs(t, k, D.name, D.desc);
  }
}
async function bs(t, r, i, s) {
  const f = await Ic(
    t,
    {
      name: i,
      desc: s
    }
  );
  await t.ensureRelationship(r, f);
}
async function ou(t, r) {
  let i;
  r.processResourceId && (i = await t.db.table(Le).get(r.processResourceId), Te(i, "ProcessResource record not found"));
  const s = {
    tagName: "ControlRef",
    namespace: zt,
    attributes: [
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "controlled",
        value: await Wr(
          t.db,
          r.controlledLNodeUuid,
          r.controlledDoName
        )
      },
      {
        name: "output",
        value: r.output
      },
      {
        name: "outputInst",
        value: r.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: r.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: r.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceUuid",
        value: V(i, "uuid") || ""
      },
      {
        name: "resourceName",
        value: i ? await t.generatePath(i) : ""
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(s);
}
async function Wr(t, r, i, s) {
  if (!r) return "";
  const c = await t.table(Le).where({ tagName: "LNode" }).and((D) => V(D, "uuid") === r).first();
  if (!c) return "";
  const f = [];
  let u = c;
  const p = ["LNode", "SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
  for (; u && u.parent; ) {
    if (p.includes(u.tagName)) {
      const D = V(u, "name");
      D && f.unshift(D);
    }
    u = await t.table(Le).get(u.parent.id);
  }
  const v = (() => {
    const D = c.attributes?.find((W) => W.name === "prefix")?.value || "", $ = c.attributes?.find((W) => W.name === "lnClass")?.value || "", U = c.attributes?.find((W) => W.name === "lnInst")?.value || "";
    return `${D}${$}${U}`;
  })();
  f.push(v);
  let k = f.join("/");
  return i && (k += `.${i}`, s && (k += "." + s)), k;
}
async function Wp(t, r, i) {
  const s = await Wr(t, r), c = V(i, "input"), f = V(i, "inputInst"), u = V(i, "pDA");
  let p = `${s}.${c}`;
  return f && (p += `(${f})`), u && (p += `.${u}`), p;
}
async function Gp(t, r, i) {
  const s = await Wr(t, r), c = V(i, "output"), f = V(i, "outputInst");
  let u = `${s}.${c}`;
  return f && (u += `(${f})`), u;
}
async function Vo(t, r) {
  const i = await t.db.table(Le).get(r);
  if (!i || !i?.parent)
    return [];
  const s = await t.db.table(Le).get(i.parent.id);
  return s?.tagName === "Function" || s?.tagName === "SubFunction" ? await t.db.table(Le).where({ tagName: "FunctionRef" }).and(
    (u) => V(u, "functionUuid") === V(s, "uuid")
  ).toArray() : [];
}
async function $a(t, r) {
  const i = [];
  for (const s of r)
    (await t.findParentRecordsWithinDepthAndGivenTagName(
      s,
      3,
      ["Application"]
    )).length === 1 && i.push(s);
  return i;
}
async function iu(t, r) {
  const i = /* @__PURE__ */ new Map();
  for (const s of r) {
    const c = await t.findParentRecordsWithinDepthAndGivenTagName(
      s,
      3,
      ["Application"]
    );
    c.length === 1 && i.set(s.id, c[0].id);
  }
  return i;
}
async function au(t, r, i) {
  const s = await Vo(t, r.id);
  if (s.length === 0)
    return;
  const c = await $a(
    t,
    s
  );
  for (const f of c) {
    let u = (await t.findChildRecords(f, {
      tagNames: ["SignalRole"],
      attrs: [{ name: "name", value: "Input" }]
    }))[0];
    u || (u = await t.addRecord({
      tagName: "SignalRole",
      attributes: [
        { name: "name", value: "Input" },
        { name: "uuid", value: crypto.randomUUID() }
      ],
      parent: null,
      namespace: zt,
      value: "",
      children: []
    }), await t.ensureRelationship(f, u));
    for (const p of i) {
      const v = await t.addRecord({
        tagName: "LNodeInputRef",
        attributes: [
          {
            name: "sourceRef",
            value: await Wp(t.db, r.uuid, p)
          },
          { name: "sourceRefUuid", value: V(p, "uuid") || "" }
        ],
        parent: null,
        namespace: zt,
        value: "",
        children: []
      });
      await t.ensureRelationship(u, v);
    }
  }
}
async function su(t, r, i) {
  const s = await Vo(t, r.id);
  if (s.length === 0)
    return;
  const c = await $a(
    t,
    s
  );
  for (const f of c) {
    let u = (await t.findChildRecords(f, {
      tagNames: ["SignalRole"],
      attrs: [{ name: "name", value: "Output" }]
    }))[0];
    u || (u = await t.addRecord({
      tagName: "SignalRole",
      attributes: [
        { name: "name", value: "Output" },
        { name: "uuid", value: crypto.randomUUID() }
      ],
      parent: null,
      namespace: zt,
      value: "",
      children: []
    }), await t.ensureRelationship(f, u));
    const p = await t.addRecord({
      tagName: "LNodeOutputRef",
      attributes: [
        {
          name: "controlRef",
          value: await Gp(
            t.db,
            r.uuid,
            i
          )
        },
        { name: "controlRefUuid", value: V(i, "uuid") || "" }
      ],
      parent: null,
      namespace: zt,
      value: "",
      children: []
    });
    await t.ensureRelationship(u, p);
  }
}
async function Hp(t, r, i, s, c) {
  const f = await Vo(t, r.id);
  if (f.length === 0)
    return;
  const u = await $a(
    t,
    f
  ), p = await Wr(t.db, r.uuid, i, s);
  for (const v of u)
    await Or(
      t,
      v,
      "Process",
      p,
      r.uuid,
      i,
      s
    ), c === et.REPORT && await Or(
      t,
      v,
      "Signalisation",
      p,
      r.uuid,
      i,
      s
    );
}
async function Yp(t, r, i) {
  const s = await Vo(t, r.id);
  if (s.length === 0)
    return;
  const c = await $a(
    t,
    s
  ), f = await Wr(t.db, r.uuid, i);
  for (const u of c)
    await Or(
      t,
      u,
      "Control",
      f,
      r.uuid,
      i
    );
}
async function ea(t, r, i, s, c, f) {
  const u = await Vo(
    t,
    r.id
  ), p = await iu(
    t,
    u
  ), v = await Vo(
    t,
    i.id
  ), k = await iu(
    t,
    v
  );
  let D = "", $, U;
  if (s === et.CONTROL ? (D = await Wr(t.db, i.uuid, c), $ = i, U = v.filter(
    (E) => Array.from(k.keys()).includes(E.id)
  )) : (D = await Wr(t.db, r.uuid, c, f), $ = r, U = u.filter(
    (E) => Array.from(p.keys()).includes(E.id)
  )), U.length === 0)
    return;
  for (const E of U)
    s === et.REPORT && await Or(
      t,
      E,
      "Signalisation",
      D,
      $.uuid,
      c,
      f
    ), s === et.CONTROL && await Or(
      t,
      E,
      "Control",
      D,
      $.uuid,
      c
    );
  const P = It().lnodeTypes.find((E) => E.lnClass === $.lnClass)?.dataObjects.find((E) => E.name === c);
  if (P) {
    const E = await t.db.table(Le).where({ tagName: "DOType" }).and((we) => V(we, "id") === P.type).first(), K = V(E, "cdc");
    if (K === "DPL" || K === "LPL" || K === "VSD")
      for (const we of U)
        await Or(
          t,
          we,
          "Information",
          D,
          $.uuid,
          c,
          f
        );
    else {
      const we = $.dataObjectSpecifications?.find((ge) => ge.name === c)?.dataAttributeSpecifications.find((ge) => ge.name === f);
      if (await t.db.table(Le).where({ tagName: "Val", "parent.id": we?.id }).first())
        for (const ge of U)
          await Or(
            t,
            ge,
            "Setting",
            D,
            $.uuid,
            c,
            f
          );
    }
  }
  let B = /* @__PURE__ */ new Set(), X = /* @__PURE__ */ new Set();
  function F(E, K) {
    const we = E.find((de) => de.id === K);
    if (!we)
      throw new Error(`FunctionRef with id ${K} not found`);
    return we;
  }
  if (p.size === 0)
    X = new Set(
      v.filter(
        (E) => Array.from(k.keys()).includes(E.id)
      )
    );
  else if (k.size === 0)
    X = new Set(
      u.filter(
        (E) => Array.from(p.keys()).includes(E.id)
      )
    );
  else
    for (const [
      E,
      K
    ] of p)
      for (const [
        we,
        de
      ] of k) {
        const ge = F(
          u,
          E
        ), Ue = F(
          v,
          we
        );
        K === de ? (B.add(ge), B.add(Ue)) : (X.add(ge), X.add(Ue));
      }
  for (const E of U)
    X.has(E) && await Or(
      t,
      E,
      "Process",
      D,
      $.uuid,
      c,
      f
    ), B.has(E) && await Or(
      t,
      E,
      "Internal",
      D,
      $.uuid,
      c,
      f
    );
}
async function Or(t, r, i, s, c, f, u) {
  const p = await zp(
    t,
    r,
    i
  );
  await Xp(
    t,
    p,
    s,
    c,
    f,
    u
  );
}
async function zp(t, r, i) {
  let s = (await t.findChildRecords(r, {
    tagNames: ["SignalRole"],
    attrs: [{ name: "name", value: i }]
  }))[0];
  return s || (s = await t.addRecord({
    tagName: "SignalRole",
    attributes: [
      { name: "name", value: i },
      { name: "uuid", value: crypto.randomUUID() }
    ],
    parent: null,
    namespace: zt,
    value: "",
    children: []
  }), await t.ensureRelationship(r, s), s);
}
async function Xp(t, r, i, s, c, f) {
  const u = [
    { name: "data", value: i },
    { name: "lnodeUuid", value: s },
    { name: "doName", value: c }
  ];
  if (f && u.push({ name: "daName", value: f }), !(await t.findChildRecords(r, {
    tagNames: ["LNodeDataRef"],
    attrs: u
  }))[0]) {
    const v = await t.addRecord({
      tagName: "LNodeDataRef",
      attributes: u,
      parent: null,
      namespace: zt,
      value: "",
      children: []
    });
    await t.ensureRelationship(r, v);
  }
}
function lu(t) {
  return {
    id: t.id,
    uuid: V(t, "uuid") || "",
    desc: V(t, "desc") || "",
    intAddr: V(t, "intAddr") || "",
    pServT: V(t, "pServT") ?? void 0,
    pLN: V(t, "pLN") || "",
    pDo: V(t, "pDO") || "",
    pDa: V(t, "pDA") || "",
    daName: V(t, "daName") || "",
    doName: V(t, "doName") || "",
    ldInst: V(t, "ldInst") || "",
    lnClass: V(t, "lnClass") || "",
    lnInst: V(t, "lnInst") || "",
    prefix: V(t, "prefix") || "",
    serviceType: V(t, "serviceType") ?? void 0,
    srcCbName: V(t, "srcCBName") || "",
    srcLdInst: V(t, "srcLDInst") || "",
    srcPrefix: V(t, "srcPrefix") || "",
    srcLnClass: V(t, "srcLNClass") || "",
    srcLnInst: V(t, "srcLNInst") || "",
    iedName: V(t, "iedName") || ""
  };
}
function Qp(t) {
  return {
    id: t.id,
    name: V(t, "name") || "",
    confRev: V(t, "confRev") || "",
    datSet: V(t, "datSet") || ""
  };
}
function Jp(t) {
  return {
    id: t.id,
    name: V(t, "name") || ""
  };
}
function Zp(t) {
  return {
    id: t.id,
    doName: V(t, "doName") || "",
    daName: V(t, "daName") || "",
    fc: V(t, "fc") || ""
  };
}
function ws(t, r) {
  return {
    dataflowType: t.type,
    inputName: t.inputName,
    inputInstance: t.inputInstance,
    sourceLNodeUuid: r.uuid,
    processResourceId: "",
    sourceDoName: t.signal,
    sourceDaName: t.attribute,
    pLN: r.lnClass,
    // SETRULE: set lnClass of source LNode also as preferred LN
    pDO: t.signal,
    // SETRULE: set signal/data object also as preferred DO
    pDA: t.attribute
    // SETRULE: set data attribute also as preferred DA
  };
}
function eh(t) {
  return {
    pDO: t.preferredDataObject,
    pLN: t.preferredLNode,
    output: t.outputName,
    outputInst: t.outputInstance,
    controlledLNodeUuid: "",
    controlledDoName: "",
    processResourceId: t.processResourceId
  };
}
function th(t, r) {
  return {
    pDO: t.controlledSignal,
    pLN: r.lnClass,
    output: t.outputName,
    outputInst: t.outputInstance,
    controlledLNodeUuid: r.uuid,
    controlledDoName: t.controlledSignal,
    processResourceId: ""
  };
}
async function nh(t) {
  return {
    dataflowType: t.dataflowType,
    inputName: t.inputName,
    inputInstance: t.inputInstance,
    sourceLNodeUuid: "",
    processResourceId: t.processResourceId,
    sourceDoName: "",
    sourceDaName: "",
    pLN: t.preferredLNode,
    pDO: t.preferredDataObject,
    pDA: t.preferredDataAttribute
  };
}
async function ua(t, r) {
  const i = {
    tagName: "DOS",
    namespace: zt,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(i);
}
async function Ic(t, r) {
  const i = {
    tagName: "DAS",
    namespace: zt,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(i);
}
function Ac(t) {
  return {
    findAllEnrichedLNodes: r,
    findAllLNodeTypes: i,
    findAllLNodes: u,
    enrichWithDataObjectSpecifications: f
  };
  async function r() {
    const p = await u();
    return p.length ? await f(p) : [];
  }
  async function i() {
    const p = await t.table(Le).where({ tagName: "LNodeType" }).toArray(), v = [];
    for (const k of p)
      v.push({
        id: k.id,
        typeId: V(k, "id") ?? "",
        lnClass: V(k, "lnClass") ?? "",
        dataObjects: await s(k)
      });
    return v;
  }
  async function s(p) {
    if (!p.children) return [];
    const v = [];
    for (const k of p.children) {
      if (k.tagName !== "DO") continue;
      const D = await t.table(Le).get(k.id);
      D && v.push({
        id: D.id,
        name: V(D, "name") ?? "",
        type: V(D, "type") ?? "",
        desc: V(D, "desc") ?? "",
        dataAttributes: await c(D)
      });
    }
    return v;
  }
  async function c(p) {
    const v = V(p, "type");
    if (!v) return [];
    const k = (await t.table(Le).where({ tagName: "DOType" }).toArray()).find(($) => $.attributes?.find((U) => U.name === "id" && U.value === v));
    if (!k || !k.children) return [];
    const D = [];
    for (const $ of k.children) {
      if ($.tagName !== "DA") continue;
      const U = await t.table(Le).get($.id);
      U && D.push({
        id: U.id,
        name: V(U, "name") ?? "",
        type: V(U, "type") ?? "",
        desc: V(U, "desc") ?? "",
        bType: V(U, "bType") ?? "",
        fc: V(U, "fc") ?? ""
      });
    }
    return D;
  }
  async function f(p) {
    const v = await t.table(Le).where({ tagName: "Private" }).toArray(), k = await t.table(Le).where({ tagName: "DOS" }).toArray(), D = await t.table(Le).where({ tagName: "DAS" }).toArray(), $ = await t.table(Le).where({ tagName: "SubscriberLNode" }).toArray();
    return Promise.all(
      p.map(async (U) => {
        const W = v.find(
          (P) => P.parent?.id === U.id && P.parent?.tagName === "LNode" && V(P, "type") === "eIEC61850-6-100"
        );
        if (!W || !W.children)
          return { ...U, dataObjectSpecifications: [] };
        const A = [];
        for (const P of W.children) {
          if (P.tagName !== "DOS") continue;
          const B = k.find((F) => F.id === P.id);
          if (!B) continue;
          const X = [];
          if (B.children)
            for (const F of B.children) {
              if (F.tagName !== "DAS") continue;
              const E = D.find((we) => we.id === F.id);
              if (!E) continue;
              let K = [];
              if (E.children) {
                const we = E.children.filter((ge) => ge.tagName === "SubscriberLNode"), de = $.filter(
                  (ge) => we.some((Ue) => Ue.id === ge.id)
                );
                for (const ge of de)
                  K.push({
                    id: ge.id,
                    inputName: V(ge, "inputName") ?? "",
                    service: fl(ge, "service"),
                    pLN: V(ge, "pLN") ?? "",
                    resourceName: V(ge, "resourceName") ?? ""
                  });
              }
              X.push({
                id: E.id,
                name: V(E, "name") ?? "",
                desc: V(E, "desc") ?? "",
                subscriberLNodes: K
              });
            }
          A.push({
            id: B.id,
            name: V(B, "name") ?? "",
            desc: V(B, "desc") ?? "",
            dataAttributeSpecifications: X
          });
        }
        return { ...U, dataObjectSpecifications: A };
      })
    );
  }
  async function u() {
    return (await t.table(Le).where({ tagName: "LNode" }).toArray()).map((v) => ({
      id: v.id,
      uuid: V(v, "uuid") ?? "",
      iedName: V(v, "iedName") ?? "",
      prefix: V(v, "prefix") ?? "",
      lnClass: V(v, "lnClass") ?? "",
      lnInst: V(v, "lnInst") ?? "",
      lnType: V(v, "lnType") ?? "",
      ldInst: V(v, "ldInst") ?? "",
      dataObjects: []
    }));
  }
}
function fl(t, r) {
  const i = t?.attributes?.find((c) => c.name === r)?.value;
  if (!i) return;
  switch (i.toUpperCase()) {
    case "GOOSE":
      return et.GOOSE;
    case "SMV":
      return et.SMV;
    case "REPORT":
      return et.REPORT;
    case "WIRED":
      return et.WIRED;
    case "CONTROL":
      return et.CONTROL;
    case "INTERNAL":
      return et.INTERNAL;
    default:
      return;
  }
}
function rh(t) {
  const r = ll(t);
  return {
    findAllExistingConnections: i,
    findAllExistingControlledConnections: s
  };
  async function i() {
    const c = await t.table(Le).where({ tagName: "SourceRef" }).toArray();
    if (!c.length) return [];
    const f = [];
    for (const u of c) {
      if (!u.attributes) continue;
      const p = V(u, "sourceLNodeUuid"), v = await t.table(Le).where({ tagName: "LNode" }).toArray().then(
        (E) => E.find(
          (K) => K.attributes?.some(
            (we) => we.name === "uuid" && we.value === p
          )
        )
      ), k = await r.findParentRecordsWithinDepthAndGivenTagName(
        u,
        3,
        ["LNode"]
      );
      if (k.length != 1) {
        const E = {
          msg: "Destination LNode record not found for SourceRef id",
          id: u.id
        };
        throw console.error(E), new Error(JSON.stringify(E));
      }
      const D = await t.table(Le).where({ tagName: "IED" }).toArray();
      let $ = !1;
      const U = V(v, "iedName");
      if (U) {
        const E = D.find(
          (K) => V(K, "name") === U
        );
        Te(E, `IED record not found for iedName: ${U}`), $ = V(E, "manufacturer") !== "S_IED";
      }
      let W = !1;
      const A = V(k[0], "iedName");
      if (A) {
        const E = D.find(
          (K) => V(K, "name") === A
        );
        Te(
          E,
          `IED record not found for iedName: ${A}`
        ), W = V(E, "manufacturer") !== "S_IED";
      }
      const P = !$ || !W;
      let B = !1;
      const X = V(u, "extRefUuid");
      if (X) {
        const E = await r.findRecord({
          tagNames: ["ExtRef"],
          attr: { name: "uuid", value: X }
        });
        Te(E, `ExtRef record not found for uuid: ${X}`), B = !!V(E, "srcCBName");
      }
      const F = oh(
        u,
        v?.id ?? null,
        k[0].id,
        B,
        P,
        X
      );
      f.push(F);
    }
    return f;
  }
  async function s() {
    const c = await t.table(Le).where({ tagName: "ControlRef" }).toArray();
    if (!c.length) return [];
    const f = [];
    for (const u of c) {
      if (!u.attributes) continue;
      const p = V(u, "controlledLNodeUuid"), v = V(u, "controlledDoName"), k = await t.table(Le).where({ tagName: "LNode" }).toArray().then(
        (U) => U.find(
          (W) => W.attributes?.some(
            (A) => A.name === "uuid" && A.value === p
          )
        )?.id
      ) || null, D = await r.findParentRecordsWithinDepthAndGivenTagName(
        u,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (D.length != 1) {
        const U = {
          msg: "LNode record not found for ControlRef id",
          id: u.id
        };
        throw console.error(U), new Error(JSON.stringify(U));
      }
      const $ = {
        controllerLNodeId: D[0].id,
        controlledLNodeId: k,
        controlledDataObject: v || "",
        dataflowType: et.CONTROL,
        outputInstance: V(u, "outputInst") || "",
        outputName: V(u, "output") || "",
        id: u.id,
        preferredLNode: V(u, "pLN") || "",
        preferredDataObject: V(u, "pDO") || "",
        processResource: V(u, "resourceName") || ""
      };
      f.push($);
    }
    return f;
  }
}
function oh(t, r, i, s, c, f) {
  return {
    id: t.id,
    sourceLNodeId: r,
    destinationLNodeId: i,
    sourceDataObject: V(t, "sourceDoName") || "",
    sourceDataAttribute: V(t, "sourceDaName") || "",
    dataflowType: fl(t, "service"),
    inputInstance: V(t, "inputInst") || "",
    input: V(t, "input") || "",
    preferredLNode: V(t, "pLN") || "",
    preferredDataObject: V(t, "pDO") || "",
    preferredDataAttribute: V(t, "pDA") || "",
    processResource: V(t, "resourceName") || "",
    isImplemented: s,
    notPossibleToImplement: c,
    extRefUuid: f
  };
}
function ih(t) {
  const r = ll(t), i = Ac(t);
  return {
    findAllSourcePlaceholders: s,
    findAllDestinationPlaceholdersForControlDataflow: c,
    findAllDestinationPlaceholders: f
  };
  async function s() {
    let $ = [];
    const U = await i.findAllEnrichedLNodes();
    if (!U.length) return $;
    for (const A of U) {
      const P = A.dataObjectSpecifications ?? [];
      for (const B of P) {
        const X = B.dataAttributeSpecifications ?? [];
        for (const F of X) {
          const E = F.subscriberLNodes ?? [];
          for (const K of E)
            $.push({
              lnodeId: A.id,
              id: K.id,
              dataObject: B.name,
              dataAttribute: F.name,
              dataflowType: K.service,
              preferredLNode: K.pLN,
              input: K.inputName,
              processResource: K.resourceName,
              isFulfilled: void 0
            });
        }
      }
    }
    return await k($);
  }
  async function c() {
    let $ = [];
    const U = await i.findAllEnrichedLNodes();
    if (!U.length) return $;
    for (const W of U) {
      const A = W.dataObjectSpecifications ?? [];
      for (const P of A) {
        const B = await r.db.table(Le).get(P.id);
        Te(B, `DOS record with id ${P.id} not found`);
        const X = await r.findChildRecords(B, {
          tagNames: ["ControllingLNode"]
        });
        for (const F of X)
          $.push({
            id: F.id,
            lnodeId: W.id,
            dataObject: P.name,
            outputName: kr(F, "outputName"),
            preferredLnode: V(F, "pLN") ?? "",
            processResource: V(F, "resourceName") ?? ""
          });
      }
    }
    return $;
  }
  async function f() {
    const $ = [], W = (await u()).filter((P) => !P.source && !P.sourceLNodeUuid);
    for (const P of W) {
      const B = await v(P.id, 3);
      $.push({
        id: P.id,
        dataflowType: P.dataflowType,
        preferredLNode: P.pLN,
        preferredDataObject: P.pDO,
        preferredDataAttribute: P.pDA,
        sourceLNodeUuid: P.sourceLNodeUuid,
        source: P.source,
        input: P.input,
        inputInst: P.inputInst,
        processResource: P.processResource,
        lNodeId: B,
        isFulfilled: void 0
      });
    }
    return await D($);
  }
  async function u() {
    const U = (await t.table(Le).where({ tagName: "SourceRef" }).toArray()).map(async (A) => ({
      id: A.id,
      uuid: V(A, "uuid") ?? "",
      pDO: V(A, "pDO") ?? "",
      pDA: V(A, "pDA") ?? "",
      pLN: V(A, "pLN") ?? "",
      input: V(A, "input") ?? "",
      inputInst: V(A, "inputInst") ?? "",
      source: V(A, "source") ?? "",
      sourceLNodeUuid: V(A, "sourceLNodeUuid") ?? "",
      dataflowType: fl(A, "service"),
      sourceDoName: V(A, "sourceDoName") ?? "",
      sourceDaName: V(A, "sourceDaName") ?? "",
      processResource: V(A, "resourceName") ?? "",
      // Add the lnClass for finding fulfilled placeholders
      lnClassOfParentLNode: await p(A.id, 3)
    }));
    return await Promise.all(U);
  }
  async function p($, U) {
    const W = await r.db.table(Le).get($);
    if (W) {
      const A = await r.findParentRecordsWithinDepthAndGivenTagName(
        W,
        U,
        ["LNode"]
      );
      return V(A[0], "lnClass");
    } else return "";
  }
  async function v($, U) {
    const W = await r.db.table(Le).get($);
    if (W)
      return (await r.findParentRecordsWithinDepthAndGivenTagName(
        W,
        U,
        ["LNode"]
      ))?.[0]?.id ?? void 0;
  }
  async function k($) {
    const U = await u(), W = [];
    for (const A of $) {
      const P = U.some((B) => !(A.preferredLNode && A.preferredLNode !== B.lnClassOfParentLNode || A.dataflowType && A.dataflowType !== B.dataflowType || A.dataObject && A.dataObject !== B.sourceDoName || A.dataAttribute && A.dataAttribute !== B.sourceDaName));
      W.push({
        ...A,
        isFulfilled: P
      });
    }
    return W;
  }
  async function D($) {
    const U = await u(), W = await i.findAllLNodes(), A = [];
    for (const P of $) {
      let B = !1;
      for (const X of U)
        if (!(X.id === P.id || !X.source || !X.sourceLNodeUuid || await v(X.id, 3) !== P.lNodeId) && P.input === X.input && !(P.dataflowType && P.dataflowType !== X.dataflowType)) {
          if (P.preferredLNode) {
            const K = W.find((we) => we.uuid === X.sourceLNodeUuid)?.lnClass;
            if (!K || K !== P.preferredLNode) continue;
          }
          if (!(P.preferredDataObject && P.preferredDataObject !== X.sourceDoName) && !(P.preferredDataAttribute && P.preferredDataAttribute !== X.sourceDaName)) {
            B = !0;
            break;
          }
        }
      A.push({
        ...P,
        isFulfilled: B
      });
    }
    return A;
  }
}
const It = /* @__PURE__ */ sl("dataflow/app", () => {
  let t = null;
  const r = Ke(""), i = Ke([]), s = Ke([]), c = Ke([]), f = Ke([]), u = Ke([]), p = Ke(
    []
  ), v = Ke([]), k = Dn(), D = Dn(), $ = Dn(), U = Dn();
  async function W(F) {
    A(), t = new wa(F), await t.open(), $.value = Ac(t), D.value = rh(t), U.value = ih(t), r.value = F, k.value = Ep(t), i.value = await $.value.findAllEnrichedLNodes(), s.value = await $.value.findAllLNodeTypes(), c.value = await D.value.findAllExistingConnections(), f.value = await D.value.findAllExistingControlledConnections(), u.value = await U.value.findAllSourcePlaceholders(), p.value = await U.value.findAllDestinationPlaceholdersForControlDataflow(), v.value = await U.value.findAllDestinationPlaceholders();
  }
  function A() {
    t && (t.close(), t = null);
  }
  async function P() {
    c.value = await D.value.findAllExistingConnections(), f.value = await D.value.findAllExistingControlledConnections();
  }
  async function B(F) {
    const K = (await $.value.findAllEnrichedLNodes()).find((we) => we.id === F);
    if (K) {
      const we = i.value.findIndex((de) => de.id === F);
      we !== -1 && (i.value[we] = K);
    }
  }
  async function X() {
    u.value = await U.value.findAllSourcePlaceholders(), p.value = await U.value.findAllDestinationPlaceholdersForControlDataflow(), v.value = await U.value.findAllDestinationPlaceholders();
  }
  return {
    // states
    activeFilename: r,
    lnodes: i,
    lnodeTypes: s,
    connections: c,
    controlledConnections: f,
    sourcePlaceholders: u,
    destinationPlaceholdersForControlDataflow: p,
    destinationPlaceholders: v,
    // getters
    dataflowSdk: k,
    // actions
    initApp: W,
    closeDatabase: A,
    refreshConnections: P,
    refreshLNode: B,
    refreshPlaceholders: X
  };
}), ah = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, sh = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, lh = { class: "mt-4" }, uh = { key: 0 }, ch = { key: 1 }, dh = { class: "mt-4" }, fh = /* @__PURE__ */ _t({
  __name: "connection-details",
  props: {
    connection: {}
  },
  setup(t) {
    const r = t, i = It(), { lnodes: s } = jt(i), c = He(() => s.value.find((p) => p.id === r.connection.sourceLNodeId)?.dataObjectSpecifications?.find(
      (p) => p.name === r.connection.sourceDataObject
    )), f = He(() => c?.value?.dataAttributeSpecifications?.find(
      (u) => u.name === r.connection.sourceDataAttribute
    ));
    return (u, p) => (Q(), re($e, null, [
      p[10] || (p[10] = h("h2", { class: "text-lg font-bold mb-2" }, "Specified Dataflow", -1)),
      u.connection.dataflowType ? (Q(), re("span", ah, ne(u.connection.dataflowType), 1)) : We("", !0),
      h("dl", sh, [
        h("div", null, [
          p[0] || (p[0] = h("dt", null, "Input:", -1)),
          h("dd", null, ne(u.connection.input), 1)
        ]),
        h("div", null, [
          p[1] || (p[1] = h("dt", null, "Input Instance:", -1)),
          h("dd", null, ne(u.connection.inputInstance || "-"), 1)
        ]),
        h("div", lh, [
          p[2] || (p[2] = h("dt", null, "DO:", -1)),
          h("dd", null, ne(u.connection.sourceDataObject || "-"), 1)
        ]),
        c.value?.desc ? (Q(), re("div", uh, [
          p[3] || (p[3] = h("dt", null, "DO Desc:", -1)),
          h("dd", null, ne(c.value.desc), 1)
        ])) : We("", !0),
        h("div", null, [
          p[4] || (p[4] = h("dt", null, "DA:", -1)),
          h("dd", null, ne(u.connection.sourceDataAttribute || "-"), 1)
        ]),
        f.value?.desc ? (Q(), re("div", ch, [
          p[5] || (p[5] = h("dt", null, "DA Desc:", -1)),
          h("dd", null, ne(f.value.desc), 1)
        ])) : We("", !0),
        h("div", dh, [
          p[6] || (p[6] = h("dt", null, "Preferred LN:", -1)),
          h("dd", null, ne(u.connection.preferredLNode || "-"), 1)
        ]),
        h("div", null, [
          p[7] || (p[7] = h("dt", null, "Preferred DO:", -1)),
          h("dd", null, ne(u.connection.preferredDataObject || "-"), 1)
        ]),
        h("div", null, [
          p[8] || (p[8] = h("dt", null, "Preferred DA:", -1)),
          h("dd", null, ne(u.connection.preferredDataAttribute || "-"), 1)
        ]),
        h("div", null, [
          p[9] || (p[9] = h("dt", null, "Process Resource:", -1)),
          h("dd", null, ne(u.connection.processResource || "-"), 1)
        ])
      ])
    ], 64));
  }
}), ph = { key: 0 }, hh = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, mh = { class: "flex flex-col gap-4" }, vh = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, yh = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, gh = /* @__PURE__ */ _t({
  __name: "implemented-dataflow-details",
  props: {
    connection: {}
  },
  setup(t) {
    const r = t, i = It(), { dataflowSdk: s } = jt(i), c = Ke(null), f = Ke(null), u = Ke(null), p = Ke("");
    Da(async () => {
      !r.connection.extRefUuid || !r.connection.isImplemented || (c.value = await s.value.findExtRefByUuid(r.connection.extRefUuid), c.value.srcCbName && (f.value = await s.value.findControlBlock(
        c.value.iedName,
        c.value.ldInst,
        c.value.srcCbName
      ), u.value = await s.value.findDataSet(
        c.value.iedName,
        c.value.ldInst,
        f.value.datSet
      ), p.value = await s.value.findPathToExtRef(c.value.id)));
    });
    const v = He(() => `${c.value?.iedName}/${c.value?.ldInst}/${c.value?.prefix}${c.value?.lnClass}${c.value?.lnInst}`), k = He(() => p.value.split("/").slice(0, -1).join("/")), D = He(() => `${c.value?.iedName}/${c.value?.srcLdInst}/${c.value?.srcPrefix}${c.value?.srcLnClass}${c.value?.srcLnInst}`);
    return ($, U) => (Q(), re($e, null, [
      U[9] || (U[9] = h("h2", { class: "text-lg font-bold mb-2" }, "Implemented Dataflow", -1)),
      $.connection.isImplemented ? We("", !0) : (Q(), re("p", ph, "Not implemented yet")),
      c.value ? (Q(), re($e, { key: 1 }, [
        $.connection.dataflowType ? (Q(), re("span", hh, ne(c.value.serviceType), 1)) : We("", !0),
        h("div", mh, [
          h("dl", vh, [
            h("div", null, [
              U[0] || (U[0] = h("dt", null, "DO:", -1)),
              h("dd", null, ne(c.value.doName), 1)
            ]),
            h("div", null, [
              U[1] || (U[1] = h("dt", null, "DA:", -1)),
              h("dd", null, ne(c.value.daName), 1)
            ])
          ]),
          h("div", null, [
            U[2] || (U[2] = h("h3", { class: "font-semibold" }, "Sending IED/LD/LN", -1)),
            h("div", null, ne(v.value), 1)
          ]),
          h("div", null, [
            U[3] || (U[3] = h("h3", { class: "font-semibold" }, "Receiving IED/LD/LN", -1)),
            h("div", null, ne(k.value), 1)
          ]),
          h("div", null, [
            U[8] || (U[8] = h("h3", { class: "font-semibold" }, "Control Block and Data Set", -1)),
            h("dl", yh, [
              h("div", null, [
                U[4] || (U[4] = h("dt", null, "Location:", -1)),
                h("dd", null, ne(D.value), 1)
              ]),
              h("div", null, [
                U[5] || (U[5] = h("dt", null, "Control Block:", -1)),
                h("dd", null, ne(f.value?.name), 1)
              ]),
              h("div", null, [
                U[6] || (U[6] = h("dt", null, "ConfRev:", -1)),
                h("dd", null, ne(f.value?.confRev), 1)
              ]),
              h("div", null, [
                U[7] || (U[7] = h("dt", null, "DataSet:", -1)),
                h("dd", null, ne(u.value?.name), 1)
              ])
            ])
          ])
        ])
      ], 64)) : We("", !0)
    ], 64));
  }
}), bh = { class: "grid grid-cols-2 gap-4" }, wh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, _h = ["value"], Nh = { class: "grid grid-cols-2 gap-4" }, xh = ["value", "title"], Rh = { class: "grid grid-cols-2 gap-4" }, Ch = ["value", "title"], Oh = { class: "grid grid-cols-2 gap-4" }, Th = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Eh = ["value"], Ih = { class: "grid grid-cols-2 gap-4" }, Ah = { class: "flex items-center" }, Dh = { class: "flex items-center" }, Ph = ["value"], Sh = { class: "grid grid-cols-2 gap-4" }, Lh = { class: "flex items-center" }, kh = /* @__PURE__ */ _t({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {},
    sourcePlaceholder: {},
    destinationPlaceholder: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { lnodeTypes: c, dataflowSdk: f } = jt(s), u = Ke(W()), p = Ke(!1), v = Ke([]), k = Ke(!0);
    Po(async () => {
      v.value = await f.value.findExistingInputs(r.destinationLNode);
    }), qt(p, (F) => {
      F ? u.value.inputName = "" : u.value.inputName = u.value.signal;
    }), qt(
      [
        () => u.value.inputName,
        () => u.value.attribute
      ],
      async ([F, E]) => {
        const K = await f.value.calculateNextInputInstance(
          F,
          E,
          r.destinationLNode
        );
        u.value.inputInstance = K.toString();
      }
    ), qt(
      () => u.value.signal,
      (F, E) => {
        const K = u.value.inputName !== E && u.value.inputName !== "";
        !p.value && !K && (u.value.inputName = F);
      }
    ), Da(() => {
      switch (X(), u.value.type = r.dataflowType, r.dataflowType) {
        case et.GOOSE:
        case et.SMV:
          u.value.includeQuality = !0, u.value.includeTimestamp = !1;
          break;
        case et.REPORT:
          u.value.includeQuality = !0, u.value.includeTimestamp = !0;
          break;
        default:
          u.value.includeQuality = !1, u.value.includeTimestamp = !1;
      }
    });
    const D = He(() => !r.dataflowType || !r.sourceLNode ? [] : c.value.find((F) => F.typeId === r.sourceLNode.lnType)?.dataObjects.filter(
      (F) => F.dataAttributes.some(
        (E) => Uo[r.dataflowType]?.includes(E.fc)
      )
    ).sort((F, E) => F.name.localeCompare(E.name)) ?? []), $ = He(() => !r.dataflowType || !r.sourceLNode ? [] : c.value.find((F) => F.typeId === r.sourceLNode.lnType)?.dataObjects.find((F) => F.name === u.value.signal)?.dataAttributes.filter(
      (F) => Uo[r.dataflowType].includes(F.fc)
    ).filter((F) => !Ki.includes(F.name)).sort((F, E) => F.name.localeCompare(E.name)) ?? []);
    U();
    function U() {
      const F = r.sourcePlaceholder?.dataObject ?? r.destinationPlaceholder?.preferredDataObject;
      if (F && D.value.length > 0) {
        const we = D.value.find((de) => de.name === F);
        u.value.signal = we ? we.name : "";
      }
      const E = r.sourcePlaceholder?.dataAttribute ?? r.destinationPlaceholder?.preferredDataAttribute;
      if (E && $.value.length > 0) {
        const we = $.value.find((de) => de.name === E);
        we && u.value.signal === F && (u.value.attribute = we.name);
      }
      const K = r.sourcePlaceholder?.input ?? r.destinationPlaceholder?.input;
      K && p.value === !1 && (u.value.inputName = K);
    }
    function W() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function A(F) {
      for (const E of F)
        u.value[E] = "";
    }
    async function P() {
      try {
        if (!B(u.value))
          return;
        await f.value.createConnection(
          u.value,
          r.sourceLNode,
          r.destinationLNode,
          k.value
        ), i.handleClose();
      } catch (F) {
        console.error("Error creating dataflow:", F), alert(`Error creating dataflow: ${F instanceof Error ? F.message : "Unknown error"}`);
      }
    }
    function B(F) {
      return F.type ? F.signal ? F.attribute ? F.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function X() {
      u.value = W(), p.value = !1, k.value = !0;
    }
    return (F, E) => (Q(), re("form", {
      method: "dialog",
      onSubmit: P,
      class: "flex flex-col gap-4 mt-4"
    }, [
      h("div", bh, [
        E[11] || (E[11] = h("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Source", -1)),
        h("select", wh, [
          h("option", {
            value: r.sourceLNode.id
          }, ne(_e(ba)(F.sourceLNode)), 9, _h)
        ])
      ]),
      h("div", Nh, [
        E[13] || (E[13] = h("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Signal (DO)", -1)),
        Ye(h("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": E[0] || (E[0] = (K) => u.value.signal = K),
          onChange: E[1] || (E[1] = (K) => A(["attribute"]))
        }, [
          E[12] || (E[12] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(D.value, (K) => (Q(), re("option", {
            key: K.name,
            value: K.name,
            title: K.desc ? `Desc: ${K.desc}` : ""
          }, ne(K.desc ? K.name + " ⓘ" : K.name), 9, xh))), 128))
        ], 544), [
          [Pt, u.value.signal]
        ])
      ]),
      h("div", Rh, [
        E[15] || (E[15] = h("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Attribute (DA)", -1)),
        Ye(h("select", {
          id: "data-attribute-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": E[2] || (E[2] = (K) => u.value.attribute = K)
        }, [
          E[14] || (E[14] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt($.value, (K) => (Q(), re("option", {
            key: K.name,
            value: K.name,
            title: K.desc ? `Desc: ${K.desc}` : ""
          }, ne(K.desc ? K.name + " ⓘ" : K.name), 9, Ch))), 128))
        ], 512), [
          [Pt, u.value.attribute]
        ])
      ]),
      E[24] || (E[24] = h("hr", { class: "solid" }, null, -1)),
      h("div", Oh, [
        E[16] || (E[16] = h("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Destination", -1)),
        h("select", Th, [
          h("option", {
            value: r.destinationLNode.id
          }, ne(_e(ba)(F.destinationLNode)), 9, Eh)
        ])
      ]),
      h("div", Ih, [
        h("fieldset", null, [
          E[19] || (E[19] = h("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
          h("div", Ah, [
            Ye(h("input", {
              type: "radio",
              id: "dataflow-new-input",
              name: "input",
              "onUpdate:modelValue": E[3] || (E[3] = (K) => p.value = K),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, p.value]
            ]),
            E[17] || (E[17] = h("label", { for: "dataflow-new-input" }, "New Input", -1))
          ]),
          h("div", Dh, [
            Ye(h("input", {
              type: "radio",
              id: "dataflow-existing-input",
              name: "input",
              "onUpdate:modelValue": E[4] || (E[4] = (K) => p.value = K),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, p.value]
            ]),
            E[18] || (E[18] = h("label", { for: "dataflow-existing-input" }, "Existing Input", -1))
          ])
        ]),
        p.value ? We("", !0) : Ye((Q(), re("input", {
          key: 0,
          "aria-label": "New Input Name",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": E[5] || (E[5] = (K) => u.value.inputName = K)
        }, null, 512)), [
          [Jn, u.value.inputName]
        ]),
        p.value ? Ye((Q(), re("select", {
          key: 1,
          "aria-label": "Existing Input Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": E[6] || (E[6] = (K) => u.value.inputName = K)
        }, [
          (Q(!0), re($e, null, lt(v.value, (K) => (Q(), re("option", {
            key: K,
            value: K
          }, ne(K), 9, Ph))), 128))
        ], 512)), [
          [Pt, u.value.inputName]
        ]) : We("", !0)
      ]),
      h("div", Sh, [
        E[20] || (E[20] = h("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        Ye(h("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": E[7] || (E[7] = (K) => u.value.inputInstance = K)
        }, null, 512), [
          [Jn, u.value.inputInstance]
        ])
      ]),
      E[25] || (E[25] = h("hr", { class: "solid" }, null, -1)),
      h("div", null, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": E[8] || (E[8] = (K) => u.value.includeQuality = K),
          class: "checkbox mr-2",
          id: "checkbox-include-quality"
        }, null, 512), [
          [Dr, u.value.includeQuality]
        ]),
        E[21] || (E[21] = h("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
      ]),
      h("div", null, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": E[9] || (E[9] = (K) => u.value.includeTimestamp = K),
          class: "checkbox mr-2",
          id: "checkbox-include-timestamp"
        }, null, 512), [
          [Dr, u.value.includeTimestamp]
        ]),
        E[22] || (E[22] = h("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
      ]),
      h("div", Lh, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": E[10] || (E[10] = (K) => k.value = K),
          class: "checkbox mr-2",
          id: "dataflow-checkbox-add-references"
        }, null, 512), [
          [Dr, k.value]
        ]),
        E[23] || (E[23] = h("label", { for: "dataflow-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      E[26] || (E[26] = h("div", { class: "modal-action" }, [
        h("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          type: "submit",
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ], -1))
    ], 32));
  }
}), jh = { class: "grid grid-cols-2 gap-4" }, $h = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Fh = ["value"], Mh = { class: "grid grid-cols-2 gap-4" }, Bh = ["value", "title"], Kh = { class: "grid grid-cols-2 gap-4" }, qh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Uh = ["value"], Vh = { class: "grid grid-cols-2 gap-4" }, Wh = { class: "flex items-center" }, Gh = { class: "flex items-center" }, Hh = ["value"], Yh = { class: "grid grid-cols-2 gap-4" }, zh = { class: "flex items-center" }, Xh = /* @__PURE__ */ _t({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { lnodeTypes: c, dataflowSdk: f } = jt(s), u = Ke(
      $()
    ), p = Ke(!1), v = Ke([]), k = Ke(!0);
    Po(async () => {
      v.value = await f.value.findExistingOutputs(r.sourceLNode);
    }), qt(p, (A) => {
      A ? u.value.outputName = "" : u.value.outputName = u.value.controlledSignal;
    }), qt(
      () => u.value.outputName,
      async (A) => {
        const P = await f.value.calculateNextOutputInstance(
          A,
          r.sourceLNode
        );
        u.value.outputInstance = P.toString();
      }
    ), qt(
      () => u.value.controlledSignal,
      (A, P) => {
        const B = u.value.outputName !== P && u.value.outputName !== "";
        !p.value && !B && (u.value.outputName = A);
      }
    );
    const D = He(() => r.destinationLNode ? c.value.find((P) => P.typeId === r.destinationLNode.lnType)?.dataObjects.map((P) => ({
      name: P.name,
      desc: P.desc
    })).sort((P, B) => P.name.localeCompare(B.name)) ?? [] : []);
    function $() {
      return {
        type: et.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function U() {
      try {
        if (!W(u.value))
          return;
        await f.value.createControlledConnection(
          u.value,
          r.sourceLNode,
          r.destinationLNode,
          k.value
        ), i.handleClose();
      } catch (A) {
        console.error("Error creating controlled dataflow:", A), alert(`Error creating controlled dataflow: ${A instanceof Error ? A.message : "Unknown error"}`);
      }
    }
    function W(A) {
      return A.type ? A.outputName ? A.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    return (A, P) => (Q(), re("form", {
      method: "dialog",
      onSubmit: U,
      class: "flex flex-col gap-4 mt-4"
    }, [
      h("div", jh, [
        P[7] || (P[7] = h("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        h("select", $h, [
          h("option", {
            value: r.destinationLNode.id
          }, ne(_e(ba)(A.destinationLNode)), 9, Fh)
        ])
      ]),
      h("div", Mh, [
        P[9] || (P[9] = h("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        Ye(h("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": P[0] || (P[0] = (B) => u.value.controlledSignal = B)
        }, [
          P[8] || (P[8] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(D.value, (B) => (Q(), re("option", {
            key: B.name,
            value: B.name,
            title: B.desc ? `Desc: ${B.desc}` : ""
          }, ne(B.desc ? B.name + " ⓘ" : B.name), 9, Bh))), 128))
        ], 512), [
          [Pt, u.value.controlledSignal]
        ])
      ]),
      P[16] || (P[16] = h("hr", { class: "solid" }, null, -1)),
      h("div", Kh, [
        P[10] || (P[10] = h("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        h("select", qh, [
          h("option", {
            value: r.sourceLNode.id
          }, ne(_e(ba)(A.sourceLNode)), 9, Uh)
        ])
      ]),
      h("div", Vh, [
        h("fieldset", null, [
          P[13] || (P[13] = h("legend", { class: "col-start-1 self-start" }, "Controller Output Name", -1)),
          h("div", Wh, [
            Ye(h("input", {
              type: "radio",
              id: "dataflow-control-new-output",
              name: "output",
              "onUpdate:modelValue": P[1] || (P[1] = (B) => p.value = B),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, p.value]
            ]),
            P[11] || (P[11] = h("label", { for: "dataflow-control-new-output" }, "New Output", -1))
          ]),
          h("div", Gh, [
            Ye(h("input", {
              type: "radio",
              id: "dataflow-control-existing-output",
              name: "output",
              "onUpdate:modelValue": P[2] || (P[2] = (B) => p.value = B),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, p.value]
            ]),
            P[12] || (P[12] = h("label", { for: "dataflow-control-existing-output" }, "Existing Output", -1))
          ])
        ]),
        p.value ? We("", !0) : Ye((Q(), re("input", {
          key: 0,
          "aria-label": "New Output Name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": P[3] || (P[3] = (B) => u.value.outputName = B)
        }, null, 512)), [
          [Jn, u.value.outputName]
        ]),
        p.value ? Ye((Q(), re("select", {
          key: 1,
          "aria-label": "Existing Output Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": P[4] || (P[4] = (B) => u.value.outputName = B)
        }, [
          (Q(!0), re($e, null, lt(v.value, (B) => (Q(), re("option", {
            key: B,
            value: B
          }, ne(B), 9, Hh))), 128))
        ], 512)), [
          [Pt, u.value.outputName]
        ]) : We("", !0)
      ]),
      h("div", Yh, [
        P[14] || (P[14] = h("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Output Instance", -1)),
        Ye(h("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": P[5] || (P[5] = (B) => u.value.outputInstance = B)
        }, null, 512), [
          [Jn, u.value.outputInstance]
        ])
      ]),
      P[17] || (P[17] = h("hr", { class: "solid" }, null, -1)),
      h("div", zh, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": P[6] || (P[6] = (B) => k.value = B),
          class: "checkbox mr-2",
          id: "dataflow-control-checkbox-add-references"
        }, null, 512), [
          [Dr, k.value]
        ]),
        P[15] || (P[15] = h("label", { for: "dataflow-control-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      P[18] || (P[18] = h("div", { class: "modal-action" }, [
        h("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          "data-testId": " save-dataflow-connection"
        }, " Save ")
      ], -1))
    ], 32));
  }
}), Qh = { class: "grid grid-cols-2 gap-4 mt-4" }, Jh = ["value", "disabled"], Zh = /* @__PURE__ */ _t({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    sourcePlaceholder: {},
    destinationPlaceholder: {}
  },
  setup(t) {
    const r = t, i = Ke(null);
    r.sourcePlaceholder && r.sourcePlaceholder.dataflowType ? i.value = r.sourcePlaceholder.dataflowType : r.destinationPlaceholder && r.destinationPlaceholder.dataflowType ? i.value = r.destinationPlaceholder.dataflowType : i.value = null;
    const s = He(
      () => Object.values(et).filter((u) => u !== et.INTERNAL)
    ), c = He(
      () => r.sourceLNode?.lnClass === "IHMI" || r.sourceLNode?.lnClass === "ITCI"
    );
    function f(u) {
      const p = u.target.value;
      i.value = p;
    }
    return (u, p) => (Q(), re($e, null, [
      p[3] || (p[3] = h("h3", { class: "font-bold text-lg" }, "Create Dataflow", -1)),
      h("div", Qh, [
        p[2] || (p[2] = h("label", {
          for: "dataflow-type-select",
          class: "col-start-1 self-center"
        }, "Dataflow Type", -1)),
        Ye(h("select", {
          id: "dataflow-type-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": p[0] || (p[0] = (v) => i.value = v),
          onChange: f
        }, [
          p[1] || (p[1] = h("option", {
            key: "empty",
            value: null
          }, "-", -1)),
          (Q(!0), re($e, null, lt(s.value, (v) => (Q(), re("option", {
            key: v,
            value: v,
            disabled: v === _e(et).CONTROL && !c.value
          }, ne(v), 9, Jh))), 128))
        ], 544), [
          [Pt, i.value]
        ])
      ]),
      p[4] || (p[4] = h("hr", { class: "solid mt-4" }, null, -1)),
      i.value !== _e(et).CONTROL ? (Q(), Lt(kh, {
        key: 0,
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        dataflowType: i.value,
        sourcePlaceholder: u.sourcePlaceholder,
        destinationPlaceholder: u.destinationPlaceholder
      }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType", "sourcePlaceholder", "destinationPlaceholder"])) : (Q(), Lt(Xh, {
        key: 1,
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        dataflowType: i.value
      }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType"]))
    ], 64));
  }
});
function em(t) {
  return Vs() ? (yu(t), !0) : !1;
}
const tm = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const nm = () => {
};
function rm(t, r, i = {}) {
  const {
    immediate: s = !0,
    immediateCallback: c = !1
  } = i, f = Dn(!1);
  let u;
  function p() {
    u && (clearTimeout(u), u = void 0);
  }
  function v() {
    f.value = !1, p();
  }
  function k(...D) {
    c && t(), p(), f.value = !0, u = setTimeout(() => {
      f.value = !1, u = void 0, t(...D);
    }, fd(r));
  }
  return s && (f.value = !0, tm && k()), em(v), {
    isPending: cd(f),
    start: k,
    stop: v
  };
}
function Gi(t, r, i) {
  let s;
  St(i) ? s = {
    evaluating: i
  } : s = {};
  const {
    lazy: c = !1,
    flush: f = "pre",
    evaluating: u = void 0,
    shallow: p = !0,
    onError: v = nm
  } = s, k = Dn(!c), D = p ? Dn(r) : Ke(r);
  let $ = 0;
  return Da(async (U) => {
    if (!k.value)
      return;
    $++;
    const W = $;
    let A = !1;
    u && Promise.resolve().then(() => {
      u.value = !0;
    });
    try {
      const P = await t((B) => {
        U(() => {
          u && (u.value = !1), A || B();
        });
      });
      W === $ && (D.value = P);
    } catch (P) {
      v(P);
    } finally {
      u && W === $ && (u.value = !1), A = !0;
    }
  }, { flush: f }), c ? He(() => (k.value = !0, D.value)) : D;
}
const om = { class: "grid grid-cols-2 gap-4 items-center" }, im = ["value"], am = { class: "grid grid-cols-2 gap-4 items-center" }, sm = ["value"], lm = { class: "grid grid-cols-2 gap-4 items-center" }, um = ["value", "title"], cm = { class: "grid grid-cols-2 gap-4 mt-4" }, dm = { class: "flex items-center" }, fm = { class: "flex items-center" }, pm = ["value"], hm = { class: "grid grid-cols-2 gap-4" }, mm = { class: "flex items-center" }, vm = /* @__PURE__ */ _t({
  __name: "control-dataflow-source-placeholder-form",
  props: {
    controllerLNode: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { lnodeTypes: c, lnodes: f, dataflowSdk: u } = jt(s), p = Ke(
      B()
    ), v = Ke(!1), k = Ke([]), D = Ke(!0);
    Po(async () => {
      k.value = await u.value.findExistingOutputs(r.controllerLNode);
    }), qt(v, (F) => {
      F ? p.value.outputName = "" : p.value.outputName = p.value.preferredDataObject;
    }), qt(
      () => p.value.preferredDataObject,
      (F, E) => {
        const K = p.value.outputName !== E && p.value.outputName !== "";
        !v.value && !K && (p.value.outputName = F);
      }
    ), qt(
      () => p.value.outputName,
      async (F) => {
        const E = await u.value.calculateNextOutputInstance(
          F,
          r.controllerLNode
        );
        p.value.outputInstance = E.toString();
      }
    );
    const $ = He(
      () => [...c.value].sort((F, E) => F.lnClass.localeCompare(E.lnClass))
    ), U = Gi(async () => u.value ? (await u.value.findProcessResourcesForLnode(
      r.controllerLNode.id
    )).map((E) => ({
      name: kr(E, "name"),
      id: E.id
    })).sort((E, K) => E.name.localeCompare(K.name)) : []), W = He(() => {
      if (!p.value.preferredLNode) return [];
      const F = c.value.find(
        (E) => E.lnClass === p.value.preferredLNode
      );
      return Te(
        F,
        `LNodeType of class ${p.value.preferredLNode} not found`
      ), F?.dataObjects.map((E) => ({
        name: E.name,
        desc: E.desc,
        id: E.id
      })).sort((E, K) => E.name.localeCompare(K.name)) ?? [];
    });
    async function A() {
      try {
        if (!P(p.value))
          return;
        await u.value.createControlSourcePlaceholder(
          p.value,
          r.controllerLNode,
          D.value
        ), i.handleClose();
      } catch (F) {
        console.error("Error creating control source placeholder port:", F), alert(`Error creating placeholder: ${F instanceof Error ? F.message : "Unknown error"}`);
      }
    }
    function P(F) {
      return F.outputName ? !0 : (alert("Please enter a controller output name."), !1);
    }
    function B() {
      return {
        dataflowType: et.CONTROL,
        outputName: "",
        outputInstance: "",
        preferredLNode: "",
        preferredDataObject: "",
        processResourceId: ""
      };
    }
    function X(F) {
      for (const E of F)
        p.value[E] = "";
    }
    return (F, E) => (Q(), re("form", {
      onSubmit: A,
      method: "dialog",
      class: "flex flex-col gap-4 mt-4"
    }, [
      h("div", om, [
        E[11] || (E[11] = h("label", {
          for: "process-resource-select",
          class: "col-start-1"
        }, "Process Resource", -1)),
        Ye(h("select", {
          id: "process-resource-select",
          name: "processResource",
          class: "select col-start-2",
          "onUpdate:modelValue": E[0] || (E[0] = (K) => p.value.processResourceId = K)
        }, [
          E[10] || (E[10] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(_e(U), (K) => (Q(), re("option", {
            key: K.id,
            value: K.id
          }, ne(K.name), 9, im))), 128))
        ], 512), [
          [Pt, p.value.processResourceId]
        ])
      ]),
      h("div", am, [
        E[13] || (E[13] = h("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
        Ye(h("select", {
          id: "preferred-lnode-select",
          name: "preferredLNode",
          class: "select col-start-2",
          "onUpdate:modelValue": E[1] || (E[1] = (K) => p.value.preferredLNode = K),
          onChange: E[2] || (E[2] = (K) => X(["preferredDataObject"]))
        }, [
          E[12] || (E[12] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt($.value, (K) => (Q(), re("option", {
            key: K.lnClass,
            value: K.lnClass
          }, ne(K.lnClass), 9, sm))), 128))
        ], 544), [
          [Pt, p.value.preferredLNode]
        ])
      ]),
      h("div", lm, [
        E[15] || (E[15] = h("label", { for: "data-object-select" }, "Preferred Data Object", -1)),
        Ye(h("select", {
          required: "",
          id: "data-object-select",
          name: "data object",
          class: "select col-start-2",
          "onUpdate:modelValue": E[3] || (E[3] = (K) => p.value.preferredDataObject = K)
        }, [
          E[14] || (E[14] = h("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(W.value, (K) => (Q(), re("option", {
            key: K.id,
            value: K.name,
            title: K.desc ? `Desc: ${K.desc}` : ""
          }, ne(K.desc ? K.name + " ⓘ" : K.name), 9, um))), 128))
        ], 512), [
          [Pt, p.value.preferredDataObject]
        ])
      ]),
      h("div", cm, [
        h("fieldset", null, [
          E[18] || (E[18] = h("legend", { class: "col-start-1 self-start" }, "Controller Output Name", -1)),
          h("div", dm, [
            Ye(h("input", {
              type: "radio",
              id: "dataflow-control-new-output",
              name: "output",
              "onUpdate:modelValue": E[4] || (E[4] = (K) => v.value = K),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, v.value]
            ]),
            E[16] || (E[16] = h("label", { for: "dataflow-control-new-output" }, "New Output", -1))
          ]),
          h("div", fm, [
            Ye(h("input", {
              type: "radio",
              id: "dataflow-control-existing-output",
              name: "output",
              "onUpdate:modelValue": E[5] || (E[5] = (K) => v.value = K),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, v.value]
            ]),
            E[17] || (E[17] = h("label", { for: "dataflow-control-existing-output" }, "Existing Output", -1))
          ])
        ]),
        v.value ? We("", !0) : Ye((Q(), re("input", {
          key: 0,
          "aria-label": "New Output Name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": E[6] || (E[6] = (K) => p.value.outputName = K)
        }, null, 512)), [
          [Jn, p.value.outputName]
        ]),
        v.value ? Ye((Q(), re("select", {
          key: 1,
          "aria-label": "Existing Output Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": E[7] || (E[7] = (K) => p.value.outputName = K)
        }, [
          (Q(!0), re($e, null, lt(k.value, (K) => (Q(), re("option", {
            key: K,
            value: K
          }, ne(K), 9, pm))), 128))
        ], 512)), [
          [Pt, p.value.outputName]
        ]) : We("", !0)
      ]),
      h("div", hm, [
        E[19] || (E[19] = h("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Output Instance", -1)),
        Ye(h("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": E[8] || (E[8] = (K) => p.value.outputInstance = K)
        }, null, 512), [
          [Jn, p.value.outputInstance]
        ])
      ]),
      E[21] || (E[21] = h("hr", { class: "solid" }, null, -1)),
      h("div", mm, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": E[9] || (E[9] = (K) => D.value = K),
          class: "checkbox mr-2",
          id: "dataflow-control-checkbox-add-references"
        }, null, 512), [
          [Dr, D.value]
        ]),
        E[20] || (E[20] = h("label", { for: "dataflow-control-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      E[22] || (E[22] = h("div", { class: "modal-action" }, [
        h("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
      ], -1))
    ], 32));
  }
}), ym = { class: "grid grid-cols-2 gap-4 items-center" }, gm = { class: "grid grid-cols-2 gap-4 items-center" }, bm = ["value", "title"], wm = { class: "grid grid-cols-2 gap-4 items-center" }, _m = ["value", "title"], Nm = { class: "grid grid-cols-2 gap-4 items-center" }, xm = ["value"], Rm = { class: "grid grid-cols-2 gap-4 items-center" }, Cm = ["value"], Om = { class: "flex items-center" }, Tm = /* @__PURE__ */ _t({
  __name: "source-placeholder-form",
  props: {
    sourceLNode: {},
    dataflowType: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { lnodeTypes: c, dataflowSdk: f } = jt(s), u = Ke(
      W()
    ), p = Ke(!0);
    qt(
      () => r.dataflowType,
      () => {
        u.value = W();
      },
      { immediate: !0 }
    );
    async function v() {
      try {
        await f.value.createSourcePlaceholder(
          r.sourceLNode,
          u.value,
          p.value
        ), i.handleClose();
      } catch (P) {
        console.error("Error creating source placeholder port:", P), alert(`Error creating placeholder: ${P instanceof Error ? P.message : "Unknown error"}`);
      }
    }
    const k = Gi(async () => f.value ? (await f.value.findProcessResourcesForLnode(
      r.sourceLNode.id
    )).map((B) => ({
      name: kr(B, "name"),
      id: B.id
    })).sort((B, X) => B.name.localeCompare(X.name)) : []), D = He(
      () => [...c.value].sort((P, B) => P.lnClass.localeCompare(B.lnClass))
    ), $ = He(() => {
      const P = c.value.find((B) => B.typeId === r.sourceLNode.lnType);
      return P ? r.dataflowType ? P.dataObjects.filter(
        (B) => B.dataAttributes.some(
          (X) => Uo[r.dataflowType].includes(X.fc)
        )
      ).sort((B, X) => B.name.localeCompare(X.name)) : P.dataObjects.sort((B, X) => B.name.localeCompare(X.name)) : [];
    }), U = He(() => {
      const P = c.value.find((B) => B.typeId === r.sourceLNode.lnType)?.dataObjects.find((B) => B.name === u.value.dataObject);
      return P ? r.dataflowType ? P.dataAttributes.filter((B) => Uo[r.dataflowType].includes(B.fc)).filter((B) => !Ki.includes(B.name)).sort((B, X) => B.name.localeCompare(X.name)) : P.dataAttributes.filter((B) => !Ki.includes(B.name)).sort((B, X) => B.name.localeCompare(X.name)) : [];
    });
    function W() {
      return {
        dataObject: "",
        dataAttribute: "",
        inputName: "",
        dataflowType: r.dataflowType,
        processResourceId: "",
        preferredLNode: ""
      };
    }
    function A(P) {
      for (const B of P)
        u.value[B] = "";
    }
    return (P, B) => (Q(), re("form", {
      onSubmit: v,
      method: "dialog",
      class: "flex flex-col gap-4 mt-4"
    }, [
      h("div", ym, [
        B[7] || (B[7] = h("label", { for: "input-name" }, "Input Name", -1)),
        Ye(h("input", {
          required: "",
          id: "input-name",
          name: "inputName",
          "onUpdate:modelValue": B[0] || (B[0] = (X) => u.value.inputName = X),
          placeholder: "Input Name",
          class: "input col-start-2"
        }, null, 512), [
          [Jn, u.value.inputName]
        ])
      ]),
      h("div", gm, [
        B[9] || (B[9] = h("label", { for: "data-object-select" }, "Data Object", -1)),
        Ye(h("select", {
          required: "",
          id: "data-object-select",
          name: "data object",
          class: "select col-start-2",
          "onUpdate:modelValue": B[1] || (B[1] = (X) => u.value.dataObject = X),
          onChange: B[2] || (B[2] = (X) => A(["dataAttribute"]))
        }, [
          B[8] || (B[8] = h("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt($.value, (X) => (Q(), re("option", {
            key: X.id,
            value: X.name,
            title: X.desc ? `Desc: ${X.desc}` : ""
          }, ne(X.desc ? X.name + " ⓘ" : X.name), 9, bm))), 128))
        ], 544), [
          [Pt, u.value.dataObject]
        ])
      ]),
      h("div", wm, [
        B[11] || (B[11] = h("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
        Ye(h("select", {
          required: "",
          id: "data-attribute-select",
          name: "data attribute",
          "onUpdate:modelValue": B[3] || (B[3] = (X) => u.value.dataAttribute = X),
          class: "select col-start-2"
        }, [
          B[10] || (B[10] = h("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(U.value, (X) => (Q(), re("option", {
            key: X.id,
            value: X.name,
            title: X.desc ? `Desc: ${X.desc}` : ""
          }, ne(X.desc ? X.name + " ⓘ" : X.name), 9, _m))), 128))
        ], 512), [
          [Pt, u.value.dataAttribute]
        ])
      ]),
      h("div", Nm, [
        B[13] || (B[13] = h("label", {
          for: "process-resource-select",
          class: "col-start-1"
        }, "Process Resource", -1)),
        Ye(h("select", {
          id: "process-resource-select",
          name: "processResource",
          class: "select col-start-2",
          "onUpdate:modelValue": B[4] || (B[4] = (X) => u.value.processResourceId = X)
        }, [
          B[12] || (B[12] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(_e(k), (X) => (Q(), re("option", {
            key: X.id,
            value: X.id
          }, ne(X.name), 9, xm))), 128))
        ], 512), [
          [Pt, u.value.processResourceId]
        ])
      ]),
      h("div", Rm, [
        B[15] || (B[15] = h("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
        Ye(h("select", {
          id: "preferred-lnode-select",
          name: "preferredLNode",
          class: "select col-start-2",
          "onUpdate:modelValue": B[5] || (B[5] = (X) => u.value.preferredLNode = X)
        }, [
          B[14] || (B[14] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(D.value, (X) => (Q(), re("option", {
            key: X.lnClass,
            value: X.lnClass
          }, ne(X.lnClass), 9, Cm))), 128))
        ], 512), [
          [Pt, u.value.preferredLNode]
        ])
      ]),
      B[17] || (B[17] = h("hr", { class: "solid" }, null, -1)),
      h("div", Om, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": B[6] || (B[6] = (X) => p.value = X),
          class: "checkbox mr-2",
          id: "source-placeholder-checkbox-add-references"
        }, null, 512), [
          [Dr, p.value]
        ]),
        B[16] || (B[16] = h("label", { for: "source-placeholder-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      B[18] || (B[18] = h("div", { class: "modal-action" }, [
        h("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
      ], -1))
    ], 32));
  }
}), Em = {
  key: 0,
  class: "font-bold text-lg mb-4"
}, Im = {
  key: 1,
  class: "font-bold text-lg mb-4"
}, Am = { class: "grid grid-cols-2 gap-4 items-center" }, Dm = ["value", "disabled"], Pm = /* @__PURE__ */ _t({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {}
  },
  setup(t) {
    const r = t, i = Ke(""), s = He(
      () => r.sourceLNode.lnClass === "IHMI" || r.sourceLNode.lnClass === "ITCI"
    ), c = He(
      () => Object.values(et).filter((f) => f !== et.INTERNAL)
    );
    return (f, u) => (Q(), re($e, null, [
      i.value === _e(et).CONTROL ? (Q(), re("h3", Em, " Create Placeholder - Control data from ")) : (Q(), re("h3", Im, "Create Placeholder - Provide data")),
      h("div", Am, [
        u[2] || (u[2] = h("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
        Ye(h("select", {
          id: "dataflow-type-select",
          name: "dataflowType",
          class: "select col-start-2",
          "onUpdate:modelValue": u[0] || (u[0] = (p) => i.value = p)
        }, [
          u[1] || (u[1] = h("option", { value: "" }, "-", -1)),
          (Q(!0), re($e, null, lt(c.value, (p) => (Q(), re("option", {
            key: p,
            value: p,
            disabled: p === _e(et).CONTROL && !s.value
          }, ne(p), 9, Dm))), 128))
        ], 512), [
          [Pt, i.value]
        ])
      ]),
      u[3] || (u[3] = h("hr", { class: "solid mt-4" }, null, -1)),
      i.value !== _e(et).CONTROL ? (Q(), Lt(Tm, {
        key: 2,
        sourceLNode: r.sourceLNode,
        dataflowType: i.value
      }, null, 8, ["sourceLNode", "dataflowType"])) : (Q(), Lt(vm, {
        key: 3,
        controllerLNode: r.sourceLNode
      }, null, 8, ["controllerLNode"]))
    ], 64));
  }
}), Sm = { class: "grid grid-cols-2 gap-4 items-center" }, Lm = ["value", "title"], km = { class: "grid grid-cols-2 gap-4 items-center" }, jm = { class: "grid grid-cols-2 gap-4 items-center" }, $m = ["value"], Fm = { class: "grid grid-cols-2 gap-4 items-center" }, Mm = ["value"], Bm = { class: "flex items-center" }, Km = /* @__PURE__ */ _t({
  __name: "control-dataflow-destination-placeholder-form",
  props: {
    controlledLNode: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { lnodeTypes: c, dataflowSdk: f } = jt(s), u = Ke(
      W()
    ), p = Ke(!0);
    qt(
      () => u.value.dataObject,
      (A, P) => {
        u.value.outputName !== P && u.value.outputName !== "" || (u.value.outputName = A);
      }
    );
    const v = He(
      () => c.value.filter((A) => A.lnClass === "IHMI" || A.lnClass === "ITCI").sort((A, P) => A.lnClass.localeCompare(P.lnClass))
    ), k = Gi(async () => f.value ? (await f.value.findProcessResourcesForLnode(
      r.controlledLNode.id
    )).map((P) => ({
      name: kr(P, "name"),
      id: P.id
    })).sort((P, B) => P.name.localeCompare(B.name)) : []), D = He(() => {
      const A = c.value.find(
        (P) => P.typeId === r.controlledLNode.lnType
      );
      return Te(A, `LNodeType of class ${r.controlledLNode.lnClass} not found`), A?.dataObjects.map((P) => ({
        name: P.name,
        desc: P.desc,
        id: P.id
      })).sort((P, B) => P.name.localeCompare(B.name)) ?? [];
    });
    async function $() {
      try {
        if (!U(u.value))
          return;
        await f.value.createControlDestinationPlaceholder(
          u.value,
          r.controlledLNode,
          p.value
        ), i.handleClose();
      } catch (A) {
        console.error("Error creating control destination placeholder port:", A), alert(`Error creating placeholder: ${A instanceof Error ? A.message : "Unknown error"}`);
      }
    }
    function U(A) {
      return A.outputName ? A.dataObject ? !0 : (alert("Please enter a data object to be controlled."), !1) : (alert("Please enter a controller output name."), !1);
    }
    function W() {
      return {
        outputName: "",
        preferredLNode: "",
        dataObject: "",
        processResourceId: ""
      };
    }
    return (A, P) => (Q(), re("form", {
      onSubmit: $,
      method: "dialog",
      class: "flex flex-col gap-4 mt-4"
    }, [
      h("div", Sm, [
        P[6] || (P[6] = h("label", { for: "data-object-select" }, "Controlled Data Object", -1)),
        Ye(h("select", {
          required: "",
          id: "data-object-select",
          name: "data object",
          class: "select col-start-2",
          "onUpdate:modelValue": P[0] || (P[0] = (B) => u.value.dataObject = B)
        }, [
          P[5] || (P[5] = h("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(D.value, (B) => (Q(), re("option", {
            key: B.id,
            value: B.name,
            title: B.desc ? `Desc: ${B.desc}` : ""
          }, ne(B.desc ? B.name + " ⓘ" : B.name), 9, Lm))), 128))
        ], 512), [
          [Pt, u.value.dataObject]
        ])
      ]),
      h("div", km, [
        P[7] || (P[7] = h("label", { for: "output-name" }, "Controller Output Name", -1)),
        Ye(h("input", {
          id: "output-name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": P[1] || (P[1] = (B) => u.value.outputName = B)
        }, null, 512), [
          [Jn, u.value.outputName]
        ])
      ]),
      h("div", jm, [
        P[9] || (P[9] = h("label", {
          for: "process-resource-select",
          class: "col-start-1"
        }, "Process Resource", -1)),
        Ye(h("select", {
          id: "process-resource-select",
          name: "processResource",
          class: "select col-start-2",
          "onUpdate:modelValue": P[2] || (P[2] = (B) => u.value.processResourceId = B)
        }, [
          P[8] || (P[8] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(_e(k), (B) => (Q(), re("option", {
            key: B.id,
            value: B.id
          }, ne(B.name), 9, $m))), 128))
        ], 512), [
          [Pt, u.value.processResourceId]
        ])
      ]),
      h("div", Fm, [
        P[11] || (P[11] = h("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
        Ye(h("select", {
          id: "preferred-lnode-select",
          name: "preferredLNode",
          class: "select col-start-2",
          "onUpdate:modelValue": P[3] || (P[3] = (B) => u.value.preferredLNode = B)
        }, [
          P[10] || (P[10] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(v.value, (B) => (Q(), re("option", {
            key: B.lnClass,
            value: B.lnClass
          }, ne(B.lnClass), 9, Mm))), 128))
        ], 512), [
          [Pt, u.value.preferredLNode]
        ])
      ]),
      P[13] || (P[13] = h("hr", { class: "solid" }, null, -1)),
      h("div", Bm, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": P[4] || (P[4] = (B) => p.value = B),
          class: "checkbox mr-2",
          id: "dataflow-control-checkbox-add-references"
        }, null, 512), [
          [Dr, p.value]
        ]),
        P[12] || (P[12] = h("label", { for: "dataflow-control-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      P[14] || (P[14] = h("div", { class: "modal-action" }, [
        h("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
      ], -1))
    ], 32));
  }
}), qm = { class: "grid grid-cols-2 gap-4" }, Um = { class: "flex items-center" }, Vm = { class: "flex items-center" }, Wm = ["value"], Gm = { class: "grid grid-cols-2 gap-4" }, Hm = { class: "grid grid-cols-2 gap-4" }, Ym = ["value"], zm = { class: "grid grid-cols-2 gap-4" }, Xm = ["value", "title"], Qm = { class: "grid grid-cols-2 gap-4" }, Jm = ["value", "title"], Zm = { class: "grid grid-cols-2 gap-4" }, ev = ["value"], tv = { class: "flex items-center" }, nv = /* @__PURE__ */ _t({
  __name: "destination-placeholder-form",
  props: {
    dataflowType: {},
    destinationLNode: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { lnodeTypes: c, dataflowSdk: f } = jt(s), u = Ke(
      A()
    ), p = Ke(!0), v = Ke(!1), k = Ke([]);
    Po(async () => {
      k.value = await f.value.findExistingInputs(r.destinationLNode);
    }), qt(
      () => r.dataflowType,
      () => {
        u.value = A();
      },
      { immediate: !0 }
    ), qt(v, () => {
      u.value.inputName = "";
    }), qt(
      [
        () => u.value.inputName,
        () => u.value.preferredDataAttribute
      ],
      async ([X, F]) => {
        if (!X) {
          u.value.inputInstance = "";
          return;
        }
        const E = await f.value.calculateNextInputInstance(
          X,
          F,
          r.destinationLNode
        );
        u.value.inputInstance = E.toString();
      }
    );
    const D = Gi(async () => f.value ? (await f.value.findProcessResourcesForLnode(
      r.destinationLNode.id
    )).map((F) => ({
      name: kr(F, "name"),
      id: F.id
    })).sort((F, E) => F.name.localeCompare(E.name)) : []), $ = He(
      () => [...c.value].sort((X, F) => X.lnClass.localeCompare(F.lnClass))
    ), U = He(() => {
      const X = c.value.find(
        (F) => F.lnClass === u.value.preferredLNode
      );
      return X ? u.value.dataflowType ? X.dataObjects.filter(
        (F) => F.dataAttributes.some(
          (E) => Uo[u.value.dataflowType].includes(E.fc)
        )
      ).map((F) => ({
        name: F.name,
        desc: F.desc
      })).sort((F, E) => F.name.localeCompare(E.name)) : X.dataObjects.map((F) => ({
        name: F.name,
        desc: F.desc
      })).sort((F, E) => F.name.localeCompare(E.name)) : [];
    }), W = He(() => {
      const X = c.value.find(
        (E) => E.lnClass === u.value.preferredLNode
      );
      if (!X) return [];
      const F = X.dataObjects.find(
        (E) => E.name === u.value.preferredDataObject
      );
      return F ? u.value.dataflowType ? F.dataAttributes.filter(
        (E) => Uo[u.value.dataflowType].includes(E.fc)
      ).filter((E) => !Ki.includes(E.name)).sort((E, K) => E.name.localeCompare(K.name)) : F.dataAttributes.filter((E) => !Ki.includes(E.name)).sort((E, K) => E.name.localeCompare(K.name)) : [];
    });
    function A() {
      return {
        dataflowType: r.dataflowType || null,
        inputName: "",
        inputInstance: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResourceId: ""
      };
    }
    async function P() {
      try {
        await f.value.createDestinationPlaceholder(
          u.value,
          r.destinationLNode,
          p.value
        ), i.handleClose();
      } catch (X) {
        console.error("Error creating destination placeholder port:", X), alert(`Error creating placeholder: ${X instanceof Error ? X.message : "Unknown error"}`);
      }
    }
    function B(X) {
      for (const F of X)
        u.value[F] = "";
    }
    return (X, F) => (Q(), re("form", {
      method: "dialog",
      onSubmit: P,
      class: "flex flex-col gap-4 mt-4"
    }, [
      h("div", qm, [
        h("fieldset", null, [
          F[14] || (F[14] = h("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
          h("div", Um, [
            Ye(h("input", {
              type: "radio",
              id: "destination-placeholder-new-input",
              name: "input",
              "onUpdate:modelValue": F[0] || (F[0] = (E) => v.value = E),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, v.value]
            ]),
            F[12] || (F[12] = h("label", { for: "destination-placeholder-new-input" }, "New Input", -1))
          ]),
          h("div", Vm, [
            Ye(h("input", {
              type: "radio",
              id: "destination-placeholder-existing-input",
              name: "input",
              "onUpdate:modelValue": F[1] || (F[1] = (E) => v.value = E),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Zn, v.value]
            ]),
            F[13] || (F[13] = h("label", { for: "destination-placeholder-existing-input" }, "Existing Input", -1))
          ])
        ]),
        v.value ? We("", !0) : Ye((Q(), re("input", {
          key: 0,
          "aria-label": "New Input Name",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": F[2] || (F[2] = (E) => u.value.inputName = E)
        }, null, 512)), [
          [Jn, u.value.inputName]
        ]),
        v.value ? Ye((Q(), re("select", {
          key: 1,
          "aria-label": "Existing Input Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": F[3] || (F[3] = (E) => u.value.inputName = E)
        }, [
          (Q(!0), re($e, null, lt(k.value, (E) => (Q(), re("option", {
            key: E,
            value: E
          }, ne(E), 9, Wm))), 128))
        ], 512)), [
          [Pt, u.value.inputName]
        ]) : We("", !0)
      ]),
      h("div", Gm, [
        F[15] || (F[15] = h("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        Ye(h("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": F[4] || (F[4] = (E) => u.value.inputInstance = E)
        }, null, 512), [
          [Jn, u.value.inputInstance]
        ])
      ]),
      h("div", Hm, [
        F[17] || (F[17] = h("label", {
          for: "preferred-lnode-select",
          class: "col-start-1 self-center"
        }, "Preferred LNode", -1)),
        Ye(h("select", {
          id: "preferred-lnode-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[5] || (F[5] = (E) => u.value.preferredLNode = E),
          onChange: F[6] || (F[6] = (E) => B(["preferredDataObject"]))
        }, [
          F[16] || (F[16] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt($.value, (E) => (Q(), re("option", {
            key: E.id,
            value: E.lnClass
          }, ne(E.lnClass), 9, Ym))), 128))
        ], 544), [
          [Pt, u.value.preferredLNode]
        ])
      ]),
      h("div", zm, [
        F[19] || (F[19] = h("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Preferred Data Object", -1)),
        Ye(h("select", {
          id: "data-object-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[7] || (F[7] = (E) => u.value.preferredDataObject = E),
          onChange: F[8] || (F[8] = (E) => B(["preferredDataAttribute"]))
        }, [
          F[18] || (F[18] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(U.value, (E) => (Q(), re("option", {
            key: E.name,
            value: E.name,
            title: E.desc ? `Desc: ${E.desc}` : ""
          }, ne(E.desc ? E.name + " ⓘ" : E.name), 9, Xm))), 128))
        ], 544), [
          [Pt, u.value.preferredDataObject]
        ])
      ]),
      h("div", Qm, [
        F[21] || (F[21] = h("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Preferred Data Attribute", -1)),
        Ye(h("select", {
          id: "data-attribute-select",
          class: "select col-start-2",
          "onUpdate:modelValue": F[9] || (F[9] = (E) => u.value.preferredDataAttribute = E)
        }, [
          F[20] || (F[20] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(W.value, (E) => (Q(), re("option", {
            key: E.name,
            value: E.name,
            title: E.desc ? `Desc: ${E.desc}` : ""
          }, ne(E.desc ? E.name + " ⓘ" : E.name), 9, Jm))), 128))
        ], 512), [
          [Pt, u.value.preferredDataAttribute]
        ])
      ]),
      h("div", Zm, [
        F[23] || (F[23] = h("label", {
          for: "process-resource-select",
          class: "col-start-1"
        }, "Process Resource", -1)),
        Ye(h("select", {
          id: "process-resource-select",
          name: "processResource",
          class: "select col-start-2",
          "onUpdate:modelValue": F[10] || (F[10] = (E) => u.value.processResourceId = E)
        }, [
          F[22] || (F[22] = h("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (Q(!0), re($e, null, lt(_e(D), (E) => (Q(), re("option", {
            key: E.id,
            value: E.id
          }, ne(E.name), 9, ev))), 128))
        ], 512), [
          [Pt, u.value.processResourceId]
        ])
      ]),
      F[25] || (F[25] = h("hr", { class: "solid" }, null, -1)),
      h("div", tv, [
        Ye(h("input", {
          type: "checkbox",
          "onUpdate:modelValue": F[11] || (F[11] = (E) => p.value = E),
          class: "checkbox mr-2",
          id: "destination-placeholder-checkbox-add-references"
        }, null, 512), [
          [Dr, p.value]
        ]),
        F[24] || (F[24] = h("label", { for: "destination-placeholder-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      F[26] || (F[26] = h("div", { class: "modal-action" }, [
        h("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          type: "submit"
        }, "Save")
      ], -1))
    ], 32));
  }
}), rv = {
  key: 0,
  class: "font-bold text-lg mb-4"
}, ov = {
  key: 1,
  class: "font-bold text-lg mb-4"
}, iv = { class: "grid grid-cols-2 gap-4 items-center" }, av = ["value"], sv = /* @__PURE__ */ _t({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {}
  },
  setup(t) {
    const r = t, i = Ke(""), s = He(
      () => Object.values(et).filter((c) => c !== et.INTERNAL)
    );
    return (c, f) => (Q(), re($e, null, [
      i.value === _e(et).CONTROL ? (Q(), re("h3", rv, " Create Placeholder - Controlled data by ")) : (Q(), re("h3", ov, "Create Placeholder - Receive data from")),
      h("div", iv, [
        f[2] || (f[2] = h("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
        Ye(h("select", {
          id: "dataflow-type-select",
          name: "dataflowType",
          class: "select col-start-2",
          "onUpdate:modelValue": f[0] || (f[0] = (u) => i.value = u)
        }, [
          f[1] || (f[1] = h("option", { value: "" }, "-", -1)),
          (Q(!0), re($e, null, lt(s.value, (u) => (Q(), re("option", {
            key: u,
            value: u
          }, ne(u), 9, av))), 128))
        ], 512), [
          [Pt, i.value]
        ])
      ]),
      f[3] || (f[3] = h("hr", { class: "solid mt-4" }, null, -1)),
      i.value !== _e(et).CONTROL ? (Q(), Lt(nv, {
        key: 2,
        destinationLNode: r.destinationLNode,
        dataflowType: i.value
      }, null, 8, ["destinationLNode", "dataflowType"])) : (Q(), Lt(Km, {
        key: 3,
        controlledLNode: r.destinationLNode
      }, null, 8, ["controlledLNode"]))
    ], 64));
  }
}), lv = { class: "grid grid-cols-[1fr_20px_0.5fr_20px_1fr] w-full mb-8 grid-rows-[50px_50px_80px]" }, uv = { class: "col-start-1 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, cv = { class: "col-start-1 col-span-2 self-center justify-self-center row-start-2 text-center" }, dv = { class: "col-start-4 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, fv = { class: "col-start-4 col-span-2 self-center justify-self-center row-start-2 text-center" }, pv = { class: "col-span-full row-start-3" }, hv = { class: "grid grid-cols-[1fr_20px_0.5fr_20px_1fr] h-[50px]" }, mv = { class: "col-start-1 col-span-1 self-center justify-self-end" }, vv = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, yv = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 p-1 rounded-sm text-sm row-start-1" }, gv = { class: "col-start-5 col-span-1 self-center justify-self-start" }, bv = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, ta = /* @__PURE__ */ _t({
  __name: "single-dataflow",
  props: {
    sendingSecondaryLabel: {},
    receivingSecondaryLabel: {},
    sendingPrimaryLabel: {},
    receivingPrimaryLabel: {},
    dataflowType: {},
    sendingPortLabels: {},
    receivingPortLabels: {}
  },
  setup(t) {
    return (r, i) => (Q(), re("div", lv, [
      i[2] || (i[2] = h("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2" }, null, -1)),
      h("div", uv, ne(r.sendingSecondaryLabel), 1),
      h("div", cv, ne(r.sendingPrimaryLabel), 1),
      i[3] || (i[3] = h("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2" }, null, -1)),
      h("div", dv, ne(r.receivingSecondaryLabel), 1),
      h("div", fv, ne(r.receivingPrimaryLabel), 1),
      h("div", pv, [
        h("div", hv, [
          h("div", mv, [
            (Q(!0), re($e, null, lt(r.sendingPortLabels, (s) => (Q(), re("span", vv, ne(s), 1))), 256))
          ]),
          i[0] || (i[0] = hc('<div class="rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] bg-(--color-ocean-gray-100)"></div><div class="col-start-3 col-span-1 row-start-1 flex items-center"><div class="border h-[2px] w-full border-(--color-ocean-gray-100) border-solid"></div></div><svg height="12" width="8" class="col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1" xmlns="http://www.w3.org/2000/svg"><polygon points="0,0 8,6 0,12" style="fill:var(--color-ocean-gray-100);"></polygon></svg>', 3)),
          h("div", yv, ne(r.dataflowType), 1),
          i[1] || (i[1] = h("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] bg-(--color-ocean-gray-100)" }, null, -1)),
          h("div", gv, [
            (Q(!0), re($e, null, lt(r.receivingPortLabels, (s) => (Q(), re("span", bv, ne(s), 1))), 256))
          ])
        ])
      ])
    ]));
  }
}), wv = { class: "bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2 p-3" }, _v = { class: "text-center text-xs mb-4" }, Nv = { class: "flex flex-col justify-between gap-4" }, xv = { class: "flex-1 bg-(--color-ocean-gray-50) rounded-xl border-(--color-ocean-gray-100) border-2 p-3" }, Rv = { class: "text-center mb-4" }, Cv = { key: 0 }, Ov = { class: "grid grid-cols-[max-content_auto] gap-x-2" }, Tv = { class: "collapse collapse-arrow mt-2" }, Ev = { class: "collapse-content text-sm px-5 pt-1" }, Iv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, Av = { key: 1 }, Dv = { class: "grid grid-cols-[max-content_auto] gap-x-2" }, Pv = { class: "collapse collapse-arrow mt-2" }, Sv = { class: "collapse-content text-sm px-5 pt-1" }, Lv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, kv = { class: "collapse collapse-arrow mt-2" }, jv = { class: "collapse-content text-sm px-5 pt-1" }, $v = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, Fv = { key: 2 }, Mv = { class: "grid grid-cols-[max-content_auto] gap-x-2" }, Bv = { class: "collapse collapse-arrow mt-2" }, Kv = { class: "collapse-content text-sm px-5 pt-1" }, qv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, Uv = { class: "collapse collapse-arrow mt-2" }, Vv = { class: "collapse-content text-sm px-5 pt-1" }, Wv = { class: "grid grid-cols-[max-content_auto] gap-x-2 [&>dt]:text-right" }, Gv = { class: "flex-1 bg-(--color-ocean-gray-50) rounded-xl border-(--color-ocean-gray-100) border-2 p-3" }, Hv = { class: "text-center mb-4" }, Yv = { class: "list-disc pl-5" }, zv = /* @__PURE__ */ _t({
  __name: "dataflow-implementation-details",
  props: {
    dataflowType: {},
    ldInst: {},
    controlBlock: {},
    dataSet: {},
    fcdas: {},
    ln0Path: {}
  },
  setup(t) {
    const r = t, i = It(), { dataflowSdk: s } = jt(i), c = Ke(), f = Ke(), u = Ke();
    return Da(async () => {
      r.dataflowType === et.GOOSE ? c.value = await s.value.findGseControlBlockDetails(
        r.controlBlock.id,
        r.ldInst
      ) : r.dataflowType === et.SMV ? f.value = await s.value.findSmvControlBlockDetails(
        r.controlBlock.id,
        r.ldInst
      ) : r.dataflowType === et.REPORT && (u.value = await s.value.findReportControlBlockDetails(
        r.controlBlock.id
      ));
    }), (p, v) => (Q(), re("div", wv, [
      h("div", _v, ne(p.ln0Path), 1),
      h("div", Nv, [
        h("div", xv, [
          h("div", Rv, ne(p.controlBlock.name), 1),
          c.value ? (Q(), re("div", Cv, [
            h("dl", Ov, [
              v[0] || (v[0] = h("dt", null, "App ID:", -1)),
              h("dd", null, ne(c.value.appId), 1),
              v[1] || (v[1] = h("dt", null, "ConfRev:", -1)),
              h("dd", null, ne(p.controlBlock.confRev), 1)
            ]),
            h("details", Tv, [
              v[6] || (v[6] = h("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, " Communication ", -1)),
              h("div", Ev, [
                h("dl", Iv, [
                  v[2] || (v[2] = h("dt", null, "MAC Address:", -1)),
                  h("dd", null, ne(c.value.communicationDetails.macAddress), 1),
                  v[3] || (v[3] = h("dt", null, "App ID:", -1)),
                  h("dd", null, ne(c.value.communicationDetails.appId), 1),
                  v[4] || (v[4] = h("dt", null, "VLAN ID:", -1)),
                  h("dd", null, ne(c.value.communicationDetails.vlanId), 1),
                  v[5] || (v[5] = h("dt", null, "VLAN Priority:", -1)),
                  h("dd", null, ne(c.value.communicationDetails.vlanPriority), 1)
                ])
              ])
            ])
          ])) : We("", !0),
          f.value ? (Q(), re("div", Av, [
            h("dl", Dv, [
              v[7] || (v[7] = h("dt", null, "SMV ID:", -1)),
              h("dd", null, ne(f.value.smvId), 1),
              v[8] || (v[8] = h("dt", null, "ConfRev:", -1)),
              h("dd", null, ne(p.controlBlock.confRev), 1),
              v[9] || (v[9] = h("dt", null, "Multicast:", -1)),
              h("dd", null, ne(f.value.multicast), 1),
              v[10] || (v[10] = h("dt", null, "NofASDU:", -1)),
              h("dd", null, ne(f.value.nofAsdu), 1),
              v[11] || (v[11] = h("dt", null, "SmpMod:", -1)),
              h("dd", null, ne(f.value.smpMod), 1),
              v[12] || (v[12] = h("dt", null, "SmpRate:", -1)),
              h("dd", null, ne(f.value.smpRate), 1)
            ]),
            h("details", Pv, [
              v[19] || (v[19] = h("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, "SmvOpts", -1)),
              h("div", Sv, [
                h("dl", Lv, [
                  v[13] || (v[13] = h("dt", null, "RefreshTime:", -1)),
                  h("dd", null, ne(f.value.smvOpts.refreshTime), 1),
                  v[14] || (v[14] = h("dt", null, "SampleSynchronized:", -1)),
                  h("dd", null, ne(f.value.smvOpts.sampleSynchronized), 1),
                  v[15] || (v[15] = h("dt", null, "SampleRate:", -1)),
                  h("dd", null, ne(f.value.smvOpts.sampleRate), 1),
                  v[16] || (v[16] = h("dt", null, "DataSet:", -1)),
                  h("dd", null, ne(f.value.smvOpts.dataSet), 1),
                  v[17] || (v[17] = h("dt", null, "Security:", -1)),
                  h("dd", null, ne(f.value.smvOpts.security), 1),
                  v[18] || (v[18] = h("dt", null, "SynchSourceId:", -1)),
                  h("dd", null, ne(f.value.smvOpts.synchSourceId), 1)
                ])
              ])
            ]),
            h("details", kv, [
              v[24] || (v[24] = h("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, " Communication ", -1)),
              h("div", jv, [
                h("dl", $v, [
                  v[20] || (v[20] = h("dt", null, "MAC Address:", -1)),
                  h("dd", null, ne(f.value.communicationDetails.macAddress), 1),
                  v[21] || (v[21] = h("dt", null, "App ID:", -1)),
                  h("dd", null, ne(f.value.communicationDetails.appId), 1),
                  v[22] || (v[22] = h("dt", null, "VLAN ID:", -1)),
                  h("dd", null, ne(f.value.communicationDetails.vlanId), 1),
                  v[23] || (v[23] = h("dt", null, "VLAN Priority:", -1)),
                  h("dd", null, ne(f.value.communicationDetails.vlanPriority), 1)
                ])
              ])
            ])
          ])) : We("", !0),
          u.value ? (Q(), re("div", Fv, [
            h("dl", Mv, [
              v[25] || (v[25] = h("dt", null, "RPT ID:", -1)),
              h("dd", null, ne(u.value.rptId), 1),
              v[26] || (v[26] = h("dt", null, "ConfRev:", -1)),
              h("dd", null, ne(p.controlBlock.confRev), 1),
              v[27] || (v[27] = h("dt", null, "Buffered:", -1)),
              h("dd", null, ne(u.value.buffered), 1)
            ]),
            h("details", Bv, [
              v[33] || (v[33] = h("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, "TrgOps", -1)),
              h("div", Kv, [
                h("dl", qv, [
                  v[28] || (v[28] = h("dt", null, "Dchg:", -1)),
                  h("dd", null, ne(u.value.trgOps.dchg), 1),
                  v[29] || (v[29] = h("dt", null, "Dupd:", -1)),
                  h("dd", null, ne(u.value.trgOps.dupd), 1),
                  v[30] || (v[30] = h("dt", null, "Gi:", -1)),
                  h("dd", null, ne(u.value.trgOps.gi), 1),
                  v[31] || (v[31] = h("dt", null, "Period:", -1)),
                  h("dd", null, ne(u.value.trgOps.period), 1),
                  v[32] || (v[32] = h("dt", null, "Qchg:", -1)),
                  h("dd", null, ne(u.value.trgOps.qchg), 1)
                ])
              ])
            ]),
            h("details", Uv, [
              v[42] || (v[42] = h("summary", { class: "collapse-title after:start-0 after:!top-3 ps-5 p-0" }, "OptFields", -1)),
              h("div", Vv, [
                h("dl", Wv, [
                  v[34] || (v[34] = h("dt", null, "BufOvfl:", -1)),
                  h("dd", null, ne(u.value.optFields.bufOvfl), 1),
                  v[35] || (v[35] = h("dt", null, "ConfigRef:", -1)),
                  h("dd", null, ne(u.value.optFields.configRef), 1),
                  v[36] || (v[36] = h("dt", null, "DataRef:", -1)),
                  h("dd", null, ne(u.value.optFields.dataRef), 1),
                  v[37] || (v[37] = h("dt", null, "DataSet:", -1)),
                  h("dd", null, ne(u.value.optFields.dataSet), 1),
                  v[38] || (v[38] = h("dt", null, "EntryID:", -1)),
                  h("dd", null, ne(u.value.optFields.entryId), 1),
                  v[39] || (v[39] = h("dt", null, "ReasonCode:", -1)),
                  h("dd", null, ne(u.value.optFields.reasonCode), 1),
                  v[40] || (v[40] = h("dt", null, "SeqNum:", -1)),
                  h("dd", null, ne(u.value.optFields.seqNum), 1),
                  v[41] || (v[41] = h("dt", null, "TimeStamp:", -1)),
                  h("dd", null, ne(u.value.optFields.timeStamp), 1)
                ])
              ])
            ])
          ])) : We("", !0)
        ]),
        h("div", Gv, [
          h("div", Hv, ne(p.dataSet.name), 1),
          h("ul", Yv, [
            (Q(!0), re($e, null, lt(p.fcdas, (k) => (Q(), re("li", null, ne(`${k.doName}.${k.daName} (fc: ${k.fc || "-"})`), 1))), 256))
          ])
        ])
      ])
    ]));
  }
}), Xv = { class: "font-bold text-lg mb-4" }, Qv = { key: 0 }, Jv = { key: 1 }, Zv = {
  key: 4,
  class: "modal-action"
}, ey = /* @__PURE__ */ _t({
  __name: "dataflow-implementation",
  props: {
    connection: {},
    extRef: {}
  },
  setup(t) {
    const r = t, i = In(), s = It(), { dataflowSdk: c, lnodes: f } = jt(s), u = Ke(""), p = Ke(""), v = Ke(""), k = Ke(), D = Ke(), $ = Ke([]);
    qt(
      () => r.extRef,
      async function(ge) {
        ge && (v.value = await c.value.findPathToExtRef(ge.id), ge.srcCbName && (k.value = await c.value.findControlBlock(
          ge.iedName,
          ge.ldInst,
          ge.srcCbName
        ), D.value = await c.value.findDataSet(
          ge.iedName,
          ge.ldInst,
          k.value.datSet
        ), $.value = await c.value.findFcdasForDataSet(D.value.id)));
      },
      { immediate: !0 }
    ), qt(
      () => r.connection,
      async function(ge) {
        Te(ge.sourceLNodeId, "Source LNodeId is undefined"), u.value = await c.value.findPathToLnode(ge.sourceLNodeId), p.value = await c.value.findPathToLnode(
          ge.destinationLNodeId
        );
      },
      { immediate: !0 }
    );
    const U = He(() => u.value.split("/").slice(-1).join("")), W = He(() => u.value.split("/").slice(0, -1).join("/")), A = He(() => p.value.split("/").slice(-1).join("")), P = He(() => p.value.split("/").slice(0, -1).join("/")), B = He(() => {
      if (!r.connection.isImplemented) {
        const de = f.value.find((ge) => ge.id === r.connection.sourceLNodeId);
        return Te(de, "Sending LNode not found"), `${de.prefix}${de.lnClass}${de.lnInst}`;
      }
      return `${r.extRef?.prefix ?? ""}${r.extRef?.lnClass}${r.extRef?.lnInst ?? ""}`;
    }), X = He(() => {
      if (!r.connection.isImplemented) {
        const de = f.value.find((ge) => ge.id === r.connection.sourceLNodeId);
        return Te(de, "Sending LNode not found"), `${de.iedName}/${de.ldInst}`;
      }
      return `${r.extRef?.iedName}/${r.extRef?.ldInst}`;
    }), F = He(() => v.value.split("/").slice(-2, -1).join("")), E = He(() => v.value.split("/").slice(0, -2).join("/")), K = He(() => `${r.extRef?.iedName}/${r.extRef?.srcLdInst}/${r.extRef?.srcPrefix}${r.extRef?.srcLnClass}${r.extRef?.srcLnInst}`);
    async function we() {
      try {
        if (!r.extRef)
          throw new Error("No matching ExtRef found for dataflow implementation");
        await c.value.implementDataflow(r.connection, r.extRef), i.handleClose();
      } catch (de) {
        console.error("Error implementing dataflow:", de), alert(`Error implementing dataflow: ${de instanceof Error ? de.message : "Unknown error"}`);
      }
    }
    return (de, ge) => (Q(), re($e, null, [
      h("h3", Xv, ne(de.connection.isImplemented ? "Implemented Dataflow Details" : "Implement Dataflow"), 1),
      de.extRef ? We("", !0) : (Q(), re("p", Qv, "No matching ExtRef found for dataflow implementation.")),
      de.connection.notPossibleToImplement ? (Q(), re("p", Jv, "Sending or receiving LNode is not mapped to a real IED.")) : We("", !0),
      de.extRef && de.connection.isImplemented ? (Q(), re($e, { key: 2 }, [
        ge[0] || (ge[0] = h("h3", { class: "mb-4" }, "Specification:", -1)),
        ft(ta, {
          sendingSecondaryLabel: W.value,
          sendingPrimaryLabel: U.value,
          receivingSecondaryLabel: P.value,
          receivingPrimaryLabel: A.value,
          dataflowType: de.connection.dataflowType,
          sendingPortLabels: [de.connection.sourceDataObject, de.connection.sourceDataAttribute],
          receivingPortLabels: [de.connection.input, de.connection.inputInstance]
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"]),
        ge[1] || (ge[1] = h("h3", { class: "mb-4" }, "Implementation:", -1)),
        ft(ta, {
          sendingSecondaryLabel: X.value,
          sendingPrimaryLabel: B.value,
          receivingSecondaryLabel: E.value,
          receivingPrimaryLabel: F.value,
          dataflowType: de.extRef.serviceType,
          sendingPortLabels: [de.extRef.doName, de.extRef.daName],
          receivingPortLabels: [de.extRef.intAddr, de.extRef.desc].filter(Boolean)
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"]),
        k.value && D.value ? (Q(), Lt(zv, {
          key: 0,
          controlBlock: k.value,
          dataSet: D.value,
          fcdas: $.value,
          ln0Path: K.value,
          dataflowType: de.extRef.serviceType,
          ldInst: de.extRef.srcLdInst
        }, null, 8, ["controlBlock", "dataSet", "fcdas", "ln0Path", "dataflowType", "ldInst"])) : We("", !0)
      ], 64)) : We("", !0),
      de.extRef && !de.connection.notPossibleToImplement && !de.connection.isImplemented ? (Q(), re($e, { key: 3 }, [
        ge[2] || (ge[2] = h("h3", { class: "mb-4" }, "Specification:", -1)),
        ft(ta, {
          sendingSecondaryLabel: W.value,
          sendingPrimaryLabel: U.value,
          receivingSecondaryLabel: P.value,
          receivingPrimaryLabel: A.value,
          dataflowType: de.connection.dataflowType,
          sendingPortLabels: [de.connection.sourceDataObject, de.connection.sourceDataAttribute],
          receivingPortLabels: [de.connection.input, de.connection.inputInstance]
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"]),
        ge[3] || (ge[3] = h("h3", { class: "mb-4" }, "Matching ExtRef to implement:", -1)),
        ft(ta, {
          sendingSecondaryLabel: X.value,
          sendingPrimaryLabel: B.value,
          receivingSecondaryLabel: E.value,
          receivingPrimaryLabel: F.value,
          dataflowType: de.extRef.serviceType || de.extRef.pServT || de.connection.dataflowType,
          sendingPortLabels: [
            de.extRef.pDo || de.connection.sourceDataObject,
            de.extRef.pDa || de.connection.sourceDataAttribute
          ],
          receivingPortLabels: [de.extRef.intAddr, de.extRef.desc].filter(Boolean)
        }, null, 8, ["sendingSecondaryLabel", "sendingPrimaryLabel", "receivingSecondaryLabel", "receivingPrimaryLabel", "dataflowType", "sendingPortLabels", "receivingPortLabels"])
      ], 64)) : We("", !0),
      !de.connection.isImplemented && !de.connection.notPossibleToImplement ? (Q(), re("div", Zv, [
        h("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: we
        }, " Implement ")
      ])) : We("", !0)
    ], 64));
  }
}), In = /* @__PURE__ */ sl("dataflow/dialog-store", () => {
  const t = {
    component: void 0,
    props: void 0
  }, r = Ke(), i = Ke(t), s = Ke(), c = Ui({
    DataflowCreation: Dn(Zh),
    SourcePlaceholderCreation: Dn(Pm),
    DestinationPlaceholderCreation: Dn(sv),
    DataflowImplementation: Dn(ey)
  });
  function f() {
    i.value = {
      component: void 0,
      props: void 0
    };
  }
  function u() {
    r.value?.close(), rm(() => {
      f();
    }, 300);
  }
  function p(v, k, D) {
    i.value.component = Ea(c[v]), i.value.props = k, D && (s.value = D), r.value?.showModal();
  }
  return {
    // states
    dialogRef: r,
    currentDialogContent: i,
    availableDialogContent: c,
    dialogAttributes: s,
    // getters
    // actions
    hardReset: f,
    handleClose: u,
    openDialogWithContent: p
  };
}), ty = ["onClick"], ny = /* @__PURE__ */ _t({
  __name: "context-menu",
  props: {
    x: {},
    y: {},
    isVisible: { type: Boolean },
    items: {}
  },
  emits: ["close"],
  setup(t, { emit: r }) {
    const i = t, s = r, c = He(() => ({
      left: `${i.x}px`,
      top: `${i.y}px`,
      display: i.isVisible ? "flex" : "none"
    }));
    function f(u) {
      u.action(), s("close");
    }
    return (u, p) => (Q(), re($e, null, [
      u.isVisible ? (Q(), re("div", {
        key: 0,
        class: "menu bg-base-100 rounded-box fixed z-10",
        style: jr(c.value)
      }, [
        h("ul", null, [
          (Q(!0), re($e, null, lt(u.items, (v) => (Q(), re("li", null, [
            h("a", {
              onClick: (k) => f(v)
            }, ne(v.label), 9, ty)
          ]))), 256))
        ])
      ], 4)) : We("", !0),
      (Q(), Lt(Ur, { to: "body" }, [
        i.isVisible ? (Q(), re("div", {
          key: 0,
          class: "backdrop",
          onClick: p[0] || (p[0] = ga((v) => u.$emit("close"), ["prevent"])),
          onContextmenu: p[1] || (p[1] = ga((v) => u.$emit("close"), ["prevent"]))
        }, null, 32)) : We("", !0)
      ]))
    ], 64));
  }
}), Hi = (t, r) => {
  const i = t.__vccOpts || t;
  for (const [s, c] of r)
    i[s] = c;
  return i;
}, ry = /* @__PURE__ */ Hi(ny, [["__scopeId", "data-v-9cc5b747"]]), oy = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, iy = ["onClick"], ay = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, sy = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, ly = ["onClick"], uy = ["onClick", "onContextmenu"], cy = ["data-testid"], dy = ["onClick"], fy = ["onClick", "onContextmenu"], py = ["onClick"], hy = ["onClick"], my = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, vy = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, yy = /* @__PURE__ */ _t({
  __name: "dataflow-connections",
  props: {
    connections: {},
    isDataflowImplementationEnabled: { type: Boolean }
  },
  setup(t) {
    const r = t, i = ja(), { activeElement: s } = jt(i), c = It(), { dataflowSdk: f } = jt(c), u = In(), p = Ke(!1), v = Ke(0), k = Ke(0), D = Ke([]), $ = [
      et.GOOSE,
      et.REPORT,
      et.SMV
    ], U = He(() => [...r.connections].sort((F, E) => F.dataflowType < E.dataflowType ? -1 : F.dataflowType > E.dataflowType ? 1 : 0));
    async function W(F) {
      const E = await f.value.findMatchingExtRef(F);
      u.openDialogWithContent(
        "DataflowImplementation",
        {
          extRef: E,
          connection: F
        },
        { class: "w-1/2 max-w-none" }
      );
    }
    function A(F) {
      return F ? $.includes(F) : !1;
    }
    function P(F, E) {
      !A(E.dataflowType) || !r.isDataflowImplementationEnabled || (F.preventDefault(), B(F), D.value = X(E), p.value = !0);
    }
    function B(F) {
      v.value = F.clientX, k.value = F.clientY;
    }
    function X(F) {
      return [
        {
          label: F.isImplemented ? "Show Implementation" : "Implement",
          action: () => W(F)
        }
      ];
    }
    return (F, E) => (Q(), re($e, null, [
      (Q(!0), re($e, null, lt(U.value, (K, we) => (Q(), re("div", oy, [
        h("div", {
          class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer",
          onClick: (de) => _e(i).setOrResetActiveElement(K.id)
        }, [
          h("span", ay, ne(K.sourceDataObject), 1),
          h("span", sy, ne(K.sourceDataAttribute), 1)
        ], 8, iy),
        h("div", {
          onClick: (de) => _e(i).setOrResetActiveElement(K.id),
          class: Tt(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
            "bg-(--color-primary)": _e(s) === K.id,
            "bg-(--color-ocean-gray-100)": _e(s) !== K.id
          }])
        }, null, 10, ly),
        h("div", {
          class: "col-start-3 col-span-1 row-start-1 hover:cursor-pointer flex items-center",
          onClick: (de) => _e(i).setOrResetActiveElement(K.id),
          onContextmenu: ga((de) => P(de, K), ["right"])
        }, [
          h("div", {
            class: Tt(["border h-[2px] w-full", {
              "border-(--color-primary)": _e(s) === K.id,
              "border-(--color-ocean-gray-100)": _e(s) !== K.id,
              "border-solid": !F.isDataflowImplementationEnabled || K.isImplemented,
              "border-dashed": F.isDataflowImplementationEnabled && !K.isImplemented,
              "border-dotted": F.isDataflowImplementationEnabled && K.notPossibleToImplement
            }]),
            "data-testid": `dataflow-line-${we}`
          }, null, 10, cy)
        ], 40, uy),
        (Q(), re("svg", {
          onClick: (de) => _e(i).setOrResetActiveElement(K.id),
          height: "12",
          width: "8",
          class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          h("polygon", {
            points: "0,0 8,6 0,12",
            style: jr({
              fill: _e(s) === K.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
            })
          }, null, 4)
        ], 8, dy)),
        h("div", {
          onClick: (de) => _e(i).setOrResetActiveElement(K.id),
          onContextmenu: ga((de) => P(de, K), ["right"]),
          class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
        }, ne(K.dataflowType), 41, fy),
        h("div", {
          onClick: (de) => _e(i).setOrResetActiveElement(K.id),
          class: Tt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
            "bg-(--color-primary)": _e(s) === K.id,
            "bg-(--color-ocean-gray-100)": _e(s) !== K.id
          }])
        }, null, 10, py),
        h("div", {
          onClick: (de) => _e(i).setOrResetActiveElement(K.id),
          class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
        }, [
          h("span", my, ne(K.input), 1),
          h("span", vy, ne(K.inputInstance), 1)
        ], 8, hy),
        _e(s) == K.id && !F.isDataflowImplementationEnabled ? (Q(), Lt(Ur, {
          key: 0,
          to: "#sidebar-details"
        }, [
          ft(fh, { connection: K }, null, 8, ["connection"])
        ])) : We("", !0),
        _e(s) == K.id && F.isDataflowImplementationEnabled ? (Q(), Lt(Ur, {
          key: 1,
          to: "#sidebar-details"
        }, [
          ft(gh, { connection: K }, null, 8, ["connection"])
        ])) : We("", !0)
      ]))), 256)),
      ft(ry, {
        x: v.value,
        y: k.value,
        isVisible: p.value,
        items: D.value,
        onClose: E[0] || (E[0] = (K) => p.value = !1)
      }, null, 8, ["x", "y", "isVisible", "items"])
    ], 64));
  }
}), gy = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, by = {
  class: "[&_dt,dd]:inline [&_dt]:mr-1",
  "data-testid": "destination-placeholder-details"
}, wy = { class: "mt-4" }, _y = { key: 0 }, Ny = { key: 1 }, xy = {
  key: 2,
  class: "mt-4"
}, Ry = /* @__PURE__ */ _t({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(t) {
    const r = t, i = It(), { lnodeTypes: s } = jt(i), c = He(() => s.value.find((p) => p.lnClass === r.placeholder.preferredLNode)?.dataObjects.find(
      (p) => p.name === r.placeholder.preferredDataObject
    )), f = He(() => c?.value?.dataAttributes?.find(
      (u) => u.name === r.placeholder.preferredDataAttribute
    ));
    return (u, p) => (Q(), re($e, null, [
      p[9] || (p[9] = h("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder", -1)),
      u.placeholder.dataflowType ? (Q(), re("span", gy, ne(u.placeholder.dataflowType), 1)) : We("", !0),
      h("dl", by, [
        h("div", null, [
          p[0] || (p[0] = h("dt", null, "Input:", -1)),
          h("dd", null, ne(u.placeholder.input), 1)
        ]),
        h("div", null, [
          p[1] || (p[1] = h("dt", null, "Input Instance:", -1)),
          h("dd", null, ne(u.placeholder.inputInst || "-"), 1)
        ]),
        h("div", wy, [
          p[2] || (p[2] = h("dt", null, "Preferred LN:", -1)),
          h("dd", null, ne(u.placeholder.preferredLNode || "-"), 1)
        ]),
        h("div", null, [
          p[3] || (p[3] = h("dt", null, "Preferred DO:", -1)),
          h("dd", null, ne(u.placeholder.preferredDataObject || "-"), 1)
        ]),
        c.value?.desc ? (Q(), re("div", _y, [
          p[4] || (p[4] = h("dt", null, "Preferred DO Desc:", -1)),
          h("dd", null, ne(c.value.desc), 1)
        ])) : We("", !0),
        h("div", null, [
          p[5] || (p[5] = h("dt", null, "Preferred DA:", -1)),
          h("dd", null, ne(u.placeholder.preferredDataAttribute || "-"), 1)
        ]),
        f.value?.desc ? (Q(), re("div", Ny, [
          p[6] || (p[6] = h("dt", null, "Preferred DA Desc:", -1)),
          h("dd", null, ne(f.value.desc), 1)
        ])) : We("", !0),
        h("div", null, [
          p[7] || (p[7] = h("dt", null, "Process Resource:", -1)),
          h("dd", null, ne(u.placeholder.processResource || "-"), 1)
        ]),
        u.placeholder.isFulfilled != null ? (Q(), re("div", xy, [
          p[8] || (p[8] = h("dt", null, "Placeholder is fulfilled:", -1)),
          h("dd", null, ne(u.placeholder.isFulfilled), 1)
        ])) : We("", !0)
      ])
    ], 64));
  }
}), Cy = {}, Oy = {
  width: "16",
  height: "16",
  viewBox: "0 0 20 20",
  fill: "currentColor"
};
function Ty(t, r) {
  return Q(), re("svg", Oy, r[0] || (r[0] = [
    h("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }, null, -1),
    h("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" }, null, -1)
  ]));
}
const Ao = /* @__PURE__ */ Hi(Cy, [["render", Ty]]), Ey = { class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block" }, Iy = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, Ay = { class: "mt-4" }, Dy = /* @__PURE__ */ _t({
  __name: "control-dataflow-destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(t) {
    return (r, i) => (Q(), re($e, null, [
      i[4] || (i[4] = h("h2", { class: "text-lg font-bold mb-2" }, "Controlled LNode Placeholder", -1)),
      h("span", Ey, ne(_e(et).CONTROL), 1),
      h("dl", Iy, [
        h("div", null, [
          i[0] || (i[0] = h("dt", null, "Output:", -1)),
          h("dd", null, ne(r.placeholder.outputName), 1)
        ]),
        h("div", null, [
          i[1] || (i[1] = h("dt", null, "Controlled DO:", -1)),
          h("dd", null, ne(r.placeholder.dataObject || "-"), 1)
        ]),
        h("div", Ay, [
          i[2] || (i[2] = h("dt", null, "Preferred controller LN:", -1)),
          h("dd", null, ne(r.placeholder.preferredLnode || "-"), 1)
        ]),
        h("div", null, [
          i[3] || (i[3] = h("dt", null, "Process Resource:", -1)),
          h("dd", null, ne(r.placeholder.processResource || "-"), 1)
        ])
      ])
    ], 64));
  }
}), Py = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, Sy = ["onClick"], Ly = ["data-testid"], ky = ["onClick"], jy = ["disabled", "onClick"], $y = ["onClick"], Fy = ["onClick"], My = { class: "col-start-5 col-span-1 self-center justify-self-start" }, By = ["onClick"], Ky = ["onClick"], qy = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, Uy = ["onClick"], Vy = ["data-testid"], Wy = ["onClick"], Gy = {
  class: "col-start-3 self-center justify-self-center p-4 rounded-sm text-sm row-start-1 btn border-1 relative z-2 !bg-(--color-ocean-gray-75) text-(--color-ocean-gray-200) border-(--color-ocean-gray-200)",
  disabled: "",
  "aria-label": "Fulfill placeholder"
}, Hy = ["onClick"], Yy = ["onClick"], zy = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Xy = ["onClick"], Qy = /* @__PURE__ */ _t({
  __name: "destination-placeholder-ports",
  props: {
    sourceLNode: {},
    destinationLNode: {}
  },
  setup(t) {
    const r = t, i = It(), s = ja(), { destinationPlaceholders: c, destinationPlaceholdersForControlDataflow: f } = jt(i), { activeElement: u } = jt(s), p = In(), v = He(() => r.destinationLNode.id ? f.value.filter(
      (U) => U.lnodeId === r.destinationLNode.id
    ) : []), k = He(() => r.destinationLNode ? c?.value.filter((U) => U.lNodeId === r.destinationLNode?.id) : []), D = (U) => {
      if (r.sourceLNode)
        return U.preferredLNode ? r.sourceLNode.lnClass === U.preferredLNode : !0;
    };
    function $(U) {
      Te(r.sourceLNode, "Source LNode is undefined"), p.openDialogWithContent("DataflowCreation", {
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        destinationPlaceholder: U
      });
    }
    return (U, W) => (Q(), re($e, null, [
      (Q(!0), re($e, null, lt(k.value, (A, P) => (Q(), re("div", {
        class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
        key: `destination-placeholder-port-${P}`
      }, [
        h("div", Py, [
          h("div", {
            class: "flex items-center justify-self-end h-full w-3/4 hover:cursor-pointer",
            onClick: (B) => _e(s).setOrResetActiveElement(A.id)
          }, [
            h("div", {
              class: "relative w-full h-[12px]",
              "data-testid": `dest-placeholder-line-${P}`
            }, [
              (Q(), re("svg", {
                width: "100%",
                height: "12",
                class: Tt(["text-(--color-ocean-gray-100)", {
                  "text-(--color-primary)": _e(u) === A.id
                }])
              }, W[0] || (W[0] = [
                h("line", {
                  x1: "0",
                  y1: "6",
                  x2: "calc(100% - 10px)",
                  y2: "6",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-dasharray": "3,2"
                }, null, -1)
              ]), 2)),
              (Q(), re("svg", {
                width: "12",
                height: "12",
                class: Tt(["text-(--color-ocean-gray-100) absolute right-2 top-0", {
                  "text-(--color-primary)": _e(u) === A.id
                }]),
                viewBox: "0 0 12 12"
              }, W[1] || (W[1] = [
                h("polygon", {
                  points: "3.6,0 12,6 3.6,12",
                  fill: "currentColor"
                }, null, -1)
              ]), 2))
            ], 8, Ly)
          ], 8, Sy)
        ]),
        A.preferredLNode ? (Q(), re("div", {
          key: 0,
          onClick: (B) => _e(s).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-end z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer right-[70%]"
        }, ne(A.preferredLNode), 9, ky)) : We("", !0),
        h("button", {
          class: "col-start-3 self-center justify-self-center p-4 rounded-sm text-sm row-start-1 btn bg-(--color-primary) border-1 text-white relative z-2",
          disabled: !r.sourceLNode || !r.destinationLNode || !D(A),
          style: jr(
            !r.sourceLNode || !r.destinationLNode || !D(A) ? {
              border: "1",
              backgroundColor: "var(--color-ocean-gray-75)",
              color: "var(--color-ocean-gray-200)",
              borderColor: "var(--color-ocean-gray-200)"
            } : { borderColor: "var(--color-primary)" }
          ),
          "aria-label": "Fulfill placeholder",
          onClick: (B) => $(A)
        }, [
          ft(Ao)
        ], 12, jy),
        A.preferredDataObject ? (Q(), re("div", {
          key: 1,
          onClick: (B) => _e(s).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-end z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer right-[10%] truncate max-w-[8ch]"
        }, ne(A.preferredDataObject), 9, $y)) : We("", !0),
        h("div", {
          onClick: (B) => _e(s).setOrResetActiveElement(A.id),
          class: Tt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
            "bg-(--color-primary)": _e(u) === A.id
          }])
        }, null, 10, Fy),
        h("div", My, [
          h("span", {
            onClick: (B) => _e(s).setOrResetActiveElement(A.id),
            class: Tt([
              "relative inline-block px-2 py-1 mr-2 rounded-sm hover:cursor-pointer border-2",
              A.isFulfilled ? "border-solid" : "border-dashed",
              "border-(--color-ocean-gray-100)"
            ])
          }, [
            il(ne(A.input) + " ", 1),
            h("span", {
              class: Tt([{
                "bg-(--color-primary)": _e(u) === A.id
              }, "absolute -top-3 -right-3 bg-(--color-ocean-gray-100) text-white text-xs font-semibold rounded-full w-5 h-5 flex items-center justify-center"])
            }, " 1+ ", 2)
          ], 10, By),
          h("span", {
            onClick: (B) => _e(s).setOrResetActiveElement(A.id),
            class: Tt([
              "px-2 py-1 rounded-sm hover:cursor-pointer border-2",
              A.isFulfilled ? "border-solid" : "border-dashed",
              "border-(--color-ocean-gray-100)"
            ])
          }, ne(A.inputInst), 11, Ky)
        ]),
        _e(u) == A.id ? (Q(), Lt(Ur, {
          key: 2,
          to: "#sidebar-details"
        }, [
          ft(Ry, { placeholder: A }, null, 8, ["placeholder"])
        ])) : We("", !0)
      ]))), 128)),
      (Q(!0), re($e, null, lt(v.value, (A, P) => (Q(), re("div", {
        class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
        key: `destination-placeholder-port-${P}`
      }, [
        h("div", qy, [
          h("div", {
            class: "flex items-center justify-self-end h-full w-3/4 hover:cursor-pointer",
            onClick: (B) => _e(s).setOrResetActiveElement(A.id)
          }, [
            h("div", {
              class: "relative w-full h-[12px]",
              "data-testid": `control-dest-placeholder-line-${P}`
            }, [
              (Q(), re("svg", {
                width: "100%",
                height: "12",
                class: Tt(["text-(--color-ocean-gray-100)", {
                  "text-(--color-primary)": _e(u) === A.id
                }])
              }, W[2] || (W[2] = [
                h("line", {
                  x1: "0",
                  y1: "6",
                  x2: "calc(100% - 10px)",
                  y2: "6",
                  stroke: "currentColor",
                  "stroke-width": "2",
                  "stroke-dasharray": "3,2"
                }, null, -1)
              ]), 2)),
              (Q(), re("svg", {
                width: "12",
                height: "12",
                class: Tt(["text-(--color-ocean-gray-100) absolute right-2 top-0", {
                  "text-(--color-primary)": _e(u) === A.id
                }]),
                viewBox: "0 0 12 12"
              }, W[3] || (W[3] = [
                h("polygon", {
                  points: "3.6,0 12,6 3.6,12",
                  fill: "currentColor"
                }, null, -1)
              ]), 2))
            ], 8, Vy)
          ], 8, Uy)
        ]),
        A.preferredLnode ? (Q(), re("div", {
          key: 0,
          onClick: (B) => _e(s).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-end z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer right-[70%]"
        }, ne(A.preferredLnode), 9, Wy)) : We("", !0),
        h("button", Gy, [
          ft(Ao)
        ]),
        h("div", {
          onClick: (B) => _e(s).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-end z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer right-[10%] truncate max-w-[8ch]"
        }, ne(A.outputName), 9, Hy),
        h("div", {
          onClick: (B) => _e(s).setOrResetActiveElement(A.id),
          class: Tt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
            "bg-(--color-primary)": _e(u) === A.id
          }])
        }, null, 10, Yy),
        h("div", zy, [
          h("span", {
            class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
            onClick: (B) => _e(s).setOrResetActiveElement(A.id)
          }, ne(A.dataObject), 9, Xy)
        ]),
        _e(u) == A.id ? (Q(), Lt(Ur, {
          key: 1,
          to: "#sidebar-details"
        }, [
          ft(Dy, { placeholder: A }, null, 8, ["placeholder"])
        ])) : We("", !0)
      ]))), 128))
    ], 64));
  }
}), Jy = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, Zy = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, eg = { class: "mt-4" }, tg = { key: 0 }, ng = { key: 1 }, rg = { class: "mt-4" }, og = {
  key: 2,
  class: "mt-4"
}, ig = /* @__PURE__ */ _t({
  __name: "source-placeholder-details",
  props: {
    placeholder: {},
    sourceLNodeId: {}
  },
  setup(t) {
    const r = t, i = It(), { lnodes: s } = jt(i), c = He(() => s.value.find((p) => p.id === r.sourceLNodeId)?.dataObjectSpecifications?.find(
      (p) => p.name === r.placeholder.dataObject
    )), f = He(() => c?.value?.dataAttributeSpecifications?.find(
      (u) => u.name === r.placeholder.dataAttribute
    ));
    return (u, p) => (Q(), re($e, null, [
      p[8] || (p[8] = h("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder", -1)),
      u.placeholder.dataflowType ? (Q(), re("span", Jy, ne(u.placeholder.dataflowType), 1)) : We("", !0),
      h("dl", Zy, [
        h("div", null, [
          p[0] || (p[0] = h("dt", null, "Input:", -1)),
          h("dd", null, ne(u.placeholder.input), 1)
        ]),
        h("div", eg, [
          p[1] || (p[1] = h("dt", null, "DO:", -1)),
          h("dd", null, ne(u.placeholder.dataObject || "-"), 1)
        ]),
        c.value?.desc ? (Q(), re("div", tg, [
          p[2] || (p[2] = h("dt", null, "DO Desc:", -1)),
          h("dd", null, ne(c.value?.desc), 1)
        ])) : We("", !0),
        h("div", null, [
          p[3] || (p[3] = h("dt", null, "DA:", -1)),
          h("dd", null, ne(u.placeholder.dataAttribute || "-"), 1)
        ]),
        f.value?.desc ? (Q(), re("div", ng, [
          p[4] || (p[4] = h("dt", null, "DA Desc:", -1)),
          h("dd", null, ne(f.value?.desc), 1)
        ])) : We("", !0),
        h("div", rg, [
          p[5] || (p[5] = h("dt", null, "Preferred LN:", -1)),
          h("dd", null, ne(u.placeholder.preferredLNode || "-"), 1)
        ]),
        h("div", null, [
          p[6] || (p[6] = h("dt", null, "Process Resource:", -1)),
          h("dd", null, ne(u.placeholder.processResource || "-"), 1)
        ]),
        u.placeholder.isFulfilled != null ? (Q(), re("div", og, [
          p[7] || (p[7] = h("dt", null, "Placeholder is fulfilled:", -1)),
          h("dd", null, ne(u.placeholder.isFulfilled), 1)
        ])) : We("", !0)
      ])
    ], 64));
  }
}), ag = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, sg = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, lg = { class: "mt-4" }, ug = /* @__PURE__ */ _t({
  __name: "control-dataflow-source-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(t) {
    return (r, i) => (Q(), re($e, null, [
      i[5] || (i[5] = h("h2", { class: "text-lg font-bold mb-2" }, "Controller Placeholder", -1)),
      r.placeholder.dataflowType ? (Q(), re("span", ag, ne(r.placeholder.dataflowType), 1)) : We("", !0),
      h("dl", sg, [
        h("div", null, [
          i[0] || (i[0] = h("dt", null, "Output:", -1)),
          h("dd", null, ne(r.placeholder.outputName), 1)
        ]),
        h("div", null, [
          i[1] || (i[1] = h("dt", null, "Output Instance:", -1)),
          h("dd", null, ne(r.placeholder.outputInstance || "-"), 1)
        ]),
        h("div", lg, [
          i[2] || (i[2] = h("dt", null, "Preferred LN:", -1)),
          h("dd", null, ne(r.placeholder.preferredLNode || "-"), 1)
        ]),
        h("div", null, [
          i[3] || (i[3] = h("dt", null, "Preferred DO:", -1)),
          h("dd", null, ne(r.placeholder.preferredDataObject || "-"), 1)
        ]),
        h("div", null, [
          i[4] || (i[4] = h("dt", null, "Process Resource:", -1)),
          h("dd", null, ne(r.placeholder.processResource || "-"), 1)
        ])
      ])
    ], 64));
  }
}), cg = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12" }, dg = ["onClick"], fg = ["onClick"], pg = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, hg = ["onClick"], mg = ["onClick"], vg = ["onClick"], yg = ["onClick"], gg = ["disabled", "onClick"], bg = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12" }, wg = ["onClick"], _g = { class: "border-2 border-(--color-ocean-gray-100) border-dashed px-2 py-1 mr-2 rounded-sm" }, Ng = { class: "border-2 border-(--color-ocean-gray-100) border-dashed px-2 py-1 rounded-sm" }, xg = ["onClick"], Rg = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, Cg = ["onClick"], Og = ["onClick"], Tg = ["onClick"], Eg = ["onClick"], Ig = {
  class: "col-start-3 self-center justify-self-center p-4 rounded-sm text-sm row-start-1 btn border-1 relative z-2 !bg-(--color-ocean-gray-75) text-(--color-ocean-gray-200) border-(--color-ocean-gray-200)",
  disabled: "",
  "aria-label": "Fulfill placeholder"
}, Ag = /* @__PURE__ */ _t({
  __name: "source-placeholder-ports",
  props: {
    sourceLNode: {},
    destinationLNode: {}
  },
  setup(t) {
    const r = t, i = ja(), { activeElement: s } = jt(i), c = It(), { sourcePlaceholders: f, controlledConnections: u } = jt(c), p = In(), v = He(() => r.sourceLNode.id ? f.value.filter((U) => U.lnodeId === r.sourceLNode.id) : []), k = He(() => r.sourceLNode.id ? u.value.filter(
      (U) => U.controllerLNodeId === r.sourceLNode.id && !U.controlledLNodeId
    ) : []), D = (U) => {
      if (r.destinationLNode)
        return U.preferredLNode ? r.destinationLNode.lnClass === U.preferredLNode ? r.destinationLNode : void 0 : r.destinationLNode;
    };
    function $(U) {
      Te(r.destinationLNode, "Destination LNode is undefined"), p.openDialogWithContent("DataflowCreation", {
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        sourcePlaceholder: U
      });
    }
    return (U, W) => (Q(), re($e, null, [
      (Q(!0), re($e, null, lt(v.value, (A) => (Q(), re("div", cg, [
        h("div", {
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
        }, [
          h("span", {
            class: Tt([A.isFulfilled ? "border-solid" : "border-dashed", "relative inline-block border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm"])
          }, [
            il(ne(A.dataObject) + "." + ne(A.dataAttribute) + " ", 1),
            h("span", {
              class: Tt([{
                "bg-(--color-primary)": _e(s) === A.id
              }, "absolute -top-3 -right-3 bg-(--color-ocean-gray-100) text-white text-xs font-semibold rounded-full w-5 h-5 flex items-center justify-center"])
            }, " 1+ ", 2)
          ], 2)
        ], 8, dg),
        h("div", {
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: Tt([{
            "bg-(--color-primary)": _e(s) === A.id
          }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
        }, null, 10, fg),
        h("div", pg, [
          h("div", {
            class: "flex items-center h-full w-3/4 hover:cursor-pointer",
            onClick: (P) => _e(i).setOrResetActiveElement(A.id)
          }, [
            h("div", {
              class: Tt(["h-[2px] w-full border border-dashed", {
                "border-[var(--color-primary)]": _e(s) === A.id,
                "border-[var(--color-gray-200)]": _e(s) !== A.id
              }]),
              onClick: (P) => _e(i).setOrResetActiveElement(A.id)
            }, null, 10, mg)
          ], 8, hg)
        ]),
        h("div", {
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-start z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer left-[10%] truncate max-w-[8ch]"
        }, ne(A.input), 9, vg),
        A.preferredLNode ? (Q(), re("div", {
          key: 0,
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-start z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer left-[70%]"
        }, ne(A.preferredLNode), 9, yg)) : We("", !0),
        h("button", {
          class: "col-start-3 self-center justify-self-center p-4 rounded-sm text-sm row-start-1 btn bg-(--color-primary) border-1 text-white relative z-2",
          disabled: !r.sourceLNode || !r.destinationLNode || !D(A),
          style: jr(
            !r.sourceLNode || !r.destinationLNode || !D(A) ? {
              border: "1",
              backgroundColor: "var(--color-ocean-gray-75)",
              color: "var(--color-ocean-gray-200)",
              borderColor: "var(--color-ocean-gray-200)"
            } : { borderColor: "var(--color-primary)" }
          ),
          "aria-label": "Fulfill placeholder",
          onClick: (P) => $(A)
        }, [
          ft(Ao)
        ], 12, gg),
        _e(s) == A.id ? (Q(), Lt(Ur, {
          key: 1,
          to: "#sidebar-details"
        }, [
          ft(ig, {
            placeholder: A,
            sourceLNodeId: r.sourceLNode.id
          }, null, 8, ["placeholder", "sourceLNodeId"])
        ])) : We("", !0)
      ]))), 256)),
      (Q(!0), re($e, null, lt(k.value, (A) => (Q(), re("div", bg, [
        h("div", {
          class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer",
          onClick: (P) => _e(i).setOrResetActiveElement(A.id)
        }, [
          h("span", _g, ne(A.outputName), 1),
          h("span", Ng, ne(A.outputInstance), 1)
        ], 8, wg),
        h("div", {
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: Tt([{
            "bg-(--color-primary)": _e(s) === A.id
          }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
        }, null, 10, xg),
        h("div", Rg, [
          h("div", {
            class: "flex items-center h-full w-3/4 hover:cursor-pointer",
            onClick: (P) => _e(i).setOrResetActiveElement(A.id)
          }, [
            h("div", {
              class: Tt(["h-[2px] w-full border border-dashed", {
                "border-[var(--color-primary)]": _e(s) === A.id,
                "border-[var(--color-gray-200)]": _e(s) !== A.id
              }]),
              onClick: (P) => _e(i).setOrResetActiveElement(A.id)
            }, null, 10, Og)
          ], 8, Cg)
        ]),
        h("div", {
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-start z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer left-[10%] truncate max-w-[8ch]"
        }, ne(A.preferredDataObject), 9, Tg),
        A.preferredLNode ? (Q(), re("div", {
          key: 0,
          onClick: (P) => _e(i).setOrResetActiveElement(A.id),
          class: "bg-(--color-ocean-gray-25) col-start-3 self-center justify-self-start z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer left-[70%]"
        }, ne(A.preferredLNode), 9, Eg)) : We("", !0),
        h("button", Ig, [
          ft(Ao)
        ]),
        _e(s) == A.id ? (Q(), Lt(Ur, {
          key: 1,
          to: "#sidebar-details"
        }, [
          ft(ug, { placeholder: A }, null, 8, ["placeholder"])
        ])) : We("", !0)
      ]))), 256))
    ], 64));
  }
}), Dg = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, Pg = { class: "[&_dt,dd]:inline [&_dt]:mr-1" }, Sg = { class: "mt-4" }, Lg = { key: 0 }, kg = { class: "mt-4" }, jg = /* @__PURE__ */ _t({
  __name: "controlled-connection-details",
  props: {
    controlledConnection: {}
  },
  setup(t) {
    const r = t, i = It(), { lnodes: s } = jt(i), c = He(() => s.value.find(
      (u) => u.id === r.controlledConnection.controlledLNodeId
    )?.dataObjectSpecifications?.find(
      (u) => u.name === r.controlledConnection.controlledDataObject
    ));
    return (f, u) => (Q(), re($e, null, [
      u[7] || (u[7] = h("h2", { class: "text-lg font-bold mb-2" }, "Specified Controlled Dataflow", -1)),
      f.controlledConnection.dataflowType ? (Q(), re("span", Dg, ne(f.controlledConnection.dataflowType), 1)) : We("", !0),
      h("dl", Pg, [
        h("div", null, [
          u[0] || (u[0] = h("dt", null, "Output:", -1)),
          h("dd", null, ne(f.controlledConnection.outputName), 1)
        ]),
        h("div", null, [
          u[1] || (u[1] = h("dt", null, "Output Instance:", -1)),
          h("dd", null, ne(f.controlledConnection.outputInstance || "-"), 1)
        ]),
        h("div", Sg, [
          u[2] || (u[2] = h("dt", null, "Controlled DO:", -1)),
          h("dd", null, ne(f.controlledConnection.controlledDataObject || "-"), 1)
        ]),
        c.value?.desc ? (Q(), re("div", Lg, [
          u[3] || (u[3] = h("dt", null, "Controlled DO Desc:", -1)),
          h("dd", null, ne(c.value.desc), 1)
        ])) : We("", !0),
        h("div", null, [
          u[4] || (u[4] = h("dt", null, "Preferred LN:", -1)),
          h("dd", null, ne(f.controlledConnection.preferredLNode || "-"), 1)
        ]),
        h("div", kg, [
          u[5] || (u[5] = h("dt", null, "Preferred DO:", -1)),
          h("dd", null, ne(f.controlledConnection.preferredDataObject || "-"), 1)
        ]),
        h("div", null, [
          u[6] || (u[6] = h("dt", null, "Process Resource:", -1)),
          h("dd", null, ne(f.controlledConnection.processResource || "-"), 1)
        ])
      ])
    ], 64));
  }
}), $g = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Fg = ["onClick"], Mg = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Bg = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Kg = ["onClick"], qg = ["onClick"], Ug = ["data-testid"], Vg = ["onClick"], Wg = ["onClick"], Gg = ["onClick"], Hg = ["onClick"], Yg = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, zg = /* @__PURE__ */ _t({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(t) {
    const r = ja(), { activeElement: i } = jt(r);
    return (s, c) => (Q(!0), re($e, null, lt(s.controlledConnections, (f, u) => (Q(), re("div", $g, [
      h("div", {
        onClick: (p) => _e(r).setOrResetActiveElement(f.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        h("span", Mg, ne(f.outputName), 1),
        h("span", Bg, ne(f.outputInstance), 1)
      ], 8, Fg),
      h("div", {
        onClick: (p) => _e(r).setOrResetActiveElement(f.id),
        class: Tt(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": _e(i) === f.id,
          "bg-(--color-ocean-gray-100)": _e(i) !== f.id
        }])
      }, null, 10, Kg),
      h("div", {
        class: "col-start-3 col-span-1 row-start-1 hover:cursor-pointer flex items-center",
        onClick: (p) => _e(r).setOrResetActiveElement(f.id)
      }, [
        h("div", {
          class: Tt(["h-[2px] w-full", {
            "bg-(--color-primary)": _e(i) === f.id,
            "bg-(--color-ocean-gray-100)": _e(i) !== f.id
          }]),
          "data-testid": `dataflow-controlled-connection-line-${u}`
        }, null, 10, Ug)
      ], 8, qg),
      (Q(), re("svg", {
        onClick: (p) => _e(r).setOrResetActiveElement(f.id),
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        h("polygon", {
          points: "0,0 8,6 0,12",
          style: jr({
            fill: _e(i) === f.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ], 8, Vg)),
      h("div", {
        onClick: (p) => _e(r).setOrResetActiveElement(f.id),
        class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
      }, ne(f.dataflowType), 9, Wg),
      h("div", {
        onClick: (p) => _e(r).setOrResetActiveElement(f.id),
        class: Tt(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": _e(i) === f.id,
          "bg-(--color-ocean-gray-100)": _e(i) !== f.id
        }])
      }, null, 10, Gg),
      h("div", {
        onClick: (p) => _e(r).setOrResetActiveElement(f.id),
        class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
      }, [
        h("span", Yg, ne(f.controlledDataObject), 1)
      ], 8, Hg),
      _e(i) == f.id ? (Q(), Lt(Ur, {
        key: 0,
        to: "#sidebar-details"
      }, [
        ft(jg, { "controlled-connection": f }, null, 8, ["controlled-connection"])
      ])) : We("", !0)
    ]))), 256));
  }
}), Xg = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[50px_50px_1fr_80px]" }, Qg = { class: "col-start-1 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, Jg = ["value"], Zg = ["label"], eb = ["value"], tb = { class: "col-start-4 col-span-2 self-end justify-self-center row-start-1 text-center text-xs px-5" }, nb = ["value"], rb = ["label"], ob = ["value"], ib = { class: "col-span-full row-start-3" }, ab = /* @__PURE__ */ _t({
  __name: "dataflow-visualisation",
  props: {
    isDataflowImplementationEnabled: { type: Boolean }
  },
  emits: ["sourceLNodeChange", "destinationLNodeChange"],
  setup(t, { emit: r }) {
    const i = r, s = In(), c = It(), { lnodes: f, connections: u, controlledConnections: p, dataflowSdk: v } = jt(c), k = Ke(), D = Ke(), $ = Ke(), U = Ke();
    qt(
      () => f.value,
      () => {
        k.value = void 0, D.value = void 0;
      }
    );
    const W = Gi(
      async () => await Promise.all(
        f.value.map(async (oe) => {
          const fe = (await v.value.findPathToLnode(oe.id))?.split("/");
          Te(fe.length > 0, "LNode path is invalid");
          const me = fe[fe.length - 1], Pe = fe.slice(0, -1).join("/");
          return {
            lnodeId: oe.id,
            path: Pe,
            label: me
          };
        })
      )
    ), A = He(() => {
      if (!W.value)
        return {};
      const oe = W.value.filter(
        (ce) => ce.lnodeId !== D.value
      );
      return Y(oe);
    }), P = He(() => {
      if (!W.value)
        return {};
      const oe = W.value.filter(
        (ce) => ce.lnodeId !== k.value
      );
      return Y(oe);
    }), B = He(() => !k.value || !D.value ? [] : u.value.filter(
      (oe) => oe.sourceLNodeId === k.value && oe.destinationLNodeId === D.value
    )), X = He(() => !k.value || !D.value ? [] : p.value.filter(
      (oe) => oe.controllerLNodeId === k.value && oe.controlledLNodeId === D.value
    )), F = He(
      () => W.value?.find((oe) => oe.lnodeId === k.value)?.path || ""
    ), E = He(
      () => W.value?.find((oe) => oe.lnodeId === D.value)?.path || ""
    );
    function K(oe) {
      return f.value.find((ce) => ce.id === oe) ?? void 0;
    }
    async function we(oe) {
      k.value = oe, $.value = K(oe), i("sourceLNodeChange", oe);
    }
    async function de(oe) {
      D.value = oe, U.value = K(oe), i("destinationLNodeChange", oe);
    }
    function ge() {
      if (!$.value)
        throw new Error("Source LNode is undefined");
      s.openDialogWithContent("SourcePlaceholderCreation", {
        sourceLNode: $.value
      });
    }
    function Ue() {
      if (!U.value)
        throw new Error("Destination LNode is undefined");
      s.openDialogWithContent("DestinationPlaceholderCreation", {
        destinationLNode: U.value
      });
    }
    function Y(oe) {
      const ce = oe.sort((me, Pe) => me.label.localeCompare(Pe.label));
      let fe = {};
      for (const me of ce) {
        const Pe = me.path;
        fe[Pe] || (fe[Pe] = []), fe[Pe].push({
          lnodeId: me.lnodeId,
          label: me.label
        });
      }
      return Op(fe);
    }
    return (oe, ce) => (Q(), re("div", Xg, [
      ce[4] || (ce[4] = h("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2 min-h-[450px]" }, null, -1)),
      h("div", Qg, ne(F.value), 1),
      h("select", {
        value: k.value ?? "",
        onChange: ce[0] || (ce[0] = (fe) => we(fe.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-2 text-lg text-center font-medium"
      }, [
        ce[2] || (ce[2] = h("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (Q(!0), re($e, null, lt(A.value, (fe, me) => (Q(), re("optgroup", { label: me }, [
          (Q(!0), re($e, null, lt(fe, (Pe) => (Q(), re("option", {
            key: Pe.lnodeId,
            value: Pe.lnodeId
          }, ne(Pe.label), 9, eb))), 128))
        ], 8, Zg))), 256))
      ], 40, Jg),
      ce[5] || (ce[5] = h("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) rounded-xl -z-1 border-(--color-ocean-gray-100) border-2 min-h-[450px]" }, null, -1)),
      h("div", tb, ne(E.value), 1),
      h("select", {
        value: D.value ?? "",
        onChange: ce[1] || (ce[1] = (fe) => de(fe.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-2 text-lg text-center font-medium"
      }, [
        ce[3] || (ce[3] = h("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (Q(!0), re($e, null, lt(P.value, (fe, me) => (Q(), re("optgroup", { label: me }, [
          (Q(!0), re($e, null, lt(fe, (Pe) => (Q(), re("option", {
            key: Pe.lnodeId,
            value: Pe.lnodeId
          }, ne(Pe.label), 9, ob))), 128))
        ], 8, rb))), 256))
      ], 40, nb),
      h("div", ib, [
        B.value.length > 0 ? (Q(), Lt(yy, {
          key: 0,
          connections: B.value,
          isDataflowImplementationEnabled: oe.isDataflowImplementationEnabled
        }, null, 8, ["connections", "isDataflowImplementationEnabled"])) : We("", !0),
        X.value.length > 0 ? (Q(), Lt(zg, {
          key: 1,
          controlledConnections: X.value
        }, null, 8, ["controlledConnections"])) : We("", !0),
        $.value && !oe.isDataflowImplementationEnabled ? (Q(), Lt(Ag, {
          key: 2,
          sourceLNode: $.value,
          destinationLNode: U.value
        }, null, 8, ["sourceLNode", "destinationLNode"])) : We("", !0),
        U.value && !oe.isDataflowImplementationEnabled ? (Q(), Lt(Qy, {
          key: 3,
          sourceLNode: $.value,
          destinationLNode: U.value
        }, null, 8, ["sourceLNode", "destinationLNode"])) : We("", !0)
      ]),
      $.value && !oe.isDataflowImplementationEnabled ? (Q(), re("button", {
        key: 0,
        "aria-label": "Add source placeholder",
        class: "custom-plus-btn-left",
        onClick: ge
      }, [
        ft(Ao)
      ])) : We("", !0),
      U.value && !oe.isDataflowImplementationEnabled ? (Q(), re("button", {
        key: 1,
        class: "custom-plus-btn-right",
        "aria-label": "Add destination placeholder",
        onClick: Ue
      }, [
        ft(Ao)
      ])) : We("", !0)
    ]));
  }
}), sb = /* @__PURE__ */ Hi(ab, [["__scopeId", "data-v-749a83f4"]]), lb = { class: "flex justify-between mb-6 w-full h-18" }, ub = { key: 0 }, cb = { class: "flex flex-col items-center justify-center w-full" }, db = ["disabled"], fb = /* @__PURE__ */ _t({
  __name: "dataflow-view",
  setup(t) {
    const r = Ke(), i = Ke(), s = Ke(!1), c = In(), f = It(), { lnodes: u } = jt(f), p = He(() => $(r.value)), v = He(() => $(i.value));
    function k(W) {
      r.value = W;
    }
    function D(W) {
      i.value = W;
    }
    function $(W) {
      return u.value.find((A) => A.id === W) ?? void 0;
    }
    function U() {
      if (!p.value || !v.value)
        throw new Error("Source or Destination LNode is undefined");
      c.openDialogWithContent("DataflowCreation", {
        sourceLNode: p.value,
        destinationLNode: v.value
      });
    }
    return (W, A) => (Q(), re($e, null, [
      h("div", lb, [
        h("div", null, [
          A[1] || (A[1] = h("span", { class: "mr-3" }, "Specification", -1)),
          Ye(h("input", {
            type: "checkbox",
            "onUpdate:modelValue": A[0] || (A[0] = (P) => s.value = P),
            class: "toggle"
          }, null, 512), [
            [Dr, s.value]
          ]),
          A[2] || (A[2] = h("span", { class: "ml-3" }, "Implementation", -1))
        ]),
        s.value ? (Q(), re("div", ub, A[3] || (A[3] = [
          hc('<div class="flex items-center"><div class="border w-[50px] h-[2px] mr-2"></div><span>Implemented</span></div><div class="flex items-center"><div class="border border-dashed w-[50px] h-[2px] mr-2"></div><span>Not implemented</span></div><div class="flex items-center"><div class="border border-dotted w-[50px] h-[2px] mr-2"></div><span>Not possible to implement</span></div>', 3)
        ]))) : We("", !0)
      ]),
      h("div", cb, [
        ft(sb, {
          onSourceLNodeChange: k,
          onDestinationLNodeChange: D,
          isDataflowImplementationEnabled: s.value
        }, null, 8, ["isDataflowImplementationEnabled"]),
        s.value ? We("", !0) : (Q(), re("button", {
          key: 0,
          class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
          onClick: U,
          disabled: !p.value || !v.value,
          "aria-label": "Add connection"
        }, [
          ft(Ao)
        ], 8, db))
      ])
    ], 64));
  }
}), pb = {}, hb = { class: "layout" }, mb = { class: "main" }, vb = { class: "sidebar" };
function yb(t, r) {
  return Q(), re("div", hb, [
    h("div", mb, [
      Nl(t.$slots, "main", {}, void 0)
    ]),
    h("div", vb, [
      Nl(t.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const gb = /* @__PURE__ */ Hi(pb, [["render", yb], ["__scopeId", "data-v-5f95d421"]]), bb = {
  name: "sidebar",
  class: "root"
}, wb = { class: "tabs tabs-box" }, _b = { key: 0 }, Nb = { key: 1 }, xb = /* @__PURE__ */ _t({
  __name: "sidebar",
  setup(t) {
    const r = Ke("details");
    return (i, s) => (Q(), re("div", bb, [
      h("div", wb, [
        Ye(h("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": s[0] || (s[0] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [Zn, r.value]
        ]),
        Ye(h("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": s[1] || (s[1] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [Zn, r.value]
        ])
      ]),
      h("div", null, [
        r.value === "details" ? (Q(), re("div", _b, s[2] || (s[2] = [
          h("div", { id: "sidebar-details" }, null, -1)
        ]))) : We("", !0),
        r.value === "advanced" ? (Q(), re("div", Nb)) : We("", !0)
      ])
    ]));
  }
}), Rb = /* @__PURE__ */ Hi(xb, [["__scopeId", "data-v-ec5c053a"]]), Cb = {
  class: "modal",
  ref: "dialogRef"
}, Ob = /* @__PURE__ */ _t({
  __name: "dialog-container",
  setup(t) {
    const r = In(), { currentDialogContent: i } = jt(r), s = Td("dialogRef");
    return Po(() => {
      s.value && (r.dialogRef = s.value);
    }), (c, f) => (Q(), re("dialog", Cb, [
      h("div", {
        class: Tt(["modal-box max-h-[85vh]", _e(r).dialogAttributes?.class])
      }, [
        h("button", {
          class: "btn btn-sm btn-circle btn-ghost absolute right-2 top-2",
          "aria-label": "Close dialog",
          onClick: f[0] || (f[0] = //@ts-ignore
          (...u) => _e(r).handleClose && _e(r).handleClose(...u))
        }, " ✕ "),
        _e(i).component ? (Q(), Lt(Bd(_e(i).component), Bc(mc({ key: 0 }, _e(i).props)), null, 16)) : We("", !0)
      ], 2),
      f[1] || (f[1] = h("form", {
        method: "dialog",
        class: "modal-backdrop"
      }, [
        h("button", null, "close")
      ], -1))
    ], 512));
  }
}), Tb = ["id"], Eb = { class: "px-5" }, Ib = /* @__PURE__ */ _t({
  __name: "app",
  props: {
    api: {}
  },
  setup(t) {
    const r = "dataflow", i = t, s = It();
    let c = () => {
    };
    return Po(() => {
      c = i.api.activeFileName.subscribe((f) => {
        s.initApp(f);
      }), s.initApp(i.api.activeFileName.value);
    }), Zs(() => {
      s.closeDatabase(), c();
    }), (f, u) => (Q(), re("article", {
      id: _e(r),
      style: { height: "100%" }
    }, [
      ft(gb, null, {
        main: Cs(() => [
          h("div", Eb, [
            ft(fb),
            ft(Ob)
          ])
        ]),
        sidebar: Cs(() => [
          ft(Rb)
        ]),
        _: 1
      })
    ], 8, Tb));
  }
});
function Jb(t, r) {
  if (!document.getElementById(t)) {
    console.error({ msg: "could not found root element", rootId: t });
    return;
  }
  const s = rp(Ib, { api: r });
  return s.use(ap()), s.mount(`#${t}`), s.unmount;
}
export {
  Jb as default
};
