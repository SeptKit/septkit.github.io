(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.pointer-events-none{pointer-events:none}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-\\[1\\.5rem\\]{top:1.5rem}.right-\\[1\\.5rem\\]{right:1.5rem}.-z-1{z-index:-1}.z-1{z-index:1}.z-10{z-index:10}.-order-1{order:-1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-2{margin-left:calc(var(--spacing)*2)}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.inline-flex{display:inline-flex}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.min-h-\\[450px\\]{min-height:450px}.w-\\[20px\\]{width:20px}.w-full{width:100%}.max-w-max{max-width:max-content}.cursor-pointer{cursor:pointer}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-1{grid-template-rows:repeat(1,minmax(0,1fr))}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.self-start{align-self:flex-start}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function fa(n) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const a of n.split(",")) r[a] = 1;
  return (a) => a in r;
}
const ut = {}, Eo = [], qn = () => {
}, Xl = () => !1, Qi = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // uppercase letter
(n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), da = (n) => n.startsWith("onUpdate:"), Gt = Object.assign, pa = (n, r) => {
  const a = n.indexOf(r);
  a > -1 && n.splice(a, 1);
}, Ql = Object.prototype.hasOwnProperty, it = (n, r) => Ql.call(n, r), Ie = Array.isArray, To = (n) => Oi(n) === "[object Map]", Ao = (n) => Oi(n) === "[object Set]", ja = (n) => Oi(n) === "[object Date]", qe = (n) => typeof n == "function", Tt = (n) => typeof n == "string", Rn = (n) => typeof n == "symbol", mt = (n) => n !== null && typeof n == "object", Su = (n) => (mt(n) || qe(n)) && qe(n.then) && qe(n.catch), Cu = Object.prototype.toString, Oi = (n) => Cu.call(n), zl = (n) => Oi(n).slice(8, -1), Au = (n) => Oi(n) === "[object Object]", ha = (n) => Tt(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, fi = /* @__PURE__ */ fa(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), zi = (n) => {
  const r = /* @__PURE__ */ Object.create(null);
  return (a) => r[a] || (r[a] = n(a));
}, Jl = /-(\w)/g, Cr = zi(
  (n) => n.replace(Jl, (r, a) => a ? a.toUpperCase() : "")
), Zl = /\B([A-Z])/g, bo = zi(
  (n) => n.replace(Zl, "-$1").toLowerCase()
), Pu = zi((n) => n.charAt(0).toUpperCase() + n.slice(1)), Rs = zi(
  (n) => n ? `on${Pu(n)}` : ""
), Sr = (n, r) => !Object.is(n, r), Di = (n, ...r) => {
  for (let a = 0; a < n.length; a++)
    n[a](...r);
}, Gs = (n, r, a, u = !1) => {
  Object.defineProperty(n, r, {
    configurable: !0,
    enumerable: !1,
    writable: u,
    value: a
  });
}, Bi = (n) => {
  const r = parseFloat(n);
  return isNaN(r) ? n : r;
};
let La;
const Ji = () => La || (La = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function ma(n) {
  if (Ie(n)) {
    const r = {};
    for (let a = 0; a < n.length; a++) {
      const u = n[a], c = Tt(u) ? rc(u) : ma(u);
      if (c)
        for (const f in c)
          r[f] = c[f];
    }
    return r;
  } else if (Tt(n) || mt(n))
    return n;
}
const ec = /;(?![^(]*\))/g, tc = /:([^]+)/, nc = /\/\*[^]*?\*\//g;
function rc(n) {
  const r = {};
  return n.replace(nc, "").split(ec).forEach((a) => {
    if (a) {
      const u = a.split(tc);
      u.length > 1 && (r[u[0].trim()] = u[1].trim());
    }
  }), r;
}
function vo(n) {
  let r = "";
  if (Tt(n))
    r = n;
  else if (Ie(n))
    for (let a = 0; a < n.length; a++) {
      const u = vo(n[a]);
      u && (r += u + " ");
    }
  else if (mt(n))
    for (const a in n)
      n[a] && (r += a + " ");
  return r.trim();
}
const oc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ic = /* @__PURE__ */ fa(oc);
function Iu(n) {
  return !!n || n === "";
}
function sc(n, r) {
  if (n.length !== r.length) return !1;
  let a = !0;
  for (let u = 0; a && u < n.length; u++)
    a = go(n[u], r[u]);
  return a;
}
function go(n, r) {
  if (n === r) return !0;
  let a = ja(n), u = ja(r);
  if (a || u)
    return a && u ? n.getTime() === r.getTime() : !1;
  if (a = Rn(n), u = Rn(r), a || u)
    return n === r;
  if (a = Ie(n), u = Ie(r), a || u)
    return a && u ? sc(n, r) : !1;
  if (a = mt(n), u = mt(r), a || u) {
    if (!a || !u)
      return !1;
    const c = Object.keys(n).length, f = Object.keys(r).length;
    if (c !== f)
      return !1;
    for (const h in n) {
      const y = n.hasOwnProperty(h), _ = r.hasOwnProperty(h);
      if (y && !_ || !y && _ || !go(n[h], r[h]))
        return !1;
    }
  }
  return String(n) === String(r);
}
function ya(n, r) {
  return n.findIndex((a) => go(a, r));
}
const ku = (n) => !!(n && n.__v_isRef === !0), Re = (n) => Tt(n) ? n : n == null ? "" : Ie(n) || mt(n) && (n.toString === Cu || !qe(n.toString)) ? ku(n) ? Re(n.value) : JSON.stringify(n, Du, 2) : String(n), Du = (n, r) => ku(r) ? Du(n, r.value) : To(r) ? {
  [`Map(${r.size})`]: [...r.entries()].reduce(
    (a, [u, c], f) => (a[js(u, f) + " =>"] = c, a),
    {}
  )
} : Ao(r) ? {
  [`Set(${r.size})`]: [...r.values()].map((a) => js(a))
} : Rn(r) ? js(r) : mt(r) && !Ie(r) && !Au(r) ? String(r) : r, js = (n, r = "") => {
  var a;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Rn(n) ? `Symbol(${(a = n.description) != null ? a : r})` : n
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Ht;
class Ru {
  constructor(r = !1) {
    this.detached = r, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Ht, !r && Ht && (this.index = (Ht.scopes || (Ht.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let r, a;
      if (this.scopes)
        for (r = 0, a = this.scopes.length; r < a; r++)
          this.scopes[r].pause();
      for (r = 0, a = this.effects.length; r < a; r++)
        this.effects[r].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let r, a;
      if (this.scopes)
        for (r = 0, a = this.scopes.length; r < a; r++)
          this.scopes[r].resume();
      for (r = 0, a = this.effects.length; r < a; r++)
        this.effects[r].resume();
    }
  }
  run(r) {
    if (this._active) {
      const a = Ht;
      try {
        return Ht = this, r();
      } finally {
        Ht = a;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Ht, Ht = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Ht = this.prevScope, this.prevScope = void 0);
  }
  stop(r) {
    if (this._active) {
      this._active = !1;
      let a, u;
      for (a = 0, u = this.effects.length; a < u; a++)
        this.effects[a].stop();
      for (this.effects.length = 0, a = 0, u = this.cleanups.length; a < u; a++)
        this.cleanups[a]();
      if (this.cleanups.length = 0, this.scopes) {
        for (a = 0, u = this.scopes.length; a < u; a++)
          this.scopes[a].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !r) {
        const c = this.parent.scopes.pop();
        c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function ju(n) {
  return new Ru(n);
}
function Lu() {
  return Ht;
}
function ac(n, r = !1) {
  Ht && Ht.cleanups.push(n);
}
let ht;
const Ls = /* @__PURE__ */ new WeakSet();
class Ku {
  constructor(r) {
    this.fn = r, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Ht && Ht.active && Ht.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ls.has(this) && (Ls.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Mu(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Ka(this), Bu(this);
    const r = ht, a = Dn;
    ht = this, Dn = !0;
    try {
      return this.fn();
    } finally {
      qu(this), ht = r, Dn = a, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let r = this.deps; r; r = r.nextDep)
        ba(r);
      this.deps = this.depsTail = void 0, Ka(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ls.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    Ys(this) && this.run();
  }
  get dirty() {
    return Ys(this);
  }
}
let Fu = 0, di, pi;
function Mu(n, r = !1) {
  if (n.flags |= 8, r) {
    n.next = pi, pi = n;
    return;
  }
  n.next = di, di = n;
}
function va() {
  Fu++;
}
function ga() {
  if (--Fu > 0)
    return;
  if (pi) {
    let r = pi;
    for (pi = void 0; r; ) {
      const a = r.next;
      r.next = void 0, r.flags &= -9, r = a;
    }
  }
  let n;
  for (; di; ) {
    let r = di;
    for (di = void 0; r; ) {
      const a = r.next;
      if (r.next = void 0, r.flags &= -9, r.flags & 1)
        try {
          r.trigger();
        } catch (u) {
          n || (n = u);
        }
      r = a;
    }
  }
  if (n) throw n;
}
function Bu(n) {
  for (let r = n.deps; r; r = r.nextDep)
    r.version = -1, r.prevActiveLink = r.dep.activeLink, r.dep.activeLink = r;
}
function qu(n) {
  let r, a = n.depsTail, u = a;
  for (; u; ) {
    const c = u.prevDep;
    u.version === -1 ? (u === a && (a = c), ba(u), uc(u)) : r = u, u.dep.activeLink = u.prevActiveLink, u.prevActiveLink = void 0, u = c;
  }
  n.deps = r, n.depsTail = a;
}
function Ys(n) {
  for (let r = n.deps; r; r = r.nextDep)
    if (r.dep.version !== r.version || r.dep.computed && ($u(r.dep.computed) || r.dep.version !== r.version))
      return !0;
  return !!n._dirty;
}
function $u(n) {
  if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === _i) || (n.globalVersion = _i, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !Ys(n))))
    return;
  n.flags |= 2;
  const r = n.dep, a = ht, u = Dn;
  ht = n, Dn = !0;
  try {
    Bu(n);
    const c = n.fn(n._value);
    (r.version === 0 || Sr(c, n._value)) && (n.flags |= 128, n._value = c, r.version++);
  } catch (c) {
    throw r.version++, c;
  } finally {
    ht = a, Dn = u, qu(n), n.flags &= -3;
  }
}
function ba(n, r = !1) {
  const { dep: a, prevSub: u, nextSub: c } = n;
  if (u && (u.nextSub = c, n.prevSub = void 0), c && (c.prevSub = u, n.nextSub = void 0), a.subs === n && (a.subs = u, !u && a.computed)) {
    a.computed.flags &= -5;
    for (let f = a.computed.deps; f; f = f.nextDep)
      ba(f, !0);
  }
  !r && !--a.sc && a.map && a.map.delete(a.key);
}
function uc(n) {
  const { prevDep: r, nextDep: a } = n;
  r && (r.nextDep = a, n.prevDep = void 0), a && (a.prevDep = r, n.nextDep = void 0);
}
let Dn = !0;
const Uu = [];
function _r() {
  Uu.push(Dn), Dn = !1;
}
function wr() {
  const n = Uu.pop();
  Dn = n === void 0 ? !0 : n;
}
function Ka(n) {
  const { cleanup: r } = n;
  if (n.cleanup = void 0, r) {
    const a = ht;
    ht = void 0;
    try {
      r();
    } finally {
      ht = a;
    }
  }
}
let _i = 0;
class lc {
  constructor(r, a) {
    this.sub = r, this.dep = a, this.version = a.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class _a {
  // TODO isolatedDeclarations "__v_skip"
  constructor(r) {
    this.computed = r, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(r) {
    if (!ht || !Dn || ht === this.computed)
      return;
    let a = this.activeLink;
    if (a === void 0 || a.sub !== ht)
      a = this.activeLink = new lc(ht, this), ht.deps ? (a.prevDep = ht.depsTail, ht.depsTail.nextDep = a, ht.depsTail = a) : ht.deps = ht.depsTail = a, Vu(a);
    else if (a.version === -1 && (a.version = this.version, a.nextDep)) {
      const u = a.nextDep;
      u.prevDep = a.prevDep, a.prevDep && (a.prevDep.nextDep = u), a.prevDep = ht.depsTail, a.nextDep = void 0, ht.depsTail.nextDep = a, ht.depsTail = a, ht.deps === a && (ht.deps = u);
    }
    return a;
  }
  trigger(r) {
    this.version++, _i++, this.notify(r);
  }
  notify(r) {
    va();
    try {
      for (let a = this.subs; a; a = a.prevSub)
        a.sub.notify() && a.sub.dep.notify();
    } finally {
      ga();
    }
  }
}
function Vu(n) {
  if (n.dep.sc++, n.sub.flags & 4) {
    const r = n.dep.computed;
    if (r && !n.dep.subs) {
      r.flags |= 20;
      for (let u = r.deps; u; u = u.nextDep)
        Vu(u);
    }
    const a = n.dep.subs;
    a !== n && (n.prevSub = a, a && (a.nextSub = n)), n.dep.subs = n;
  }
}
const qi = /* @__PURE__ */ new WeakMap(), mo = Symbol(
  ""
), Xs = Symbol(
  ""
), wi = Symbol(
  ""
);
function Wt(n, r, a) {
  if (Dn && ht) {
    let u = qi.get(n);
    u || qi.set(n, u = /* @__PURE__ */ new Map());
    let c = u.get(a);
    c || (u.set(a, c = new _a()), c.map = u, c.key = a), c.track();
  }
}
function mr(n, r, a, u, c, f) {
  const h = qi.get(n);
  if (!h) {
    _i++;
    return;
  }
  const y = (_) => {
    _ && _.trigger();
  };
  if (va(), r === "clear")
    h.forEach(y);
  else {
    const _ = Ie(n), j = _ && ha(a);
    if (_ && a === "length") {
      const D = Number(u);
      h.forEach((R, $) => {
        ($ === "length" || $ === wi || !Rn($) && $ >= D) && y(R);
      });
    } else
      switch ((a !== void 0 || h.has(void 0)) && y(h.get(a)), j && y(h.get(wi)), r) {
        case "add":
          _ ? j && y(h.get("length")) : (y(h.get(mo)), To(n) && y(h.get(Xs)));
          break;
        case "delete":
          _ || (y(h.get(mo)), To(n) && y(h.get(Xs)));
          break;
        case "set":
          To(n) && y(h.get(mo));
          break;
      }
  }
  ga();
}
function cc(n, r) {
  const a = qi.get(n);
  return a && a.get(r);
}
function _o(n) {
  const r = Ze(n);
  return r === n ? r : (Wt(r, "iterate", wi), wn(n) ? r : r.map($t));
}
function Zi(n) {
  return Wt(n = Ze(n), "iterate", wi), n;
}
const fc = {
  __proto__: null,
  [Symbol.iterator]() {
    return Ks(this, Symbol.iterator, $t);
  },
  concat(...n) {
    return _o(this).concat(
      ...n.map((r) => Ie(r) ? _o(r) : r)
    );
  },
  entries() {
    return Ks(this, "entries", (n) => (n[1] = $t(n[1]), n));
  },
  every(n, r) {
    return pr(this, "every", n, r, void 0, arguments);
  },
  filter(n, r) {
    return pr(this, "filter", n, r, (a) => a.map($t), arguments);
  },
  find(n, r) {
    return pr(this, "find", n, r, $t, arguments);
  },
  findIndex(n, r) {
    return pr(this, "findIndex", n, r, void 0, arguments);
  },
  findLast(n, r) {
    return pr(this, "findLast", n, r, $t, arguments);
  },
  findLastIndex(n, r) {
    return pr(this, "findLastIndex", n, r, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(n, r) {
    return pr(this, "forEach", n, r, void 0, arguments);
  },
  includes(...n) {
    return Fs(this, "includes", n);
  },
  indexOf(...n) {
    return Fs(this, "indexOf", n);
  },
  join(n) {
    return _o(this).join(n);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...n) {
    return Fs(this, "lastIndexOf", n);
  },
  map(n, r) {
    return pr(this, "map", n, r, void 0, arguments);
  },
  pop() {
    return ui(this, "pop");
  },
  push(...n) {
    return ui(this, "push", n);
  },
  reduce(n, ...r) {
    return Fa(this, "reduce", n, r);
  },
  reduceRight(n, ...r) {
    return Fa(this, "reduceRight", n, r);
  },
  shift() {
    return ui(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(n, r) {
    return pr(this, "some", n, r, void 0, arguments);
  },
  splice(...n) {
    return ui(this, "splice", n);
  },
  toReversed() {
    return _o(this).toReversed();
  },
  toSorted(n) {
    return _o(this).toSorted(n);
  },
  toSpliced(...n) {
    return _o(this).toSpliced(...n);
  },
  unshift(...n) {
    return ui(this, "unshift", n);
  },
  values() {
    return Ks(this, "values", $t);
  }
};
function Ks(n, r, a) {
  const u = Zi(n), c = u[r]();
  return u !== n && !wn(n) && (c._next = c.next, c.next = () => {
    const f = c._next();
    return f.value && (f.value = a(f.value)), f;
  }), c;
}
const dc = Array.prototype;
function pr(n, r, a, u, c, f) {
  const h = Zi(n), y = h !== n && !wn(n), _ = h[r];
  if (_ !== dc[r]) {
    const R = _.apply(n, f);
    return y ? $t(R) : R;
  }
  let j = a;
  h !== n && (y ? j = function(R, $) {
    return a.call(this, $t(R), $, n);
  } : a.length > 2 && (j = function(R, $) {
    return a.call(this, R, $, n);
  }));
  const D = _.call(h, j, u);
  return y && c ? c(D) : D;
}
function Fa(n, r, a, u) {
  const c = Zi(n);
  let f = a;
  return c !== n && (wn(n) ? a.length > 3 && (f = function(h, y, _) {
    return a.call(this, h, y, _, n);
  }) : f = function(h, y, _) {
    return a.call(this, h, $t(y), _, n);
  }), c[r](f, ...u);
}
function Fs(n, r, a) {
  const u = Ze(n);
  Wt(u, "iterate", wi);
  const c = u[r](...a);
  return (c === -1 || c === !1) && Ea(a[0]) ? (a[0] = Ze(a[0]), u[r](...a)) : c;
}
function ui(n, r, a = []) {
  _r(), va();
  const u = Ze(n)[r].apply(n, a);
  return ga(), wr(), u;
}
const pc = /* @__PURE__ */ fa("__proto__,__v_isRef,__isVue"), Hu = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((n) => n !== "arguments" && n !== "caller").map((n) => Symbol[n]).filter(Rn)
);
function hc(n) {
  Rn(n) || (n = String(n));
  const r = Ze(this);
  return Wt(r, "has", n), r.hasOwnProperty(n);
}
class Wu {
  constructor(r = !1, a = !1) {
    this._isReadonly = r, this._isShallow = a;
  }
  get(r, a, u) {
    if (a === "__v_skip") return r.__v_skip;
    const c = this._isReadonly, f = this._isShallow;
    if (a === "__v_isReactive")
      return !c;
    if (a === "__v_isReadonly")
      return c;
    if (a === "__v_isShallow")
      return f;
    if (a === "__v_raw")
      return u === (c ? f ? Tc : Qu : f ? Xu : Yu).get(r) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(r) === Object.getPrototypeOf(u) ? r : void 0;
    const h = Ie(r);
    if (!c) {
      let _;
      if (h && (_ = fc[a]))
        return _;
      if (a === "hasOwnProperty")
        return hc;
    }
    const y = Reflect.get(
      r,
      a,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      st(r) ? r : u
    );
    return (Rn(a) ? Hu.has(a) : pc(a)) || (c || Wt(r, "get", a), f) ? y : st(y) ? h && ha(a) ? y : y.value : mt(y) ? c ? zu(y) : es(y) : y;
  }
}
class Gu extends Wu {
  constructor(r = !1) {
    super(!1, r);
  }
  set(r, a, u, c) {
    let f = r[a];
    if (!this._isShallow) {
      const _ = Ar(f);
      if (!wn(u) && !Ar(u) && (f = Ze(f), u = Ze(u)), !Ie(r) && st(f) && !st(u))
        return _ ? !1 : (f.value = u, !0);
    }
    const h = Ie(r) && ha(a) ? Number(a) < r.length : it(r, a), y = Reflect.set(
      r,
      a,
      u,
      st(r) ? r : c
    );
    return r === Ze(c) && (h ? Sr(u, f) && mr(r, "set", a, u) : mr(r, "add", a, u)), y;
  }
  deleteProperty(r, a) {
    const u = it(r, a);
    r[a];
    const c = Reflect.deleteProperty(r, a);
    return c && u && mr(r, "delete", a, void 0), c;
  }
  has(r, a) {
    const u = Reflect.has(r, a);
    return (!Rn(a) || !Hu.has(a)) && Wt(r, "has", a), u;
  }
  ownKeys(r) {
    return Wt(
      r,
      "iterate",
      Ie(r) ? "length" : mo
    ), Reflect.ownKeys(r);
  }
}
class mc extends Wu {
  constructor(r = !1) {
    super(!0, r);
  }
  set(r, a) {
    return !0;
  }
  deleteProperty(r, a) {
    return !0;
  }
}
const yc = /* @__PURE__ */ new Gu(), vc = /* @__PURE__ */ new mc(), gc = /* @__PURE__ */ new Gu(!0);
const Qs = (n) => n, Ci = (n) => Reflect.getPrototypeOf(n);
function bc(n, r, a) {
  return function(...u) {
    const c = this.__v_raw, f = Ze(c), h = To(f), y = n === "entries" || n === Symbol.iterator && h, _ = n === "keys" && h, j = c[n](...u), D = a ? Qs : r ? $i : $t;
    return !r && Wt(
      f,
      "iterate",
      _ ? Xs : mo
    ), {
      // iterator protocol
      next() {
        const { value: R, done: $ } = j.next();
        return $ ? { value: R, done: $ } : {
          value: y ? [D(R[0]), D(R[1])] : D(R),
          done: $
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function Ai(n) {
  return function(...r) {
    return n === "delete" ? !1 : n === "clear" ? void 0 : this;
  };
}
function _c(n, r) {
  const a = {
    get(c) {
      const f = this.__v_raw, h = Ze(f), y = Ze(c);
      n || (Sr(c, y) && Wt(h, "get", c), Wt(h, "get", y));
      const { has: _ } = Ci(h), j = r ? Qs : n ? $i : $t;
      if (_.call(h, c))
        return j(f.get(c));
      if (_.call(h, y))
        return j(f.get(y));
      f !== h && f.get(c);
    },
    get size() {
      const c = this.__v_raw;
      return !n && Wt(Ze(c), "iterate", mo), Reflect.get(c, "size", c);
    },
    has(c) {
      const f = this.__v_raw, h = Ze(f), y = Ze(c);
      return n || (Sr(c, y) && Wt(h, "has", c), Wt(h, "has", y)), c === y ? f.has(c) : f.has(c) || f.has(y);
    },
    forEach(c, f) {
      const h = this, y = h.__v_raw, _ = Ze(y), j = r ? Qs : n ? $i : $t;
      return !n && Wt(_, "iterate", mo), y.forEach((D, R) => c.call(f, j(D), j(R), h));
    }
  };
  return Gt(
    a,
    n ? {
      add: Ai("add"),
      set: Ai("set"),
      delete: Ai("delete"),
      clear: Ai("clear")
    } : {
      add(c) {
        !r && !wn(c) && !Ar(c) && (c = Ze(c));
        const f = Ze(this);
        return Ci(f).has.call(f, c) || (f.add(c), mr(f, "add", c, c)), this;
      },
      set(c, f) {
        !r && !wn(f) && !Ar(f) && (f = Ze(f));
        const h = Ze(this), { has: y, get: _ } = Ci(h);
        let j = y.call(h, c);
        j || (c = Ze(c), j = y.call(h, c));
        const D = _.call(h, c);
        return h.set(c, f), j ? Sr(f, D) && mr(h, "set", c, f) : mr(h, "add", c, f), this;
      },
      delete(c) {
        const f = Ze(this), { has: h, get: y } = Ci(f);
        let _ = h.call(f, c);
        _ || (c = Ze(c), _ = h.call(f, c)), y && y.call(f, c);
        const j = f.delete(c);
        return _ && mr(f, "delete", c, void 0), j;
      },
      clear() {
        const c = Ze(this), f = c.size !== 0, h = c.clear();
        return f && mr(
          c,
          "clear",
          void 0,
          void 0
        ), h;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((c) => {
    a[c] = bc(c, n, r);
  }), a;
}
function wa(n, r) {
  const a = _c(n, r);
  return (u, c, f) => c === "__v_isReactive" ? !n : c === "__v_isReadonly" ? n : c === "__v_raw" ? u : Reflect.get(
    it(a, c) && c in u ? a : u,
    c,
    f
  );
}
const wc = {
  get: /* @__PURE__ */ wa(!1, !1)
}, xc = {
  get: /* @__PURE__ */ wa(!1, !0)
}, Ec = {
  get: /* @__PURE__ */ wa(!0, !1)
};
const Yu = /* @__PURE__ */ new WeakMap(), Xu = /* @__PURE__ */ new WeakMap(), Qu = /* @__PURE__ */ new WeakMap(), Tc = /* @__PURE__ */ new WeakMap();
function Oc(n) {
  switch (n) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Nc(n) {
  return n.__v_skip || !Object.isExtensible(n) ? 0 : Oc(zl(n));
}
function es(n) {
  return Ar(n) ? n : xa(
    n,
    !1,
    yc,
    wc,
    Yu
  );
}
function Sc(n) {
  return xa(
    n,
    !1,
    gc,
    xc,
    Xu
  );
}
function zu(n) {
  return xa(
    n,
    !0,
    vc,
    Ec,
    Qu
  );
}
function xa(n, r, a, u, c) {
  if (!mt(n) || n.__v_raw && !(r && n.__v_isReactive))
    return n;
  const f = Nc(n);
  if (f === 0)
    return n;
  const h = c.get(n);
  if (h)
    return h;
  const y = new Proxy(
    n,
    f === 2 ? u : a
  );
  return c.set(n, y), y;
}
function gr(n) {
  return Ar(n) ? gr(n.__v_raw) : !!(n && n.__v_isReactive);
}
function Ar(n) {
  return !!(n && n.__v_isReadonly);
}
function wn(n) {
  return !!(n && n.__v_isShallow);
}
function Ea(n) {
  return n ? !!n.__v_raw : !1;
}
function Ze(n) {
  const r = n && n.__v_raw;
  return r ? Ze(r) : n;
}
function Ta(n) {
  return !it(n, "__v_skip") && Object.isExtensible(n) && Gs(n, "__v_skip", !0), n;
}
const $t = (n) => mt(n) ? es(n) : n, $i = (n) => mt(n) ? zu(n) : n;
function st(n) {
  return n ? n.__v_isRef === !0 : !1;
}
function lt(n) {
  return Ju(n, !1);
}
function Ri(n) {
  return Ju(n, !0);
}
function Ju(n, r) {
  return st(n) ? n : new Cc(n, r);
}
class Cc {
  constructor(r, a) {
    this.dep = new _a(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = a ? r : Ze(r), this._value = a ? r : $t(r), this.__v_isShallow = a;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(r) {
    const a = this._rawValue, u = this.__v_isShallow || wn(r) || Ar(r);
    r = u ? r : Ze(r), Sr(r, a) && (this._rawValue = r, this._value = u ? r : $t(r), this.dep.trigger());
  }
}
function Ve(n) {
  return st(n) ? n.value : n;
}
const Ac = {
  get: (n, r, a) => r === "__v_raw" ? n : Ve(Reflect.get(n, r, a)),
  set: (n, r, a, u) => {
    const c = n[r];
    return st(c) && !st(a) ? (c.value = a, !0) : Reflect.set(n, r, a, u);
  }
};
function Zu(n) {
  return gr(n) ? n : new Proxy(n, Ac);
}
function Pc(n) {
  const r = Ie(n) ? new Array(n.length) : {};
  for (const a in n)
    r[a] = el(n, a);
  return r;
}
class Ic {
  constructor(r, a, u) {
    this._object = r, this._key = a, this._defaultValue = u, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const r = this._object[this._key];
    return this._value = r === void 0 ? this._defaultValue : r;
  }
  set value(r) {
    this._object[this._key] = r;
  }
  get dep() {
    return cc(Ze(this._object), this._key);
  }
}
class kc {
  constructor(r) {
    this._getter = r, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Dc(n, r, a) {
  return st(n) ? n : qe(n) ? new kc(n) : mt(n) && arguments.length > 1 ? el(n, r, a) : lt(n);
}
function el(n, r, a) {
  const u = n[r];
  return st(u) ? u : new Ic(n, r, a);
}
class Rc {
  constructor(r, a, u) {
    this.fn = r, this.setter = a, this._value = void 0, this.dep = new _a(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = _i - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !a, this.isSSR = u;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    ht !== this)
      return Mu(this, !0), !0;
  }
  get value() {
    const r = this.dep.track();
    return $u(this), r && (r.version = this.dep.version), this._value;
  }
  set value(r) {
    this.setter && this.setter(r);
  }
}
function jc(n, r, a = !1) {
  let u, c;
  return qe(n) ? u = n : (u = n.get, c = n.set), new Rc(u, c, a);
}
const Pi = {}, Ui = /* @__PURE__ */ new WeakMap();
let ho;
function Lc(n, r = !1, a = ho) {
  if (a) {
    let u = Ui.get(a);
    u || Ui.set(a, u = []), u.push(n);
  }
}
function Kc(n, r, a = ut) {
  const { immediate: u, deep: c, once: f, scheduler: h, augmentJob: y, call: _ } = a, j = (ae) => c ? ae : wn(ae) || c === !1 || c === 0 ? yr(ae, 1) : yr(ae);
  let D, R, $, W, J = !1, re = !1;
  if (st(n) ? (R = () => n.value, J = wn(n)) : gr(n) ? (R = () => j(n), J = !0) : Ie(n) ? (re = !0, J = n.some((ae) => gr(ae) || wn(ae)), R = () => n.map((ae) => {
    if (st(ae))
      return ae.value;
    if (gr(ae))
      return j(ae);
    if (qe(ae))
      return _ ? _(ae, 2) : ae();
  })) : qe(n) ? r ? R = _ ? () => _(n, 2) : n : R = () => {
    if ($) {
      _r();
      try {
        $();
      } finally {
        wr();
      }
    }
    const ae = ho;
    ho = D;
    try {
      return _ ? _(n, 3, [W]) : n(W);
    } finally {
      ho = ae;
    }
  } : R = qn, r && c) {
    const ae = R, ge = c === !0 ? 1 / 0 : c;
    R = () => yr(ae(), ge);
  }
  const te = Lu(), M = () => {
    D.stop(), te && te.active && pa(te.effects, D);
  };
  if (f && r) {
    const ae = r;
    r = (...ge) => {
      ae(...ge), M();
    };
  }
  let G = re ? new Array(n.length).fill(Pi) : Pi;
  const fe = (ae) => {
    if (!(!(D.flags & 1) || !D.dirty && !ae))
      if (r) {
        const ge = D.run();
        if (c || J || (re ? ge.some((Ce, _e) => Sr(Ce, G[_e])) : Sr(ge, G))) {
          $ && $();
          const Ce = ho;
          ho = D;
          try {
            const _e = [
              ge,
              // pass undefined as the old value when it's changed for the first time
              G === Pi ? void 0 : re && G[0] === Pi ? [] : G,
              W
            ];
            G = ge, _ ? _(r, 3, _e) : (
              // @ts-expect-error
              r(..._e)
            );
          } finally {
            ho = Ce;
          }
        }
      } else
        D.run();
  };
  return y && y(fe), D = new Ku(R), D.scheduler = h ? () => h(fe, !1) : fe, W = (ae) => Lc(ae, !1, D), $ = D.onStop = () => {
    const ae = Ui.get(D);
    if (ae) {
      if (_)
        _(ae, 4);
      else
        for (const ge of ae) ge();
      Ui.delete(D);
    }
  }, r ? u ? fe(!0) : G = D.run() : h ? h(fe.bind(null, !0), !0) : D.run(), M.pause = D.pause.bind(D), M.resume = D.resume.bind(D), M.stop = M, M;
}
function yr(n, r = 1 / 0, a) {
  if (r <= 0 || !mt(n) || n.__v_skip || (a = a || /* @__PURE__ */ new Set(), a.has(n)))
    return n;
  if (a.add(n), r--, st(n))
    yr(n.value, r, a);
  else if (Ie(n))
    for (let u = 0; u < n.length; u++)
      yr(n[u], r, a);
  else if (Ao(n) || To(n))
    n.forEach((u) => {
      yr(u, r, a);
    });
  else if (Au(n)) {
    for (const u in n)
      yr(n[u], r, a);
    for (const u of Object.getOwnPropertySymbols(n))
      Object.prototype.propertyIsEnumerable.call(n, u) && yr(n[u], r, a);
  }
  return n;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Ni(n, r, a, u) {
  try {
    return u ? n(...u) : n();
  } catch (c) {
    ts(c, r, a);
  }
}
function $n(n, r, a, u) {
  if (qe(n)) {
    const c = Ni(n, r, a, u);
    return c && Su(c) && c.catch((f) => {
      ts(f, r, a);
    }), c;
  }
  if (Ie(n)) {
    const c = [];
    for (let f = 0; f < n.length; f++)
      c.push($n(n[f], r, a, u));
    return c;
  }
}
function ts(n, r, a, u = !0) {
  const c = r ? r.vnode : null, { errorHandler: f, throwUnhandledErrorInProduction: h } = r && r.appContext.config || ut;
  if (r) {
    let y = r.parent;
    const _ = r.proxy, j = `https://vuejs.org/error-reference/#runtime-${a}`;
    for (; y; ) {
      const D = y.ec;
      if (D) {
        for (let R = 0; R < D.length; R++)
          if (D[R](n, _, j) === !1)
            return;
      }
      y = y.parent;
    }
    if (f) {
      _r(), Ni(f, null, 10, [
        n,
        _,
        j
      ]), wr();
      return;
    }
  }
  Fc(n, a, c, u, h);
}
function Fc(n, r, a, u = !0, c = !1) {
  if (c)
    throw n;
  console.error(n);
}
const sn = [];
let Fn = -1;
const Oo = [];
let Or = null, xo = 0;
const tl = /* @__PURE__ */ Promise.resolve();
let Vi = null;
function Oa(n) {
  const r = Vi || tl;
  return n ? r.then(this ? n.bind(this) : n) : r;
}
function Mc(n) {
  let r = Fn + 1, a = sn.length;
  for (; r < a; ) {
    const u = r + a >>> 1, c = sn[u], f = xi(c);
    f < n || f === n && c.flags & 2 ? r = u + 1 : a = u;
  }
  return r;
}
function Na(n) {
  if (!(n.flags & 1)) {
    const r = xi(n), a = sn[sn.length - 1];
    !a || // fast path when the job id is larger than the tail
    !(n.flags & 2) && r >= xi(a) ? sn.push(n) : sn.splice(Mc(r), 0, n), n.flags |= 1, nl();
  }
}
function nl() {
  Vi || (Vi = tl.then(ol));
}
function Bc(n) {
  Ie(n) ? Oo.push(...n) : Or && n.id === -1 ? Or.splice(xo + 1, 0, n) : n.flags & 1 || (Oo.push(n), n.flags |= 1), nl();
}
function Ma(n, r, a = Fn + 1) {
  for (; a < sn.length; a++) {
    const u = sn[a];
    if (u && u.flags & 2) {
      if (n && u.id !== n.uid)
        continue;
      sn.splice(a, 1), a--, u.flags & 4 && (u.flags &= -2), u(), u.flags & 4 || (u.flags &= -2);
    }
  }
}
function rl(n) {
  if (Oo.length) {
    const r = [...new Set(Oo)].sort(
      (a, u) => xi(a) - xi(u)
    );
    if (Oo.length = 0, Or) {
      Or.push(...r);
      return;
    }
    for (Or = r, xo = 0; xo < Or.length; xo++) {
      const a = Or[xo];
      a.flags & 4 && (a.flags &= -2), a.flags & 8 || a(), a.flags &= -2;
    }
    Or = null, xo = 0;
  }
}
const xi = (n) => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function ol(n) {
  try {
    for (Fn = 0; Fn < sn.length; Fn++) {
      const r = sn[Fn];
      r && !(r.flags & 8) && (r.flags & 4 && (r.flags &= -2), Ni(
        r,
        r.i,
        r.i ? 15 : 14
      ), r.flags & 4 || (r.flags &= -2));
    }
  } finally {
    for (; Fn < sn.length; Fn++) {
      const r = sn[Fn];
      r && (r.flags &= -2);
    }
    Fn = -1, sn.length = 0, rl(), Vi = null, (sn.length || Oo.length) && ol();
  }
}
let jt = null, il = null;
function Hi(n) {
  const r = jt;
  return jt = n, il = n && n.type.__scopeId || null, r;
}
function zs(n, r = jt, a) {
  if (!r || n._n)
    return n;
  const u = (...c) => {
    u._d && Ja(-1);
    const f = Hi(r);
    let h;
    try {
      h = n(...c);
    } finally {
      Hi(f), u._d && Ja(1);
    }
    return h;
  };
  return u._n = !0, u._c = !0, u._d = !0, u;
}
function et(n, r) {
  if (jt === null)
    return n;
  const a = is(jt), u = n.dirs || (n.dirs = []);
  for (let c = 0; c < r.length; c++) {
    let [f, h, y, _ = ut] = r[c];
    f && (qe(f) && (f = {
      mounted: f,
      updated: f
    }), f.deep && yr(h), u.push({
      dir: f,
      instance: a,
      value: h,
      oldValue: void 0,
      arg: y,
      modifiers: _
    }));
  }
  return n;
}
function fo(n, r, a, u) {
  const c = n.dirs, f = r && r.dirs;
  for (let h = 0; h < c.length; h++) {
    const y = c[h];
    f && (y.oldValue = f[h].value);
    let _ = y.dir[u];
    _ && (_r(), $n(_, a, 8, [
      n.el,
      y,
      n,
      r
    ]), wr());
  }
}
const sl = Symbol("_vte"), qc = (n) => n.__isTeleport, hi = (n) => n && (n.disabled || n.disabled === ""), Ba = (n) => n && (n.defer || n.defer === ""), qa = (n) => typeof SVGElement < "u" && n instanceof SVGElement, $a = (n) => typeof MathMLElement == "function" && n instanceof MathMLElement, Js = (n, r) => {
  const a = n && n.to;
  return Tt(a) ? r ? r(a) : null : a;
}, al = {
  name: "Teleport",
  __isTeleport: !0,
  process(n, r, a, u, c, f, h, y, _, j) {
    const {
      mc: D,
      pc: R,
      pbc: $,
      o: { insert: W, querySelector: J, createText: re, createComment: te }
    } = j, M = hi(r.props);
    let { shapeFlag: G, children: fe, dynamicChildren: ae } = r;
    if (n == null) {
      const ge = r.el = re(""), Ce = r.anchor = re("");
      W(ge, a, u), W(Ce, a, u);
      const _e = (B, Xe) => {
        G & 16 && (c && c.isCE && (c.ce._teleportTarget = B), D(
          fe,
          B,
          Xe,
          c,
          f,
          h,
          y,
          _
        ));
      }, Ae = () => {
        const B = r.target = Js(r.props, J), Xe = ll(B, r, re, W);
        B && (h !== "svg" && qa(B) ? h = "svg" : h !== "mathml" && $a(B) && (h = "mathml"), M || (_e(B, Xe), ji(r, !1)));
      };
      M && (_e(a, Ce), ji(r, !0)), Ba(r.props) ? (r.el.__isMounted = !1, on(() => {
        Ae(), delete r.el.__isMounted;
      }, f)) : Ae();
    } else {
      if (Ba(r.props) && n.el.__isMounted === !1) {
        on(() => {
          al.process(
            n,
            r,
            a,
            u,
            c,
            f,
            h,
            y,
            _,
            j
          );
        }, f);
        return;
      }
      r.el = n.el, r.targetStart = n.targetStart;
      const ge = r.anchor = n.anchor, Ce = r.target = n.target, _e = r.targetAnchor = n.targetAnchor, Ae = hi(n.props), B = Ae ? a : Ce, Xe = Ae ? ge : _e;
      if (h === "svg" || qa(Ce) ? h = "svg" : (h === "mathml" || $a(Ce)) && (h = "mathml"), ae ? ($(
        n.dynamicChildren,
        ae,
        B,
        c,
        f,
        h,
        y
      ), Ia(n, r, !0)) : _ || R(
        n,
        r,
        B,
        Xe,
        c,
        f,
        h,
        y,
        !1
      ), M)
        Ae ? r.props && n.props && r.props.to !== n.props.to && (r.props.to = n.props.to) : Ii(
          r,
          a,
          ge,
          j,
          1
        );
      else if ((r.props && r.props.to) !== (n.props && n.props.to)) {
        const ct = r.target = Js(
          r.props,
          J
        );
        ct && Ii(
          r,
          ct,
          null,
          j,
          0
        );
      } else Ae && Ii(
        r,
        Ce,
        _e,
        j,
        1
      );
      ji(r, M);
    }
  },
  remove(n, r, a, { um: u, o: { remove: c } }, f) {
    const {
      shapeFlag: h,
      children: y,
      anchor: _,
      targetStart: j,
      targetAnchor: D,
      target: R,
      props: $
    } = n;
    if (R && (c(j), c(D)), f && c(_), h & 16) {
      const W = f || !hi($);
      for (let J = 0; J < y.length; J++) {
        const re = y[J];
        u(
          re,
          r,
          a,
          W,
          !!re.dynamicChildren
        );
      }
    }
  },
  move: Ii,
  hydrate: $c
};
function Ii(n, r, a, { o: { insert: u }, m: c }, f = 2) {
  f === 0 && u(n.targetAnchor, r, a);
  const { el: h, anchor: y, shapeFlag: _, children: j, props: D } = n, R = f === 2;
  if (R && u(h, r, a), (!R || hi(D)) && _ & 16)
    for (let $ = 0; $ < j.length; $++)
      c(
        j[$],
        r,
        a,
        2
      );
  R && u(y, r, a);
}
function $c(n, r, a, u, c, f, {
  o: { nextSibling: h, parentNode: y, querySelector: _, insert: j, createText: D }
}, R) {
  const $ = r.target = Js(
    r.props,
    _
  );
  if ($) {
    const W = hi(r.props), J = $._lpa || $.firstChild;
    if (r.shapeFlag & 16)
      if (W)
        r.anchor = R(
          h(n),
          r,
          y(n),
          a,
          u,
          c,
          f
        ), r.targetStart = J, r.targetAnchor = J && h(J);
      else {
        r.anchor = h(n);
        let re = J;
        for (; re; ) {
          if (re && re.nodeType === 8) {
            if (re.data === "teleport start anchor")
              r.targetStart = re;
            else if (re.data === "teleport anchor") {
              r.targetAnchor = re, $._lpa = r.targetAnchor && h(r.targetAnchor);
              break;
            }
          }
          re = h(re);
        }
        r.targetAnchor || ll($, r, D, j), R(
          J && h(J),
          r,
          $,
          a,
          u,
          c,
          f
        );
      }
    ji(r, W);
  }
  return r.anchor && h(r.anchor);
}
const ul = al;
function ji(n, r) {
  const a = n.ctx;
  if (a && a.ut) {
    let u, c;
    for (r ? (u = n.el, c = n.anchor) : (u = n.targetStart, c = n.targetAnchor); u && u !== c; )
      u.nodeType === 1 && u.setAttribute("data-v-owner", a.uid), u = u.nextSibling;
    a.ut();
  }
}
function ll(n, r, a, u) {
  const c = r.targetStart = a(""), f = r.targetAnchor = a("");
  return c[sl] = f, n && (u(c, n), u(f, n)), f;
}
function Sa(n, r) {
  n.shapeFlag & 6 && n.component ? (n.transition = r, Sa(n.component.subTree, r)) : n.shapeFlag & 128 ? (n.ssContent.transition = r.clone(n.ssContent), n.ssFallback.transition = r.clone(n.ssFallback)) : n.transition = r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Yt(n, r) {
  return qe(n) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Gt({ name: n.name }, r, { setup: n })
  ) : n;
}
function cl(n) {
  n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0];
}
function fl(n) {
  const r = Bf(), a = Ri(null);
  if (r) {
    const c = r.refs === ut ? r.refs = {} : r.refs;
    Object.defineProperty(c, n, {
      enumerable: !0,
      get: () => a.value,
      set: (f) => a.value = f
    });
  }
  return a;
}
function mi(n, r, a, u, c = !1) {
  if (Ie(n)) {
    n.forEach(
      (J, re) => mi(
        J,
        r && (Ie(r) ? r[re] : r),
        a,
        u,
        c
      )
    );
    return;
  }
  if (No(u) && !c) {
    u.shapeFlag & 512 && u.type.__asyncResolved && u.component.subTree.component && mi(n, r, a, u.component.subTree);
    return;
  }
  const f = u.shapeFlag & 4 ? is(u.component) : u.el, h = c ? null : f, { i: y, r: _ } = n, j = r && r.r, D = y.refs === ut ? y.refs = {} : y.refs, R = y.setupState, $ = Ze(R), W = R === ut ? () => !1 : (J) => it($, J);
  if (j != null && j !== _ && (Tt(j) ? (D[j] = null, W(j) && (R[j] = null)) : st(j) && (j.value = null)), qe(_))
    Ni(_, y, 12, [h, D]);
  else {
    const J = Tt(_), re = st(_);
    if (J || re) {
      const te = () => {
        if (n.f) {
          const M = J ? W(_) ? R[_] : D[_] : _.value;
          c ? Ie(M) && pa(M, f) : Ie(M) ? M.includes(f) || M.push(f) : J ? (D[_] = [f], W(_) && (R[_] = D[_])) : (_.value = [f], n.k && (D[n.k] = _.value));
        } else J ? (D[_] = h, W(_) && (R[_] = h)) : re && (_.value = h, n.k && (D[n.k] = h));
      };
      h ? (te.id = -1, on(te, a)) : te();
    }
  }
}
Ji().requestIdleCallback;
Ji().cancelIdleCallback;
const No = (n) => !!n.type.__asyncLoader, dl = (n) => n.type.__isKeepAlive;
function Uc(n, r) {
  pl(n, "a", r);
}
function Vc(n, r) {
  pl(n, "da", r);
}
function pl(n, r, a = Ut) {
  const u = n.__wdc || (n.__wdc = () => {
    let c = a;
    for (; c; ) {
      if (c.isDeactivated)
        return;
      c = c.parent;
    }
    return n();
  });
  if (ns(r, u, a), a) {
    let c = a.parent;
    for (; c && c.parent; )
      dl(c.parent.vnode) && Hc(u, r, a, c), c = c.parent;
  }
}
function Hc(n, r, a, u) {
  const c = ns(
    r,
    n,
    u,
    !0
    /* prepend */
  );
  Ca(() => {
    pa(u[r], c);
  }, a);
}
function ns(n, r, a = Ut, u = !1) {
  if (a) {
    const c = a[n] || (a[n] = []), f = r.__weh || (r.__weh = (...h) => {
      _r();
      const y = Si(a), _ = $n(r, a, n, h);
      return y(), wr(), _;
    });
    return u ? c.unshift(f) : c.push(f), f;
  }
}
const Er = (n) => (r, a = Ut) => {
  (!Ti || n === "sp") && ns(n, (...u) => r(...u), a);
}, Wc = Er("bm"), hl = Er("m"), Gc = Er(
  "bu"
), Yc = Er("u"), Xc = Er(
  "bum"
), Ca = Er("um"), Qc = Er(
  "sp"
), zc = Er("rtg"), Jc = Er("rtc");
function Zc(n, r = Ut) {
  ns("ec", n, r);
}
const ef = Symbol.for("v-ndc");
function St(n, r, a, u) {
  let c;
  const f = a, h = Ie(n);
  if (h || Tt(n)) {
    const y = h && gr(n);
    let _ = !1, j = !1;
    y && (_ = !wn(n), j = Ar(n), n = Zi(n)), c = new Array(n.length);
    for (let D = 0, R = n.length; D < R; D++)
      c[D] = r(
        _ ? j ? $i($t(n[D])) : $t(n[D]) : n[D],
        D,
        void 0,
        f
      );
  } else if (typeof n == "number") {
    c = new Array(n);
    for (let y = 0; y < n; y++)
      c[y] = r(y + 1, y, void 0, f);
  } else if (mt(n))
    if (n[Symbol.iterator])
      c = Array.from(
        n,
        (y, _) => r(y, _, void 0, f)
      );
    else {
      const y = Object.keys(n);
      c = new Array(y.length);
      for (let _ = 0, j = y.length; _ < j; _++) {
        const D = y[_];
        c[_] = r(n[D], D, _, f);
      }
    }
  else
    c = [];
  return c;
}
function Ua(n, r, a = {}, u, c) {
  if (jt.ce || jt.parent && No(jt.parent) && jt.parent.ce)
    return r !== "default" && (a.name = r), ve(), kn(
      Ye,
      null,
      [Ct("slot", a, u)],
      64
    );
  let f = n[r];
  f && f._c && (f._d = !1), ve();
  const h = f && ml(f(a)), y = a.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  h && h.key, _ = kn(
    Ye,
    {
      key: (y && !Rn(y) ? y : `_${r}`) + // #7256 force differentiate fallback content from actual content
      (!h && u ? "_fb" : "")
    },
    h || [],
    h && n._ === 1 ? 64 : -2
  );
  return f && f._c && (f._d = !0), _;
}
function ml(n) {
  return n.some((r) => Da(r) ? !(r.type === xr || r.type === Ye && !ml(r.children)) : !0) ? n : null;
}
const Zs = (n) => n ? Rl(n) ? is(n) : Zs(n.parent) : null, yi = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Gt(/* @__PURE__ */ Object.create(null), {
    $: (n) => n,
    $el: (n) => n.vnode.el,
    $data: (n) => n.data,
    $props: (n) => n.props,
    $attrs: (n) => n.attrs,
    $slots: (n) => n.slots,
    $refs: (n) => n.refs,
    $parent: (n) => Zs(n.parent),
    $root: (n) => Zs(n.root),
    $host: (n) => n.ce,
    $emit: (n) => n.emit,
    $options: (n) => vl(n),
    $forceUpdate: (n) => n.f || (n.f = () => {
      Na(n.update);
    }),
    $nextTick: (n) => n.n || (n.n = Oa.bind(n.proxy)),
    $watch: (n) => Of.bind(n)
  })
), Ms = (n, r) => n !== ut && !n.__isScriptSetup && it(n, r), tf = {
  get({ _: n }, r) {
    if (r === "__v_skip")
      return !0;
    const { ctx: a, setupState: u, data: c, props: f, accessCache: h, type: y, appContext: _ } = n;
    let j;
    if (r[0] !== "$") {
      const W = h[r];
      if (W !== void 0)
        switch (W) {
          case 1:
            return u[r];
          case 2:
            return c[r];
          case 4:
            return a[r];
          case 3:
            return f[r];
        }
      else {
        if (Ms(u, r))
          return h[r] = 1, u[r];
        if (c !== ut && it(c, r))
          return h[r] = 2, c[r];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (j = n.propsOptions[0]) && it(j, r)
        )
          return h[r] = 3, f[r];
        if (a !== ut && it(a, r))
          return h[r] = 4, a[r];
        ea && (h[r] = 0);
      }
    }
    const D = yi[r];
    let R, $;
    if (D)
      return r === "$attrs" && Wt(n.attrs, "get", ""), D(n);
    if (
      // css module (injected by vue-loader)
      (R = y.__cssModules) && (R = R[r])
    )
      return R;
    if (a !== ut && it(a, r))
      return h[r] = 4, a[r];
    if (
      // global properties
      $ = _.config.globalProperties, it($, r)
    )
      return $[r];
  },
  set({ _: n }, r, a) {
    const { data: u, setupState: c, ctx: f } = n;
    return Ms(c, r) ? (c[r] = a, !0) : u !== ut && it(u, r) ? (u[r] = a, !0) : it(n.props, r) || r[0] === "$" && r.slice(1) in n ? !1 : (f[r] = a, !0);
  },
  has({
    _: { data: n, setupState: r, accessCache: a, ctx: u, appContext: c, propsOptions: f }
  }, h) {
    let y;
    return !!a[h] || n !== ut && it(n, h) || Ms(r, h) || (y = f[0]) && it(y, h) || it(u, h) || it(yi, h) || it(c.config.globalProperties, h);
  },
  defineProperty(n, r, a) {
    return a.get != null ? n._.accessCache[r] = 0 : it(a, "value") && this.set(n, r, a.value, null), Reflect.defineProperty(n, r, a);
  }
};
function Va(n) {
  return Ie(n) ? n.reduce(
    (r, a) => (r[a] = null, r),
    {}
  ) : n;
}
let ea = !0;
function nf(n) {
  const r = vl(n), a = n.proxy, u = n.ctx;
  ea = !1, r.beforeCreate && Ha(r.beforeCreate, n, "bc");
  const {
    // state
    data: c,
    computed: f,
    methods: h,
    watch: y,
    provide: _,
    inject: j,
    // lifecycle
    created: D,
    beforeMount: R,
    mounted: $,
    beforeUpdate: W,
    updated: J,
    activated: re,
    deactivated: te,
    beforeDestroy: M,
    beforeUnmount: G,
    destroyed: fe,
    unmounted: ae,
    render: ge,
    renderTracked: Ce,
    renderTriggered: _e,
    errorCaptured: Ae,
    serverPrefetch: B,
    // public API
    expose: Xe,
    inheritAttrs: ct,
    // assets
    components: Ke,
    directives: ot,
    filters: bn
  } = r;
  if (j && rf(j, u, null), h)
    for (const xe in h) {
      const Le = h[xe];
      qe(Le) && (u[xe] = Le.bind(a));
    }
  if (c) {
    const xe = c.call(a, a);
    mt(xe) && (n.data = es(xe));
  }
  if (ea = !0, f)
    for (const xe in f) {
      const Le = f[xe], yt = qe(Le) ? Le.bind(a, a) : qe(Le.get) ? Le.get.bind(a, a) : qn, at = !qe(Le) && qe(Le.set) ? Le.set.bind(a) : qn, bt = It({
        get: yt,
        set: at
      });
      Object.defineProperty(u, xe, {
        enumerable: !0,
        configurable: !0,
        get: () => bt.value,
        set: (Dt) => bt.value = Dt
      });
    }
  if (y)
    for (const xe in y)
      yl(y[xe], u, a, xe);
  if (_) {
    const xe = qe(_) ? _.call(a) : _;
    Reflect.ownKeys(xe).forEach((Le) => {
      cf(Le, xe[Le]);
    });
  }
  D && Ha(D, n, "c");
  function tt(xe, Le) {
    Ie(Le) ? Le.forEach((yt) => xe(yt.bind(a))) : Le && xe(Le.bind(a));
  }
  if (tt(Wc, R), tt(hl, $), tt(Gc, W), tt(Yc, J), tt(Uc, re), tt(Vc, te), tt(Zc, Ae), tt(Jc, Ce), tt(zc, _e), tt(Xc, G), tt(Ca, ae), tt(Qc, B), Ie(Xe))
    if (Xe.length) {
      const xe = n.exposed || (n.exposed = {});
      Xe.forEach((Le) => {
        Object.defineProperty(xe, Le, {
          get: () => a[Le],
          set: (yt) => a[Le] = yt
        });
      });
    } else n.exposed || (n.exposed = {});
  ge && n.render === qn && (n.render = ge), ct != null && (n.inheritAttrs = ct), Ke && (n.components = Ke), ot && (n.directives = ot), B && cl(n);
}
function rf(n, r, a = qn) {
  Ie(n) && (n = ta(n));
  for (const u in n) {
    const c = n[u];
    let f;
    mt(c) ? "default" in c ? f = vi(
      c.from || u,
      c.default,
      !0
    ) : f = vi(c.from || u) : f = vi(c), st(f) ? Object.defineProperty(r, u, {
      enumerable: !0,
      configurable: !0,
      get: () => f.value,
      set: (h) => f.value = h
    }) : r[u] = f;
  }
}
function Ha(n, r, a) {
  $n(
    Ie(n) ? n.map((u) => u.bind(r.proxy)) : n.bind(r.proxy),
    r,
    a
  );
}
function yl(n, r, a, u) {
  let c = u.includes(".") ? Cl(a, u) : () => a[u];
  if (Tt(n)) {
    const f = r[n];
    qe(f) && cn(c, f);
  } else if (qe(n))
    cn(c, n.bind(a));
  else if (mt(n))
    if (Ie(n))
      n.forEach((f) => yl(f, r, a, u));
    else {
      const f = qe(n.handler) ? n.handler.bind(a) : r[n.handler];
      qe(f) && cn(c, f, n);
    }
}
function vl(n) {
  const r = n.type, { mixins: a, extends: u } = r, {
    mixins: c,
    optionsCache: f,
    config: { optionMergeStrategies: h }
  } = n.appContext, y = f.get(r);
  let _;
  return y ? _ = y : !c.length && !a && !u ? _ = r : (_ = {}, c.length && c.forEach(
    (j) => Wi(_, j, h, !0)
  ), Wi(_, r, h)), mt(r) && f.set(r, _), _;
}
function Wi(n, r, a, u = !1) {
  const { mixins: c, extends: f } = r;
  f && Wi(n, f, a, !0), c && c.forEach(
    (h) => Wi(n, h, a, !0)
  );
  for (const h in r)
    if (!(u && h === "expose")) {
      const y = of[h] || a && a[h];
      n[h] = y ? y(n[h], r[h]) : r[h];
    }
  return n;
}
const of = {
  data: Wa,
  props: Ga,
  emits: Ga,
  // objects
  methods: ci,
  computed: ci,
  // lifecycle
  beforeCreate: rn,
  created: rn,
  beforeMount: rn,
  mounted: rn,
  beforeUpdate: rn,
  updated: rn,
  beforeDestroy: rn,
  beforeUnmount: rn,
  destroyed: rn,
  unmounted: rn,
  activated: rn,
  deactivated: rn,
  errorCaptured: rn,
  serverPrefetch: rn,
  // assets
  components: ci,
  directives: ci,
  // watch
  watch: af,
  // provide / inject
  provide: Wa,
  inject: sf
};
function Wa(n, r) {
  return r ? n ? function() {
    return Gt(
      qe(n) ? n.call(this, this) : n,
      qe(r) ? r.call(this, this) : r
    );
  } : r : n;
}
function sf(n, r) {
  return ci(ta(n), ta(r));
}
function ta(n) {
  if (Ie(n)) {
    const r = {};
    for (let a = 0; a < n.length; a++)
      r[n[a]] = n[a];
    return r;
  }
  return n;
}
function rn(n, r) {
  return n ? [...new Set([].concat(n, r))] : r;
}
function ci(n, r) {
  return n ? Gt(/* @__PURE__ */ Object.create(null), n, r) : r;
}
function Ga(n, r) {
  return n ? Ie(n) && Ie(r) ? [.../* @__PURE__ */ new Set([...n, ...r])] : Gt(
    /* @__PURE__ */ Object.create(null),
    Va(n),
    Va(r ?? {})
  ) : r;
}
function af(n, r) {
  if (!n) return r;
  if (!r) return n;
  const a = Gt(/* @__PURE__ */ Object.create(null), n);
  for (const u in r)
    a[u] = rn(n[u], r[u]);
  return a;
}
function gl() {
  return {
    app: null,
    config: {
      isNativeTag: Xl,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uf = 0;
function lf(n, r) {
  return function(u, c = null) {
    qe(u) || (u = Gt({}, u)), c != null && !mt(c) && (c = null);
    const f = gl(), h = /* @__PURE__ */ new WeakSet(), y = [];
    let _ = !1;
    const j = f.app = {
      _uid: uf++,
      _component: u,
      _props: c,
      _container: null,
      _context: f,
      _instance: null,
      version: Wf,
      get config() {
        return f.config;
      },
      set config(D) {
      },
      use(D, ...R) {
        return h.has(D) || (D && qe(D.install) ? (h.add(D), D.install(j, ...R)) : qe(D) && (h.add(D), D(j, ...R))), j;
      },
      mixin(D) {
        return f.mixins.includes(D) || f.mixins.push(D), j;
      },
      component(D, R) {
        return R ? (f.components[D] = R, j) : f.components[D];
      },
      directive(D, R) {
        return R ? (f.directives[D] = R, j) : f.directives[D];
      },
      mount(D, R, $) {
        if (!_) {
          const W = j._ceVNode || Ct(u, c);
          return W.appContext = f, $ === !0 ? $ = "svg" : $ === !1 && ($ = void 0), n(W, D, $), _ = !0, j._container = D, D.__vue_app__ = j, is(W.component);
        }
      },
      onUnmount(D) {
        y.push(D);
      },
      unmount() {
        _ && ($n(
          y,
          j._instance,
          16
        ), n(null, j._container), delete j._container.__vue_app__);
      },
      provide(D, R) {
        return f.provides[D] = R, j;
      },
      runWithContext(D) {
        const R = yo;
        yo = j;
        try {
          return D();
        } finally {
          yo = R;
        }
      }
    };
    return j;
  };
}
let yo = null;
function cf(n, r) {
  if (Ut) {
    let a = Ut.provides;
    const u = Ut.parent && Ut.parent.provides;
    u === a && (a = Ut.provides = Object.create(u)), a[n] = r;
  }
}
function vi(n, r, a = !1) {
  const u = Ut || jt;
  if (u || yo) {
    let c = yo ? yo._context.provides : u ? u.parent == null || u.ce ? u.vnode.appContext && u.vnode.appContext.provides : u.parent.provides : void 0;
    if (c && n in c)
      return c[n];
    if (arguments.length > 1)
      return a && qe(r) ? r.call(u && u.proxy) : r;
  }
}
function ff() {
  return !!(Ut || jt || yo);
}
const bl = {}, _l = () => Object.create(bl), wl = (n) => Object.getPrototypeOf(n) === bl;
function df(n, r, a, u = !1) {
  const c = {}, f = _l();
  n.propsDefaults = /* @__PURE__ */ Object.create(null), xl(n, r, c, f);
  for (const h in n.propsOptions[0])
    h in c || (c[h] = void 0);
  a ? n.props = u ? c : Sc(c) : n.type.props ? n.props = c : n.props = f, n.attrs = f;
}
function pf(n, r, a, u) {
  const {
    props: c,
    attrs: f,
    vnode: { patchFlag: h }
  } = n, y = Ze(c), [_] = n.propsOptions;
  let j = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (u || h > 0) && !(h & 16)
  ) {
    if (h & 8) {
      const D = n.vnode.dynamicProps;
      for (let R = 0; R < D.length; R++) {
        let $ = D[R];
        if (rs(n.emitsOptions, $))
          continue;
        const W = r[$];
        if (_)
          if (it(f, $))
            W !== f[$] && (f[$] = W, j = !0);
          else {
            const J = Cr($);
            c[J] = na(
              _,
              y,
              J,
              W,
              n,
              !1
            );
          }
        else
          W !== f[$] && (f[$] = W, j = !0);
      }
    }
  } else {
    xl(n, r, c, f) && (j = !0);
    let D;
    for (const R in y)
      (!r || // for camelCase
      !it(r, R) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((D = bo(R)) === R || !it(r, D))) && (_ ? a && // for camelCase
      (a[R] !== void 0 || // for kebab-case
      a[D] !== void 0) && (c[R] = na(
        _,
        y,
        R,
        void 0,
        n,
        !0
      )) : delete c[R]);
    if (f !== y)
      for (const R in f)
        (!r || !it(r, R)) && (delete f[R], j = !0);
  }
  j && mr(n.attrs, "set", "");
}
function xl(n, r, a, u) {
  const [c, f] = n.propsOptions;
  let h = !1, y;
  if (r)
    for (let _ in r) {
      if (fi(_))
        continue;
      const j = r[_];
      let D;
      c && it(c, D = Cr(_)) ? !f || !f.includes(D) ? a[D] = j : (y || (y = {}))[D] = j : rs(n.emitsOptions, _) || (!(_ in u) || j !== u[_]) && (u[_] = j, h = !0);
    }
  if (f) {
    const _ = Ze(a), j = y || ut;
    for (let D = 0; D < f.length; D++) {
      const R = f[D];
      a[R] = na(
        c,
        _,
        R,
        j[R],
        n,
        !it(j, R)
      );
    }
  }
  return h;
}
function na(n, r, a, u, c, f) {
  const h = n[a];
  if (h != null) {
    const y = it(h, "default");
    if (y && u === void 0) {
      const _ = h.default;
      if (h.type !== Function && !h.skipFactory && qe(_)) {
        const { propsDefaults: j } = c;
        if (a in j)
          u = j[a];
        else {
          const D = Si(c);
          u = j[a] = _.call(
            null,
            r
          ), D();
        }
      } else
        u = _;
      c.ce && c.ce._setProp(a, u);
    }
    h[
      0
      /* shouldCast */
    ] && (f && !y ? u = !1 : h[
      1
      /* shouldCastTrue */
    ] && (u === "" || u === bo(a)) && (u = !0));
  }
  return u;
}
const hf = /* @__PURE__ */ new WeakMap();
function El(n, r, a = !1) {
  const u = a ? hf : r.propsCache, c = u.get(n);
  if (c)
    return c;
  const f = n.props, h = {}, y = [];
  let _ = !1;
  if (!qe(n)) {
    const D = (R) => {
      _ = !0;
      const [$, W] = El(R, r, !0);
      Gt(h, $), W && y.push(...W);
    };
    !a && r.mixins.length && r.mixins.forEach(D), n.extends && D(n.extends), n.mixins && n.mixins.forEach(D);
  }
  if (!f && !_)
    return mt(n) && u.set(n, Eo), Eo;
  if (Ie(f))
    for (let D = 0; D < f.length; D++) {
      const R = Cr(f[D]);
      Ya(R) && (h[R] = ut);
    }
  else if (f)
    for (const D in f) {
      const R = Cr(D);
      if (Ya(R)) {
        const $ = f[D], W = h[R] = Ie($) || qe($) ? { type: $ } : Gt({}, $), J = W.type;
        let re = !1, te = !0;
        if (Ie(J))
          for (let M = 0; M < J.length; ++M) {
            const G = J[M], fe = qe(G) && G.name;
            if (fe === "Boolean") {
              re = !0;
              break;
            } else fe === "String" && (te = !1);
          }
        else
          re = qe(J) && J.name === "Boolean";
        W[
          0
          /* shouldCast */
        ] = re, W[
          1
          /* shouldCastTrue */
        ] = te, (re || it(W, "default")) && y.push(R);
      }
    }
  const j = [h, y];
  return mt(n) && u.set(n, j), j;
}
function Ya(n) {
  return n[0] !== "$" && !fi(n);
}
const Aa = (n) => n[0] === "_" || n === "$stable", Pa = (n) => Ie(n) ? n.map(Mn) : [Mn(n)], mf = (n, r, a) => {
  if (r._n)
    return r;
  const u = zs((...c) => Pa(r(...c)), a);
  return u._c = !1, u;
}, Tl = (n, r, a) => {
  const u = n._ctx;
  for (const c in n) {
    if (Aa(c)) continue;
    const f = n[c];
    if (qe(f))
      r[c] = mf(c, f, u);
    else if (f != null) {
      const h = Pa(f);
      r[c] = () => h;
    }
  }
}, Ol = (n, r) => {
  const a = Pa(r);
  n.slots.default = () => a;
}, Nl = (n, r, a) => {
  for (const u in r)
    (a || !Aa(u)) && (n[u] = r[u]);
}, yf = (n, r, a) => {
  const u = n.slots = _l();
  if (n.vnode.shapeFlag & 32) {
    const c = r.__;
    c && Gs(u, "__", c, !0);
    const f = r._;
    f ? (Nl(u, r, a), a && Gs(u, "_", f, !0)) : Tl(r, u);
  } else r && Ol(n, r);
}, vf = (n, r, a) => {
  const { vnode: u, slots: c } = n;
  let f = !0, h = ut;
  if (u.shapeFlag & 32) {
    const y = r._;
    y ? a && y === 1 ? f = !1 : Nl(c, r, a) : (f = !r.$stable, Tl(r, c)), h = r;
  } else r && (Ol(n, r), h = { default: 1 });
  if (f)
    for (const y in c)
      !Aa(y) && h[y] == null && delete c[y];
}, on = kf;
function gf(n) {
  return bf(n);
}
function bf(n, r) {
  const a = Ji();
  a.__VUE__ = !0;
  const {
    insert: u,
    remove: c,
    patchProp: f,
    createElement: h,
    createText: y,
    createComment: _,
    setText: j,
    setElementText: D,
    parentNode: R,
    nextSibling: $,
    setScopeId: W = qn,
    insertStaticContent: J
  } = n, re = (C, F, ee, oe = null, ue = null, ie = null, pe = void 0, me = null, le = !!F.dynamicChildren) => {
    if (C === F)
      return;
    C && !li(C, F) && (oe = A(C), Dt(C, ue, ie, !0), C = null), F.patchFlag === -2 && (le = !1, F.dynamicChildren = null);
    const { type: se, ref: Oe, shapeFlag: ye } = F;
    switch (se) {
      case os:
        te(C, F, ee, oe);
        break;
      case xr:
        M(C, F, ee, oe);
        break;
      case qs:
        C == null && G(F, ee, oe, pe);
        break;
      case Ye:
        Ke(
          C,
          F,
          ee,
          oe,
          ue,
          ie,
          pe,
          me,
          le
        );
        break;
      default:
        ye & 1 ? ge(
          C,
          F,
          ee,
          oe,
          ue,
          ie,
          pe,
          me,
          le
        ) : ye & 6 ? ot(
          C,
          F,
          ee,
          oe,
          ue,
          ie,
          pe,
          me,
          le
        ) : (ye & 64 || ye & 128) && se.process(
          C,
          F,
          ee,
          oe,
          ue,
          ie,
          pe,
          me,
          le,
          V
        );
    }
    Oe != null && ue ? mi(Oe, C && C.ref, ie, F || C, !F) : Oe == null && C && C.ref != null && mi(C.ref, null, ie, C, !0);
  }, te = (C, F, ee, oe) => {
    if (C == null)
      u(
        F.el = y(F.children),
        ee,
        oe
      );
    else {
      const ue = F.el = C.el;
      F.children !== C.children && j(ue, F.children);
    }
  }, M = (C, F, ee, oe) => {
    C == null ? u(
      F.el = _(F.children || ""),
      ee,
      oe
    ) : F.el = C.el;
  }, G = (C, F, ee, oe) => {
    [C.el, C.anchor] = J(
      C.children,
      F,
      ee,
      oe,
      C.el,
      C.anchor
    );
  }, fe = ({ el: C, anchor: F }, ee, oe) => {
    let ue;
    for (; C && C !== F; )
      ue = $(C), u(C, ee, oe), C = ue;
    u(F, ee, oe);
  }, ae = ({ el: C, anchor: F }) => {
    let ee;
    for (; C && C !== F; )
      ee = $(C), c(C), C = ee;
    c(F);
  }, ge = (C, F, ee, oe, ue, ie, pe, me, le) => {
    F.type === "svg" ? pe = "svg" : F.type === "math" && (pe = "mathml"), C == null ? Ce(
      F,
      ee,
      oe,
      ue,
      ie,
      pe,
      me,
      le
    ) : B(
      C,
      F,
      ue,
      ie,
      pe,
      me,
      le
    );
  }, Ce = (C, F, ee, oe, ue, ie, pe, me) => {
    let le, se;
    const { props: Oe, shapeFlag: ye, transition: Ne, dirs: Se } = C;
    if (le = C.el = h(
      C.type,
      ie,
      Oe && Oe.is,
      Oe
    ), ye & 8 ? D(le, C.children) : ye & 16 && Ae(
      C.children,
      le,
      null,
      oe,
      ue,
      Bs(C, ie),
      pe,
      me
    ), Se && fo(C, null, oe, "created"), _e(le, C, C.scopeId, pe, oe), Oe) {
      for (const $e in Oe)
        $e !== "value" && !fi($e) && f(le, $e, null, Oe[$e], ie, oe);
      "value" in Oe && f(le, "value", null, Oe.value, ie), (se = Oe.onVnodeBeforeMount) && Kn(se, oe, C);
    }
    Se && fo(C, null, oe, "beforeMount");
    const ke = _f(ue, Ne);
    ke && Ne.beforeEnter(le), u(le, F, ee), ((se = Oe && Oe.onVnodeMounted) || ke || Se) && on(() => {
      se && Kn(se, oe, C), ke && Ne.enter(le), Se && fo(C, null, oe, "mounted");
    }, ue);
  }, _e = (C, F, ee, oe, ue) => {
    if (ee && W(C, ee), oe)
      for (let ie = 0; ie < oe.length; ie++)
        W(C, oe[ie]);
    if (ue) {
      let ie = ue.subTree;
      if (F === ie || Pl(ie.type) && (ie.ssContent === F || ie.ssFallback === F)) {
        const pe = ue.vnode;
        _e(
          C,
          pe,
          pe.scopeId,
          pe.slotScopeIds,
          ue.parent
        );
      }
    }
  }, Ae = (C, F, ee, oe, ue, ie, pe, me, le = 0) => {
    for (let se = le; se < C.length; se++) {
      const Oe = C[se] = me ? Nr(C[se]) : Mn(C[se]);
      re(
        null,
        Oe,
        F,
        ee,
        oe,
        ue,
        ie,
        pe,
        me
      );
    }
  }, B = (C, F, ee, oe, ue, ie, pe) => {
    const me = F.el = C.el;
    let { patchFlag: le, dynamicChildren: se, dirs: Oe } = F;
    le |= C.patchFlag & 16;
    const ye = C.props || ut, Ne = F.props || ut;
    let Se;
    if (ee && po(ee, !1), (Se = Ne.onVnodeBeforeUpdate) && Kn(Se, ee, F, C), Oe && fo(F, C, ee, "beforeUpdate"), ee && po(ee, !0), (ye.innerHTML && Ne.innerHTML == null || ye.textContent && Ne.textContent == null) && D(me, ""), se ? Xe(
      C.dynamicChildren,
      se,
      me,
      ee,
      oe,
      Bs(F, ue),
      ie
    ) : pe || Le(
      C,
      F,
      me,
      null,
      ee,
      oe,
      Bs(F, ue),
      ie,
      !1
    ), le > 0) {
      if (le & 16)
        ct(me, ye, Ne, ee, ue);
      else if (le & 2 && ye.class !== Ne.class && f(me, "class", null, Ne.class, ue), le & 4 && f(me, "style", ye.style, Ne.style, ue), le & 8) {
        const ke = F.dynamicProps;
        for (let $e = 0; $e < ke.length; $e++) {
          const He = ke[$e], dt = ye[He], _t = Ne[He];
          (_t !== dt || He === "value") && f(me, He, dt, _t, ue, ee);
        }
      }
      le & 1 && C.children !== F.children && D(me, F.children);
    } else !pe && se == null && ct(me, ye, Ne, ee, ue);
    ((Se = Ne.onVnodeUpdated) || Oe) && on(() => {
      Se && Kn(Se, ee, F, C), Oe && fo(F, C, ee, "updated");
    }, oe);
  }, Xe = (C, F, ee, oe, ue, ie, pe) => {
    for (let me = 0; me < F.length; me++) {
      const le = C[me], se = F[me], Oe = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        le.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (le.type === Ye || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !li(le, se) || // - In the case of a component, it could contain anything.
        le.shapeFlag & 198) ? R(le.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          ee
        )
      );
      re(
        le,
        se,
        Oe,
        null,
        oe,
        ue,
        ie,
        pe,
        !0
      );
    }
  }, ct = (C, F, ee, oe, ue) => {
    if (F !== ee) {
      if (F !== ut)
        for (const ie in F)
          !fi(ie) && !(ie in ee) && f(
            C,
            ie,
            F[ie],
            null,
            ue,
            oe
          );
      for (const ie in ee) {
        if (fi(ie)) continue;
        const pe = ee[ie], me = F[ie];
        pe !== me && ie !== "value" && f(C, ie, me, pe, ue, oe);
      }
      "value" in ee && f(C, "value", F.value, ee.value, ue);
    }
  }, Ke = (C, F, ee, oe, ue, ie, pe, me, le) => {
    const se = F.el = C ? C.el : y(""), Oe = F.anchor = C ? C.anchor : y("");
    let { patchFlag: ye, dynamicChildren: Ne, slotScopeIds: Se } = F;
    Se && (me = me ? me.concat(Se) : Se), C == null ? (u(se, ee, oe), u(Oe, ee, oe), Ae(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      F.children || [],
      ee,
      Oe,
      ue,
      ie,
      pe,
      me,
      le
    )) : ye > 0 && ye & 64 && Ne && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    C.dynamicChildren ? (Xe(
      C.dynamicChildren,
      Ne,
      ee,
      ue,
      ie,
      pe,
      me
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (F.key != null || ue && F === ue.subTree) && Ia(
      C,
      F,
      !0
      /* shallow */
    )) : Le(
      C,
      F,
      ee,
      Oe,
      ue,
      ie,
      pe,
      me,
      le
    );
  }, ot = (C, F, ee, oe, ue, ie, pe, me, le) => {
    F.slotScopeIds = me, C == null ? F.shapeFlag & 512 ? ue.ctx.activate(
      F,
      ee,
      oe,
      pe,
      le
    ) : bn(
      F,
      ee,
      oe,
      ue,
      ie,
      pe,
      le
    ) : kt(C, F, le);
  }, bn = (C, F, ee, oe, ue, ie, pe) => {
    const me = C.component = Mf(
      C,
      oe,
      ue
    );
    if (dl(C) && (me.ctx.renderer = V), qf(me, !1, pe), me.asyncDep) {
      if (ue && ue.registerDep(me, tt, pe), !C.el) {
        const le = me.subTree = Ct(xr);
        M(null, le, F, ee);
      }
    } else
      tt(
        me,
        C,
        F,
        ee,
        ue,
        ie,
        pe
      );
  }, kt = (C, F, ee) => {
    const oe = F.component = C.component;
    if (Pf(C, F, ee))
      if (oe.asyncDep && !oe.asyncResolved) {
        xe(oe, F, ee);
        return;
      } else
        oe.next = F, oe.update();
    else
      F.el = C.el, oe.vnode = F;
  }, tt = (C, F, ee, oe, ue, ie, pe) => {
    const me = () => {
      if (C.isMounted) {
        let { next: ye, bu: Ne, u: Se, parent: ke, vnode: $e } = C;
        {
          const pt = Sl(C);
          if (pt) {
            ye && (ye.el = $e.el, xe(C, ye, pe)), pt.asyncDep.then(() => {
              C.isUnmounted || me();
            });
            return;
          }
        }
        let He = ye, dt;
        po(C, !1), ye ? (ye.el = $e.el, xe(C, ye, pe)) : ye = $e, Ne && Di(Ne), (dt = ye.props && ye.props.onVnodeBeforeUpdate) && Kn(dt, ke, ye, $e), po(C, !0);
        const _t = Qa(C), Ot = C.subTree;
        C.subTree = _t, re(
          Ot,
          _t,
          // parent may have changed if it's in a teleport
          R(Ot.el),
          // anchor may have changed if it's in a fragment
          A(Ot),
          C,
          ue,
          ie
        ), ye.el = _t.el, He === null && If(C, _t.el), Se && on(Se, ue), (dt = ye.props && ye.props.onVnodeUpdated) && on(
          () => Kn(dt, ke, ye, $e),
          ue
        );
      } else {
        let ye;
        const { el: Ne, props: Se } = F, { bm: ke, m: $e, parent: He, root: dt, type: _t } = C, Ot = No(F);
        po(C, !1), ke && Di(ke), !Ot && (ye = Se && Se.onVnodeBeforeMount) && Kn(ye, He, F), po(C, !0);
        {
          dt.ce && // @ts-expect-error _def is private
          dt.ce._def.shadowRoot !== !1 && dt.ce._injectChildStyle(_t);
          const pt = C.subTree = Qa(C);
          re(
            null,
            pt,
            ee,
            oe,
            C,
            ue,
            ie
          ), F.el = pt.el;
        }
        if ($e && on($e, ue), !Ot && (ye = Se && Se.onVnodeMounted)) {
          const pt = F;
          on(
            () => Kn(ye, He, pt),
            ue
          );
        }
        (F.shapeFlag & 256 || He && No(He.vnode) && He.vnode.shapeFlag & 256) && C.a && on(C.a, ue), C.isMounted = !0, F = ee = oe = null;
      }
    };
    C.scope.on();
    const le = C.effect = new Ku(me);
    C.scope.off();
    const se = C.update = le.run.bind(le), Oe = C.job = le.runIfDirty.bind(le);
    Oe.i = C, Oe.id = C.uid, le.scheduler = () => Na(Oe), po(C, !0), se();
  }, xe = (C, F, ee) => {
    F.component = C;
    const oe = C.vnode.props;
    C.vnode = F, C.next = null, pf(C, F.props, oe, ee), vf(C, F.children, ee), _r(), Ma(C), wr();
  }, Le = (C, F, ee, oe, ue, ie, pe, me, le = !1) => {
    const se = C && C.children, Oe = C ? C.shapeFlag : 0, ye = F.children, { patchFlag: Ne, shapeFlag: Se } = F;
    if (Ne > 0) {
      if (Ne & 128) {
        at(
          se,
          ye,
          ee,
          oe,
          ue,
          ie,
          pe,
          me,
          le
        );
        return;
      } else if (Ne & 256) {
        yt(
          se,
          ye,
          ee,
          oe,
          ue,
          ie,
          pe,
          me,
          le
        );
        return;
      }
    }
    Se & 8 ? (Oe & 16 && wt(se, ue, ie), ye !== se && D(ee, ye)) : Oe & 16 ? Se & 16 ? at(
      se,
      ye,
      ee,
      oe,
      ue,
      ie,
      pe,
      me,
      le
    ) : wt(se, ue, ie, !0) : (Oe & 8 && D(ee, ""), Se & 16 && Ae(
      ye,
      ee,
      oe,
      ue,
      ie,
      pe,
      me,
      le
    ));
  }, yt = (C, F, ee, oe, ue, ie, pe, me, le) => {
    C = C || Eo, F = F || Eo;
    const se = C.length, Oe = F.length, ye = Math.min(se, Oe);
    let Ne;
    for (Ne = 0; Ne < ye; Ne++) {
      const Se = F[Ne] = le ? Nr(F[Ne]) : Mn(F[Ne]);
      re(
        C[Ne],
        Se,
        ee,
        null,
        ue,
        ie,
        pe,
        me,
        le
      );
    }
    se > Oe ? wt(
      C,
      ue,
      ie,
      !0,
      !1,
      ye
    ) : Ae(
      F,
      ee,
      oe,
      ue,
      ie,
      pe,
      me,
      le,
      ye
    );
  }, at = (C, F, ee, oe, ue, ie, pe, me, le) => {
    let se = 0;
    const Oe = F.length;
    let ye = C.length - 1, Ne = Oe - 1;
    for (; se <= ye && se <= Ne; ) {
      const Se = C[se], ke = F[se] = le ? Nr(F[se]) : Mn(F[se]);
      if (li(Se, ke))
        re(
          Se,
          ke,
          ee,
          null,
          ue,
          ie,
          pe,
          me,
          le
        );
      else
        break;
      se++;
    }
    for (; se <= ye && se <= Ne; ) {
      const Se = C[ye], ke = F[Ne] = le ? Nr(F[Ne]) : Mn(F[Ne]);
      if (li(Se, ke))
        re(
          Se,
          ke,
          ee,
          null,
          ue,
          ie,
          pe,
          me,
          le
        );
      else
        break;
      ye--, Ne--;
    }
    if (se > ye) {
      if (se <= Ne) {
        const Se = Ne + 1, ke = Se < Oe ? F[Se].el : oe;
        for (; se <= Ne; )
          re(
            null,
            F[se] = le ? Nr(F[se]) : Mn(F[se]),
            ee,
            ke,
            ue,
            ie,
            pe,
            me,
            le
          ), se++;
      }
    } else if (se > Ne)
      for (; se <= ye; )
        Dt(C[se], ue, ie, !0), se++;
    else {
      const Se = se, ke = se, $e = /* @__PURE__ */ new Map();
      for (se = ke; se <= Ne; se++) {
        const nt = F[se] = le ? Nr(F[se]) : Mn(F[se]);
        nt.key != null && $e.set(nt.key, se);
      }
      let He, dt = 0;
      const _t = Ne - ke + 1;
      let Ot = !1, pt = 0;
      const Xt = new Array(_t);
      for (se = 0; se < _t; se++) Xt[se] = 0;
      for (se = Se; se <= ye; se++) {
        const nt = C[se];
        if (dt >= _t) {
          Dt(nt, ue, ie, !0);
          continue;
        }
        let ne;
        if (nt.key != null)
          ne = $e.get(nt.key);
        else
          for (He = ke; He <= Ne; He++)
            if (Xt[He - ke] === 0 && li(nt, F[He])) {
              ne = He;
              break;
            }
        ne === void 0 ? Dt(nt, ue, ie, !0) : (Xt[ne - ke] = se + 1, ne >= pt ? pt = ne : Ot = !0, re(
          nt,
          F[ne],
          ee,
          null,
          ue,
          ie,
          pe,
          me,
          le
        ), dt++);
      }
      const Ln = Ot ? wf(Xt) : Eo;
      for (He = Ln.length - 1, se = _t - 1; se >= 0; se--) {
        const nt = ke + se, ne = F[nt], un = nt + 1 < Oe ? F[nt + 1].el : oe;
        Xt[se] === 0 ? re(
          null,
          ne,
          ee,
          un,
          ue,
          ie,
          pe,
          me,
          le
        ) : Ot && (He < 0 || se !== Ln[He] ? bt(ne, ee, un, 2) : He--);
      }
    }
  }, bt = (C, F, ee, oe, ue = null) => {
    const { el: ie, type: pe, transition: me, children: le, shapeFlag: se } = C;
    if (se & 6) {
      bt(C.component.subTree, F, ee, oe);
      return;
    }
    if (se & 128) {
      C.suspense.move(F, ee, oe);
      return;
    }
    if (se & 64) {
      pe.move(C, F, ee, V);
      return;
    }
    if (pe === Ye) {
      u(ie, F, ee);
      for (let ye = 0; ye < le.length; ye++)
        bt(le[ye], F, ee, oe);
      u(C.anchor, F, ee);
      return;
    }
    if (pe === qs) {
      fe(C, F, ee);
      return;
    }
    if (oe !== 2 && se & 1 && me)
      if (oe === 0)
        me.beforeEnter(ie), u(ie, F, ee), on(() => me.enter(ie), ue);
      else {
        const { leave: ye, delayLeave: Ne, afterLeave: Se } = me, ke = () => {
          C.ctx.isUnmounted ? c(ie) : u(ie, F, ee);
        }, $e = () => {
          ye(ie, () => {
            ke(), Se && Se();
          });
        };
        Ne ? Ne(ie, ke, $e) : $e();
      }
    else
      u(ie, F, ee);
  }, Dt = (C, F, ee, oe = !1, ue = !1) => {
    const {
      type: ie,
      props: pe,
      ref: me,
      children: le,
      dynamicChildren: se,
      shapeFlag: Oe,
      patchFlag: ye,
      dirs: Ne,
      cacheIndex: Se
    } = C;
    if (ye === -2 && (ue = !1), me != null && (_r(), mi(me, null, ee, C, !0), wr()), Se != null && (F.renderCache[Se] = void 0), Oe & 256) {
      F.ctx.deactivate(C);
      return;
    }
    const ke = Oe & 1 && Ne, $e = !No(C);
    let He;
    if ($e && (He = pe && pe.onVnodeBeforeUnmount) && Kn(He, F, C), Oe & 6)
      an(C.component, ee, oe);
    else {
      if (Oe & 128) {
        C.suspense.unmount(ee, oe);
        return;
      }
      ke && fo(C, null, F, "beforeUnmount"), Oe & 64 ? C.type.remove(
        C,
        F,
        ee,
        V,
        oe
      ) : se && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !se.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (ie !== Ye || ye > 0 && ye & 64) ? wt(
        se,
        F,
        ee,
        !1,
        !0
      ) : (ie === Ye && ye & 384 || !ue && Oe & 16) && wt(le, F, ee), oe && Rt(C);
    }
    ($e && (He = pe && pe.onVnodeUnmounted) || ke) && on(() => {
      He && Kn(He, F, C), ke && fo(C, null, F, "unmounted");
    }, ee);
  }, Rt = (C) => {
    const { type: F, el: ee, anchor: oe, transition: ue } = C;
    if (F === Ye) {
      jn(ee, oe);
      return;
    }
    if (F === qs) {
      ae(C);
      return;
    }
    const ie = () => {
      c(ee), ue && !ue.persisted && ue.afterLeave && ue.afterLeave();
    };
    if (C.shapeFlag & 1 && ue && !ue.persisted) {
      const { leave: pe, delayLeave: me } = ue, le = () => pe(ee, ie);
      me ? me(C.el, ie, le) : le();
    } else
      ie();
  }, jn = (C, F) => {
    let ee;
    for (; C !== F; )
      ee = $(C), c(C), C = ee;
    c(F);
  }, an = (C, F, ee) => {
    const {
      bum: oe,
      scope: ue,
      job: ie,
      subTree: pe,
      um: me,
      m: le,
      a: se,
      parent: Oe,
      slots: { __: ye }
    } = C;
    Xa(le), Xa(se), oe && Di(oe), Oe && Ie(ye) && ye.forEach((Ne) => {
      Oe.renderCache[Ne] = void 0;
    }), ue.stop(), ie && (ie.flags |= 8, Dt(pe, C, F, ee)), me && on(me, F), on(() => {
      C.isUnmounted = !0;
    }, F), F && F.pendingBranch && !F.isUnmounted && C.asyncDep && !C.asyncResolved && C.suspenseId === F.pendingId && (F.deps--, F.deps === 0 && F.resolve());
  }, wt = (C, F, ee, oe = !1, ue = !1, ie = 0) => {
    for (let pe = ie; pe < C.length; pe++)
      Dt(C[pe], F, ee, oe, ue);
  }, A = (C) => {
    if (C.shapeFlag & 6)
      return A(C.component.subTree);
    if (C.shapeFlag & 128)
      return C.suspense.next();
    const F = $(C.anchor || C.el), ee = F && F[sl];
    return ee ? $(ee) : F;
  };
  let x = !1;
  const K = (C, F, ee) => {
    C == null ? F._vnode && Dt(F._vnode, null, null, !0) : re(
      F._vnode || null,
      C,
      F,
      null,
      null,
      null,
      ee
    ), F._vnode = C, x || (x = !0, Ma(), rl(), x = !1);
  }, V = {
    p: re,
    um: Dt,
    m: bt,
    r: Rt,
    mt: bn,
    mc: Ae,
    pc: Le,
    pbc: Xe,
    n: A,
    o: n
  };
  return {
    render: K,
    hydrate: void 0,
    createApp: lf(K)
  };
}
function Bs({ type: n, props: r }, a) {
  return a === "svg" && n === "foreignObject" || a === "mathml" && n === "annotation-xml" && r && r.encoding && r.encoding.includes("html") ? void 0 : a;
}
function po({ effect: n, job: r }, a) {
  a ? (n.flags |= 32, r.flags |= 4) : (n.flags &= -33, r.flags &= -5);
}
function _f(n, r) {
  return (!n || n && !n.pendingBranch) && r && !r.persisted;
}
function Ia(n, r, a = !1) {
  const u = n.children, c = r.children;
  if (Ie(u) && Ie(c))
    for (let f = 0; f < u.length; f++) {
      const h = u[f];
      let y = c[f];
      y.shapeFlag & 1 && !y.dynamicChildren && ((y.patchFlag <= 0 || y.patchFlag === 32) && (y = c[f] = Nr(c[f]), y.el = h.el), !a && y.patchFlag !== -2 && Ia(h, y)), y.type === os && (y.el = h.el), y.type === xr && !y.el && (y.el = h.el);
    }
}
function wf(n) {
  const r = n.slice(), a = [0];
  let u, c, f, h, y;
  const _ = n.length;
  for (u = 0; u < _; u++) {
    const j = n[u];
    if (j !== 0) {
      if (c = a[a.length - 1], n[c] < j) {
        r[u] = c, a.push(u);
        continue;
      }
      for (f = 0, h = a.length - 1; f < h; )
        y = f + h >> 1, n[a[y]] < j ? f = y + 1 : h = y;
      j < n[a[f]] && (f > 0 && (r[u] = a[f - 1]), a[f] = u);
    }
  }
  for (f = a.length, h = a[f - 1]; f-- > 0; )
    a[f] = h, h = r[h];
  return a;
}
function Sl(n) {
  const r = n.subTree.component;
  if (r)
    return r.asyncDep && !r.asyncResolved ? r : Sl(r);
}
function Xa(n) {
  if (n)
    for (let r = 0; r < n.length; r++)
      n[r].flags |= 8;
}
const xf = Symbol.for("v-scx"), Ef = () => vi(xf);
function Tf(n, r) {
  return ka(n, null, r);
}
function cn(n, r, a) {
  return ka(n, r, a);
}
function ka(n, r, a = ut) {
  const { immediate: u, deep: c, flush: f, once: h } = a, y = Gt({}, a), _ = r && u || !r && f !== "post";
  let j;
  if (Ti) {
    if (f === "sync") {
      const W = Ef();
      j = W.__watcherHandles || (W.__watcherHandles = []);
    } else if (!_) {
      const W = () => {
      };
      return W.stop = qn, W.resume = qn, W.pause = qn, W;
    }
  }
  const D = Ut;
  y.call = (W, J, re) => $n(W, D, J, re);
  let R = !1;
  f === "post" ? y.scheduler = (W) => {
    on(W, D && D.suspense);
  } : f !== "sync" && (R = !0, y.scheduler = (W, J) => {
    J ? W() : Na(W);
  }), y.augmentJob = (W) => {
    r && (W.flags |= 4), R && (W.flags |= 2, D && (W.id = D.uid, W.i = D));
  };
  const $ = Kc(n, r, y);
  return Ti && (j ? j.push($) : _ && $()), $;
}
function Of(n, r, a) {
  const u = this.proxy, c = Tt(n) ? n.includes(".") ? Cl(u, n) : () => u[n] : n.bind(u, u);
  let f;
  qe(r) ? f = r : (f = r.handler, a = r);
  const h = Si(this), y = ka(c, f.bind(u), a);
  return h(), y;
}
function Cl(n, r) {
  const a = r.split(".");
  return () => {
    let u = n;
    for (let c = 0; c < a.length && u; c++)
      u = u[a[c]];
    return u;
  };
}
const Nf = (n, r) => r === "modelValue" || r === "model-value" ? n.modelModifiers : n[`${r}Modifiers`] || n[`${Cr(r)}Modifiers`] || n[`${bo(r)}Modifiers`];
function Sf(n, r, ...a) {
  if (n.isUnmounted) return;
  const u = n.vnode.props || ut;
  let c = a;
  const f = r.startsWith("update:"), h = f && Nf(u, r.slice(7));
  h && (h.trim && (c = a.map((D) => Tt(D) ? D.trim() : D)), h.number && (c = a.map(Bi)));
  let y, _ = u[y = Rs(r)] || // also try camelCase event handler (#2249)
  u[y = Rs(Cr(r))];
  !_ && f && (_ = u[y = Rs(bo(r))]), _ && $n(
    _,
    n,
    6,
    c
  );
  const j = u[y + "Once"];
  if (j) {
    if (!n.emitted)
      n.emitted = {};
    else if (n.emitted[y])
      return;
    n.emitted[y] = !0, $n(
      j,
      n,
      6,
      c
    );
  }
}
function Al(n, r, a = !1) {
  const u = r.emitsCache, c = u.get(n);
  if (c !== void 0)
    return c;
  const f = n.emits;
  let h = {}, y = !1;
  if (!qe(n)) {
    const _ = (j) => {
      const D = Al(j, r, !0);
      D && (y = !0, Gt(h, D));
    };
    !a && r.mixins.length && r.mixins.forEach(_), n.extends && _(n.extends), n.mixins && n.mixins.forEach(_);
  }
  return !f && !y ? (mt(n) && u.set(n, null), null) : (Ie(f) ? f.forEach((_) => h[_] = null) : Gt(h, f), mt(n) && u.set(n, h), h);
}
function rs(n, r) {
  return !n || !Qi(r) ? !1 : (r = r.slice(2).replace(/Once$/, ""), it(n, r[0].toLowerCase() + r.slice(1)) || it(n, bo(r)) || it(n, r));
}
function Qa(n) {
  const {
    type: r,
    vnode: a,
    proxy: u,
    withProxy: c,
    propsOptions: [f],
    slots: h,
    attrs: y,
    emit: _,
    render: j,
    renderCache: D,
    props: R,
    data: $,
    setupState: W,
    ctx: J,
    inheritAttrs: re
  } = n, te = Hi(n);
  let M, G;
  try {
    if (a.shapeFlag & 4) {
      const ae = c || u, ge = ae;
      M = Mn(
        j.call(
          ge,
          ae,
          D,
          R,
          W,
          $,
          J
        )
      ), G = y;
    } else {
      const ae = r;
      M = Mn(
        ae.length > 1 ? ae(
          R,
          { attrs: y, slots: h, emit: _ }
        ) : ae(
          R,
          null
        )
      ), G = r.props ? y : Cf(y);
    }
  } catch (ae) {
    gi.length = 0, ts(ae, n, 1), M = Ct(xr);
  }
  let fe = M;
  if (G && re !== !1) {
    const ae = Object.keys(G), { shapeFlag: ge } = fe;
    ae.length && ge & 7 && (f && ae.some(da) && (G = Af(
      G,
      f
    )), fe = So(fe, G, !1, !0));
  }
  return a.dirs && (fe = So(fe, null, !1, !0), fe.dirs = fe.dirs ? fe.dirs.concat(a.dirs) : a.dirs), a.transition && Sa(fe, a.transition), M = fe, Hi(te), M;
}
const Cf = (n) => {
  let r;
  for (const a in n)
    (a === "class" || a === "style" || Qi(a)) && ((r || (r = {}))[a] = n[a]);
  return r;
}, Af = (n, r) => {
  const a = {};
  for (const u in n)
    (!da(u) || !(u.slice(9) in r)) && (a[u] = n[u]);
  return a;
};
function Pf(n, r, a) {
  const { props: u, children: c, component: f } = n, { props: h, children: y, patchFlag: _ } = r, j = f.emitsOptions;
  if (r.dirs || r.transition)
    return !0;
  if (a && _ >= 0) {
    if (_ & 1024)
      return !0;
    if (_ & 16)
      return u ? za(u, h, j) : !!h;
    if (_ & 8) {
      const D = r.dynamicProps;
      for (let R = 0; R < D.length; R++) {
        const $ = D[R];
        if (h[$] !== u[$] && !rs(j, $))
          return !0;
      }
    }
  } else
    return (c || y) && (!y || !y.$stable) ? !0 : u === h ? !1 : u ? h ? za(u, h, j) : !0 : !!h;
  return !1;
}
function za(n, r, a) {
  const u = Object.keys(r);
  if (u.length !== Object.keys(n).length)
    return !0;
  for (let c = 0; c < u.length; c++) {
    const f = u[c];
    if (r[f] !== n[f] && !rs(a, f))
      return !0;
  }
  return !1;
}
function If({ vnode: n, parent: r }, a) {
  for (; r; ) {
    const u = r.subTree;
    if (u.suspense && u.suspense.activeBranch === n && (u.el = n.el), u === n)
      (n = r.vnode).el = a, r = r.parent;
    else
      break;
  }
}
const Pl = (n) => n.__isSuspense;
function kf(n, r) {
  r && r.pendingBranch ? Ie(n) ? r.effects.push(...n) : r.effects.push(n) : Bc(n);
}
const Ye = Symbol.for("v-fgt"), os = Symbol.for("v-txt"), xr = Symbol.for("v-cmt"), qs = Symbol.for("v-stc"), gi = [];
let gn = null;
function ve(n = !1) {
  gi.push(gn = n ? null : []);
}
function Df() {
  gi.pop(), gn = gi[gi.length - 1] || null;
}
let Ei = 1;
function Ja(n, r = !1) {
  Ei += n, n < 0 && gn && r && (gn.hasOnce = !0);
}
function Il(n) {
  return n.dynamicChildren = Ei > 0 ? gn || Eo : null, Df(), Ei > 0 && gn && gn.push(n), n;
}
function Ee(n, r, a, u, c, f) {
  return Il(
    L(
      n,
      r,
      a,
      u,
      c,
      f,
      !0
    )
  );
}
function kn(n, r, a, u, c) {
  return Il(
    Ct(
      n,
      r,
      a,
      u,
      c,
      !0
    )
  );
}
function Da(n) {
  return n ? n.__v_isVNode === !0 : !1;
}
function li(n, r) {
  return n.type === r.type && n.key === r.key;
}
const kl = ({ key: n }) => n ?? null, Li = ({
  ref: n,
  ref_key: r,
  ref_for: a
}) => (typeof n == "number" && (n = "" + n), n != null ? Tt(n) || st(n) || qe(n) ? { i: jt, r: n, k: r, f: !!a } : n : null);
function L(n, r = null, a = null, u = 0, c = null, f = n === Ye ? 0 : 1, h = !1, y = !1) {
  const _ = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n,
    props: r,
    key: r && kl(r),
    ref: r && Li(r),
    scopeId: il,
    slotScopeIds: null,
    children: a,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: f,
    patchFlag: u,
    dynamicProps: c,
    dynamicChildren: null,
    appContext: null,
    ctx: jt
  };
  return y ? (Ra(_, a), f & 128 && n.normalize(_)) : a && (_.shapeFlag |= Tt(a) ? 8 : 16), Ei > 0 && // avoid a block node from tracking itself
  !h && // has current parent block
  gn && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (_.patchFlag > 0 || f & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  _.patchFlag !== 32 && gn.push(_), _;
}
const Ct = Rf;
function Rf(n, r = null, a = null, u = 0, c = null, f = !1) {
  if ((!n || n === ef) && (n = xr), Da(n)) {
    const y = So(
      n,
      r,
      !0
      /* mergeRef: true */
    );
    return a && Ra(y, a), Ei > 0 && !f && gn && (y.shapeFlag & 6 ? gn[gn.indexOf(n)] = y : gn.push(y)), y.patchFlag = -2, y;
  }
  if (Hf(n) && (n = n.__vccOpts), r) {
    r = jf(r);
    let { class: y, style: _ } = r;
    y && !Tt(y) && (r.class = vo(y)), mt(_) && (Ea(_) && !Ie(_) && (_ = Gt({}, _)), r.style = ma(_));
  }
  const h = Tt(n) ? 1 : Pl(n) ? 128 : qc(n) ? 64 : mt(n) ? 4 : qe(n) ? 2 : 0;
  return L(
    n,
    r,
    a,
    u,
    c,
    h,
    f,
    !0
  );
}
function jf(n) {
  return n ? Ea(n) || wl(n) ? Gt({}, n) : n : null;
}
function So(n, r, a = !1, u = !1) {
  const { props: c, ref: f, patchFlag: h, children: y, transition: _ } = n, j = r ? Lf(c || {}, r) : c, D = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: n.type,
    props: j,
    key: j && kl(j),
    ref: r && r.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      a && f ? Ie(f) ? f.concat(Li(r)) : [f, Li(r)] : Li(r)
    ) : f,
    scopeId: n.scopeId,
    slotScopeIds: n.slotScopeIds,
    children: y,
    target: n.target,
    targetStart: n.targetStart,
    targetAnchor: n.targetAnchor,
    staticCount: n.staticCount,
    shapeFlag: n.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: r && n.type !== Ye ? h === -1 ? 16 : h | 16 : h,
    dynamicProps: n.dynamicProps,
    dynamicChildren: n.dynamicChildren,
    appContext: n.appContext,
    dirs: n.dirs,
    transition: _,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: n.component,
    suspense: n.suspense,
    ssContent: n.ssContent && So(n.ssContent),
    ssFallback: n.ssFallback && So(n.ssFallback),
    el: n.el,
    anchor: n.anchor,
    ctx: n.ctx,
    ce: n.ce
  };
  return _ && u && Sa(
    D,
    _.clone(D)
  ), D;
}
function Dl(n = " ", r = 0) {
  return Ct(os, null, n, r);
}
function Vt(n = "", r = !1) {
  return r ? (ve(), kn(xr, null, n)) : Ct(xr, null, n);
}
function Mn(n) {
  return n == null || typeof n == "boolean" ? Ct(xr) : Ie(n) ? Ct(
    Ye,
    null,
    // #3666, avoid reference pollution when reusing vnode
    n.slice()
  ) : Da(n) ? Nr(n) : Ct(os, null, String(n));
}
function Nr(n) {
  return n.el === null && n.patchFlag !== -1 || n.memo ? n : So(n);
}
function Ra(n, r) {
  let a = 0;
  const { shapeFlag: u } = n;
  if (r == null)
    r = null;
  else if (Ie(r))
    a = 16;
  else if (typeof r == "object")
    if (u & 65) {
      const c = r.default;
      c && (c._c && (c._d = !1), Ra(n, c()), c._c && (c._d = !0));
      return;
    } else {
      a = 32;
      const c = r._;
      !c && !wl(r) ? r._ctx = jt : c === 3 && jt && (jt.slots._ === 1 ? r._ = 1 : (r._ = 2, n.patchFlag |= 1024));
    }
  else qe(r) ? (r = { default: r, _ctx: jt }, a = 32) : (r = String(r), u & 64 ? (a = 16, r = [Dl(r)]) : a = 8);
  n.children = r, n.shapeFlag |= a;
}
function Lf(...n) {
  const r = {};
  for (let a = 0; a < n.length; a++) {
    const u = n[a];
    for (const c in u)
      if (c === "class")
        r.class !== u.class && (r.class = vo([r.class, u.class]));
      else if (c === "style")
        r.style = ma([r.style, u.style]);
      else if (Qi(c)) {
        const f = r[c], h = u[c];
        h && f !== h && !(Ie(f) && f.includes(h)) && (r[c] = f ? [].concat(f, h) : h);
      } else c !== "" && (r[c] = u[c]);
  }
  return r;
}
function Kn(n, r, a, u = null) {
  $n(n, r, 7, [
    a,
    u
  ]);
}
const Kf = gl();
let Ff = 0;
function Mf(n, r, a) {
  const u = n.type, c = (r ? r.appContext : n.appContext) || Kf, f = {
    uid: Ff++,
    vnode: n,
    type: u,
    parent: r,
    appContext: c,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new Ru(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: r ? r.provides : Object.create(c.provides),
    ids: r ? r.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: El(u, c),
    emitsOptions: Al(u, c),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ut,
    // inheritAttrs
    inheritAttrs: u.inheritAttrs,
    // state
    ctx: ut,
    data: ut,
    props: ut,
    attrs: ut,
    slots: ut,
    refs: ut,
    setupState: ut,
    setupContext: null,
    // suspense related
    suspense: a,
    suspenseId: a ? a.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return f.ctx = { _: f }, f.root = r ? r.root : f, f.emit = Sf.bind(null, f), n.ce && n.ce(f), f;
}
let Ut = null;
const Bf = () => Ut || jt;
let Gi, ra;
{
  const n = Ji(), r = (a, u) => {
    let c;
    return (c = n[a]) || (c = n[a] = []), c.push(u), (f) => {
      c.length > 1 ? c.forEach((h) => h(f)) : c[0](f);
    };
  };
  Gi = r(
    "__VUE_INSTANCE_SETTERS__",
    (a) => Ut = a
  ), ra = r(
    "__VUE_SSR_SETTERS__",
    (a) => Ti = a
  );
}
const Si = (n) => {
  const r = Ut;
  return Gi(n), n.scope.on(), () => {
    n.scope.off(), Gi(r);
  };
}, Za = () => {
  Ut && Ut.scope.off(), Gi(null);
};
function Rl(n) {
  return n.vnode.shapeFlag & 4;
}
let Ti = !1;
function qf(n, r = !1, a = !1) {
  r && ra(r);
  const { props: u, children: c } = n.vnode, f = Rl(n);
  df(n, u, f, r), yf(n, c, a || r);
  const h = f ? $f(n, r) : void 0;
  return r && ra(!1), h;
}
function $f(n, r) {
  const a = n.type;
  n.accessCache = /* @__PURE__ */ Object.create(null), n.proxy = new Proxy(n.ctx, tf);
  const { setup: u } = a;
  if (u) {
    _r();
    const c = n.setupContext = u.length > 1 ? Vf(n) : null, f = Si(n), h = Ni(
      u,
      n,
      0,
      [
        n.props,
        c
      ]
    ), y = Su(h);
    if (wr(), f(), (y || n.sp) && !No(n) && cl(n), y) {
      if (h.then(Za, Za), r)
        return h.then((_) => {
          eu(n, _);
        }).catch((_) => {
          ts(_, n, 0);
        });
      n.asyncDep = h;
    } else
      eu(n, h);
  } else
    jl(n);
}
function eu(n, r, a) {
  qe(r) ? n.type.__ssrInlineRender ? n.ssrRender = r : n.render = r : mt(r) && (n.setupState = Zu(r)), jl(n);
}
function jl(n, r, a) {
  const u = n.type;
  n.render || (n.render = u.render || qn);
  {
    const c = Si(n);
    _r();
    try {
      nf(n);
    } finally {
      wr(), c();
    }
  }
}
const Uf = {
  get(n, r) {
    return Wt(n, "get", ""), n[r];
  }
};
function Vf(n) {
  const r = (a) => {
    n.exposed = a || {};
  };
  return {
    attrs: new Proxy(n.attrs, Uf),
    slots: n.slots,
    emit: n.emit,
    expose: r
  };
}
function is(n) {
  return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(Zu(Ta(n.exposed)), {
    get(r, a) {
      if (a in r)
        return r[a];
      if (a in yi)
        return yi[a](n);
    },
    has(r, a) {
      return a in r || a in yi;
    }
  })) : n.proxy;
}
function Hf(n) {
  return qe(n) && "__vccOpts" in n;
}
const It = (n, r) => jc(n, r, Ti), Wf = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let oa;
const tu = typeof window < "u" && window.trustedTypes;
if (tu)
  try {
    oa = /* @__PURE__ */ tu.createPolicy("vue", {
      createHTML: (n) => n
    });
  } catch {
  }
const Ll = oa ? (n) => oa.createHTML(n) : (n) => n, Gf = "http://www.w3.org/2000/svg", Yf = "http://www.w3.org/1998/Math/MathML", hr = typeof document < "u" ? document : null, nu = hr && /* @__PURE__ */ hr.createElement("template"), Xf = {
  insert: (n, r, a) => {
    r.insertBefore(n, a || null);
  },
  remove: (n) => {
    const r = n.parentNode;
    r && r.removeChild(n);
  },
  createElement: (n, r, a, u) => {
    const c = r === "svg" ? hr.createElementNS(Gf, n) : r === "mathml" ? hr.createElementNS(Yf, n) : a ? hr.createElement(n, { is: a }) : hr.createElement(n);
    return n === "select" && u && u.multiple != null && c.setAttribute("multiple", u.multiple), c;
  },
  createText: (n) => hr.createTextNode(n),
  createComment: (n) => hr.createComment(n),
  setText: (n, r) => {
    n.nodeValue = r;
  },
  setElementText: (n, r) => {
    n.textContent = r;
  },
  parentNode: (n) => n.parentNode,
  nextSibling: (n) => n.nextSibling,
  querySelector: (n) => hr.querySelector(n),
  setScopeId(n, r) {
    n.setAttribute(r, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(n, r, a, u, c, f) {
    const h = a ? a.previousSibling : r.lastChild;
    if (c && (c === f || c.nextSibling))
      for (; r.insertBefore(c.cloneNode(!0), a), !(c === f || !(c = c.nextSibling)); )
        ;
    else {
      nu.innerHTML = Ll(
        u === "svg" ? `<svg>${n}</svg>` : u === "mathml" ? `<math>${n}</math>` : n
      );
      const y = nu.content;
      if (u === "svg" || u === "mathml") {
        const _ = y.firstChild;
        for (; _.firstChild; )
          y.appendChild(_.firstChild);
        y.removeChild(_);
      }
      r.insertBefore(y, a);
    }
    return [
      // first
      h ? h.nextSibling : r.firstChild,
      // last
      a ? a.previousSibling : r.lastChild
    ];
  }
}, Qf = Symbol("_vtc");
function zf(n, r, a) {
  const u = n[Qf];
  u && (r = (r ? [r, ...u] : [...u]).join(" ")), r == null ? n.removeAttribute("class") : a ? n.setAttribute("class", r) : n.className = r;
}
const ru = Symbol("_vod"), Jf = Symbol("_vsh"), Zf = Symbol(""), ed = /(^|;)\s*display\s*:/;
function td(n, r, a) {
  const u = n.style, c = Tt(a);
  let f = !1;
  if (a && !c) {
    if (r)
      if (Tt(r))
        for (const h of r.split(";")) {
          const y = h.slice(0, h.indexOf(":")).trim();
          a[y] == null && Ki(u, y, "");
        }
      else
        for (const h in r)
          a[h] == null && Ki(u, h, "");
    for (const h in a)
      h === "display" && (f = !0), Ki(u, h, a[h]);
  } else if (c) {
    if (r !== a) {
      const h = u[Zf];
      h && (a += ";" + h), u.cssText = a, f = ed.test(a);
    }
  } else r && n.removeAttribute("style");
  ru in n && (n[ru] = f ? u.display : "", n[Jf] && (u.display = "none"));
}
const ou = /\s*!important$/;
function Ki(n, r, a) {
  if (Ie(a))
    a.forEach((u) => Ki(n, r, u));
  else if (a == null && (a = ""), r.startsWith("--"))
    n.setProperty(r, a);
  else {
    const u = nd(n, r);
    ou.test(a) ? n.setProperty(
      bo(u),
      a.replace(ou, ""),
      "important"
    ) : n[u] = a;
  }
}
const iu = ["Webkit", "Moz", "ms"], $s = {};
function nd(n, r) {
  const a = $s[r];
  if (a)
    return a;
  let u = Cr(r);
  if (u !== "filter" && u in n)
    return $s[r] = u;
  u = Pu(u);
  for (let c = 0; c < iu.length; c++) {
    const f = iu[c] + u;
    if (f in n)
      return $s[r] = f;
  }
  return r;
}
const su = "http://www.w3.org/1999/xlink";
function au(n, r, a, u, c, f = ic(r)) {
  u && r.startsWith("xlink:") ? a == null ? n.removeAttributeNS(su, r.slice(6, r.length)) : n.setAttributeNS(su, r, a) : a == null || f && !Iu(a) ? n.removeAttribute(r) : n.setAttribute(
    r,
    f ? "" : Rn(a) ? String(a) : a
  );
}
function uu(n, r, a, u, c) {
  if (r === "innerHTML" || r === "textContent") {
    a != null && (n[r] = r === "innerHTML" ? Ll(a) : a);
    return;
  }
  const f = n.tagName;
  if (r === "value" && f !== "PROGRESS" && // custom elements may use _value internally
  !f.includes("-")) {
    const y = f === "OPTION" ? n.getAttribute("value") || "" : n.value, _ = a == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      n.type === "checkbox" ? "on" : ""
    ) : String(a);
    (y !== _ || !("_value" in n)) && (n.value = _), a == null && n.removeAttribute(r), n._value = a;
    return;
  }
  let h = !1;
  if (a === "" || a == null) {
    const y = typeof n[r];
    y === "boolean" ? a = Iu(a) : a == null && y === "string" ? (a = "", h = !0) : y === "number" && (a = 0, h = !0);
  }
  try {
    n[r] = a;
  } catch {
  }
  h && n.removeAttribute(c || r);
}
function vr(n, r, a, u) {
  n.addEventListener(r, a, u);
}
function rd(n, r, a, u) {
  n.removeEventListener(r, a, u);
}
const lu = Symbol("_vei");
function od(n, r, a, u, c = null) {
  const f = n[lu] || (n[lu] = {}), h = f[r];
  if (u && h)
    h.value = u;
  else {
    const [y, _] = id(r);
    if (u) {
      const j = f[r] = ud(
        u,
        c
      );
      vr(n, y, j, _);
    } else h && (rd(n, y, h, _), f[r] = void 0);
  }
}
const cu = /(?:Once|Passive|Capture)$/;
function id(n) {
  let r;
  if (cu.test(n)) {
    r = {};
    let u;
    for (; u = n.match(cu); )
      n = n.slice(0, n.length - u[0].length), r[u[0].toLowerCase()] = !0;
  }
  return [n[2] === ":" ? n.slice(3) : bo(n.slice(2)), r];
}
let Us = 0;
const sd = /* @__PURE__ */ Promise.resolve(), ad = () => Us || (sd.then(() => Us = 0), Us = Date.now());
function ud(n, r) {
  const a = (u) => {
    if (!u._vts)
      u._vts = Date.now();
    else if (u._vts <= a.attached)
      return;
    $n(
      ld(u, a.value),
      r,
      5,
      [u]
    );
  };
  return a.value = n, a.attached = ad(), a;
}
function ld(n, r) {
  if (Ie(r)) {
    const a = n.stopImmediatePropagation;
    return n.stopImmediatePropagation = () => {
      a.call(n), n._stopped = !0;
    }, r.map(
      (u) => (c) => !c._stopped && u && u(c)
    );
  } else
    return r;
}
const fu = (n) => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && // lowercase letter
n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, cd = (n, r, a, u, c, f) => {
  const h = c === "svg";
  r === "class" ? zf(n, u, h) : r === "style" ? td(n, a, u) : Qi(r) ? da(r) || od(n, r, a, u, f) : (r[0] === "." ? (r = r.slice(1), !0) : r[0] === "^" ? (r = r.slice(1), !1) : fd(n, r, u, h)) ? (uu(n, r, u), !n.tagName.includes("-") && (r === "value" || r === "checked" || r === "selected") && au(n, r, u, h, f, r !== "value")) : /* #11081 force set props for possible async custom element */ n._isVueCE && (/[A-Z]/.test(r) || !Tt(u)) ? uu(n, Cr(r), u, f, r) : (r === "true-value" ? n._trueValue = u : r === "false-value" && (n._falseValue = u), au(n, r, u, h));
};
function fd(n, r, a, u) {
  if (u)
    return !!(r === "innerHTML" || r === "textContent" || r in n && fu(r) && qe(a));
  if (r === "spellcheck" || r === "draggable" || r === "translate" || r === "autocorrect" || r === "form" || r === "list" && n.tagName === "INPUT" || r === "type" && n.tagName === "TEXTAREA")
    return !1;
  if (r === "width" || r === "height") {
    const c = n.tagName;
    if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE")
      return !1;
  }
  return fu(r) && Tt(a) ? !1 : r in n;
}
const Pr = (n) => {
  const r = n.props["onUpdate:modelValue"] || !1;
  return Ie(r) ? (a) => Di(r, a) : r;
};
function dd(n) {
  n.target.composing = !0;
}
function du(n) {
  const r = n.target;
  r.composing && (r.composing = !1, r.dispatchEvent(new Event("input")));
}
const xn = Symbol("_assign"), br = {
  created(n, { modifiers: { lazy: r, trim: a, number: u } }, c) {
    n[xn] = Pr(c);
    const f = u || c.props && c.props.type === "number";
    vr(n, r ? "change" : "input", (h) => {
      if (h.target.composing) return;
      let y = n.value;
      a && (y = y.trim()), f && (y = Bi(y)), n[xn](y);
    }), a && vr(n, "change", () => {
      n.value = n.value.trim();
    }), r || (vr(n, "compositionstart", dd), vr(n, "compositionend", du), vr(n, "change", du));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(n, { value: r }) {
    n.value = r ?? "";
  },
  beforeUpdate(n, { value: r, oldValue: a, modifiers: { lazy: u, trim: c, number: f } }, h) {
    if (n[xn] = Pr(h), n.composing) return;
    const y = (f || n.type === "number") && !/^0\d/.test(n.value) ? Bi(n.value) : n.value, _ = r ?? "";
    y !== _ && (document.activeElement === n && n.type !== "range" && (u && r === a || c && n.value.trim() === _) || (n.value = _));
  }
}, pu = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(n, r, a) {
    n[xn] = Pr(a), vr(n, "change", () => {
      const u = n._modelValue, c = Co(n), f = n.checked, h = n[xn];
      if (Ie(u)) {
        const y = ya(u, c), _ = y !== -1;
        if (f && !_)
          h(u.concat(c));
        else if (!f && _) {
          const j = [...u];
          j.splice(y, 1), h(j);
        }
      } else if (Ao(u)) {
        const y = new Set(u);
        f ? y.add(c) : y.delete(c), h(y);
      } else
        h(Kl(n, f));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: hu,
  beforeUpdate(n, r, a) {
    n[xn] = Pr(a), hu(n, r, a);
  }
};
function hu(n, { value: r, oldValue: a }, u) {
  n._modelValue = r;
  let c;
  if (Ie(r))
    c = ya(r, u.props.value) > -1;
  else if (Ao(r))
    c = r.has(u.props.value);
  else {
    if (r === a) return;
    c = go(r, Kl(n, !0));
  }
  n.checked !== c && (n.checked = c);
}
const Ir = {
  created(n, { value: r }, a) {
    n.checked = go(r, a.props.value), n[xn] = Pr(a), vr(n, "change", () => {
      n[xn](Co(n));
    });
  },
  beforeUpdate(n, { value: r, oldValue: a }, u) {
    n[xn] = Pr(u), r !== a && (n.checked = go(r, u.props.value));
  }
}, ln = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(n, { value: r, modifiers: { number: a } }, u) {
    const c = Ao(r);
    vr(n, "change", () => {
      const f = Array.prototype.filter.call(n.options, (h) => h.selected).map(
        (h) => a ? Bi(Co(h)) : Co(h)
      );
      n[xn](
        n.multiple ? c ? new Set(f) : f : f[0]
      ), n._assigning = !0, Oa(() => {
        n._assigning = !1;
      });
    }), n[xn] = Pr(u);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(n, { value: r }) {
    mu(n, r);
  },
  beforeUpdate(n, r, a) {
    n[xn] = Pr(a);
  },
  updated(n, { value: r }) {
    n._assigning || mu(n, r);
  }
};
function mu(n, r) {
  const a = n.multiple, u = Ie(r);
  if (!(a && !u && !Ao(r))) {
    for (let c = 0, f = n.options.length; c < f; c++) {
      const h = n.options[c], y = Co(h);
      if (a)
        if (u) {
          const _ = typeof y;
          _ === "string" || _ === "number" ? h.selected = r.some((j) => String(j) === String(y)) : h.selected = ya(r, y) > -1;
        } else
          h.selected = r.has(y);
      else if (go(Co(h), r)) {
        n.selectedIndex !== c && (n.selectedIndex = c);
        return;
      }
    }
    !a && n.selectedIndex !== -1 && (n.selectedIndex = -1);
  }
}
function Co(n) {
  return "_value" in n ? n._value : n.value;
}
function Kl(n, r) {
  const a = r ? "_trueValue" : "_falseValue";
  return a in n ? n[a] : r;
}
const pd = /* @__PURE__ */ Gt({ patchProp: cd }, Xf);
let yu;
function hd() {
  return yu || (yu = gf(pd));
}
const md = (...n) => {
  const r = hd().createApp(...n), { mount: a } = r;
  return r.mount = (u) => {
    const c = vd(u);
    if (!c) return;
    const f = r._component;
    !qe(f) && !f.render && !f.template && (f.template = c.innerHTML), c.nodeType === 1 && (c.textContent = "");
    const h = a(c, !1, yd(c));
    return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), h;
  }, r;
};
function yd(n) {
  if (n instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && n instanceof MathMLElement)
    return "mathml";
}
function vd(n) {
  return Tt(n) ? document.querySelector(n) : n;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let Fl;
const ss = (n) => Fl = n, Ml = (
  /* istanbul ignore next */
  Symbol()
);
function ia(n) {
  return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function";
}
var bi;
(function(n) {
  n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function";
})(bi || (bi = {}));
function gd() {
  const n = ju(!0), r = n.run(() => lt({}));
  let a = [], u = [];
  const c = Ta({
    install(f) {
      ss(c), c._a = f, f.provide(Ml, c), f.config.globalProperties.$pinia = c, u.forEach((h) => a.push(h)), u = [];
    },
    use(f) {
      return this._a ? a.push(f) : u.push(f), this;
    },
    _p: a,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: n,
    _s: /* @__PURE__ */ new Map(),
    state: r
  });
  return c;
}
const Bl = () => {
};
function vu(n, r, a, u = Bl) {
  n.push(r);
  const c = () => {
    const f = n.indexOf(r);
    f > -1 && (n.splice(f, 1), u());
  };
  return !a && Lu() && ac(c), c;
}
function wo(n, ...r) {
  n.slice().forEach((a) => {
    a(...r);
  });
}
const bd = (n) => n(), gu = Symbol(), Vs = Symbol();
function sa(n, r) {
  n instanceof Map && r instanceof Map ? r.forEach((a, u) => n.set(u, a)) : n instanceof Set && r instanceof Set && r.forEach(n.add, n);
  for (const a in r) {
    if (!r.hasOwnProperty(a))
      continue;
    const u = r[a], c = n[a];
    ia(c) && ia(u) && n.hasOwnProperty(a) && !st(u) && !gr(u) ? n[a] = sa(c, u) : n[a] = u;
  }
  return n;
}
const _d = (
  /* istanbul ignore next */
  Symbol()
);
function wd(n) {
  return !ia(n) || !Object.prototype.hasOwnProperty.call(n, _d);
}
const { assign: Tr } = Object;
function xd(n) {
  return !!(st(n) && n.effect);
}
function Ed(n, r, a, u) {
  const { state: c, actions: f, getters: h } = r, y = a.state.value[n];
  let _;
  function j() {
    y || (a.state.value[n] = c ? c() : {});
    const D = Pc(a.state.value[n]);
    return Tr(D, f, Object.keys(h || {}).reduce((R, $) => (R[$] = Ta(It(() => {
      ss(a);
      const W = a._s.get(n);
      return h[$].call(W, W);
    })), R), {}));
  }
  return _ = ql(n, j, r, a, u, !0), _;
}
function ql(n, r, a = {}, u, c, f) {
  let h;
  const y = Tr({ actions: {} }, a), _ = { deep: !0 };
  let j, D, R = [], $ = [], W;
  const J = u.state.value[n];
  !f && !J && (u.state.value[n] = {}), lt({});
  let re;
  function te(Ae) {
    let B;
    j = D = !1, typeof Ae == "function" ? (Ae(u.state.value[n]), B = {
      type: bi.patchFunction,
      storeId: n,
      events: W
    }) : (sa(u.state.value[n], Ae), B = {
      type: bi.patchObject,
      payload: Ae,
      storeId: n,
      events: W
    });
    const Xe = re = Symbol();
    Oa().then(() => {
      re === Xe && (j = !0);
    }), D = !0, wo(R, B, u.state.value[n]);
  }
  const M = f ? function() {
    const { state: B } = a, Xe = B ? B() : {};
    this.$patch((ct) => {
      Tr(ct, Xe);
    });
  } : (
    /* istanbul ignore next */
    Bl
  );
  function G() {
    h.stop(), R = [], $ = [], u._s.delete(n);
  }
  const fe = (Ae, B = "") => {
    if (gu in Ae)
      return Ae[Vs] = B, Ae;
    const Xe = function() {
      ss(u);
      const ct = Array.from(arguments), Ke = [], ot = [];
      function bn(xe) {
        Ke.push(xe);
      }
      function kt(xe) {
        ot.push(xe);
      }
      wo($, {
        args: ct,
        name: Xe[Vs],
        store: ge,
        after: bn,
        onError: kt
      });
      let tt;
      try {
        tt = Ae.apply(this && this.$id === n ? this : ge, ct);
      } catch (xe) {
        throw wo(ot, xe), xe;
      }
      return tt instanceof Promise ? tt.then((xe) => (wo(Ke, xe), xe)).catch((xe) => (wo(ot, xe), Promise.reject(xe))) : (wo(Ke, tt), tt);
    };
    return Xe[gu] = !0, Xe[Vs] = B, Xe;
  }, ae = {
    _p: u,
    // _s: scope,
    $id: n,
    $onAction: vu.bind(null, $),
    $patch: te,
    $reset: M,
    $subscribe(Ae, B = {}) {
      const Xe = vu(R, Ae, B.detached, () => ct()), ct = h.run(() => cn(() => u.state.value[n], (Ke) => {
        (B.flush === "sync" ? D : j) && Ae({
          storeId: n,
          type: bi.direct,
          events: W
        }, Ke);
      }, Tr({}, _, B)));
      return Xe;
    },
    $dispose: G
  }, ge = es(ae);
  u._s.set(n, ge);
  const _e = (u._a && u._a.runWithContext || bd)(() => u._e.run(() => (h = ju()).run(() => r({ action: fe }))));
  for (const Ae in _e) {
    const B = _e[Ae];
    if (st(B) && !xd(B) || gr(B))
      f || (J && wd(B) && (st(B) ? B.value = J[Ae] : sa(B, J[Ae])), u.state.value[n][Ae] = B);
    else if (typeof B == "function") {
      const Xe = fe(B, Ae);
      _e[Ae] = Xe, y.actions[Ae] = B;
    }
  }
  return Tr(ge, _e), Tr(Ze(ge), _e), Object.defineProperty(ge, "$state", {
    get: () => u.state.value[n],
    set: (Ae) => {
      te((B) => {
        Tr(B, Ae);
      });
    }
  }), u._p.forEach((Ae) => {
    Tr(ge, h.run(() => Ae({
      store: ge,
      app: u._a,
      pinia: u,
      options: y
    })));
  }), J && f && a.hydrate && a.hydrate(ge.$state, J), j = !0, D = !0, ge;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function $l(n, r, a) {
  let u;
  const c = typeof r == "function";
  u = c ? a : r;
  function f(h, y) {
    const _ = ff();
    return h = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    h || (_ ? vi(Ml, null) : null), h && ss(h), h = Fl, h._s.has(n) || (c ? ql(n, r, u, h) : Ed(n, u, h)), h._s.get(n);
  }
  return f.$id = n, f;
}
function kr(n) {
  const r = Ze(n), a = {};
  for (const u in r) {
    const c = r[u];
    c.effect ? a[u] = // ...
    It({
      get: () => n[u],
      set(f) {
        n[u] = f;
      }
    }) : (st(c) || gr(c)) && (a[u] = // ---
    Dc(n, u));
  }
  return a;
}
function Bn(n) {
  return `${n.prefix} ${n.lnClass} ${n.lnInst}`;
}
const Td = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Od = { class: "col-start-1 col-span-1 self-center justify-self-end" }, Nd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Sd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Cd = ["data-testid"], Ad = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Pd = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Id = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, kd = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Dd = /* @__PURE__ */ Yt({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(n) {
    const r = n, a = It(() => [...r.connections].sort((u, c) => u.dataflowType < c.dataflowType ? -1 : u.dataflowType > c.dataflowType ? 1 : 0));
    return (u, c) => (ve(!0), Ee(Ye, null, St(a.value, (f, h) => (ve(), Ee("div", Td, [
      L("div", Od, [
        L("span", Nd, Re(f.sourceDataObject), 1),
        L("span", Sd, Re(f.sourceDataAttribute), 1)
      ]),
      c[0] || (c[0] = L("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      L("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-line-${h}`
      }, null, 8, Cd),
      c[1] || (c[1] = L("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        L("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      L("div", Ad, Re(f.dataflowType), 1),
      c[2] || (c[2] = L("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      L("div", Pd, [
        L("span", Id, Re(f.input), 1),
        L("span", kd, Re(f.inputInstance), 1)
      ])
    ]))), 256));
  }
});
var Nt = /* @__PURE__ */ ((n) => (n.GOOSE = "GOOSE", n.SMV = "SMV", n.REPORT = "Report", n.INTERNAL = "Internal", n.WIRED = "Wired", n.CONTROL = "Control", n))(Nt || {});
const Yi = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: [],
  Internal: []
}, Rd = { key: 0 }, jd = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, Ld = /* @__PURE__ */ Yt({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(n) {
    return (r, a) => (ve(), Ee("div", null, [
      (ve(), Ee("div", Rd, [
        a[0] || (a[0] = L("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
        r.placeholder.dataflowType ? (ve(), Ee("span", jd, Re(r.placeholder.dataflowType), 1)) : Vt("", !0),
        L("p", null, "Input: " + Re(r.placeholder.input), 1),
        L("p", null, "Input Instance: " + Re(r.placeholder.inputInstance || "-"), 1),
        L("p", null, "Preferred LNode: " + Re(r.placeholder.preferredLNode || "-"), 1),
        L("p", null, "Preferred DO: " + Re(r.placeholder.preferredDataObject || "-"), 1),
        L("p", null, "Preferred DA: " + Re(r.placeholder.preferredDataAttribute || "-"), 1),
        L("p", null, "Process Resource: " + Re(r.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Kd = ["y1", "x2", "y2"], Fd = ["points"], Md = /* @__PURE__ */ Yt({
  __name: "arrow",
  props: {
    height: {},
    length: {}
  },
  setup(n) {
    return (r, a) => (ve(), Ee(Ye, null, [
      L("line", {
        x1: 0,
        y1: r.height / 2,
        x2: r.length - r.height / 2,
        y2: r.height / 2,
        stroke: "currentColor",
        "stroke-width": "2"
      }, null, 8, Kd),
      L("polygon", {
        points: `${r.length - r.height * 0.7}, 0 ${r.length}, ${r.height / 2} ${r.length - r.height * 0.7}, ${r.height}`,
        fill: "currentColor"
      }, null, 8, Fd)
    ], 64));
  }
}), Ul = /* @__PURE__ */ $l("dataflow/sidebar", () => {
  const n = lt(null);
  function r(a) {
    n.value = a;
  }
  return {
    activeElement: n,
    setActiveElement: r
  };
}), Bd = ["onClick"], qd = ["data-testid"], $d = ["onClick"], Ud = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Vd = ["onClick"], Hd = ["onClick"], Wd = /* @__PURE__ */ Yt({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(n) {
    const r = Ul(), { activeElement: a } = kr(r);
    function u(c) {
      const f = c == a.value ? null : c;
      r.setActiveElement(f);
    }
    return (c, f) => (ve(!0), Ee(Ye, null, St(c.destinationPlaceHolderPorts, (h, y) => (ve(), Ee("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
      key: `destination-placeholder-port-${y}`
    }, [
      (ve(), Ee("svg", {
        height: "12",
        width: "35",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 text-(--color-ocean-gray-100) hover:cursor-pointer",
        onClick: (_) => u(h.id)
      }, [
        L("g", {
          "data-testid": `placeholder-line-${y}`,
          class: vo({
            "text-(--color-primary)": Ve(a) === h.id
          })
        }, [
          Ct(Md, {
            height: 12,
            length: 35
          })
        ], 10, qd)
      ], 8, Bd)),
      L("div", {
        onClick: (_) => u(h.id),
        class: vo(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Ve(a) === h.id
        }])
      }, null, 10, $d),
      L("div", Ud, [
        L("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
          onClick: (_) => u(h.id)
        }, Re(h.input), 9, Vd),
        L("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm hover:cursor-pointer",
          onClick: (_) => u(h.id)
        }, Re(h.inputInstance), 9, Hd)
      ]),
      Ve(a) == h.id ? (ve(), kn(ul, {
        key: 0,
        to: "#sidebar-details"
      }, [
        Ct(Ld, { placeholder: h }, null, 8, ["placeholder"])
      ])) : Vt("", !0)
    ]))), 128));
  }
});
var Gd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Yd(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var Fi = { exports: {} }, Xd = Fi.exports, bu;
function Qd() {
  return bu || (bu = 1, function(n, r) {
    (function(a, u) {
      n.exports = u();
    })(Xd, function() {
      var a = function(e, t) {
        return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (o[s] = i[s]);
        })(e, t);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var t, o = 1, i = arguments.length; o < i; o++) for (var s in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, t, o) {
        for (var i, s = 0, l = t.length; s < l; s++) !i && s in t || ((i = i || Array.prototype.slice.call(t, 0, s))[s] = t[s]);
        return e.concat(i || Array.prototype.slice.call(t));
      }
      var f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Gd, h = Object.keys, y = Array.isArray;
      function _(e, t) {
        return typeof t != "object" || h(t).forEach(function(o) {
          e[o] = t[o];
        }), e;
      }
      typeof Promise > "u" || f.Promise || (f.Promise = Promise);
      var j = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function R(e, t) {
        return D.call(e, t);
      }
      function $(e, t) {
        typeof t == "function" && (t = t(j(e))), (typeof Reflect > "u" ? h : Reflect.ownKeys)(t).forEach(function(o) {
          J(e, o, t[o]);
        });
      }
      var W = Object.defineProperty;
      function J(e, t, o, i) {
        W(e, t, _(o && R(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function re(e) {
        return { from: function(t) {
          return e.prototype = Object.create(t.prototype), J(e.prototype, "constructor", e), { extend: $.bind(null, e.prototype) };
        } };
      }
      var te = Object.getOwnPropertyDescriptor, M = [].slice;
      function G(e, t, o) {
        return M.call(e, t, o);
      }
      function fe(e, t) {
        return t(e);
      }
      function ae(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function ge(e) {
        f.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function Ce(e, t) {
        if (typeof t == "string" && R(e, t)) return e[t];
        if (!t) return e;
        if (typeof t != "string") {
          for (var o = [], i = 0, s = t.length; i < s; ++i) {
            var l = Ce(e, t[i]);
            o.push(l);
          }
          return o;
        }
        var d = t.indexOf(".");
        if (d !== -1) {
          var p = e[t.substr(0, d)];
          return p == null ? void 0 : Ce(p, t.substr(d + 1));
        }
      }
      function _e(e, t, o) {
        if (e && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) {
          ae(typeof o != "string" && "length" in o);
          for (var i = 0, s = t.length; i < s; ++i) _e(e, t[i], o[i]);
        } else {
          var l, d, p = t.indexOf(".");
          p !== -1 ? (l = t.substr(0, p), (d = t.substr(p + 1)) === "" ? o === void 0 ? y(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : _e(p = !(p = e[l]) || !R(e, l) ? e[l] = {} : p, d, o)) : o === void 0 ? y(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = o;
        }
      }
      function Ae(e) {
        var t, o = {};
        for (t in e) R(e, t) && (o[t] = e[t]);
        return o;
      }
      var B = [].concat;
      function Xe(e) {
        return B.apply([], e);
      }
      var ke = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Xe([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + e + "Array";
        });
      }))).filter(function(e) {
        return f[e];
      }), ct = new Set(ke.map(function(e) {
        return f[e];
      })), Ke = null;
      function ot(e) {
        return Ke = /* @__PURE__ */ new WeakMap(), e = function t(o) {
          if (!o || typeof o != "object") return o;
          var i = Ke.get(o);
          if (i) return i;
          if (y(o)) {
            i = [], Ke.set(o, i);
            for (var s = 0, l = o.length; s < l; ++s) i.push(t(o[s]));
          } else if (ct.has(o.constructor)) i = o;
          else {
            var d, p = j(o);
            for (d in i = p === Object.prototype ? {} : Object.create(p), Ke.set(o, i), o) R(o, d) && (i[d] = t(o[d]));
          }
          return i;
        }(e), Ke = null, e;
      }
      var bn = {}.toString;
      function kt(e) {
        return bn.call(e).slice(8, -1);
      }
      var tt = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", xe = typeof tt == "symbol" ? function(e) {
        var t;
        return e != null && (t = e[tt]) && t.apply(e);
      } : function() {
        return null;
      };
      function Le(e, t) {
        return t = e.indexOf(t), 0 <= t && e.splice(t, 1), 0 <= t;
      }
      var yt = {};
      function at(e) {
        var t, o, i, s;
        if (arguments.length === 1) {
          if (y(e)) return e.slice();
          if (this === yt && typeof e == "string") return [e];
          if (s = xe(e)) {
            for (o = []; !(i = s.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (t = e.length) != "number") return [e];
          for (o = new Array(t); t--; ) o[t] = e[t];
          return o;
        }
        for (t = arguments.length, o = new Array(t); t--; ) o[t] = arguments[t];
        return o;
      }
      var bt = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Se = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], vt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Se), Dt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Rt(e, t) {
        this.name = e, this.message = t;
      }
      function jn(e, t) {
        return e + ". Errors: " + Object.keys(t).map(function(o) {
          return t[o].toString();
        }).filter(function(o, i, s) {
          return s.indexOf(o) === i;
        }).join(`
`);
      }
      function an(e, t, o, i) {
        this.failures = t, this.failedKeys = i, this.successCount = o, this.message = jn(e, t);
      }
      function wt(e, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(o) {
          return t[o];
        }), this.failuresByPos = t, this.message = jn(e, this.failures);
      }
      re(Rt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), re(an).from(Rt), re(wt).from(Rt);
      var A = vt.reduce(function(e, t) {
        return e[t] = t + "Error", e;
      }, {}), x = Rt, K = vt.reduce(function(e, t) {
        var o = t + "Error";
        function i(s, l) {
          this.name = o, s ? typeof s == "string" ? (this.message = "".concat(s).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof s == "object" && (this.message = "".concat(s.name, " ").concat(s.message), this.inner = s) : (this.message = Dt[t] || o, this.inner = null);
        }
        return re(i).from(x), e[t] = i, e;
      }, {});
      K.Syntax = SyntaxError, K.Type = TypeError, K.Range = RangeError;
      var V = Se.reduce(function(e, t) {
        return e[t + "Error"] = K[t], e;
      }, {}), Ue = vt.reduce(function(e, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = K[t]), e;
      }, {});
      function C() {
      }
      function F(e) {
        return e;
      }
      function ee(e, t) {
        return e == null || e === F ? t : function(o) {
          return t(e(o));
        };
      }
      function oe(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function ue(e, t) {
        return e === C ? t : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, s = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = t.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? oe(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? oe(s, this.onerror) : s), l !== void 0 ? l : o;
        };
      }
      function ie(e, t) {
        return e === C ? t : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? oe(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? oe(i, this.onerror) : i);
        };
      }
      function pe(e, t) {
        return e === C ? t : function(o) {
          var i = e.apply(this, arguments);
          _(o, i);
          var s = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = t.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? oe(s, this.onsuccess) : s), l && (this.onerror = this.onerror ? oe(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : _(i, o);
        };
      }
      function me(e, t) {
        return e === C ? t : function() {
          return t.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function le(e, t) {
        return e === C ? t : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, s = arguments.length, l = new Array(s); s--; ) l[s] = arguments[s];
            return o.then(function() {
              return t.apply(i, l);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Ue.ModifyError = an, Ue.DexieError = Rt, Ue.BulkError = wt;
      var se = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Oe(e) {
        se = e;
      }
      var ye = {}, Ne = 100, ke = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, j(e), e];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, j(t), e];
      }(), Se = ke[0], vt = ke[1], ke = ke[2], vt = vt && vt.then, $e = Se && Se.constructor, He = !!ke, dt = function(e, t) {
        un.push([e, t]), Ot && (queueMicrotask(cs), Ot = !1);
      }, _t = !0, Ot = !0, pt = [], Xt = [], Ln = F, nt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: C, pgp: !1, env: {}, finalize: C }, ne = nt, un = [], Qt = 0, Un = [];
      function z(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = ne;
        if (typeof e != "function") {
          if (e !== ye) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && jr(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function o(i, s) {
          try {
            s(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var d = i._lib && fn();
                l && typeof l.then == "function" ? o(i, function(p, v) {
                  l instanceof z ? l._then(p, v) : l.then(p, v);
                }) : (i._state = !0, i._value = l, Io(i)), d && dn();
              }
            }, jr.bind(null, i));
          } catch (l) {
            jr(i, l);
          }
        }(this, e);
      }
      var Rr = { get: function() {
        var e = ne, t = Gn;
        function o(i, s) {
          var l = this, d = !e.global && (e !== ne || t !== Gn), p = d && !Kt(), v = new z(function(b, E) {
            Lr(l, new Po(Do(i, e, d, p), Do(s, e, d, p), b, E, e));
          });
          return this._consoleTask && (v._consoleTask = this._consoleTask), v;
        }
        return o.prototype = ye, o;
      }, set: function(e) {
        J(this, "then", e && e.prototype === ye ? Rr : { get: function() {
          return e;
        }, set: Rr.set });
      } };
      function Po(e, t, o, i, s) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = o, this.reject = i, this.psd = s;
      }
      function jr(e, t) {
        var o, i;
        Xt.push(t), e._state === null && (o = e._lib && fn(), t = Ln(t), e._state = !1, e._value = t, i = e, pt.some(function(s) {
          return s._value === i._value;
        }) || pt.push(i), Io(e), o && dn());
      }
      function Io(e) {
        var t = e._listeners;
        e._listeners = [];
        for (var o = 0, i = t.length; o < i; ++o) Lr(e, t[o]);
        var s = e._PSD;
        --s.ref || s.finalize(), Qt === 0 && (++Qt, dt(function() {
          --Qt == 0 && Kr();
        }, []));
      }
      function Lr(e, t) {
        if (e._state !== null) {
          var o = e._state ? t.onFulfilled : t.onRejected;
          if (o === null) return (e._state ? t.resolve : t.reject)(e._value);
          ++t.psd.ref, ++Qt, dt(ls, [o, e, t]);
        } else e._listeners.push(t);
      }
      function ls(e, t, o) {
        try {
          var i, s = t._value;
          !t._state && Xt.length && (Xt = []), i = se && t._consoleTask ? t._consoleTask.run(function() {
            return e(s);
          }) : e(s), t._state || Xt.indexOf(s) !== -1 || function(l) {
            for (var d = pt.length; d; ) if (pt[--d]._value === l._value) return pt.splice(d, 1);
          }(t), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Qt == 0 && Kr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function cs() {
        zt(nt, function() {
          fn() && dn();
        });
      }
      function fn() {
        var e = _t;
        return Ot = _t = !1, e;
      }
      function dn() {
        var e, t, o;
        do
          for (; 0 < un.length; ) for (e = un, un = [], o = e.length, t = 0; t < o; ++t) {
            var i = e[t];
            i[0].apply(null, i[1]);
          }
        while (0 < un.length);
        Ot = _t = !0;
      }
      function Kr() {
        var e = pt;
        pt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var t = Un.slice(0), o = t.length; o; ) t[--o]();
      }
      function Vn(e) {
        return new z(ye, !1, e);
      }
      function De(e, t) {
        var o = ne;
        return function() {
          var i = fn(), s = ne;
          try {
            return Ft(o, !0), e.apply(this, arguments);
          } catch (l) {
            t && t(l);
          } finally {
            Ft(s, !1), i && dn();
          }
        };
      }
      $(z.prototype, { then: Rr, _then: function(e, t) {
        Lr(this, new Po(null, null, e, t, ne));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var t = e, o = arguments[1];
        return typeof t == "function" ? this.then(null, function(i) {
          return (i instanceof t ? o : Vn)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === t ? o : Vn)(i);
        });
      }, finally: function(e) {
        return this.then(function(t) {
          return z.resolve(e()).then(function() {
            return t;
          });
        }, function(t) {
          return z.resolve(e()).then(function() {
            return Vn(t);
          });
        });
      }, timeout: function(e, t) {
        var o = this;
        return e < 1 / 0 ? new z(function(i, s) {
          var l = setTimeout(function() {
            return s(new K.Timeout(t));
          }, e);
          o.then(i, s).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && J(z.prototype, Symbol.toStringTag, "Dexie.Promise"), nt.env = ko(), $(z, { all: function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t, o) {
          e.length === 0 && t([]);
          var i = e.length;
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(d) {
              e[l] = d, --i || t(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof z ? e : e && typeof e.then == "function" ? new z(function(t, o) {
          e.then(t, o);
        }) : new z(ye, !0, e);
      }, reject: Vn, race: function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t, o) {
          e.map(function(i) {
            return z.resolve(i).then(t, o);
          });
        });
      }, PSD: { get: function() {
        return ne;
      }, set: function(e) {
        return ne = e;
      } }, totalEchoes: { get: function() {
        return Gn;
      } }, newPSD: Lt, usePSD: zt, scheduler: { get: function() {
        return dt;
      }, set: function(e) {
        dt = e;
      } }, rejectionMapper: { get: function() {
        return Ln;
      }, set: function(e) {
        Ln = e;
      } }, follow: function(e, t) {
        return new z(function(o, i) {
          return Lt(function(s, l) {
            var d = ne;
            d.unhandleds = [], d.onunhandled = l, d.finalize = oe(function() {
              var p, v = this;
              p = function() {
                v.unhandleds.length === 0 ? s() : l(v.unhandleds[0]);
              }, Un.push(function b() {
                p(), Un.splice(Un.indexOf(b), 1);
              }), ++Qt, dt(function() {
                --Qt == 0 && Kr();
              }, []);
            }, d.finalize), e();
          }, t, o, i);
        });
      } }), $e && ($e.allSettled && J(z, "allSettled", function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t) {
          e.length === 0 && t([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(d) {
              return i[l] = { status: "fulfilled", value: d };
            }, function(d) {
              return i[l] = { status: "rejected", reason: d };
            }).then(function() {
              return --o || t(i);
            });
          });
        });
      }), $e.any && typeof AggregateError < "u" && J(z, "any", function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, s = new Array(i);
          e.forEach(function(l, d) {
            return z.resolve(l).then(function(p) {
              return t(p);
            }, function(p) {
              s[d] = p, --i || o(new AggregateError(s));
            });
          });
        });
      }), $e.withResolvers && (z.withResolvers = $e.withResolvers));
      var We = { awaits: 0, echoes: 0, id: 0 }, fs = 0, Hn = [], Wn = 0, Gn = 0, ds = 0;
      function Lt(e, t, o, i) {
        var s = ne, l = Object.create(s);
        return l.parent = s, l.ref = 0, l.global = !1, l.id = ++ds, nt.env, l.env = He ? { Promise: z, PromiseProp: { value: z, configurable: !0, writable: !0 }, all: z.all, race: z.race, allSettled: z.allSettled, any: z.any, resolve: z.resolve, reject: z.reject } : {}, t && _(l, t), ++s.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function pn() {
        return We.id || (We.id = ++fs), ++We.awaits, We.echoes += Ne, We.id;
      }
      function Kt() {
        return !!We.awaits && (--We.awaits == 0 && (We.id = 0), We.echoes = We.awaits * Ne, !0);
      }
      function Yn(e) {
        return We.echoes && e && e.constructor === $e ? (pn(), e.then(function(t) {
          return Kt(), t;
        }, function(t) {
          return Kt(), Fe(t);
        })) : e;
      }
      function ps() {
        var e = Hn[Hn.length - 1];
        Hn.pop(), Ft(e, !1);
      }
      function Ft(e, t) {
        var o, i = ne;
        (t ? !We.echoes || Wn++ && e === ne : !Wn || --Wn && e === ne) || queueMicrotask(t ? (function(s) {
          ++Gn, We.echoes && --We.echoes != 0 || (We.echoes = We.awaits = We.id = 0), Hn.push(ne), Ft(s, !0);
        }).bind(null, e) : ps), e !== ne && (ne = e, i === nt && (nt.env = ko()), He && (o = nt.env.Promise, t = e.env, (i.global || e.global) && (Object.defineProperty(f, "Promise", t.PromiseProp), o.all = t.all, o.race = t.race, o.resolve = t.resolve, o.reject = t.reject, t.allSettled && (o.allSettled = t.allSettled), t.any && (o.any = t.any))));
      }
      function ko() {
        var e = f.Promise;
        return He ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function zt(e, t, o, i, s) {
        var l = ne;
        try {
          return Ft(e, !0), t(o, i, s);
        } finally {
          Ft(l, !1);
        }
      }
      function Do(e, t, o, i) {
        return typeof e != "function" ? e : function() {
          var s = ne;
          o && pn(), Ft(t, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Ft(s, !1), i && queueMicrotask(Kt);
          }
        };
      }
      function Fr(e) {
        Promise === $e && We.echoes === 0 ? Wn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + vt).indexOf("[native code]") === -1 && (pn = Kt = C);
      var Fe = z.reject, Jt = "￿", At = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ro = "String expected.", hn = [], Xn = "__dbnames", Mr = "readonly", Br = "readwrite";
      function Zt(e, t) {
        return e ? t ? function() {
          return e.apply(this, arguments) && t.apply(this, arguments);
        } : e : t;
      }
      var jo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Qn(e) {
        return typeof e != "string" || /\./.test(e) ? function(t) {
          return t;
        } : function(t) {
          return t[e] === void 0 && e in t && delete (t = ot(t))[e], t;
        };
      }
      function Lo() {
        throw K.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function be(e, t) {
        try {
          var o = Ko(e), i = Ko(t);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return t < e ? 1 : e < t ? -1 : 0;
            case "binary":
              return function(s, l) {
                for (var d = s.length, p = l.length, v = d < p ? d : p, b = 0; b < v; ++b) if (s[b] !== l[b]) return s[b] < l[b] ? -1 : 1;
                return d === p ? 0 : d < p ? -1 : 1;
              }(Fo(e), Fo(t));
            case "Array":
              return function(s, l) {
                for (var d = s.length, p = l.length, v = d < p ? d : p, b = 0; b < v; ++b) {
                  var E = be(s[b], l[b]);
                  if (E !== 0) return E;
                }
                return d === p ? 0 : d < p ? -1 : 1;
              }(e, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ko(e) {
        var t = typeof e;
        return t != "object" ? t : ArrayBuffer.isView(e) ? "binary" : (e = kt(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function Fo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function zn(e, t, o) {
        var i = e.schema.yProps;
        return i ? (t && 0 < o.numFailures && (t = t.filter(function(s, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(s) {
          return s = s.updatesTable, t ? e.db.table(s).where("k").anyOf(t).delete() : e.db.table(s).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Mo = (Pe.prototype._trans = function(e, t, o) {
        var i = this._tx || ne.trans, s = this.name, l = se && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function d(b, E, m) {
          if (!m.schema[s]) throw new K.NotFound("Table " + s + " not part of transaction");
          return t(m.idbtrans, m);
        }
        var p = fn();
        try {
          var v = i && i.db._novip === this.db._novip ? i === ne.trans ? i._promise(e, d, o) : Lt(function() {
            return i._promise(e, d, o);
          }, { trans: i, transless: ne.transless || ne }) : function b(E, m, N, g) {
            if (E.idbdb && (E._state.openComplete || ne.letThrough || E._vip)) {
              var w = E._createTransaction(m, N, E._dbSchema);
              try {
                w.create(), E._state.PR1398_maxLoop = 3;
              } catch (O) {
                return O.name === A.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                  return b(E, m, N, g);
                })) : Fe(O);
              }
              return w._promise(m, function(O, T) {
                return Lt(function() {
                  return ne.trans = w, g(O, T, w);
                });
              }).then(function(O) {
                if (m === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return m === "readonly" ? O : w._completion.then(function() {
                  return O;
                });
              });
            }
            if (E._state.openComplete) return Fe(new K.DatabaseClosed(E._state.dbOpenError));
            if (!E._state.isBeingOpened) {
              if (!E._state.autoOpen) return Fe(new K.DatabaseClosed());
              E.open().catch(C);
            }
            return E._state.dbReadyPromise.then(function() {
              return b(E, m, N, g);
            });
          }(this.db, e, [this.name], d);
          return l && (v._consoleTask = l, v = v.catch(function(b) {
            return console.trace(b), Fe(b);
          })), v;
        } finally {
          p && dn();
        }
      }, Pe.prototype.get = function(e, t) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(t) : e == null ? Fe(new K.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(s) {
            return o.hook.reading.fire(s);
          });
        }).then(t);
      }, Pe.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (y(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var t = h(e);
        if (t.length === 1) return this.where(t[0]).equals(e[t[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(p) {
          if (p.compound && t.every(function(b) {
            return 0 <= p.keyPath.indexOf(b);
          })) {
            for (var v = 0; v < t.length; ++v) if (t.indexOf(p.keyPath[v]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(p, v) {
          return p.keyPath.length - v.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== Jt) {
          var l = o.keyPath.slice(0, t.length);
          return this.where(l).equals(l.map(function(v) {
            return e[v];
          }));
        }
        !o && se && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var i = this.schema.idxByName;
        function s(p, v) {
          return be(p, v) === 0;
        }
        var d = t.reduce(function(m, v) {
          var b = m[0], E = m[1], m = i[v], N = e[v];
          return [b || m, b || !m ? Zt(E, m && m.multi ? function(g) {
            return g = Ce(g, v), y(g) && g.some(function(w) {
              return s(N, w);
            });
          } : function(g) {
            return s(N, Ce(g, v));
          }) : E];
        }, [null, null]), l = d[0], d = d[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(d) : o ? this.filter(d) : this.where(t).equals("");
      }, Pe.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Pe.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Pe.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Pe.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Pe.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Pe.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Pe.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Pe.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, y(e) ? "[".concat(e.join("+"), "]") : e));
      }, Pe.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Pe.prototype.mapToClass = function(e) {
        var t, o = this.db, i = this.name;
        function s() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Lo && (function(v, b) {
          if (typeof b != "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function E() {
            this.constructor = v;
          }
          a(v, b), v.prototype = b === null ? Object.create(b) : (E.prototype = b.prototype, new E());
        }(s, t = e), Object.defineProperty(s.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), s.prototype.table = function() {
          return i;
        }, e = s);
        for (var l = /* @__PURE__ */ new Set(), d = e.prototype; d; d = j(d)) Object.getOwnPropertyNames(d).forEach(function(v) {
          return l.add(v);
        });
        function p(v) {
          if (!v) return v;
          var b, E = Object.create(e.prototype);
          for (b in v) if (!l.has(b)) try {
            E[b] = v[b];
          } catch {
          }
          return E;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = p, this.hook("reading", p), e;
      }, Pe.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          _(this, e);
        });
      }, Pe.prototype.add = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, d = e;
        return l && s && (d = Qn(l)(e)), this._trans("readwrite", function(p) {
          return o.core.mutate({ trans: p, type: "add", keys: t != null ? [t] : null, values: [d] });
        }).then(function(p) {
          return p.numFailures ? z.reject(p.failures[0]) : p.lastResult;
        }).then(function(p) {
          if (l) try {
            _e(e, l, p);
          } catch {
          }
          return p;
        });
      }, Pe.prototype.update = function(e, t) {
        return typeof e != "object" || y(e) ? this.where(":id").equals(e).modify(t) : (e = Ce(e, this.schema.primKey.keyPath), e === void 0 ? Fe(new K.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(t));
      }, Pe.prototype.put = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, d = e;
        return l && s && (d = Qn(l)(e)), this._trans("readwrite", function(p) {
          return o.core.mutate({ trans: p, type: "put", values: [d], keys: t != null ? [t] : null });
        }).then(function(p) {
          return p.numFailures ? z.reject(p.failures[0]) : p.lastResult;
        }).then(function(p) {
          if (l) try {
            _e(e, l, p);
          } catch {
          }
          return p;
        });
      }, Pe.prototype.delete = function(e) {
        var t = this;
        return this._trans("readwrite", function(o) {
          return t.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return zn(t, [e], i);
          }).then(function(i) {
            return i.numFailures ? z.reject(i.failures[0]) : void 0;
          });
        });
      }, Pe.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(t) {
          return e.core.mutate({ trans: t, type: "deleteRange", range: jo }).then(function(o) {
            return zn(e, null, o);
          });
        }).then(function(t) {
          return t.numFailures ? z.reject(t.failures[0]) : void 0;
        });
      }, Pe.prototype.bulkGet = function(e) {
        var t = this;
        return this._trans("readonly", function(o) {
          return t.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(s) {
              return t.hook.reading.fire(s);
            });
          });
        });
      }, Pe.prototype.bulkAdd = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var b = i.schema.primKey, p = b.auto, b = b.keyPath;
          if (b && s) throw new K.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && p ? e.map(Qn(b)) : e;
          return i.core.mutate({ trans: d, type: "add", keys: s, values: b, wantResults: l }).then(function(w) {
            var m = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (m === 0) return l ? N : g;
            throw new wt("".concat(i.name, ".bulkAdd(): ").concat(m, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Pe.prototype.bulkPut = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var b = i.schema.primKey, p = b.auto, b = b.keyPath;
          if (b && s) throw new K.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && p ? e.map(Qn(b)) : e;
          return i.core.mutate({ trans: d, type: "put", keys: s, values: b, wantResults: l }).then(function(w) {
            var m = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (m === 0) return l ? N : g;
            throw new wt("".concat(i.name, ".bulkPut(): ").concat(m, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Pe.prototype.bulkUpdate = function(e) {
        var t = this, o = this.core, i = e.map(function(d) {
          return d.key;
        }), s = e.map(function(d) {
          return d.changes;
        }), l = [];
        return this._trans("readwrite", function(d) {
          return o.getMany({ trans: d, keys: i, cache: "clone" }).then(function(p) {
            var v = [], b = [];
            e.forEach(function(m, N) {
              var g = m.key, w = m.changes, O = p[N];
              if (O) {
                for (var T = 0, S = Object.keys(w); T < S.length; T++) {
                  var P = S[T], I = w[P];
                  if (P === t.schema.primKey.keyPath) {
                    if (be(I, g) !== 0) throw new K.Constraint("Cannot update primary key in bulkUpdate()");
                  } else _e(O, P, I);
                }
                l.push(N), v.push(g), b.push(O);
              }
            });
            var E = v.length;
            return o.mutate({ trans: d, type: "put", keys: v, values: b, updates: { keys: i, changeSpecs: s } }).then(function(m) {
              var N = m.numFailures, g = m.failures;
              if (N === 0) return E;
              for (var w = 0, O = Object.keys(g); w < O.length; w++) {
                var T, S = O[w], P = l[Number(S)];
                P != null && (T = g[S], delete g[S], g[P] = T);
              }
              throw new wt("".concat(t.name, ".bulkUpdate(): ").concat(N, " of ").concat(E, " operations failed"), g);
            });
          });
        });
      }, Pe.prototype.bulkDelete = function(e) {
        var t = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return t.core.mutate({ trans: i, type: "delete", keys: e }).then(function(s) {
            return zn(t, e, s);
          });
        }).then(function(d) {
          var s = d.numFailures, l = d.lastResult, d = d.failures;
          if (s === 0) return l;
          throw new wt("".concat(t.name, ".bulkDelete(): ").concat(s, " of ").concat(o, " operations failed"), d);
        });
      }, Pe);
      function Pe() {
      }
      function En(e) {
        function t(d, p) {
          if (p) {
            for (var v = arguments.length, b = new Array(v - 1); --v; ) b[v - 1] = arguments[v];
            return o[d].subscribe.apply(null, b), e;
          }
          if (typeof d == "string") return o[d];
        }
        var o = {};
        t.addEventType = l;
        for (var i = 1, s = arguments.length; i < s; ++i) l(arguments[i]);
        return t;
        function l(d, p, v) {
          if (typeof d != "object") {
            var b;
            p = p || me;
            var E = { subscribers: [], fire: v = v || C, subscribe: function(m) {
              E.subscribers.indexOf(m) === -1 && (E.subscribers.push(m), E.fire = p(E.fire, m));
            }, unsubscribe: function(m) {
              E.subscribers = E.subscribers.filter(function(N) {
                return N !== m;
              }), E.fire = E.subscribers.reduce(p, v);
            } };
            return o[d] = t[d] = E;
          }
          h(b = d).forEach(function(m) {
            var N = b[m];
            if (y(N)) l(m, b[m][0], b[m][1]);
            else {
              if (N !== "asap") throw new K.InvalidArgument("Invalid event config");
              var g = l(m, F, function() {
                for (var w = arguments.length, O = new Array(w); w--; ) O[w] = arguments[w];
                g.subscribers.forEach(function(T) {
                  ge(function() {
                    T.apply(null, O);
                  });
                });
              });
            }
          });
        }
      }
      function Tn(e, t) {
        return re(t).from({ prototype: e }), t;
      }
      function mn(e, t) {
        return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);
      }
      function qr(e, t) {
        e.filter = Zt(e.filter, t);
      }
      function $r(e, t, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return Zt(i(), t());
        } : t, e.justLimit = o && !i;
      }
      function Jn(e, t) {
        if (e.isPrimKey) return t.primaryKey;
        var o = t.getIndexByKeyPath(e.index);
        if (!o) throw new K.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return o;
      }
      function Bo(e, t, o) {
        var i = Jn(e, t.schema);
        return t.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function Zn(e, t, o, i) {
        var s = e.replayFilter ? Zt(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, d = function(p, v, b) {
            var E, m;
            s && !s(v, b, function(N) {
              return v.stop(N);
            }, function(N) {
              return v.fail(N);
            }) || ((m = "" + (E = v.primaryKey)) == "[object ArrayBuffer]" && (m = "" + new Uint8Array(E)), R(l, m) || (l[m] = !0, t(p, v, b)));
          };
          return Promise.all([e.or._iterate(d, o), qo(Bo(e, i, o), e.algorithm, d, !e.keysOnly && e.valueMapper)]);
        }
        return qo(Bo(e, i, o), Zt(e.algorithm, s), t, !e.keysOnly && e.valueMapper);
      }
      function qo(e, t, o, i) {
        var s = De(i ? function(l, d, p) {
          return o(i(l), d, p);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var d = function() {
              return l.continue();
            };
            t && !t(l, function(p) {
              return d = p;
            }, function(p) {
              l.stop(p), d = C;
            }, function(p) {
              l.fail(p), d = C;
            }) || s(l.value, l, function(p) {
              return d = p;
            }), d();
          });
        });
      }
      var On = ($o.prototype.execute = function(e) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var o = t.add;
          if (y(o)) return c(c([], y(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (t.remove !== void 0) {
          var i = t.remove;
          if (y(i)) return y(e) ? e.filter(function(s) {
            return !i.includes(s);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = t.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? t.replacePrefix[1] + e.substring(o.length) : e;
      }, $o);
      function $o(e) {
        this["@@propmod"] = e;
      }
      var hs = (Te.prototype._read = function(e, t) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, Fe.bind(null, o.error)) : o.table._trans("readonly", e).then(t);
      }, Te.prototype._write = function(e) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, Fe.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
      }, Te.prototype._addAlgorithm = function(e) {
        var t = this._ctx;
        t.algorithm = Zt(t.algorithm, e);
      }, Te.prototype._iterate = function(e, t) {
        return Zn(this._ctx, e, t, this._ctx.table.core);
      }, Te.prototype.clone = function(e) {
        var t = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && _(o, e), t._ctx = o, t;
      }, Te.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Te.prototype.each = function(e) {
        var t = this._ctx;
        return this._read(function(o) {
          return Zn(t, e, o, t.table.core);
        });
      }, Te.prototype.count = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx, s = i.table.core;
          if (mn(i, !0)) return s.count({ trans: o, query: { index: Jn(i, s.schema), range: i.range } }).then(function(d) {
            return Math.min(d, i.limit);
          });
          var l = 0;
          return Zn(i, function() {
            return ++l, !1;
          }, o, s).then(function() {
            return l;
          });
        }).then(e);
      }, Te.prototype.sortBy = function(e, t) {
        var o = e.split(".").reverse(), i = o[0], s = o.length - 1;
        function l(v, b) {
          return b ? l(v[o[b]], b - 1) : v[i];
        }
        var d = this._ctx.dir === "next" ? 1 : -1;
        function p(v, b) {
          return be(l(v, s), l(b, s)) * d;
        }
        return this.toArray(function(v) {
          return v.sort(p);
        }).then(t);
      }, Te.prototype.toArray = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx;
          if (i.dir === "next" && mn(i, !0) && 0 < i.limit) {
            var s = i.valueMapper, l = Jn(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(p) {
              return p = p.result, s ? p.map(s) : p;
            });
          }
          var d = [];
          return Zn(i, function(p) {
            return d.push(p);
          }, o, i.table.core).then(function() {
            return d;
          });
        }, e);
      }, Te.prototype.offset = function(e) {
        var t = this._ctx;
        return e <= 0 || (t.offset += e, mn(t) ? $r(t, function() {
          var o = e;
          return function(i, s) {
            return o === 0 || (o === 1 ? --o : s(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : $r(t, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Te.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), $r(this._ctx, function() {
          var t = e;
          return function(o, i, s) {
            return --t <= 0 && i(s), 0 <= t;
          };
        }, !0), this;
      }, Te.prototype.until = function(e, t) {
        return qr(this._ctx, function(o, i, s) {
          return !e(o.value) || (i(s), t);
        }), this;
      }, Te.prototype.first = function(e) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(e);
      }, Te.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Te.prototype.filter = function(e) {
        var t;
        return qr(this._ctx, function(o) {
          return e(o.value);
        }), (t = this._ctx).isMatch = Zt(t.isMatch, e), this;
      }, Te.prototype.and = function(e) {
        return this.filter(e);
      }, Te.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Te.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Te.prototype.desc = function() {
        return this.reverse();
      }, Te.prototype.eachKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, Te.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Te.prototype.eachPrimaryKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, Te.prototype.keys = function(e) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Te.prototype.primaryKeys = function(e) {
        var t = this._ctx;
        if (t.dir === "next" && mn(t, !0) && 0 < t.limit) return this._read(function(i) {
          var s = Jn(t, t.table.core.schema);
          return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: s, range: t.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Te.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Te.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(e);
      }, Te.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Te.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var t = {};
        return qr(this._ctx, function(s) {
          var i = s.primaryKey.toString(), s = R(t, i);
          return t[i] = !0, !s;
        }), this;
      }, Te.prototype.modify = function(e) {
        var t = this, o = this._ctx;
        return this._write(function(i) {
          var s, l, d;
          d = typeof e == "function" ? e : (s = h(e), l = s.length, function(S) {
            for (var P = !1, I = 0; I < l; ++I) {
              var k = s[I], q = e[k], Y = Ce(S, k);
              q instanceof On ? (_e(S, k, q.execute(Y)), P = !0) : Y !== q && (_e(S, k, q), P = !0);
            }
            return P;
          });
          var p = o.table.core, m = p.schema.primaryKey, v = m.outbound, b = m.extractKey, E = 200, m = t.db._options.modifyChunkSize;
          m && (E = typeof m == "object" ? m[p.name] || m["*"] || 200 : m);
          function N(S, k) {
            var I = k.failures, k = k.numFailures;
            w += S - k;
            for (var q = 0, Y = h(I); q < Y.length; q++) {
              var U = Y[q];
              g.push(I[U]);
            }
          }
          var g = [], w = 0, O = [], T = e === Uo;
          return t.clone().primaryKeys().then(function(S) {
            function P(k) {
              var q = Math.min(E, S.length - k), Y = S.slice(k, k + q);
              return (T ? Promise.resolve([]) : p.getMany({ trans: i, keys: Y, cache: "immutable" })).then(function(U) {
                var H = [], Q = [], X = v ? [] : null, Z = T ? Y : [];
                if (!T) for (var he = 0; he < q; ++he) {
                  var we = U[he], de = { value: ot(we), primKey: S[k + he] };
                  d.call(de, de.value, de) !== !1 && (de.value == null ? Z.push(S[k + he]) : v || be(b(we), b(de.value)) === 0 ? (Q.push(de.value), v && X.push(S[k + he])) : (Z.push(S[k + he]), H.push(de.value)));
                }
                return Promise.resolve(0 < H.length && p.mutate({ trans: i, type: "add", values: H }).then(function(je) {
                  for (var ce in je.failures) Z.splice(parseInt(ce), 1);
                  N(H.length, je);
                })).then(function() {
                  return (0 < Q.length || I && typeof e == "object") && p.mutate({ trans: i, type: "put", keys: X, values: Q, criteria: I, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < k }).then(function(je) {
                    return N(Q.length, je);
                  });
                }).then(function() {
                  return (0 < Z.length || I && T) && p.mutate({ trans: i, type: "delete", keys: Z, criteria: I, isAdditionalChunk: 0 < k }).then(function(je) {
                    return zn(o.table, Z, je);
                  }).then(function(je) {
                    return N(Z.length, je);
                  });
                }).then(function() {
                  return S.length > k + q && P(k + E);
                });
              });
            }
            var I = mn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return P(0).then(function() {
              if (0 < g.length) throw new an("Error modifying one or more objects", g, w, O);
              return S.length;
            });
          });
        });
      }, Te.prototype.delete = function() {
        var e = this._ctx, t = e.range;
        return !mn(e) || e.table.schema.yProps || !e.isPrimKey && t.type !== 3 ? this.modify(Uo) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, s = t;
          return e.table.core.count({ trans: o, query: { index: i, range: s } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: s }).then(function(v) {
              var p = v.failures, v = v.numFailures;
              if (v) throw new an("Could not delete some values", Object.keys(p).map(function(b) {
                return p[b];
              }), l - v);
              return l - v;
            });
          });
        });
      }, Te);
      function Te() {
      }
      var Uo = function(e, t) {
        return t.value = null;
      };
      function ms(e, t) {
        return e < t ? -1 : e === t ? 0 : 1;
      }
      function ys(e, t) {
        return t < e ? -1 : e === t ? 0 : 1;
      }
      function ft(e, t, o) {
        return e = e instanceof Ho ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(t), e;
      }
      function yn(e) {
        return new e.Collection(e, function() {
          return Vo("");
        }).limit(0);
      }
      function er(e, t, o, i) {
        var s, l, d, p, v, b, E, m = o.length;
        if (!o.every(function(w) {
          return typeof w == "string";
        })) return ft(e, Ro);
        function N(w) {
          s = w === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = w === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, d = w === "next" ? ms : ys;
          var O = o.map(function(T) {
            return { lower: l(T), upper: s(T) };
          }).sort(function(T, S) {
            return d(T.lower, S.lower);
          });
          p = O.map(function(T) {
            return T.upper;
          }), v = O.map(function(T) {
            return T.lower;
          }), E = (b = w) === "next" ? "" : i;
        }
        N("next"), e = new e.Collection(e, function() {
          return Mt(p[0], v[m - 1] + i);
        }), e._ondirectionchange = function(w) {
          N(w);
        };
        var g = 0;
        return e._addAlgorithm(function(w, O, T) {
          var S = w.key;
          if (typeof S != "string") return !1;
          var P = l(S);
          if (t(P, v, g)) return !0;
          for (var I = null, k = g; k < m; ++k) {
            var q = function(Y, U, H, Q, X, Z) {
              for (var he = Math.min(Y.length, Q.length), we = -1, de = 0; de < he; ++de) {
                var je = U[de];
                if (je !== Q[de]) return X(Y[de], H[de]) < 0 ? Y.substr(0, de) + H[de] + H.substr(de + 1) : X(Y[de], Q[de]) < 0 ? Y.substr(0, de) + Q[de] + H.substr(de + 1) : 0 <= we ? Y.substr(0, we) + U[we] + H.substr(we + 1) : null;
                X(Y[de], je) < 0 && (we = de);
              }
              return he < Q.length && Z === "next" ? Y + H.substr(Y.length) : he < Y.length && Z === "prev" ? Y.substr(0, H.length) : we < 0 ? null : Y.substr(0, we) + Q[we] + H.substr(we + 1);
            }(S, P, p[k], v[k], d, b);
            q === null && I === null ? g = k + 1 : (I === null || 0 < d(I, q)) && (I = q);
          }
          return O(I !== null ? function() {
            w.continue(I + E);
          } : T), !1;
        }), e;
      }
      function Mt(e, t, o, i) {
        return { type: 2, lower: e, upper: t, lowerOpen: o, upperOpen: i };
      }
      function Vo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var Ho = (Object.defineProperty(Ge.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Ge.prototype.between = function(e, t, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, t) || this._cmp(e, t) === 0 && (o || i) && (!o || !i) ? yn(this) : new this.Collection(this, function() {
            return Mt(e, t, !o, !i);
          });
        } catch {
          return ft(this, At);
        }
      }, Ge.prototype.equals = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Vo(e);
        });
      }, Ge.prototype.above = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(e, void 0, !0);
        });
      }, Ge.prototype.aboveOrEqual = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(e, void 0, !1);
        });
      }, Ge.prototype.below = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(void 0, e, !1, !0);
        });
      }, Ge.prototype.belowOrEqual = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(void 0, e);
        });
      }, Ge.prototype.startsWith = function(e) {
        return typeof e != "string" ? ft(this, Ro) : this.between(e, e + Jt, !0, !0);
      }, Ge.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : er(this, function(t, o) {
          return t.indexOf(o[0]) === 0;
        }, [e], Jt);
      }, Ge.prototype.equalsIgnoreCase = function(e) {
        return er(this, function(t, o) {
          return t === o[0];
        }, [e], "");
      }, Ge.prototype.anyOfIgnoreCase = function() {
        var e = at.apply(yt, arguments);
        return e.length === 0 ? yn(this) : er(this, function(t, o) {
          return o.indexOf(t) !== -1;
        }, e, "");
      }, Ge.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = at.apply(yt, arguments);
        return e.length === 0 ? yn(this) : er(this, function(t, o) {
          return o.some(function(i) {
            return t.indexOf(i) === 0;
          });
        }, e, Jt);
      }, Ge.prototype.anyOf = function() {
        var e = this, t = at.apply(yt, arguments), o = this._cmp;
        try {
          t.sort(o);
        } catch {
          return ft(this, At);
        }
        if (t.length === 0) return yn(this);
        var i = new this.Collection(this, function() {
          return Mt(t[0], t[t.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, t.sort(o);
        };
        var s = 0;
        return i._addAlgorithm(function(l, d, p) {
          for (var v = l.key; 0 < o(v, t[s]); ) if (++s === t.length) return d(p), !1;
          return o(v, t[s]) === 0 || (d(function() {
            l.continue(t[s]);
          }), !1);
        }), i;
      }, Ge.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Ge.prototype.noneOf = function() {
        var e = at.apply(yt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return ft(this, At);
        }
        var t = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, Ge.prototype.inAnyRange = function(S, t) {
        var o = this, i = this._cmp, s = this._ascending, l = this._descending, d = this._min, p = this._max;
        if (S.length === 0) return yn(this);
        if (!S.every(function(P) {
          return P[0] !== void 0 && P[1] !== void 0 && s(P[0], P[1]) <= 0;
        })) return ft(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", K.InvalidArgument);
        var v = !t || t.includeLowers !== !1, b = t && t.includeUppers === !0, E, m = s;
        function N(P, I) {
          return m(P[0], I[0]);
        }
        try {
          (E = S.reduce(function(P, I) {
            for (var k = 0, q = P.length; k < q; ++k) {
              var Y = P[k];
              if (i(I[0], Y[1]) < 0 && 0 < i(I[1], Y[0])) {
                Y[0] = d(Y[0], I[0]), Y[1] = p(Y[1], I[1]);
                break;
              }
            }
            return k === q && P.push(I), P;
          }, [])).sort(N);
        } catch {
          return ft(this, At);
        }
        var g = 0, w = b ? function(P) {
          return 0 < s(P, E[g][1]);
        } : function(P) {
          return 0 <= s(P, E[g][1]);
        }, O = v ? function(P) {
          return 0 < l(P, E[g][0]);
        } : function(P) {
          return 0 <= l(P, E[g][0]);
        }, T = w, S = new this.Collection(this, function() {
          return Mt(E[0][0], E[E.length - 1][1], !v, !b);
        });
        return S._ondirectionchange = function(P) {
          m = P === "next" ? (T = w, s) : (T = O, l), E.sort(N);
        }, S._addAlgorithm(function(P, I, k) {
          for (var q, Y = P.key; T(Y); ) if (++g === E.length) return I(k), !1;
          return !w(q = Y) && !O(q) || (o._cmp(Y, E[g][1]) === 0 || o._cmp(Y, E[g][0]) === 0 || I(function() {
            m === s ? P.continue(E[g][0]) : P.continue(E[g][1]);
          }), !1);
        }), S;
      }, Ge.prototype.startsWithAnyOf = function() {
        var e = at.apply(yt, arguments);
        return e.every(function(t) {
          return typeof t == "string";
        }) ? e.length === 0 ? yn(this) : this.inAnyRange(e.map(function(t) {
          return [t, t + Jt];
        })) : ft(this, "startsWithAnyOf() only works with strings");
      }, Ge);
      function Ge() {
      }
      function xt(e) {
        return De(function(t) {
          return Nn(t), e(t.target.error), !1;
        });
      }
      function Nn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Sn = "storagemutated", Ur = "x-storagemutated-1", Bt = En(null, Sn), vs = (Et.prototype._lock = function() {
        return ae(!ne.global), ++this._reculock, this._reculock !== 1 || ne.global || (ne.lockOwnerFor = this), this;
      }, Et.prototype._unlock = function() {
        if (ae(!ne.global), --this._reculock == 0) for (ne.global || (ne.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Et.prototype._locked = function() {
        return this._reculock && ne.lockOwnerFor !== this;
      }, Et.prototype.create = function(e) {
        var t = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (ae(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new K.DatabaseClosed(i);
          case "MissingAPIError":
            throw new K.MissingAPI(i.message, i);
          default:
            throw new K.OpenFailed(i);
        }
        if (!this.active) throw new K.TransactionInactive();
        return ae(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = De(function(s) {
          Nn(s), t._reject(e.error);
        }), e.onabort = De(function(s) {
          Nn(s), t.active && t._reject(new K.Abort(e.error)), t.active = !1, t.on("abort").fire(s);
        }), e.oncomplete = De(function() {
          t.active = !1, t._resolve(), "mutatedParts" in e && Bt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Et.prototype._promise = function(e, t, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return Fe(new K.ReadOnly("Transaction is readonly"));
        if (!this.active) return Fe(new K.TransactionInactive());
        if (this._locked()) return new z(function(l, d) {
          i._blockedFuncs.push([function() {
            i._promise(e, t, o).then(l, d);
          }, ne]);
        });
        if (o) return Lt(function() {
          var l = new z(function(d, p) {
            i._lock();
            var v = t(d, p, i);
            v && v.then && v.then(d, p);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var s = new z(function(l, d) {
          var p = t(l, d, i);
          p && p.then && p.then(l, d);
        });
        return s._lib = !0, s;
      }, Et.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Et.prototype.waitFor = function(e) {
        var t, o = this._root(), i = z.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], t = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (t.get(-1 / 0).onsuccess = l);
        }());
        var s = o._waitingFor;
        return new z(function(l, d) {
          i.then(function(p) {
            return o._waitingQueue.push(De(l.bind(null, p)));
          }, function(p) {
            return o._waitingQueue.push(De(d.bind(null, p)));
          }).finally(function() {
            o._waitingFor === s && (o._waitingFor = null);
          });
        });
      }, Et.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new K.Abort()));
      }, Et.prototype.table = function(e) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (R(t, e)) return t[e];
        var o = this.schema[e];
        if (!o) throw new K.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), t[e] = o;
      }, Et);
      function Et() {
      }
      function Vr(e, t, o, i, s, l, d, p) {
        return { name: e, keyPath: t, unique: o, multi: i, auto: s, compound: l, src: (o && !d ? "&" : "") + (i ? "*" : "") + (s ? "++" : "") + Wo(t), type: p };
      }
      function Wo(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Hr(e, t, o) {
        return { name: e, primKey: t, indexes: o, mappedClass: null, idxByName: (i = function(s) {
          return [s.name, s];
        }, o.reduce(function(s, l, d) {
          return d = i(l, d), d && (s[d[0]] = d[1]), s;
        }, {})) };
        var i;
      }
      var Cn = function(e) {
        try {
          return e.only([[]]), Cn = function() {
            return [[]];
          }, [[]];
        } catch {
          return Cn = function() {
            return Jt;
          }, Jt;
        }
      };
      function Wr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (t = e).split(".").length === 1 ? function(o) {
          return o[t];
        } : function(o) {
          return Ce(o, t);
        } : function(o) {
          return Ce(o, e);
        };
        var t;
      }
      function Go(e) {
        return [].slice.call(e);
      }
      var gs = 0;
      function An(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function bs(e, t, v) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var g = T.lower, w = T.upper, O = T.lowerOpen, T = T.upperOpen;
          return g === void 0 ? w === void 0 ? null : t.upperBound(w, !!T) : w === void 0 ? t.lowerBound(g, !!O) : t.bound(g, w, !!O, !!T);
        }
        function s(N) {
          var g, w = N.name;
          return { name: w, schema: N, mutate: function(O) {
            var T = O.trans, S = O.type, P = O.keys, I = O.values, k = O.range;
            return new Promise(function(q, Y) {
              q = De(q);
              var U = T.objectStore(w), H = U.keyPath == null, Q = S === "put" || S === "add";
              if (!Q && S !== "delete" && S !== "deleteRange") throw new Error("Invalid operation type: " + S);
              var X, Z = (P || I || { length: 1 }).length;
              if (P && I && P.length !== I.length) throw new Error("Given keys array must have same length as given values array.");
              if (Z === 0) return q({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function he(rt) {
                ++je, Nn(rt);
              }
              var we = [], de = [], je = 0;
              if (S === "deleteRange") {
                if (k.type === 4) return q({ numFailures: je, failures: de, results: [], lastResult: void 0 });
                k.type === 3 ? we.push(X = U.clear()) : we.push(X = U.delete(i(k)));
              } else {
                var H = Q ? H ? [I, P] : [I, null] : [P, null], ce = H[0], ze = H[1];
                if (Q) for (var Je = 0; Je < Z; ++Je) we.push(X = ze && ze[Je] !== void 0 ? U[S](ce[Je], ze[Je]) : U[S](ce[Je])), X.onerror = he;
                else for (Je = 0; Je < Z; ++Je) we.push(X = U[S](ce[Je])), X.onerror = he;
              }
              function dr(rt) {
                rt = rt.target.result, we.forEach(function(nn, co) {
                  return nn.error != null && (de[co] = nn.error);
                }), q({ numFailures: je, failures: de, results: S === "delete" ? P : we.map(function(nn) {
                  return nn.result;
                }), lastResult: rt });
              }
              X.onerror = function(rt) {
                he(rt), dr(rt);
              }, X.onsuccess = dr;
            });
          }, getMany: function(O) {
            var T = O.trans, S = O.keys;
            return new Promise(function(P, I) {
              P = De(P);
              for (var k, q = T.objectStore(w), Y = S.length, U = new Array(Y), H = 0, Q = 0, X = function(we) {
                we = we.target, U[we._pos] = we.result, ++Q === H && P(U);
              }, Z = xt(I), he = 0; he < Y; ++he) S[he] != null && ((k = q.get(S[he]))._pos = he, k.onsuccess = X, k.onerror = Z, ++H);
              H === 0 && P(U);
            });
          }, get: function(O) {
            var T = O.trans, S = O.key;
            return new Promise(function(P, I) {
              P = De(P);
              var k = T.objectStore(w).get(S);
              k.onsuccess = function(q) {
                return P(q.target.result);
              }, k.onerror = xt(I);
            });
          }, query: (g = b, function(O) {
            return new Promise(function(T, S) {
              T = De(T);
              var P, I, k, H = O.trans, q = O.values, Y = O.limit, X = O.query, U = Y === 1 / 0 ? void 0 : Y, Q = X.index, X = X.range, H = H.objectStore(w), Q = Q.isPrimaryKey ? H : H.index(Q.name), X = i(X);
              if (Y === 0) return T({ result: [] });
              g ? ((U = q ? Q.getAll(X, U) : Q.getAllKeys(X, U)).onsuccess = function(Z) {
                return T({ result: Z.target.result });
              }, U.onerror = xt(S)) : (P = 0, I = !q && "openKeyCursor" in Q ? Q.openKeyCursor(X) : Q.openCursor(X), k = [], I.onsuccess = function(Z) {
                var he = I.result;
                return he ? (k.push(q ? he.value : he.primaryKey), ++P === Y ? T({ result: k }) : void he.continue()) : T({ result: k });
              }, I.onerror = xt(S));
            });
          }), openCursor: function(O) {
            var T = O.trans, S = O.values, P = O.query, I = O.reverse, k = O.unique;
            return new Promise(function(q, Y) {
              q = De(q);
              var Q = P.index, U = P.range, H = T.objectStore(w), H = Q.isPrimaryKey ? H : H.index(Q.name), Q = I ? k ? "prevunique" : "prev" : k ? "nextunique" : "next", X = !S && "openKeyCursor" in H ? H.openKeyCursor(i(U), Q) : H.openCursor(i(U), Q);
              X.onerror = xt(Y), X.onsuccess = De(function(Z) {
                var he, we, de, je, ce = X.result;
                ce ? (ce.___id = ++gs, ce.done = !1, he = ce.continue.bind(ce), we = (we = ce.continuePrimaryKey) && we.bind(ce), de = ce.advance.bind(ce), je = function() {
                  throw new Error("Cursor not stopped");
                }, ce.trans = T, ce.stop = ce.continue = ce.continuePrimaryKey = ce.advance = function() {
                  throw new Error("Cursor not started");
                }, ce.fail = De(Y), ce.next = function() {
                  var ze = this, Je = 1;
                  return this.start(function() {
                    return Je-- ? ze.continue() : ze.stop();
                  }).then(function() {
                    return ze;
                  });
                }, ce.start = function(ze) {
                  function Je() {
                    if (X.result) try {
                      ze();
                    } catch (rt) {
                      ce.fail(rt);
                    }
                    else ce.done = !0, ce.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ce.stop();
                  }
                  var dr = new Promise(function(rt, nn) {
                    rt = De(rt), X.onerror = xt(nn), ce.fail = nn, ce.stop = function(co) {
                      ce.stop = ce.continue = ce.continuePrimaryKey = ce.advance = je, rt(co);
                    };
                  });
                  return X.onsuccess = De(function(rt) {
                    X.onsuccess = Je, Je();
                  }), ce.continue = he, ce.continuePrimaryKey = we, ce.advance = de, Je(), dr;
                }, q(ce)) : q(null);
              }, Y);
            });
          }, count: function(O) {
            var T = O.query, S = O.trans, P = T.index, I = T.range;
            return new Promise(function(k, q) {
              var Y = S.objectStore(w), U = P.isPrimaryKey ? Y : Y.index(P.name), Y = i(I), U = Y ? U.count(Y) : U.count();
              U.onsuccess = De(function(H) {
                return k(H.target.result);
              }), U.onerror = xt(q);
            });
          } };
        }
        var l, d, p, E = (d = v, p = Go((l = e).objectStoreNames), { schema: { name: l.name, tables: p.map(function(N) {
          return d.objectStore(N);
        }).map(function(N) {
          var g = N.keyPath, T = N.autoIncrement, w = y(g), O = {}, T = { name: N.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g == null, compound: w, keyPath: g, autoIncrement: T, unique: !0, extractKey: Wr(g) }, indexes: Go(N.indexNames).map(function(S) {
            return N.index(S);
          }).map(function(k) {
            var P = k.name, I = k.unique, q = k.multiEntry, k = k.keyPath, q = { name: P, compound: y(k), keyPath: k, unique: I, multiEntry: q, extractKey: Wr(k) };
            return O[An(k)] = q;
          }), getIndexByKeyPath: function(S) {
            return O[An(S)];
          } };
          return O[":id"] = T.primaryKey, g != null && (O[An(g)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < p.length && "getAll" in d.objectStore(p[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), v = E.schema, b = E.hasGetAll, E = v.tables.map(s), m = {};
        return E.forEach(function(N) {
          return m[N.name] = N;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(N) {
          if (!m[N]) throw new Error("Table '".concat(N, "' not found"));
          return m[N];
        }, MIN_KEY: -1 / 0, MAX_KEY: Cn(t), schema: v };
      }
      function _s(e, t, o, i) {
        var s = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = bs(t, s, i), e.dbcore.reduce(function(l, d) {
          return d = d.create, u(u({}, l), d(l));
        }, i)) };
      }
      function tr(e, i) {
        var o = i.db, i = _s(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(s) {
          var l = s.name;
          e.core.schema.tables.some(function(d) {
            return d.name === l;
          }) && (s.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = s.core));
        });
      }
      function nr(e, t, o, i) {
        o.forEach(function(s) {
          var l = i[s];
          t.forEach(function(d) {
            var p = function v(b, E) {
              return te(b, E) || (b = j(b)) && v(b, E);
            }(d, s);
            (!p || "value" in p && p.value === void 0) && (d === e.Transaction.prototype || d instanceof e.Transaction ? J(d, s, { get: function() {
              return this.table(s);
            }, set: function(v) {
              W(this, s, { value: v, writable: !0, configurable: !0, enumerable: !0 });
            } }) : d[s] = new e.Table(s, l));
          });
        });
      }
      function Gr(e, t) {
        t.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function ws(e, t) {
        return e._cfg.version - t._cfg.version;
      }
      function xs(e, t, o, i) {
        var s = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !s.$meta && (s.$meta = Hr("$meta", Xo("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, s);
        l.create(o), l._completion.catch(i);
        var d = l._reject.bind(l), p = ne.transless || ne;
        Lt(function() {
          return ne.trans = l, ne.transless = p, t !== 0 ? (tr(e, o), b = t, ((v = l).storeNames.includes("$meta") ? v.table("$meta").get("version").then(function(E) {
            return E ?? b;
          }) : z.resolve(b)).then(function(E) {
            return N = E, g = l, w = o, O = [], E = (m = e)._versions, T = m._dbSchema = or(0, m.idbdb, w), (E = E.filter(function(S) {
              return S._cfg.version >= N;
            })).length !== 0 ? (E.forEach(function(S) {
              O.push(function() {
                var P = T, I = S._cfg.dbschema;
                ir(m, P, w), ir(m, I, w), T = m._dbSchema = I;
                var k = Yr(P, I);
                k.add.forEach(function(Q) {
                  Xr(w, Q[0], Q[1].primKey, Q[1].indexes);
                }), k.change.forEach(function(Q) {
                  if (Q.recreate) throw new K.Upgrade("Not yet support for changing primary key");
                  var X = w.objectStore(Q.name);
                  Q.add.forEach(function(Z) {
                    return rr(X, Z);
                  }), Q.change.forEach(function(Z) {
                    X.deleteIndex(Z.name), rr(X, Z);
                  }), Q.del.forEach(function(Z) {
                    return X.deleteIndex(Z);
                  });
                });
                var q = S._cfg.contentUpgrade;
                if (q && S._cfg.version > N) {
                  tr(m, w), g._memoizedTables = {};
                  var Y = Ae(I);
                  k.del.forEach(function(Q) {
                    Y[Q] = P[Q];
                  }), Gr(m, [m.Transaction.prototype]), nr(m, [m.Transaction.prototype], h(Y), Y), g.schema = Y;
                  var U, H = bt(q);
                  return H && pn(), k = z.follow(function() {
                    var Q;
                    (U = q(g)) && H && (Q = Kt.bind(null, null), U.then(Q, Q));
                  }), U && typeof U.then == "function" ? z.resolve(U) : k.then(function() {
                    return U;
                  });
                }
              }), O.push(function(P) {
                var I, k, q = S._cfg.dbschema;
                I = q, k = P, [].slice.call(k.db.objectStoreNames).forEach(function(Y) {
                  return I[Y] == null && k.db.deleteObjectStore(Y);
                }), Gr(m, [m.Transaction.prototype]), nr(m, [m.Transaction.prototype], m._storeNames, m._dbSchema), g.schema = m._dbSchema;
              }), O.push(function(P) {
                m.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(m.idbdb.version / 10) === S._cfg.version ? (m.idbdb.deleteObjectStore("$meta"), delete m._dbSchema.$meta, m._storeNames = m._storeNames.filter(function(I) {
                  return I !== "$meta";
                })) : P.objectStore("$meta").put(S._cfg.version, "version"));
              });
            }), function S() {
              return O.length ? z.resolve(O.shift()(g.idbtrans)).then(S) : z.resolve();
            }().then(function() {
              Yo(T, w);
            })) : z.resolve();
            var m, N, g, w, O, T;
          }).catch(d)) : (h(s).forEach(function(E) {
            Xr(o, E, s[E].primKey, s[E].indexes);
          }), tr(e, o), void z.follow(function() {
            return e.on.populate.fire(l);
          }).catch(d));
          var v, b;
        });
      }
      function Es(e, t) {
        Yo(e._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var o = or(0, e.idbdb, t);
        ir(e, e._dbSchema, t);
        for (var i = 0, s = Yr(o, e._dbSchema).change; i < s.length; i++) {
          var l = function(d) {
            if (d.change.length || d.recreate) return console.warn("Unable to patch indexes of table ".concat(d.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var p = t.objectStore(d.name);
            d.add.forEach(function(v) {
              se && console.debug("Dexie upgrade patch: Creating missing index ".concat(d.name, ".").concat(v.src)), rr(p, v);
            });
          }(s[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function Yr(e, t) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) t[o] || i.del.push(o);
        for (o in t) {
          var s = e[o], l = t[o];
          if (s) {
            var d = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (s.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || s.primKey.auto !== l.primKey.auto) d.recreate = !0, i.change.push(d);
            else {
              var p = s.idxByName, v = l.idxByName, b = void 0;
              for (b in p) v[b] || d.del.push(b);
              for (b in v) {
                var E = p[b], m = v[b];
                E ? E.src !== m.src && d.change.push(m) : d.add.push(m);
              }
              (0 < d.del.length || 0 < d.add.length || 0 < d.change.length) && i.change.push(d);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Xr(e, t, o, i) {
        var s = e.db.createObjectStore(t, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return rr(s, l);
        }), s;
      }
      function Yo(e, t) {
        h(e).forEach(function(o) {
          t.db.objectStoreNames.contains(o) || (se && console.debug("Dexie: Creating missing table", o), Xr(t, o, e[o].primKey, e[o].indexes));
        });
      }
      function rr(e, t) {
        e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function or(e, t, o) {
        var i = {};
        return G(t.objectStoreNames, 0).forEach(function(s) {
          for (var l = o.objectStore(s), d = Vr(Wo(b = l.keyPath), b || "", !0, !1, !!l.autoIncrement, b && typeof b != "string", !0), p = [], v = 0; v < l.indexNames.length; ++v) {
            var E = l.index(l.indexNames[v]), b = E.keyPath, E = Vr(E.name, b, !!E.unique, !!E.multiEntry, !1, b && typeof b != "string", !1);
            p.push(E);
          }
          i[s] = Hr(s, d, p);
        }), i;
      }
      function ir(e, t, o) {
        for (var i = o.db.objectStoreNames, s = 0; s < i.length; ++s) {
          var l = i[s], d = o.objectStore(l);
          e._hasGetAll = "getAll" in d;
          for (var p = 0; p < d.indexNames.length; ++p) {
            var v = d.indexNames[p], b = d.index(v).keyPath, E = typeof b == "string" ? b : "[" + G(b).join("+") + "]";
            !t[l] || (b = t[l].idxByName[E]) && (b.name = v, delete t[l].idxByName[E], t[l].idxByName[v] = b);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function Xo(e) {
        return e.split(",").map(function(t, o) {
          var l = t.split(":"), i = (s = l[1]) === null || s === void 0 ? void 0 : s.trim(), s = (t = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(s) ? s.match(/^\[(.*)\]$/)[1].split("+") : s;
          return Vr(s, l || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), y(l), o === 0, i);
        });
      }
      var Ts = (vn.prototype._createTableSchema = Hr, vn.prototype._parseIndexSyntax = Xo, vn.prototype._parseStoresSpec = function(e, t) {
        var o = this;
        h(e).forEach(function(i) {
          if (e[i] !== null) {
            var s = o._parseIndexSyntax(e[i]), l = s.shift();
            if (!l) throw new K.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new K.Schema("Primary key cannot be multiEntry*");
            s.forEach(function(d) {
              if (d.auto) throw new K.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!d.keyPath) throw new K.Schema("Index must have a name and cannot be an empty string");
            }), s = o._createTableSchema(i, l, s), t[i] = s;
          }
        });
      }, vn.prototype.stores = function(o) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? _(this._cfg.storesSource, o) : o;
        var o = t._versions, i = {}, s = {};
        return o.forEach(function(l) {
          _(i, l._cfg.storesSource), s = l._cfg.dbschema = {}, l._parseStoresSpec(i, s);
        }), t._dbSchema = s, Gr(t, [t._allTables, t, t.Transaction.prototype]), nr(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], h(s), s), t._storeNames = h(s), this;
      }, vn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = le(this._cfg.contentUpgrade || C, e), this;
      }, vn);
      function vn() {
      }
      function Qr(e, t) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Pt(Xn, { addons: [], indexedDB: e, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function zr(e) {
        return e && typeof e.databases == "function";
      }
      function Jr(e) {
        return Lt(function() {
          return ne.letThrough = !0, e();
        });
      }
      function Zr(e) {
        return !("from" in e);
      }
      var Qe = function(e, t) {
        if (!this) {
          var o = new Qe();
          return e && "d" in e && _(o, e), o;
        }
        _(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? t : e } : { d: 0 });
      };
      function Pn(e, t, o) {
        var i = be(t, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (Zr(e)) return _(e, { from: t, to: o, d: 1 });
          var s = e.l, i = e.r;
          if (be(o, e.from) < 0) return s ? Pn(s, t, o) : e.l = { from: t, to: o, d: 1, l: null, r: null }, zo(e);
          if (0 < be(t, e.to)) return i ? Pn(i, t, o) : e.r = { from: t, to: o, d: 1, l: null, r: null }, zo(e);
          be(t, e.from) < 0 && (e.from = t, e.l = null, e.d = i ? i.d + 1 : 1), 0 < be(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, s && !e.l && In(e, s), i && o && In(e, i);
        }
      }
      function In(e, t) {
        Zr(t) || function o(i, v) {
          var l = v.from, d = v.to, p = v.l, v = v.r;
          Pn(i, l, d), p && o(i, p), v && o(i, v);
        }(e, t);
      }
      function Qo(e, t) {
        var o = sr(t), i = o.next();
        if (i.done) return !1;
        for (var s = i.value, l = sr(e), d = l.next(s.from), p = d.value; !i.done && !d.done; ) {
          if (be(p.from, s.to) <= 0 && 0 <= be(p.to, s.from)) return !0;
          be(s.from, p.from) < 0 ? s = (i = o.next(p.from)).value : p = (d = l.next(s.from)).value;
        }
        return !1;
      }
      function sr(e) {
        var t = Zr(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, i) for (; t.n.l && be(o, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !i || be(o, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function zo(e) {
        var t, o, i = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), s = 1 < i ? "r" : i < -1 ? "l" : "";
        s && (t = s == "r" ? "l" : "r", o = u({}, e), i = e[s], e.from = i.from, e.to = i.to, e[s] = i[s], o[s] = i[t], (e[t] = o).d = Jo(o)), e.d = Jo(e);
      }
      function Jo(o) {
        var t = o.r, o = o.l;
        return (t ? o ? Math.max(t.d, o.d) : t.d : o ? o.d : 0) + 1;
      }
      function ar(e, t) {
        return h(t).forEach(function(o) {
          e[o] ? In(e[o], t[o]) : e[o] = function i(s) {
            var l, d, p = {};
            for (l in s) R(s, l) && (d = s[l], p[l] = !d || typeof d != "object" || ct.has(d.constructor) ? d : i(d));
            return p;
          }(t[o]);
        }), e;
      }
      function eo(e, t) {
        return e.all || t.all || Object.keys(e).some(function(o) {
          return t[o] && Qo(t[o], e[o]);
        });
      }
      $(Qe.prototype, ((vt = { add: function(e) {
        return In(this, e), this;
      }, addKey: function(e) {
        return Pn(this, e, e), this;
      }, addKeys: function(e) {
        var t = this;
        return e.forEach(function(o) {
          return Pn(t, o, o);
        }), this;
      }, hasKey: function(e) {
        var t = sr(this).next(e).value;
        return t && be(t.from, e) <= 0 && 0 <= be(t.to, e);
      } })[tt] = function() {
        return sr(this);
      }, vt));
      var en = {}, to = {}, no = !1;
      function ur(e) {
        ar(to, e), no || (no = !0, setTimeout(function() {
          no = !1, ro(to, !(to = {}));
        }, 0));
      }
      function ro(e, t) {
        t === void 0 && (t = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, s = Object.values(en); i < s.length; i++) Zo(d = s[i], e, o, t);
        else for (var l in e) {
          var d, p = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          p && (l = p[1], p = p[2], (d = en["idb://".concat(l, "/").concat(p)]) && Zo(d, e, o, t));
        }
        o.forEach(function(v) {
          return v();
        });
      }
      function Zo(e, t, o, i) {
        for (var s = [], l = 0, d = Object.entries(e.queries.query); l < d.length; l++) {
          for (var p = d[l], v = p[0], b = [], E = 0, m = p[1]; E < m.length; E++) {
            var N = m[E];
            eo(t, N.obsSet) ? N.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && b.push(N);
          }
          i && s.push([v, b]);
        }
        if (i) for (var g = 0, w = s; g < w.length; g++) {
          var O = w[g], v = O[0], b = O[1];
          e.queries.query[v] = b;
        }
      }
      function Os(e) {
        var t = e._state, o = e._deps.indexedDB;
        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? Fe(t.dbOpenError) : e;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var i = t.openCanceller, s = Math.round(10 * e.verno), l = !1;
        function d() {
          if (t.openCanceller !== i) throw new K.DatabaseClosed("db.open() was cancelled");
        }
        function p() {
          return new z(function(N, g) {
            if (d(), !o) throw new K.MissingAPI();
            var w = e.name, O = t.autoSchema || !s ? o.open(w) : o.open(w, s);
            if (!O) throw new K.MissingAPI();
            O.onerror = xt(g), O.onblocked = De(e._fireOnBlocked), O.onupgradeneeded = De(function(T) {
              var S;
              E = O.transaction, t.autoSchema && !e._options.allowEmptyDB ? (O.onerror = Nn, E.abort(), O.result.close(), (S = o.deleteDatabase(w)).onsuccess = S.onerror = De(function() {
                g(new K.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (E.onerror = xt(g), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, m = T < 1, e.idbdb = O.result, l && Es(e, E), xs(e, T / 10, E, g));
            }, g), O.onsuccess = De(function() {
              E = null;
              var T, S, P, I, k, q = e.idbdb = O.result, Y = G(q.objectStoreNames);
              if (0 < Y.length) try {
                var U = q.transaction((I = Y).length === 1 ? I[0] : I, "readonly");
                if (t.autoSchema) S = q, P = U, (T = e).verno = S.version / 10, P = T._dbSchema = or(0, S, P), T._storeNames = G(S.objectStoreNames, 0), nr(T, [T._allTables], h(P), P);
                else if (ir(e, e._dbSchema, U), ((k = Yr(or(0, (k = e).idbdb, U), k._dbSchema)).add.length || k.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), q.close(), s = q.version + 1, l = !0, N(p());
                tr(e, U);
              } catch {
              }
              hn.push(e), q.onversionchange = De(function(H) {
                t.vcFired = !0, e.on("versionchange").fire(H);
              }), q.onclose = De(function(H) {
                e.on("close").fire(H);
              }), m && (k = e._deps, U = w, q = k.indexedDB, k = k.IDBKeyRange, zr(q) || U === Xn || Qr(q, k).put({ name: U }).catch(C)), N();
            }, g);
          }).catch(function(N) {
            switch (N?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), p();
                break;
              case "VersionError":
                if (0 < s) return s = 0, p();
            }
            return z.reject(N);
          });
        }
        var v, b = t.dbReadyResolve, E = null, m = !1;
        return z.race([i, (typeof navigator > "u" ? z.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(N) {
          function g() {
            return indexedDB.databases().finally(N);
          }
          v = setInterval(g, 100), g();
        }).finally(function() {
          return clearInterval(v);
        }) : Promise.resolve()).then(p)]).then(function() {
          return d(), t.onReadyBeingFired = [], z.resolve(Jr(function() {
            return e.on.ready.fire(e.vip);
          })).then(function N() {
            if (0 < t.onReadyBeingFired.length) {
              var g = t.onReadyBeingFired.reduce(le, C);
              return t.onReadyBeingFired = [], z.resolve(Jr(function() {
                return g(e.vip);
              })).then(N);
            }
          });
        }).finally(function() {
          t.openCanceller === i && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(N) {
          t.dbOpenError = N;
          try {
            E && E.abort();
          } catch {
          }
          return i === t.openCanceller && e._close(), Fe(N);
        }).finally(function() {
          t.openComplete = !0, b();
        }).then(function() {
          var N;
          return m && (N = {}, e.tables.forEach(function(g) {
            g.schema.indexes.forEach(function(w) {
              w.name && (N["idb://".concat(e.name, "/").concat(g.name, "/").concat(w.name)] = new Qe(-1 / 0, [[[]]]));
            }), N["idb://".concat(e.name, "/").concat(g.name, "/")] = N["idb://".concat(e.name, "/").concat(g.name, "/:dels")] = new Qe(-1 / 0, [[[]]]);
          }), Bt(Sn).fire(N), ro(N, !0)), e;
        });
      }
      function oo(e) {
        function t(l) {
          return e.next(l);
        }
        var o = s(t), i = s(function(l) {
          return e.throw(l);
        });
        function s(l) {
          return function(v) {
            var p = l(v), v = p.value;
            return p.done ? v : v && typeof v.then == "function" ? v.then(o, i) : y(v) ? Promise.all(v).then(o, i) : o(v);
          };
        }
        return s(t)();
      }
      function lr(e, t, o) {
        for (var i = y(e) ? e.slice() : [e], s = 0; s < o; ++s) i.push(t);
        return i;
      }
      var Ns = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema, s = {}, l = [];
          function d(m, N, g) {
            var w = An(m), O = s[w] = s[w] || [], T = m == null ? 0 : typeof m == "string" ? 1 : m.length, S = 0 < N, S = u(u({}, g), { name: S ? "".concat(w, "(virtual-from:").concat(g.name, ")") : g.name, lowLevelIndex: g, isVirtual: S, keyTail: N, keyLength: T, extractKey: Wr(m), unique: !S && g.unique });
            return O.push(S), S.isPrimaryKey || l.push(S), 1 < T && d(T === 2 ? m[0] : m.slice(0, T - 1), N + 1, g), O.sort(function(P, I) {
              return P.keyTail - I.keyTail;
            }), S;
          }
          t = d(i.primaryKey.keyPath, 0, i.primaryKey), s[":id"] = [t];
          for (var p = 0, v = i.indexes; p < v.length; p++) {
            var b = v[p];
            d(b.keyPath, 0, b);
          }
          function E(m) {
            var N, g = m.query.index;
            return g.isVirtual ? u(u({}, m), { query: { index: g.lowLevelIndex, range: (N = m.query.range, g = g.keyTail, { type: N.type === 1 ? 2 : N.type, lower: lr(N.lower, N.lowerOpen ? e.MAX_KEY : e.MIN_KEY, g), lowerOpen: !0, upper: lr(N.upper, N.upperOpen ? e.MIN_KEY : e.MAX_KEY, g), upperOpen: !0 }) } }) : m;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: t, indexes: l, getIndexByKeyPath: function(m) {
            return (m = s[An(m)]) && m[0];
          } }), count: function(m) {
            return o.count(E(m));
          }, query: function(m) {
            return o.query(E(m));
          }, openCursor: function(m) {
            var N = m.query.index, g = N.keyTail, w = N.isVirtual, O = N.keyLength;
            return w ? o.openCursor(E(m)).then(function(S) {
              return S && T(S);
            }) : o.openCursor(m);
            function T(S) {
              return Object.create(S, { continue: { value: function(P) {
                P != null ? S.continue(lr(P, m.reverse ? e.MAX_KEY : e.MIN_KEY, g)) : m.unique ? S.continue(S.key.slice(0, O).concat(m.reverse ? e.MIN_KEY : e.MAX_KEY, g)) : S.continue();
              } }, continuePrimaryKey: { value: function(P, I) {
                S.continuePrimaryKey(lr(P, e.MAX_KEY, g), I);
              } }, primaryKey: { get: function() {
                return S.primaryKey;
              } }, key: { get: function() {
                var P = S.key;
                return O === 1 ? P[0] : P.slice(0, O);
              } }, value: { get: function() {
                return S.value;
              } } });
            }
          } });
        } });
      } };
      function io(e, t, o, i) {
        return o = o || {}, i = i || "", h(e).forEach(function(s) {
          var l, d, p;
          R(t, s) ? (l = e[s], d = t[s], typeof l == "object" && typeof d == "object" && l && d ? (p = kt(l)) !== kt(d) ? o[i + s] = t[s] : p === "Object" ? io(l, d, o, i + s + ".") : l !== d && (o[i + s] = t[s]) : l !== d && (o[i + s] = t[s])) : o[i + s] = void 0;
        }), h(t).forEach(function(s) {
          R(e, s) || (o[i + s] = t[s]);
        }), o;
      }
      function so(e, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey);
      }
      var Ss = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(s) {
            var l = ne.trans, d = l.table(t).hook, p = d.deleting, v = d.creating, b = d.updating;
            switch (s.type) {
              case "add":
                if (v.fire === C) break;
                return l._promise("readwrite", function() {
                  return E(s);
                }, !0);
              case "put":
                if (v.fire === C && b.fire === C) break;
                return l._promise("readwrite", function() {
                  return E(s);
                }, !0);
              case "delete":
                if (p.fire === C) break;
                return l._promise("readwrite", function() {
                  return E(s);
                }, !0);
              case "deleteRange":
                if (p.fire === C) break;
                return l._promise("readwrite", function() {
                  return function m(N, g, w) {
                    return o.query({ trans: N, values: !1, query: { index: i, range: g }, limit: w }).then(function(O) {
                      var T = O.result;
                      return E({ type: "delete", keys: T, trans: N }).then(function(S) {
                        return 0 < S.numFailures ? Promise.reject(S.failures[0]) : T.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : m(N, u(u({}, g), { lower: T[T.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(s.trans, s.range, 1e4);
                }, !0);
            }
            return o.mutate(s);
            function E(m) {
              var N, g, w, O = ne.trans, T = m.keys || so(i, m);
              if (!T) throw new Error("Keys missing");
              return (m = m.type === "add" || m.type === "put" ? u(u({}, m), { keys: T }) : u({}, m)).type !== "delete" && (m.values = c([], m.values)), m.keys && (m.keys = c([], m.keys)), N = o, w = T, ((g = m).type === "add" ? Promise.resolve([]) : N.getMany({ trans: g.trans, keys: w, cache: "immutable" })).then(function(S) {
                var P = T.map(function(I, k) {
                  var q, Y, U, H = S[k], Q = { onerror: null, onsuccess: null };
                  return m.type === "delete" ? p.fire.call(Q, I, H, O) : m.type === "add" || H === void 0 ? (q = v.fire.call(Q, I, m.values[k], O), I == null && q != null && (m.keys[k] = I = q, i.outbound || _e(m.values[k], i.keyPath, I))) : (q = io(H, m.values[k]), (Y = b.fire.call(Q, q, I, H, O)) && (U = m.values[k], Object.keys(Y).forEach(function(X) {
                    R(U, X) ? U[X] = Y[X] : _e(U, X, Y[X]);
                  }))), Q;
                });
                return o.mutate(m).then(function(I) {
                  for (var k = I.failures, q = I.results, Y = I.numFailures, I = I.lastResult, U = 0; U < T.length; ++U) {
                    var H = (q || T)[U], Q = P[U];
                    H == null ? Q.onerror && Q.onerror(k[U]) : Q.onsuccess && Q.onsuccess(m.type === "put" && S[U] ? m.values[U] : H);
                  }
                  return { failures: k, results: q, numFailures: Y, lastResult: I };
                }).catch(function(I) {
                  return P.forEach(function(k) {
                    return k.onerror && k.onerror(I);
                  }), Promise.reject(I);
                });
              });
            }
          } });
        } });
      } };
      function ei(e, t, o) {
        try {
          if (!t || t.keys.length < e.length) return null;
          for (var i = [], s = 0, l = 0; s < t.keys.length && l < e.length; ++s) be(t.keys[s], e[l]) === 0 && (i.push(o ? ot(t.values[s]) : t.values[s]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Cs = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(t) {
          var o = e.table(t);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var s = ei(i.keys, i.trans._cache, i.cache === "clone");
            return s ? z.resolve(s) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? ot(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function ti(e, t) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function ni(e, t) {
        switch (e) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var As = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var t = e.schema.name, o = new Qe(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, s, l) {
          if (ne.subscr && s !== "readonly") throw new K.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ne.querier));
          return e.transaction(i, s, l);
        }, table: function(i) {
          var s = e.table(i), l = s.schema, d = l.primaryKey, m = l.indexes, p = d.extractKey, v = d.outbound, b = d.autoIncrement && m.filter(function(g) {
            return g.compound && g.keyPath.includes(d.keyPath);
          }), E = u(u({}, s), { mutate: function(g) {
            function w(X) {
              return X = "idb://".concat(t, "/").concat(i, "/").concat(X), I[X] || (I[X] = new Qe());
            }
            var O, T, S, P = g.trans, I = g.mutatedParts || (g.mutatedParts = {}), k = w(""), q = w(":dels"), Y = g.type, Q = g.type === "deleteRange" ? [g.range] : g.type === "delete" ? [g.keys] : g.values.length < 50 ? [so(d, g).filter(function(X) {
              return X;
            }), g.values] : [], U = Q[0], H = Q[1], Q = g.trans._cache;
            return y(U) ? (k.addKeys(U), (Q = Y === "delete" || U.length === H.length ? ei(U, Q) : null) || q.addKeys(U), (Q || H) && (O = w, T = Q, S = H, l.indexes.forEach(function(X) {
              var Z = O(X.name || "");
              function he(de) {
                return de != null ? X.extractKey(de) : null;
              }
              function we(de) {
                return X.multiEntry && y(de) ? de.forEach(function(je) {
                  return Z.addKey(je);
                }) : Z.addKey(de);
              }
              (T || S).forEach(function(de, ze) {
                var ce = T && he(T[ze]), ze = S && he(S[ze]);
                be(ce, ze) !== 0 && (ce != null && we(ce), ze != null && we(ze));
              });
            }))) : U ? (H = { from: (H = U.lower) !== null && H !== void 0 ? H : e.MIN_KEY, to: (H = U.upper) !== null && H !== void 0 ? H : e.MAX_KEY }, q.add(H), k.add(H)) : (k.add(o), q.add(o), l.indexes.forEach(function(X) {
              return w(X.name).add(o);
            })), s.mutate(g).then(function(X) {
              return !U || g.type !== "add" && g.type !== "put" || (k.addKeys(X.results), b && b.forEach(function(Z) {
                for (var he = g.values.map(function(ce) {
                  return Z.extractKey(ce);
                }), we = Z.keyPath.findIndex(function(ce) {
                  return ce === d.keyPath;
                }), de = 0, je = X.results.length; de < je; ++de) he[de][we] = X.results[de];
                w(Z.name).addKeys(he);
              })), P.mutatedParts = ar(P.mutatedParts || {}, I), X;
            });
          } }), m = function(w) {
            var O = w.query, w = O.index, O = O.range;
            return [w, new Qe((w = O.lower) !== null && w !== void 0 ? w : e.MIN_KEY, (O = O.upper) !== null && O !== void 0 ? O : e.MAX_KEY)];
          }, N = { get: function(g) {
            return [d, new Qe(g.key)];
          }, getMany: function(g) {
            return [d, new Qe().addKeys(g.keys)];
          }, count: m, query: m, openCursor: m };
          return h(N).forEach(function(g) {
            E[g] = function(w) {
              var O = ne.subscr, T = !!O, S = ti(ne, s) && ni(g, w) ? w.obsSet = {} : O;
              if (T) {
                var P = function(H) {
                  return H = "idb://".concat(t, "/").concat(i, "/").concat(H), S[H] || (S[H] = new Qe());
                }, I = P(""), k = P(":dels"), O = N[g](w), T = O[0], O = O[1];
                if ((g === "query" && T.isPrimaryKey && !w.values ? k : P(T.name || "")).add(O), !T.isPrimaryKey) {
                  if (g !== "count") {
                    var q = g === "query" && v && w.values && s.query(u(u({}, w), { values: !1 }));
                    return s[g].apply(this, arguments).then(function(H) {
                      if (g === "query") {
                        if (v && w.values) return q.then(function(he) {
                          return he = he.result, I.addKeys(he), H;
                        });
                        var Q = w.values ? H.result.map(p) : H.result;
                        (w.values ? I : k).addKeys(Q);
                      } else if (g === "openCursor") {
                        var X = H, Z = w.values;
                        return X && Object.create(X, { key: { get: function() {
                          return k.addKey(X.primaryKey), X.key;
                        } }, primaryKey: { get: function() {
                          var he = X.primaryKey;
                          return k.addKey(he), he;
                        } }, value: { get: function() {
                          return Z && I.addKey(X.primaryKey), X.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  k.add(o);
                }
              }
              return s[g].apply(this, arguments);
            };
          }), E;
        } });
      } };
      function ri(e, t, o) {
        if (o.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var i = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return o.numFailures === i ? null : (t = u({}, t), y(t.keys) && (t.keys = t.keys.filter(function(s, l) {
          return !(l in o.failures);
        })), "values" in t && y(t.values) && (t.values = t.values.filter(function(s, l) {
          return !(l in o.failures);
        })), t);
      }
      function ao(e, t) {
        return o = e, ((i = t).lower === void 0 || (i.lowerOpen ? 0 < be(o, i.lower) : 0 <= be(o, i.lower))) && (e = e, (t = t).upper === void 0 || (t.upperOpen ? be(e, t.upper) < 0 : be(e, t.upper) <= 0));
        var o, i;
      }
      function oi(e, t, N, i, s, l) {
        if (!N || N.length === 0) return e;
        var d = t.query.index, p = d.multiEntry, v = t.query.range, b = i.schema.primaryKey.extractKey, E = d.extractKey, m = (d.lowLevelIndex || d).extractKey, N = N.reduce(function(g, w) {
          var O = g, T = [];
          if (w.type === "add" || w.type === "put") for (var S = new Qe(), P = w.values.length - 1; 0 <= P; --P) {
            var I, k = w.values[P], q = b(k);
            S.hasKey(q) || (I = E(k), (p && y(I) ? I.some(function(X) {
              return ao(X, v);
            }) : ao(I, v)) && (S.addKey(q), T.push(k)));
          }
          switch (w.type) {
            case "add":
              var Y = new Qe().addKeys(t.values ? g.map(function(Z) {
                return b(Z);
              }) : g), O = g.concat(t.values ? T.filter(function(Z) {
                return Z = b(Z), !Y.hasKey(Z) && (Y.addKey(Z), !0);
              }) : T.map(function(Z) {
                return b(Z);
              }).filter(function(Z) {
                return !Y.hasKey(Z) && (Y.addKey(Z), !0);
              }));
              break;
            case "put":
              var U = new Qe().addKeys(w.values.map(function(Z) {
                return b(Z);
              }));
              O = g.filter(function(Z) {
                return !U.hasKey(t.values ? b(Z) : Z);
              }).concat(t.values ? T : T.map(function(Z) {
                return b(Z);
              }));
              break;
            case "delete":
              var H = new Qe().addKeys(w.keys);
              O = g.filter(function(Z) {
                return !H.hasKey(t.values ? b(Z) : Z);
              });
              break;
            case "deleteRange":
              var Q = w.range;
              O = g.filter(function(Z) {
                return !ao(b(Z), Q);
              });
          }
          return O;
        }, e);
        return N === e ? e : (N.sort(function(g, w) {
          return be(m(g), m(w)) || be(b(g), b(w));
        }), t.limit && t.limit < 1 / 0 && (N.length > t.limit ? N.length = t.limit : e.length === t.limit && N.length < t.limit && (s.dirty = !0)), l ? Object.freeze(N) : N);
      }
      function ii(e, t) {
        return be(e.lower, t.lower) === 0 && be(e.upper, t.upper) === 0 && !!e.lowerOpen == !!t.lowerOpen && !!e.upperOpen == !!t.upperOpen;
      }
      function Ps(e, t) {
        return function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = be(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, t.lower, e.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = be(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, t.upper, e.upperOpen, t.upperOpen);
      }
      function Is(e, t, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var s, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (s = e, l = t, setTimeout(function() {
            s.subscribers.size === 0 && Le(l, s);
          }, 3e3));
        });
      }
      var ks = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var t = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, s) {
          var l, d, p = e.transaction(o, i, s);
          return i === "readwrite" && (d = (l = new AbortController()).signal, s = function(v) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var b = /* @__PURE__ */ new Set(), E = 0, m = o; E < m.length; E++) {
                  var N = m[E], g = en["idb://".concat(t, "/").concat(N)];
                  if (g) {
                    var w = e.table(N), O = g.optimisticOps.filter(function(Z) {
                      return Z.trans === p;
                    });
                    if (p._explicit && v && p.mutatedParts) for (var T = 0, S = Object.values(g.queries.query); T < S.length; T++) for (var P = 0, I = (Y = S[T]).slice(); P < I.length; P++) eo((U = I[P]).obsSet, p.mutatedParts) && (Le(Y, U), U.subscribers.forEach(function(Z) {
                      return b.add(Z);
                    }));
                    else if (0 < O.length) {
                      g.optimisticOps = g.optimisticOps.filter(function(Z) {
                        return Z.trans !== p;
                      });
                      for (var k = 0, q = Object.values(g.queries.query); k < q.length; k++) for (var Y, U, H, Q = 0, X = (Y = q[k]).slice(); Q < X.length; Q++) (U = X[Q]).res != null && p.mutatedParts && (v && !U.dirty ? (H = Object.isFrozen(U.res), H = oi(U.res, U.req, O, w, U, H), U.dirty ? (Le(Y, U), U.subscribers.forEach(function(Z) {
                        return b.add(Z);
                      })) : H !== U.res && (U.res = H, U.promise = z.resolve({ result: H }))) : (U.dirty && Le(Y, U), U.subscribers.forEach(function(Z) {
                        return b.add(Z);
                      })));
                    }
                  }
                }
                b.forEach(function(Z) {
                  return Z();
                });
              }
            };
          }, p.addEventListener("abort", s(!1), { signal: d }), p.addEventListener("error", s(!1), { signal: d }), p.addEventListener("complete", s(!0), { signal: d })), p;
        }, table: function(o) {
          var i = e.table(o), s = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var d = ne.trans;
            if (s.outbound || d.db._options.cache === "disabled" || d.explicit || d.idbtrans.mode !== "readwrite") return i.mutate(l);
            var p = en["idb://".concat(t, "/").concat(o)];
            return p ? (d = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || so(s, l).some(function(v) {
              return v == null;
            })) ? (p.optimisticOps.push(l), l.mutatedParts && ur(l.mutatedParts), d.then(function(v) {
              0 < v.numFailures && (Le(p.optimisticOps, l), (v = ri(0, l, v)) && p.optimisticOps.push(v), l.mutatedParts && ur(l.mutatedParts));
            }), d.catch(function() {
              Le(p.optimisticOps, l), l.mutatedParts && ur(l.mutatedParts);
            })) : d.then(function(v) {
              var b = ri(0, u(u({}, l), { values: l.values.map(function(E, m) {
                var N;
                return v.failures[m] ? E : (E = (N = s.keyPath) !== null && N !== void 0 && N.includes(".") ? ot(E) : u({}, E), _e(E, s.keyPath, v.results[m]), E);
              }) }), v);
              p.optimisticOps.push(b), queueMicrotask(function() {
                return l.mutatedParts && ur(l.mutatedParts);
              });
            }), d) : i.mutate(l);
          }, query: function(l) {
            if (!ti(ne, i) || !ni("query", l)) return i.query(l);
            var d = ((b = ne.trans) === null || b === void 0 ? void 0 : b.db._options.cache) === "immutable", m = ne, p = m.requery, v = m.signal, b = function(w, O, T, S) {
              var P = en["idb://".concat(w, "/").concat(O)];
              if (!P) return [];
              if (!(O = P.queries[T])) return [null, !1, P, null];
              var I = O[(S.query ? S.query.index.name : null) || ""];
              if (!I) return [null, !1, P, null];
              switch (T) {
                case "query":
                  var k = I.find(function(q) {
                    return q.req.limit === S.limit && q.req.values === S.values && ii(q.req.query.range, S.query.range);
                  });
                  return k ? [k, !0, P, I] : [I.find(function(q) {
                    return ("limit" in q.req ? q.req.limit : 1 / 0) >= S.limit && (!S.values || q.req.values) && Ps(q.req.query.range, S.query.range);
                  }), !1, P, I];
                case "count":
                  return k = I.find(function(q) {
                    return ii(q.req.query.range, S.query.range);
                  }), [k, !!k, P, I];
              }
            }(t, o, "query", l), E = b[0], m = b[1], N = b[2], g = b[3];
            return E && m ? E.obsSet = l.obsSet : (m = i.query(l).then(function(w) {
              var O = w.result;
              if (E && (E.res = O), d) {
                for (var T = 0, S = O.length; T < S; ++T) Object.freeze(O[T]);
                Object.freeze(O);
              } else w.result = ot(O);
              return w;
            }).catch(function(w) {
              return g && E && Le(g, E), Promise.reject(w);
            }), E = { obsSet: l.obsSet, promise: m, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, g ? g.push(E) : (g = [E], (N = N || (en["idb://".concat(t, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = g)), Is(E, g, p, v), E.promise.then(function(w) {
              return { result: oi(w.result, l, N?.optimisticOps, i, E, d) };
            });
          } });
        } });
      } };
      function cr(e, t) {
        return new Proxy(e, { get: function(o, i, s) {
          return i === "db" ? t : Reflect.get(o, i, s);
        } });
      }
      var Pt = (Me.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new K.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new K.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var t = this._versions, o = t.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), t.push(o), t.sort(ws), o.stores({}), this._state.autoSchema = !1, o);
      }, Me.prototype._whenReady = function(e) {
        var t = this;
        return this.idbdb && (this._state.openComplete || ne.letThrough || this._vip) ? e() : new z(function(o, i) {
          if (t._state.openComplete) return i(new K.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void i(new K.DatabaseClosed());
            t.open().catch(C);
          }
          t._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, Me.prototype.use = function(e) {
        var t = e.stack, o = e.create, i = e.level, s = e.name;
        return s && this.unuse({ stack: t, name: s }), e = this._middlewares[t] || (this._middlewares[t] = []), e.push({ stack: t, create: o, level: i ?? 10, name: s }), e.sort(function(l, d) {
          return l.level - d.level;
        }), this;
      }, Me.prototype.unuse = function(e) {
        var t = e.stack, o = e.name, i = e.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(s) {
          return i ? s.create !== i : !!o && s.name !== o;
        })), this;
      }, Me.prototype.open = function() {
        var e = this;
        return zt(nt, function() {
          return Os(e);
        });
      }, Me.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, t = hn.indexOf(this);
        if (0 <= t && hn.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new z(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new z(function(o, i) {
          e.cancelOpen = i;
        }));
      }, Me.prototype.close = function(o) {
        var t = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        t ? (o.isBeingOpened && o.cancelOpen(new K.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new K.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, Me.prototype.delete = function(e) {
        var t = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new z(function(s, l) {
          function d() {
            t.close(e);
            var p = t._deps.indexedDB.deleteDatabase(t.name);
            p.onsuccess = De(function() {
              var v, b, E;
              v = t._deps, b = t.name, E = v.indexedDB, v = v.IDBKeyRange, zr(E) || b === Xn || Qr(E, v).delete(b).catch(C), s();
            }), p.onerror = xt(l), p.onblocked = t._fireOnBlocked;
          }
          if (o) throw new K.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(d) : d();
        });
      }, Me.prototype.backendDB = function() {
        return this.idbdb;
      }, Me.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Me.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, Me.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Me.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Me.prototype, "tables", { get: function() {
        var e = this;
        return h(this._allTables).map(function(t) {
          return e._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), Me.prototype.transaction = function() {
        var e = (function(t, o, i) {
          var s = arguments.length;
          if (s < 2) throw new K.InvalidArgument("Too few arguments");
          for (var l = new Array(s - 1); --s; ) l[s - 1] = arguments[s];
          return i = l.pop(), [t, Xe(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, Me.prototype._transaction = function(e, t, o) {
        var i = this, s = ne.trans;
        s && s.db === this && e.indexOf("!") === -1 || (s = null);
        var l, d, p = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (d = t.map(function(b) {
            if (b = b instanceof i.Table ? b.name : b, typeof b != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return b;
          }), e == "r" || e === Mr) l = Mr;
          else {
            if (e != "rw" && e != Br) throw new K.InvalidArgument("Invalid transaction mode: " + e);
            l = Br;
          }
          if (s) {
            if (s.mode === Mr && l === Br) {
              if (!p) throw new K.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              s = null;
            }
            s && d.forEach(function(b) {
              if (s && s.storeNames.indexOf(b) === -1) {
                if (!p) throw new K.SubTransaction("Table " + b + " not included in parent transaction.");
                s = null;
              }
            }), p && s && !s.active && (s = null);
          }
        } catch (b) {
          return s ? s._promise(null, function(E, m) {
            m(b);
          }) : Fe(b);
        }
        var v = (function b(E, m, N, g, w) {
          return z.resolve().then(function() {
            var O = ne.transless || ne, T = E._createTransaction(m, N, E._dbSchema, g);
            if (T.explicit = !0, O = { trans: T, transless: O }, g) T.idbtrans = g.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, E._state.PR1398_maxLoop = 3;
            } catch (I) {
              return I.name === A.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                return b(E, m, N, null, w);
              })) : Fe(I);
            }
            var S, P = bt(w);
            return P && pn(), O = z.follow(function() {
              var I;
              (S = w.call(T, T)) && (P ? (I = Kt.bind(null, null), S.then(I, I)) : typeof S.next == "function" && typeof S.throw == "function" && (S = oo(S)));
            }, O), (S && typeof S.then == "function" ? z.resolve(S).then(function(I) {
              return T.active ? I : Fe(new K.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : O.then(function() {
              return S;
            })).then(function(I) {
              return g && T._resolve(), T._completion.then(function() {
                return I;
              });
            }).catch(function(I) {
              return T._reject(I), Fe(I);
            });
          });
        }).bind(null, this, l, d, s, o);
        return s ? s._promise(l, v, "lock") : ne.trans ? zt(ne.transless, function() {
          return i._whenReady(v);
        }) : this._whenReady(v);
      }, Me.prototype.table = function(e) {
        if (!R(this._allTables, e)) throw new K.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, Me);
      function Me(e, t) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = Me.dependencies;
        this._options = t = u({ addons: Me.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, i = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var s, l, d, p, v, b = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: C, dbReadyPromise: null, cancelOpen: C, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        b.dbReadyPromise = new z(function(m) {
          b.dbReadyResolve = m;
        }), b.openCanceller = new z(function(m, N) {
          b.cancelOpen = N;
        }), this._state = b, this.name = e, this.on = En(this, "populate", "blocked", "versionchange", "close", { ready: [le, C] }), this.once = function(m, N) {
          var g = function() {
            for (var w = [], O = 0; O < arguments.length; O++) w[O] = arguments[O];
            o.on(m).unsubscribe(g), N.apply(o, w);
          };
          return o.on(m, g);
        }, this.on.ready.subscribe = fe(this.on.ready.subscribe, function(m) {
          return function(N, g) {
            Me.vip(function() {
              var w, O = o._state;
              O.openComplete ? (O.dbOpenError || z.resolve().then(N), g && m(N)) : O.onReadyBeingFired ? (O.onReadyBeingFired.push(N), g && m(N)) : (m(N), w = o, g || m(function T() {
                w.on.ready.unsubscribe(N), w.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (s = this, Tn(hs.prototype, function(S, T) {
          this.db = s;
          var g = jo, w = null;
          if (T) try {
            g = T();
          } catch (P) {
            w = P;
          }
          var O = S._ctx, T = O.table, S = T.hook.reading.fire;
          this._ctx = { table: T, index: O.index, isPrimKey: !O.index || T.schema.primKey.keyPath && O.index === T.schema.primKey.name, range: g, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: O.or, valueMapper: S !== F ? S : null };
        })), this.Table = (l = this, Tn(Mo.prototype, function(m, N, g) {
          this.db = l, this._tx = g, this.name = m, this.schema = N, this.hook = l._allTables[m] ? l._allTables[m].hook : En(null, { creating: [ue, C], reading: [ee, F], updating: [pe, C], deleting: [ie, C] });
        })), this.Transaction = (d = this, Tn(vs.prototype, function(m, N, g, w, O) {
          var T = this;
          m !== "readonly" && N.forEach(function(S) {
            S = (S = g[S]) === null || S === void 0 ? void 0 : S.yProps, S && (N = N.concat(S.map(function(P) {
              return P.updatesTable;
            })));
          }), this.db = d, this.mode = m, this.storeNames = N, this.schema = g, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = En(this, "complete", "error", "abort"), this.parent = O || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new z(function(S, P) {
            T._resolve = S, T._reject = P;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(S) {
            var P = T.active;
            return T.active = !1, T.on.error.fire(S), T.parent ? T.parent._reject(S) : P && T.idbtrans && T.idbtrans.abort(), Fe(S);
          });
        })), this.Version = (p = this, Tn(Ts.prototype, function(m) {
          this.db = p, this._cfg = { version: m, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (v = this, Tn(Ho.prototype, function(m, N, g) {
          if (this.db = v, this._ctx = { table: m, index: N === ":id" ? null : N, or: g }, this._cmp = this._ascending = be, this._descending = function(w, O) {
            return be(O, w);
          }, this._max = function(w, O) {
            return 0 < be(w, O) ? w : O;
          }, this._min = function(w, O) {
            return be(w, O) < 0 ? w : O;
          }, this._IDBKeyRange = v._deps.IDBKeyRange, !this._IDBKeyRange) throw new K.MissingAPI();
        })), this.on("versionchange", function(m) {
          0 < m.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(m) {
          !m.newVersion || m.newVersion < m.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(m.oldVersion / 10));
        }), this._maxKey = Cn(t.IDBKeyRange), this._createTransaction = function(m, N, g, w) {
          return new o.Transaction(m, N, g, o._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(m) {
          o.on("blocked").fire(m), hn.filter(function(N) {
            return N.name === o.name && N !== o && !N._state.vcFired;
          }).map(function(N) {
            return N.on("versionchange").fire(m);
          });
        }, this.use(Cs), this.use(ks), this.use(As), this.use(Ns), this.use(Ss);
        var E = new Proxy(this, { get: function(m, N, g) {
          if (N === "_vip") return !0;
          if (N === "table") return function(O) {
            return cr(o.table(O), E);
          };
          var w = Reflect.get(m, N, g);
          return w instanceof Mo ? cr(w, E) : N === "tables" ? w.map(function(O) {
            return cr(O, E);
          }) : N === "_createTransaction" ? function() {
            return cr(w.apply(this, arguments), E);
          } : w;
        } });
        this.vip = E, i.forEach(function(m) {
          return m(o);
        });
      }
      var fr, vt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ds = (uo.prototype.subscribe = function(e, t, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: o });
      }, uo.prototype[vt] = function() {
        return this;
      }, uo);
      function uo(e) {
        this._subscribe = e;
      }
      try {
        fr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
      } catch {
        fr = { indexedDB: null, IDBKeyRange: null };
      }
      function si(e) {
        var t, o = !1, i = new Ds(function(s) {
          var l = bt(e), d, p = !1, v = {}, b = {}, E = { get closed() {
            return p;
          }, unsubscribe: function() {
            p || (p = !0, d && d.abort(), m && Bt.storagemutated.unsubscribe(g));
          } };
          s.start && s.start(E);
          var m = !1, N = function() {
            return Fr(w);
          }, g = function(O) {
            ar(v, O), eo(b, v) && N();
          }, w = function() {
            var O, T, S;
            !p && fr.indexedDB && (v = {}, O = {}, d && d.abort(), d = new AbortController(), S = function(P) {
              var I = fn();
              try {
                l && pn();
                var k = Lt(e, P);
                return k = l ? k.finally(Kt) : k;
              } finally {
                I && dn();
              }
            }(T = { subscr: O, signal: d.signal, requery: N, querier: e, trans: null }), Promise.resolve(S).then(function(P) {
              o = !0, t = P, p || T.signal.aborted || (v = {}, function(I) {
                for (var k in I) if (R(I, k)) return;
                return 1;
              }(b = O) || m || (Bt(Sn, g), m = !0), Fr(function() {
                return !p && s.next && s.next(P);
              }));
            }, function(P) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(P?.name) || p || Fr(function() {
                p || s.error && s.error(P);
              });
            }));
          };
          return setTimeout(N, 0), E;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return t;
        }, i;
      }
      var tn = Pt;
      function lo(e) {
        var t = qt;
        try {
          qt = !0, Bt.storagemutated.fire(e), ro(e, !0);
        } finally {
          qt = t;
        }
      }
      $(tn, u(u({}, Ue), { delete: function(e) {
        return new tn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new tn(e, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return t = tn.dependencies, o = t.indexedDB, t = t.IDBKeyRange, (zr(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(s) {
              return s.name;
            }).filter(function(s) {
              return s !== Xn;
            });
          }) : Qr(o, t).toCollection().primaryKeys()).then(e);
        } catch {
          return Fe(new K.MissingAPI());
        }
        var t, o;
      }, defineClass: function() {
        return function(e) {
          _(this, e);
        };
      }, ignoreTransaction: function(e) {
        return ne.trans ? zt(ne.transless, e) : e();
      }, vip: Jr, async: function(e) {
        return function() {
          try {
            var t = oo(e.apply(this, arguments));
            return t && typeof t.then == "function" ? t : z.resolve(t);
          } catch (o) {
            return Fe(o);
          }
        };
      }, spawn: function(e, t, o) {
        try {
          var i = oo(e.apply(o, t || []));
          return i && typeof i.then == "function" ? i : z.resolve(i);
        } catch (s) {
          return Fe(s);
        }
      }, currentTransaction: { get: function() {
        return ne.trans || null;
      } }, waitFor: function(e, t) {
        return t = z.resolve(typeof e == "function" ? tn.ignoreTransaction(e) : e).timeout(t || 6e4), ne.trans ? ne.trans.waitFor(t) : t;
      }, Promise: z, debug: { get: function() {
        return se;
      }, set: function(e) {
        Oe(e);
      } }, derive: re, extend: _, props: $, override: fe, Events: En, on: Bt, liveQuery: si, extendObservabilitySet: ar, getByKeyPath: Ce, setByKeyPath: _e, delByKeyPath: function(e, t) {
        typeof t == "string" ? _e(e, t, void 0) : "length" in t && [].map.call(t, function(o) {
          _e(e, o, void 0);
        });
      }, shallowClone: Ae, deepClone: ot, getObjectDiff: io, cmp: be, asap: ge, minKey: -1 / 0, addons: [], connections: hn, errnames: A, dependencies: fr, cache: en, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, t, o) {
        return e + t / Math.pow(10, 2 * o);
      }) })), tn.maxKey = Cn(tn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Bt(Sn, function(e) {
        qt || (e = new CustomEvent(Ur, { detail: e }), qt = !0, dispatchEvent(e), qt = !1);
      }), addEventListener(Ur, function(e) {
        e = e.detail, qt || lo(e);
      }));
      var _n, qt = !1, ai = function() {
      };
      return typeof BroadcastChannel < "u" && ((ai = function() {
        (_n = new BroadcastChannel(Ur)).onmessage = function(e) {
          return e.data && lo(e.data);
        };
      })(), typeof _n.unref == "function" && _n.unref(), Bt(Sn, function(e) {
        qt || _n.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Pt.disableBfCache && e.persisted) {
          se && console.debug("Dexie: handling persisted pagehide"), _n?.close();
          for (var t = 0, o = hn; t < o.length; t++) o[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Pt.disableBfCache && e.persisted && (se && console.debug("Dexie: handling persisted pageshow"), ai(), lo({ all: new Qe(-1 / 0, [[]]) }));
      })), z.rejectionMapper = function(e, t) {
        return !e || e instanceof Rt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !V[e.name] ? e : (t = new V[e.name](t || e.message, e), "stack" in e && J(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Oe(se), u(Pt, Object.freeze({ __proto__: null, Dexie: Pt, liveQuery: si, Entity: Lo, cmp: be, PropModification: On, replacePrefix: function(e, t) {
        return new On({ replacePrefix: [e, t] });
      }, add: function(e) {
        return new On({ add: e });
      }, remove: function(e) {
        return new On({ remove: e });
      }, default: Pt, RangeSet: Qe, mergeRanges: In, rangesOverlap: Qo }), { default: Pt }), Pt;
    });
  }(Fi)), Fi.exports;
}
var zd = Qd();
const aa = /* @__PURE__ */ Yd(zd), _u = Symbol.for("Dexie"), Xi = globalThis[_u] || (globalThis[_u] = aa);
if (aa.semVer !== Xi.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${aa.semVer} and ${Xi.semVer}`);
const {
  liveQuery: ym,
  mergeRanges: vm,
  rangesOverlap: gm,
  RangeSet: bm,
  cmp: _m,
  Entity: wm,
  PropModification: xm,
  replacePrefix: Em,
  add: Tm,
  remove: Om,
  DexieYProvider: Nm
} = Xi;
var Jd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Zd(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
function ep(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var r = n.default;
  if (typeof r == "function") {
    var a = function u() {
      var c = !1;
      try {
        c = this instanceof u;
      } catch {
      }
      return c ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    a.prototype = r.prototype;
  } else a = {};
  return Object.defineProperty(a, "__esModule", { value: !0 }), Object.keys(n).forEach(function(u) {
    var c = Object.getOwnPropertyDescriptor(n, u);
    Object.defineProperty(a, u, c.get ? c : {
      enumerable: !0,
      get: function() {
        return n[u];
      }
    });
  }), a;
}
var wu = {};
const tp = {}, np = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tp
}, Symbol.toStringTag, { value: "Module" })), xu = /* @__PURE__ */ ep(np);
var Eu;
function rp() {
  return Eu || (Eu = 1, function(n) {
    (function(r) {
      r.parser = function(A, x) {
        return new u(A, x);
      }, r.SAXParser = u, r.SAXStream = D, r.createStream = j, r.MAX_BUFFER_LENGTH = 64 * 1024;
      var a = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      r.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function u(A, x) {
        if (!(this instanceof u))
          return new u(A, x);
        var K = this;
        f(K), K.q = K.c = "", K.bufferCheckPosition = r.MAX_BUFFER_LENGTH, K.opt = x || {}, K.opt.lowercase = K.opt.lowercase || K.opt.lowercasetags, K.looseCase = K.opt.lowercase ? "toLowerCase" : "toUpperCase", K.tags = [], K.closed = K.closedRoot = K.sawRoot = !1, K.tag = K.error = null, K.strict = !!A, K.noscript = !!(A || K.opt.noscript), K.state = B.BEGIN, K.strictEntities = K.opt.strictEntities, K.ENTITIES = K.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), K.attribList = [], K.opt.xmlns && (K.ns = Object.create(re)), K.opt.unquotedAttributeValues === void 0 && (K.opt.unquotedAttributeValues = !A), K.trackPosition = K.opt.position !== !1, K.trackPosition && (K.position = K.line = K.column = 0), ct(K, "onready");
      }
      Object.create || (Object.create = function(A) {
        function x() {
        }
        x.prototype = A;
        var K = new x();
        return K;
      }), Object.keys || (Object.keys = function(A) {
        var x = [];
        for (var K in A) A.hasOwnProperty(K) && x.push(K);
        return x;
      });
      function c(A) {
        for (var x = Math.max(r.MAX_BUFFER_LENGTH, 10), K = 0, V = 0, Ue = a.length; V < Ue; V++) {
          var C = A[a[V]].length;
          if (C > x)
            switch (a[V]) {
              case "textNode":
                ot(A);
                break;
              case "cdata":
                Ke(A, "oncdata", A.cdata), A.cdata = "";
                break;
              case "script":
                Ke(A, "onscript", A.script), A.script = "";
                break;
              default:
                kt(A, "Max buffer length exceeded: " + a[V]);
            }
          K = Math.max(K, C);
        }
        var F = r.MAX_BUFFER_LENGTH - K;
        A.bufferCheckPosition = F + A.position;
      }
      function f(A) {
        for (var x = 0, K = a.length; x < K; x++)
          A[a[x]] = "";
      }
      function h(A) {
        ot(A), A.cdata !== "" && (Ke(A, "oncdata", A.cdata), A.cdata = ""), A.script !== "" && (Ke(A, "onscript", A.script), A.script = "");
      }
      u.prototype = {
        end: function() {
          tt(this);
        },
        write: wt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          h(this);
        }
      };
      var y;
      try {
        y = xu.Stream;
      } catch {
        y = function() {
        };
      }
      y || (y = function() {
      });
      var _ = r.EVENTS.filter(function(A) {
        return A !== "error" && A !== "end";
      });
      function j(A, x) {
        return new D(A, x);
      }
      function D(A, x) {
        if (!(this instanceof D))
          return new D(A, x);
        y.apply(this), this._parser = new u(A, x), this.writable = !0, this.readable = !0;
        var K = this;
        this._parser.onend = function() {
          K.emit("end");
        }, this._parser.onerror = function(V) {
          K.emit("error", V), K._parser.error = null;
        }, this._decoder = null, _.forEach(function(V) {
          Object.defineProperty(K, "on" + V, {
            get: function() {
              return K._parser["on" + V];
            },
            set: function(Ue) {
              if (!Ue)
                return K.removeAllListeners(V), K._parser["on" + V] = Ue, Ue;
              K.on(V, Ue);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      D.prototype = Object.create(y.prototype, {
        constructor: {
          value: D
        }
      }), D.prototype.write = function(A) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(A)) {
          if (!this._decoder) {
            var x = xu.StringDecoder;
            this._decoder = new x("utf8");
          }
          A = this._decoder.write(A);
        }
        return this._parser.write(A.toString()), this.emit("data", A), !0;
      }, D.prototype.end = function(A) {
        return A && A.length && this.write(A), this._parser.end(), !0;
      }, D.prototype.on = function(A, x) {
        var K = this;
        return !K._parser["on" + A] && _.indexOf(A) !== -1 && (K._parser["on" + A] = function() {
          var V = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          V.splice(0, 0, A), K.emit.apply(K, V);
        }), y.prototype.on.call(K, A, x);
      };
      var R = "[CDATA[", $ = "DOCTYPE", W = "http://www.w3.org/XML/1998/namespace", J = "http://www.w3.org/2000/xmlns/", re = { xml: W, xmlns: J }, te = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, M = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, G = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, fe = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function ae(A) {
        return A === " " || A === `
` || A === "\r" || A === "	";
      }
      function ge(A) {
        return A === '"' || A === "'";
      }
      function Ce(A) {
        return A === ">" || ae(A);
      }
      function _e(A, x) {
        return A.test(x);
      }
      function Ae(A, x) {
        return !_e(A, x);
      }
      var B = 0;
      r.STATE = {
        BEGIN: B++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: B++,
        // leading whitespace
        TEXT: B++,
        // general stuff
        TEXT_ENTITY: B++,
        // &amp and such.
        OPEN_WAKA: B++,
        // <
        SGML_DECL: B++,
        // <!BLARG
        SGML_DECL_QUOTED: B++,
        // <!BLARG foo "bar
        DOCTYPE: B++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: B++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: B++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: B++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: B++,
        // <!-
        COMMENT: B++,
        // <!--
        COMMENT_ENDING: B++,
        // <!-- blah -
        COMMENT_ENDED: B++,
        // <!-- blah --
        CDATA: B++,
        // <![CDATA[ something
        CDATA_ENDING: B++,
        // ]
        CDATA_ENDING_2: B++,
        // ]]
        PROC_INST: B++,
        // <?hi
        PROC_INST_BODY: B++,
        // <?hi there
        PROC_INST_ENDING: B++,
        // <?hi "there" ?
        OPEN_TAG: B++,
        // <strong
        OPEN_TAG_SLASH: B++,
        // <strong /
        ATTRIB: B++,
        // <a
        ATTRIB_NAME: B++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: B++,
        // <a foo _
        ATTRIB_VALUE: B++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: B++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: B++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: B++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: B++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: B++,
        // <foo bar=&quot
        CLOSE_TAG: B++,
        // </a
        CLOSE_TAG_SAW_WHITE: B++,
        // </a   >
        SCRIPT: B++,
        // <script> ...
        SCRIPT_ENDING: B++
        // <script> ... <
      }, r.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, r.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(r.ENTITIES).forEach(function(A) {
        var x = r.ENTITIES[A], K = typeof x == "number" ? String.fromCharCode(x) : x;
        r.ENTITIES[A] = K;
      });
      for (var Xe in r.STATE)
        r.STATE[r.STATE[Xe]] = Xe;
      B = r.STATE;
      function ct(A, x, K) {
        A[x] && A[x](K);
      }
      function Ke(A, x, K) {
        A.textNode && ot(A), ct(A, x, K);
      }
      function ot(A) {
        A.textNode = bn(A.opt, A.textNode), A.textNode && ct(A, "ontext", A.textNode), A.textNode = "";
      }
      function bn(A, x) {
        return A.trim && (x = x.trim()), A.normalize && (x = x.replace(/\s+/g, " ")), x;
      }
      function kt(A, x) {
        return ot(A), A.trackPosition && (x += `
Line: ` + A.line + `
Column: ` + A.column + `
Char: ` + A.c), x = new Error(x), A.error = x, ct(A, "onerror", x), A;
      }
      function tt(A) {
        return A.sawRoot && !A.closedRoot && xe(A, "Unclosed root tag"), A.state !== B.BEGIN && A.state !== B.BEGIN_WHITESPACE && A.state !== B.TEXT && kt(A, "Unexpected end"), ot(A), A.c = "", A.closed = !0, ct(A, "onend"), u.call(A, A.strict, A.opt), A;
      }
      function xe(A, x) {
        if (typeof A != "object" || !(A instanceof u))
          throw new Error("bad call to strictFail");
        A.strict && kt(A, x);
      }
      function Le(A) {
        A.strict || (A.tagName = A.tagName[A.looseCase]());
        var x = A.tags[A.tags.length - 1] || A, K = A.tag = { name: A.tagName, attributes: {} };
        A.opt.xmlns && (K.ns = x.ns), A.attribList.length = 0, Ke(A, "onopentagstart", K);
      }
      function yt(A, x) {
        var K = A.indexOf(":"), V = K < 0 ? ["", A] : A.split(":"), Ue = V[0], C = V[1];
        return x && A === "xmlns" && (Ue = "xmlns", C = ""), { prefix: Ue, local: C };
      }
      function at(A) {
        if (A.strict || (A.attribName = A.attribName[A.looseCase]()), A.attribList.indexOf(A.attribName) !== -1 || A.tag.attributes.hasOwnProperty(A.attribName)) {
          A.attribName = A.attribValue = "";
          return;
        }
        if (A.opt.xmlns) {
          var x = yt(A.attribName, !0), K = x.prefix, V = x.local;
          if (K === "xmlns")
            if (V === "xml" && A.attribValue !== W)
              xe(
                A,
                "xml: prefix must be bound to " + W + `
Actual: ` + A.attribValue
              );
            else if (V === "xmlns" && A.attribValue !== J)
              xe(
                A,
                "xmlns: prefix must be bound to " + J + `
Actual: ` + A.attribValue
              );
            else {
              var Ue = A.tag, C = A.tags[A.tags.length - 1] || A;
              Ue.ns === C.ns && (Ue.ns = Object.create(C.ns)), Ue.ns[V] = A.attribValue;
            }
          A.attribList.push([A.attribName, A.attribValue]);
        } else
          A.tag.attributes[A.attribName] = A.attribValue, Ke(A, "onattribute", {
            name: A.attribName,
            value: A.attribValue
          });
        A.attribName = A.attribValue = "";
      }
      function bt(A, x) {
        if (A.opt.xmlns) {
          var K = A.tag, V = yt(A.tagName);
          K.prefix = V.prefix, K.local = V.local, K.uri = K.ns[V.prefix] || "", K.prefix && !K.uri && (xe(A, "Unbound namespace prefix: " + JSON.stringify(A.tagName)), K.uri = V.prefix);
          var Ue = A.tags[A.tags.length - 1] || A;
          K.ns && Ue.ns !== K.ns && Object.keys(K.ns).forEach(function(Oe) {
            Ke(A, "onopennamespace", {
              prefix: Oe,
              uri: K.ns[Oe]
            });
          });
          for (var C = 0, F = A.attribList.length; C < F; C++) {
            var ee = A.attribList[C], oe = ee[0], ue = ee[1], ie = yt(oe, !0), pe = ie.prefix, me = ie.local, le = pe === "" ? "" : K.ns[pe] || "", se = {
              name: oe,
              value: ue,
              prefix: pe,
              local: me,
              uri: le
            };
            pe && pe !== "xmlns" && !le && (xe(A, "Unbound namespace prefix: " + JSON.stringify(pe)), se.uri = pe), A.tag.attributes[oe] = se, Ke(A, "onattribute", se);
          }
          A.attribList.length = 0;
        }
        A.tag.isSelfClosing = !!x, A.sawRoot = !0, A.tags.push(A.tag), Ke(A, "onopentag", A.tag), x || (!A.noscript && A.tagName.toLowerCase() === "script" ? A.state = B.SCRIPT : A.state = B.TEXT, A.tag = null, A.tagName = ""), A.attribName = A.attribValue = "", A.attribList.length = 0;
      }
      function Dt(A) {
        if (!A.tagName) {
          xe(A, "Weird empty close tag."), A.textNode += "</>", A.state = B.TEXT;
          return;
        }
        if (A.script) {
          if (A.tagName !== "script") {
            A.script += "</" + A.tagName + ">", A.tagName = "", A.state = B.SCRIPT;
            return;
          }
          Ke(A, "onscript", A.script), A.script = "";
        }
        var x = A.tags.length, K = A.tagName;
        A.strict || (K = K[A.looseCase]());
        for (var V = K; x--; ) {
          var Ue = A.tags[x];
          if (Ue.name !== V)
            xe(A, "Unexpected close tag");
          else
            break;
        }
        if (x < 0) {
          xe(A, "Unmatched closing tag: " + A.tagName), A.textNode += "</" + A.tagName + ">", A.state = B.TEXT;
          return;
        }
        A.tagName = K;
        for (var C = A.tags.length; C-- > x; ) {
          var F = A.tag = A.tags.pop();
          A.tagName = A.tag.name, Ke(A, "onclosetag", A.tagName);
          var ee = {};
          for (var oe in F.ns)
            ee[oe] = F.ns[oe];
          var ue = A.tags[A.tags.length - 1] || A;
          A.opt.xmlns && F.ns !== ue.ns && Object.keys(F.ns).forEach(function(ie) {
            var pe = F.ns[ie];
            Ke(A, "onclosenamespace", { prefix: ie, uri: pe });
          });
        }
        x === 0 && (A.closedRoot = !0), A.tagName = A.attribValue = A.attribName = "", A.attribList.length = 0, A.state = B.TEXT;
      }
      function Rt(A) {
        var x = A.entity, K = x.toLowerCase(), V, Ue = "";
        return A.ENTITIES[x] ? A.ENTITIES[x] : A.ENTITIES[K] ? A.ENTITIES[K] : (x = K, x.charAt(0) === "#" && (x.charAt(1) === "x" ? (x = x.slice(2), V = parseInt(x, 16), Ue = V.toString(16)) : (x = x.slice(1), V = parseInt(x, 10), Ue = V.toString(10))), x = x.replace(/^0+/, ""), isNaN(V) || Ue.toLowerCase() !== x ? (xe(A, "Invalid character entity"), "&" + A.entity + ";") : String.fromCodePoint(V));
      }
      function jn(A, x) {
        x === "<" ? (A.state = B.OPEN_WAKA, A.startTagPosition = A.position) : ae(x) || (xe(A, "Non-whitespace before first tag."), A.textNode = x, A.state = B.TEXT);
      }
      function an(A, x) {
        var K = "";
        return x < A.length && (K = A.charAt(x)), K;
      }
      function wt(A) {
        var x = this;
        if (this.error)
          throw this.error;
        if (x.closed)
          return kt(
            x,
            "Cannot write after close. Assign an onready handler."
          );
        if (A === null)
          return tt(x);
        typeof A == "object" && (A = A.toString());
        for (var K = 0, V = ""; V = an(A, K++), x.c = V, !!V; )
          switch (x.trackPosition && (x.position++, V === `
` ? (x.line++, x.column = 0) : x.column++), x.state) {
            case B.BEGIN:
              if (x.state = B.BEGIN_WHITESPACE, V === "\uFEFF")
                continue;
              jn(x, V);
              continue;
            case B.BEGIN_WHITESPACE:
              jn(x, V);
              continue;
            case B.TEXT:
              if (x.sawRoot && !x.closedRoot) {
                for (var Ue = K - 1; V && V !== "<" && V !== "&"; )
                  V = an(A, K++), V && x.trackPosition && (x.position++, V === `
` ? (x.line++, x.column = 0) : x.column++);
                x.textNode += A.substring(Ue, K - 1);
              }
              V === "<" && !(x.sawRoot && x.closedRoot && !x.strict) ? (x.state = B.OPEN_WAKA, x.startTagPosition = x.position) : (!ae(V) && (!x.sawRoot || x.closedRoot) && xe(x, "Text data outside of root node."), V === "&" ? x.state = B.TEXT_ENTITY : x.textNode += V);
              continue;
            case B.SCRIPT:
              V === "<" ? x.state = B.SCRIPT_ENDING : x.script += V;
              continue;
            case B.SCRIPT_ENDING:
              V === "/" ? x.state = B.CLOSE_TAG : (x.script += "<" + V, x.state = B.SCRIPT);
              continue;
            case B.OPEN_WAKA:
              if (V === "!")
                x.state = B.SGML_DECL, x.sgmlDecl = "";
              else if (!ae(V)) if (_e(te, V))
                x.state = B.OPEN_TAG, x.tagName = V;
              else if (V === "/")
                x.state = B.CLOSE_TAG, x.tagName = "";
              else if (V === "?")
                x.state = B.PROC_INST, x.procInstName = x.procInstBody = "";
              else {
                if (xe(x, "Unencoded <"), x.startTagPosition + 1 < x.position) {
                  var C = x.position - x.startTagPosition;
                  V = new Array(C).join(" ") + V;
                }
                x.textNode += "<" + V, x.state = B.TEXT;
              }
              continue;
            case B.SGML_DECL:
              if (x.sgmlDecl + V === "--") {
                x.state = B.COMMENT, x.comment = "", x.sgmlDecl = "";
                continue;
              }
              x.doctype && x.doctype !== !0 && x.sgmlDecl ? (x.state = B.DOCTYPE_DTD, x.doctype += "<!" + x.sgmlDecl + V, x.sgmlDecl = "") : (x.sgmlDecl + V).toUpperCase() === R ? (Ke(x, "onopencdata"), x.state = B.CDATA, x.sgmlDecl = "", x.cdata = "") : (x.sgmlDecl + V).toUpperCase() === $ ? (x.state = B.DOCTYPE, (x.doctype || x.sawRoot) && xe(
                x,
                "Inappropriately located doctype declaration"
              ), x.doctype = "", x.sgmlDecl = "") : V === ">" ? (Ke(x, "onsgmldeclaration", x.sgmlDecl), x.sgmlDecl = "", x.state = B.TEXT) : (ge(V) && (x.state = B.SGML_DECL_QUOTED), x.sgmlDecl += V);
              continue;
            case B.SGML_DECL_QUOTED:
              V === x.q && (x.state = B.SGML_DECL, x.q = ""), x.sgmlDecl += V;
              continue;
            case B.DOCTYPE:
              V === ">" ? (x.state = B.TEXT, Ke(x, "ondoctype", x.doctype), x.doctype = !0) : (x.doctype += V, V === "[" ? x.state = B.DOCTYPE_DTD : ge(V) && (x.state = B.DOCTYPE_QUOTED, x.q = V));
              continue;
            case B.DOCTYPE_QUOTED:
              x.doctype += V, V === x.q && (x.q = "", x.state = B.DOCTYPE);
              continue;
            case B.DOCTYPE_DTD:
              V === "]" ? (x.doctype += V, x.state = B.DOCTYPE) : V === "<" ? (x.state = B.OPEN_WAKA, x.startTagPosition = x.position) : ge(V) ? (x.doctype += V, x.state = B.DOCTYPE_DTD_QUOTED, x.q = V) : x.doctype += V;
              continue;
            case B.DOCTYPE_DTD_QUOTED:
              x.doctype += V, V === x.q && (x.state = B.DOCTYPE_DTD, x.q = "");
              continue;
            case B.COMMENT:
              V === "-" ? x.state = B.COMMENT_ENDING : x.comment += V;
              continue;
            case B.COMMENT_ENDING:
              V === "-" ? (x.state = B.COMMENT_ENDED, x.comment = bn(x.opt, x.comment), x.comment && Ke(x, "oncomment", x.comment), x.comment = "") : (x.comment += "-" + V, x.state = B.COMMENT);
              continue;
            case B.COMMENT_ENDED:
              V !== ">" ? (xe(x, "Malformed comment"), x.comment += "--" + V, x.state = B.COMMENT) : x.doctype && x.doctype !== !0 ? x.state = B.DOCTYPE_DTD : x.state = B.TEXT;
              continue;
            case B.CDATA:
              V === "]" ? x.state = B.CDATA_ENDING : x.cdata += V;
              continue;
            case B.CDATA_ENDING:
              V === "]" ? x.state = B.CDATA_ENDING_2 : (x.cdata += "]" + V, x.state = B.CDATA);
              continue;
            case B.CDATA_ENDING_2:
              V === ">" ? (x.cdata && Ke(x, "oncdata", x.cdata), Ke(x, "onclosecdata"), x.cdata = "", x.state = B.TEXT) : V === "]" ? x.cdata += "]" : (x.cdata += "]]" + V, x.state = B.CDATA);
              continue;
            case B.PROC_INST:
              V === "?" ? x.state = B.PROC_INST_ENDING : ae(V) ? x.state = B.PROC_INST_BODY : x.procInstName += V;
              continue;
            case B.PROC_INST_BODY:
              if (!x.procInstBody && ae(V))
                continue;
              V === "?" ? x.state = B.PROC_INST_ENDING : x.procInstBody += V;
              continue;
            case B.PROC_INST_ENDING:
              V === ">" ? (Ke(x, "onprocessinginstruction", {
                name: x.procInstName,
                body: x.procInstBody
              }), x.procInstName = x.procInstBody = "", x.state = B.TEXT) : (x.procInstBody += "?" + V, x.state = B.PROC_INST_BODY);
              continue;
            case B.OPEN_TAG:
              _e(M, V) ? x.tagName += V : (Le(x), V === ">" ? bt(x) : V === "/" ? x.state = B.OPEN_TAG_SLASH : (ae(V) || xe(x, "Invalid character in tag name"), x.state = B.ATTRIB));
              continue;
            case B.OPEN_TAG_SLASH:
              V === ">" ? (bt(x, !0), Dt(x)) : (xe(x, "Forward-slash in opening tag not followed by >"), x.state = B.ATTRIB);
              continue;
            case B.ATTRIB:
              if (ae(V))
                continue;
              V === ">" ? bt(x) : V === "/" ? x.state = B.OPEN_TAG_SLASH : _e(te, V) ? (x.attribName = V, x.attribValue = "", x.state = B.ATTRIB_NAME) : xe(x, "Invalid attribute name");
              continue;
            case B.ATTRIB_NAME:
              V === "=" ? x.state = B.ATTRIB_VALUE : V === ">" ? (xe(x, "Attribute without value"), x.attribValue = x.attribName, at(x), bt(x)) : ae(V) ? x.state = B.ATTRIB_NAME_SAW_WHITE : _e(M, V) ? x.attribName += V : xe(x, "Invalid attribute name");
              continue;
            case B.ATTRIB_NAME_SAW_WHITE:
              if (V === "=")
                x.state = B.ATTRIB_VALUE;
              else {
                if (ae(V))
                  continue;
                xe(x, "Attribute without value"), x.tag.attributes[x.attribName] = "", x.attribValue = "", Ke(x, "onattribute", {
                  name: x.attribName,
                  value: ""
                }), x.attribName = "", V === ">" ? bt(x) : _e(te, V) ? (x.attribName = V, x.state = B.ATTRIB_NAME) : (xe(x, "Invalid attribute name"), x.state = B.ATTRIB);
              }
              continue;
            case B.ATTRIB_VALUE:
              if (ae(V))
                continue;
              ge(V) ? (x.q = V, x.state = B.ATTRIB_VALUE_QUOTED) : (x.opt.unquotedAttributeValues || kt(x, "Unquoted attribute value"), x.state = B.ATTRIB_VALUE_UNQUOTED, x.attribValue = V);
              continue;
            case B.ATTRIB_VALUE_QUOTED:
              if (V !== x.q) {
                V === "&" ? x.state = B.ATTRIB_VALUE_ENTITY_Q : x.attribValue += V;
                continue;
              }
              at(x), x.q = "", x.state = B.ATTRIB_VALUE_CLOSED;
              continue;
            case B.ATTRIB_VALUE_CLOSED:
              ae(V) ? x.state = B.ATTRIB : V === ">" ? bt(x) : V === "/" ? x.state = B.OPEN_TAG_SLASH : _e(te, V) ? (xe(x, "No whitespace between attributes"), x.attribName = V, x.attribValue = "", x.state = B.ATTRIB_NAME) : xe(x, "Invalid attribute name");
              continue;
            case B.ATTRIB_VALUE_UNQUOTED:
              if (!Ce(V)) {
                V === "&" ? x.state = B.ATTRIB_VALUE_ENTITY_U : x.attribValue += V;
                continue;
              }
              at(x), V === ">" ? bt(x) : x.state = B.ATTRIB;
              continue;
            case B.CLOSE_TAG:
              if (x.tagName)
                V === ">" ? Dt(x) : _e(M, V) ? x.tagName += V : x.script ? (x.script += "</" + x.tagName, x.tagName = "", x.state = B.SCRIPT) : (ae(V) || xe(x, "Invalid tagname in closing tag"), x.state = B.CLOSE_TAG_SAW_WHITE);
              else {
                if (ae(V))
                  continue;
                Ae(te, V) ? x.script ? (x.script += "</" + V, x.state = B.SCRIPT) : xe(x, "Invalid tagname in closing tag.") : x.tagName = V;
              }
              continue;
            case B.CLOSE_TAG_SAW_WHITE:
              if (ae(V))
                continue;
              V === ">" ? Dt(x) : xe(x, "Invalid characters in closing tag");
              continue;
            case B.TEXT_ENTITY:
            case B.ATTRIB_VALUE_ENTITY_Q:
            case B.ATTRIB_VALUE_ENTITY_U:
              var F, ee;
              switch (x.state) {
                case B.TEXT_ENTITY:
                  F = B.TEXT, ee = "textNode";
                  break;
                case B.ATTRIB_VALUE_ENTITY_Q:
                  F = B.ATTRIB_VALUE_QUOTED, ee = "attribValue";
                  break;
                case B.ATTRIB_VALUE_ENTITY_U:
                  F = B.ATTRIB_VALUE_UNQUOTED, ee = "attribValue";
                  break;
              }
              if (V === ";") {
                var oe = Rt(x);
                x.opt.unparsedEntities && !Object.values(r.XML_ENTITIES).includes(oe) ? (x.entity = "", x.state = F, x.write(oe)) : (x[ee] += oe, x.entity = "", x.state = F);
              } else _e(x.entity.length ? fe : G, V) ? x.entity += V : (xe(x, "Invalid character in entity name"), x[ee] += "&" + x.entity + V, x.entity = "", x.state = F);
              continue;
            default:
              throw new Error(x, "Unknown state: " + x.state);
          }
        return x.position >= x.bufferCheckPosition && c(x), x;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var A = String.fromCharCode, x = Math.floor, K = function() {
          var V = 16384, Ue = [], C, F, ee = -1, oe = arguments.length;
          if (!oe)
            return "";
          for (var ue = ""; ++ee < oe; ) {
            var ie = Number(arguments[ee]);
            if (!isFinite(ie) || // `NaN`, `+Infinity`, or `-Infinity`
            ie < 0 || // not a valid Unicode code point
            ie > 1114111 || // not a valid Unicode code point
            x(ie) !== ie)
              throw RangeError("Invalid code point: " + ie);
            ie <= 65535 ? Ue.push(ie) : (ie -= 65536, C = (ie >> 10) + 55296, F = ie % 1024 + 56320, Ue.push(C, F)), (ee + 1 === oe || Ue.length > V) && (ue += A.apply(null, Ue), Ue.length = 0);
          }
          return ue;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: K,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = K;
      }();
    })(n);
  }(wu)), wu;
}
rp();
var ua = { exports: {} }, op = ua.exports, Tu;
function ip() {
  return Tu || (Tu = 1, function(n, r) {
    (function(a, u) {
      n.exports = u();
    })(op, function() {
      var a = function(e, t) {
        return (a = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (o[s] = i[s]);
        })(e, t);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var t, o = 1, i = arguments.length; o < i; o++) for (var s in t = arguments[o]) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, t, o) {
        for (var i, s = 0, l = t.length; s < l; s++) !i && s in t || ((i = i || Array.prototype.slice.call(t, 0, s))[s] = t[s]);
        return e.concat(i || Array.prototype.slice.call(t));
      }
      var f = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Jd, h = Object.keys, y = Array.isArray;
      function _(e, t) {
        return typeof t != "object" || h(t).forEach(function(o) {
          e[o] = t[o];
        }), e;
      }
      typeof Promise > "u" || f.Promise || (f.Promise = Promise);
      var j = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function R(e, t) {
        return D.call(e, t);
      }
      function $(e, t) {
        typeof t == "function" && (t = t(j(e))), (typeof Reflect > "u" ? h : Reflect.ownKeys)(t).forEach(function(o) {
          J(e, o, t[o]);
        });
      }
      var W = Object.defineProperty;
      function J(e, t, o, i) {
        W(e, t, _(o && R(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function re(e) {
        return { from: function(t) {
          return e.prototype = Object.create(t.prototype), J(e.prototype, "constructor", e), { extend: $.bind(null, e.prototype) };
        } };
      }
      var te = Object.getOwnPropertyDescriptor, M = [].slice;
      function G(e, t, o) {
        return M.call(e, t, o);
      }
      function fe(e, t) {
        return t(e);
      }
      function ae(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function ge(e) {
        f.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function Ce(e, t) {
        if (typeof t == "string" && R(e, t)) return e[t];
        if (!t) return e;
        if (typeof t != "string") {
          for (var o = [], i = 0, s = t.length; i < s; ++i) {
            var l = Ce(e, t[i]);
            o.push(l);
          }
          return o;
        }
        var d = t.indexOf(".");
        if (d !== -1) {
          var p = e[t.substr(0, d)];
          return p == null ? void 0 : Ce(p, t.substr(d + 1));
        }
      }
      function _e(e, t, o) {
        if (e && t !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof t != "string" && "length" in t) {
          ae(typeof o != "string" && "length" in o);
          for (var i = 0, s = t.length; i < s; ++i) _e(e, t[i], o[i]);
        } else {
          var l, d, p = t.indexOf(".");
          p !== -1 ? (l = t.substr(0, p), (d = t.substr(p + 1)) === "" ? o === void 0 ? y(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : _e(p = !(p = e[l]) || !R(e, l) ? e[l] = {} : p, d, o)) : o === void 0 ? y(e) && !isNaN(parseInt(t)) ? e.splice(t, 1) : delete e[t] : e[t] = o;
        }
      }
      function Ae(e) {
        var t, o = {};
        for (t in e) R(e, t) && (o[t] = e[t]);
        return o;
      }
      var B = [].concat;
      function Xe(e) {
        return B.apply([], e);
      }
      var ke = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Xe([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(t) {
          return t + e + "Array";
        });
      }))).filter(function(e) {
        return f[e];
      }), ct = new Set(ke.map(function(e) {
        return f[e];
      })), Ke = null;
      function ot(e) {
        return Ke = /* @__PURE__ */ new WeakMap(), e = function t(o) {
          if (!o || typeof o != "object") return o;
          var i = Ke.get(o);
          if (i) return i;
          if (y(o)) {
            i = [], Ke.set(o, i);
            for (var s = 0, l = o.length; s < l; ++s) i.push(t(o[s]));
          } else if (ct.has(o.constructor)) i = o;
          else {
            var d, p = j(o);
            for (d in i = p === Object.prototype ? {} : Object.create(p), Ke.set(o, i), o) R(o, d) && (i[d] = t(o[d]));
          }
          return i;
        }(e), Ke = null, e;
      }
      var bn = {}.toString;
      function kt(e) {
        return bn.call(e).slice(8, -1);
      }
      var tt = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", xe = typeof tt == "symbol" ? function(e) {
        var t;
        return e != null && (t = e[tt]) && t.apply(e);
      } : function() {
        return null;
      };
      function Le(e, t) {
        return t = e.indexOf(t), 0 <= t && e.splice(t, 1), 0 <= t;
      }
      var yt = {};
      function at(e) {
        var t, o, i, s;
        if (arguments.length === 1) {
          if (y(e)) return e.slice();
          if (this === yt && typeof e == "string") return [e];
          if (s = xe(e)) {
            for (o = []; !(i = s.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (t = e.length) != "number") return [e];
          for (o = new Array(t); t--; ) o[t] = e[t];
          return o;
        }
        for (t = arguments.length, o = new Array(t); t--; ) o[t] = arguments[t];
        return o;
      }
      var bt = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Se = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], vt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Se), Dt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Rt(e, t) {
        this.name = e, this.message = t;
      }
      function jn(e, t) {
        return e + ". Errors: " + Object.keys(t).map(function(o) {
          return t[o].toString();
        }).filter(function(o, i, s) {
          return s.indexOf(o) === i;
        }).join(`
`);
      }
      function an(e, t, o, i) {
        this.failures = t, this.failedKeys = i, this.successCount = o, this.message = jn(e, t);
      }
      function wt(e, t) {
        this.name = "BulkError", this.failures = Object.keys(t).map(function(o) {
          return t[o];
        }), this.failuresByPos = t, this.message = jn(e, this.failures);
      }
      re(Rt).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), re(an).from(Rt), re(wt).from(Rt);
      var A = vt.reduce(function(e, t) {
        return e[t] = t + "Error", e;
      }, {}), x = Rt, K = vt.reduce(function(e, t) {
        var o = t + "Error";
        function i(s, l) {
          this.name = o, s ? typeof s == "string" ? (this.message = "".concat(s).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof s == "object" && (this.message = "".concat(s.name, " ").concat(s.message), this.inner = s) : (this.message = Dt[t] || o, this.inner = null);
        }
        return re(i).from(x), e[t] = i, e;
      }, {});
      K.Syntax = SyntaxError, K.Type = TypeError, K.Range = RangeError;
      var V = Se.reduce(function(e, t) {
        return e[t + "Error"] = K[t], e;
      }, {}), Ue = vt.reduce(function(e, t) {
        return ["Syntax", "Type", "Range"].indexOf(t) === -1 && (e[t + "Error"] = K[t]), e;
      }, {});
      function C() {
      }
      function F(e) {
        return e;
      }
      function ee(e, t) {
        return e == null || e === F ? t : function(o) {
          return t(e(o));
        };
      }
      function oe(e, t) {
        return function() {
          e.apply(this, arguments), t.apply(this, arguments);
        };
      }
      function ue(e, t) {
        return e === C ? t : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, s = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = t.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? oe(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? oe(s, this.onerror) : s), l !== void 0 ? l : o;
        };
      }
      function ie(e, t) {
        return e === C ? t : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, t.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? oe(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? oe(i, this.onerror) : i);
        };
      }
      function pe(e, t) {
        return e === C ? t : function(o) {
          var i = e.apply(this, arguments);
          _(o, i);
          var s = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = t.apply(this, arguments), s && (this.onsuccess = this.onsuccess ? oe(s, this.onsuccess) : s), l && (this.onerror = this.onerror ? oe(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : _(i, o);
        };
      }
      function me(e, t) {
        return e === C ? t : function() {
          return t.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function le(e, t) {
        return e === C ? t : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, s = arguments.length, l = new Array(s); s--; ) l[s] = arguments[s];
            return o.then(function() {
              return t.apply(i, l);
            });
          }
          return t.apply(this, arguments);
        };
      }
      Ue.ModifyError = an, Ue.DexieError = Rt, Ue.BulkError = wt;
      var se = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Oe(e) {
        se = e;
      }
      var ye = {}, Ne = 100, ke = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, j(e), e];
        var t = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [t, j(t), e];
      }(), Se = ke[0], vt = ke[1], ke = ke[2], vt = vt && vt.then, $e = Se && Se.constructor, He = !!ke, dt = function(e, t) {
        un.push([e, t]), Ot && (queueMicrotask(cs), Ot = !1);
      }, _t = !0, Ot = !0, pt = [], Xt = [], Ln = F, nt = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: C, pgp: !1, env: {}, finalize: C }, ne = nt, un = [], Qt = 0, Un = [];
      function z(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var t = this._PSD = ne;
        if (typeof e != "function") {
          if (e !== ye) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && jr(this, this._value));
        }
        this._state = null, this._value = null, ++t.ref, function o(i, s) {
          try {
            s(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var d = i._lib && fn();
                l && typeof l.then == "function" ? o(i, function(p, v) {
                  l instanceof z ? l._then(p, v) : l.then(p, v);
                }) : (i._state = !0, i._value = l, Io(i)), d && dn();
              }
            }, jr.bind(null, i));
          } catch (l) {
            jr(i, l);
          }
        }(this, e);
      }
      var Rr = { get: function() {
        var e = ne, t = Gn;
        function o(i, s) {
          var l = this, d = !e.global && (e !== ne || t !== Gn), p = d && !Kt(), v = new z(function(b, E) {
            Lr(l, new Po(Do(i, e, d, p), Do(s, e, d, p), b, E, e));
          });
          return this._consoleTask && (v._consoleTask = this._consoleTask), v;
        }
        return o.prototype = ye, o;
      }, set: function(e) {
        J(this, "then", e && e.prototype === ye ? Rr : { get: function() {
          return e;
        }, set: Rr.set });
      } };
      function Po(e, t, o, i, s) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof t == "function" ? t : null, this.resolve = o, this.reject = i, this.psd = s;
      }
      function jr(e, t) {
        var o, i;
        Xt.push(t), e._state === null && (o = e._lib && fn(), t = Ln(t), e._state = !1, e._value = t, i = e, pt.some(function(s) {
          return s._value === i._value;
        }) || pt.push(i), Io(e), o && dn());
      }
      function Io(e) {
        var t = e._listeners;
        e._listeners = [];
        for (var o = 0, i = t.length; o < i; ++o) Lr(e, t[o]);
        var s = e._PSD;
        --s.ref || s.finalize(), Qt === 0 && (++Qt, dt(function() {
          --Qt == 0 && Kr();
        }, []));
      }
      function Lr(e, t) {
        if (e._state !== null) {
          var o = e._state ? t.onFulfilled : t.onRejected;
          if (o === null) return (e._state ? t.resolve : t.reject)(e._value);
          ++t.psd.ref, ++Qt, dt(ls, [o, e, t]);
        } else e._listeners.push(t);
      }
      function ls(e, t, o) {
        try {
          var i, s = t._value;
          !t._state && Xt.length && (Xt = []), i = se && t._consoleTask ? t._consoleTask.run(function() {
            return e(s);
          }) : e(s), t._state || Xt.indexOf(s) !== -1 || function(l) {
            for (var d = pt.length; d; ) if (pt[--d]._value === l._value) return pt.splice(d, 1);
          }(t), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Qt == 0 && Kr(), --o.psd.ref || o.psd.finalize();
        }
      }
      function cs() {
        zt(nt, function() {
          fn() && dn();
        });
      }
      function fn() {
        var e = _t;
        return Ot = _t = !1, e;
      }
      function dn() {
        var e, t, o;
        do
          for (; 0 < un.length; ) for (e = un, un = [], o = e.length, t = 0; t < o; ++t) {
            var i = e[t];
            i[0].apply(null, i[1]);
          }
        while (0 < un.length);
        Ot = _t = !0;
      }
      function Kr() {
        var e = pt;
        pt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var t = Un.slice(0), o = t.length; o; ) t[--o]();
      }
      function Vn(e) {
        return new z(ye, !1, e);
      }
      function De(e, t) {
        var o = ne;
        return function() {
          var i = fn(), s = ne;
          try {
            return Ft(o, !0), e.apply(this, arguments);
          } catch (l) {
            t && t(l);
          } finally {
            Ft(s, !1), i && dn();
          }
        };
      }
      $(z.prototype, { then: Rr, _then: function(e, t) {
        Lr(this, new Po(null, null, e, t, ne));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var t = e, o = arguments[1];
        return typeof t == "function" ? this.then(null, function(i) {
          return (i instanceof t ? o : Vn)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === t ? o : Vn)(i);
        });
      }, finally: function(e) {
        return this.then(function(t) {
          return z.resolve(e()).then(function() {
            return t;
          });
        }, function(t) {
          return z.resolve(e()).then(function() {
            return Vn(t);
          });
        });
      }, timeout: function(e, t) {
        var o = this;
        return e < 1 / 0 ? new z(function(i, s) {
          var l = setTimeout(function() {
            return s(new K.Timeout(t));
          }, e);
          o.then(i, s).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && J(z.prototype, Symbol.toStringTag, "Dexie.Promise"), nt.env = ko(), $(z, { all: function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t, o) {
          e.length === 0 && t([]);
          var i = e.length;
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(d) {
              e[l] = d, --i || t(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof z ? e : e && typeof e.then == "function" ? new z(function(t, o) {
          e.then(t, o);
        }) : new z(ye, !0, e);
      }, reject: Vn, race: function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t, o) {
          e.map(function(i) {
            return z.resolve(i).then(t, o);
          });
        });
      }, PSD: { get: function() {
        return ne;
      }, set: function(e) {
        return ne = e;
      } }, totalEchoes: { get: function() {
        return Gn;
      } }, newPSD: Lt, usePSD: zt, scheduler: { get: function() {
        return dt;
      }, set: function(e) {
        dt = e;
      } }, rejectionMapper: { get: function() {
        return Ln;
      }, set: function(e) {
        Ln = e;
      } }, follow: function(e, t) {
        return new z(function(o, i) {
          return Lt(function(s, l) {
            var d = ne;
            d.unhandleds = [], d.onunhandled = l, d.finalize = oe(function() {
              var p, v = this;
              p = function() {
                v.unhandleds.length === 0 ? s() : l(v.unhandleds[0]);
              }, Un.push(function b() {
                p(), Un.splice(Un.indexOf(b), 1);
              }), ++Qt, dt(function() {
                --Qt == 0 && Kr();
              }, []);
            }, d.finalize), e();
          }, t, o, i);
        });
      } }), $e && ($e.allSettled && J(z, "allSettled", function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t) {
          e.length === 0 && t([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(s, l) {
            return z.resolve(s).then(function(d) {
              return i[l] = { status: "fulfilled", value: d };
            }, function(d) {
              return i[l] = { status: "rejected", reason: d };
            }).then(function() {
              return --o || t(i);
            });
          });
        });
      }), $e.any && typeof AggregateError < "u" && J(z, "any", function() {
        var e = at.apply(null, arguments).map(Yn);
        return new z(function(t, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, s = new Array(i);
          e.forEach(function(l, d) {
            return z.resolve(l).then(function(p) {
              return t(p);
            }, function(p) {
              s[d] = p, --i || o(new AggregateError(s));
            });
          });
        });
      }), $e.withResolvers && (z.withResolvers = $e.withResolvers));
      var We = { awaits: 0, echoes: 0, id: 0 }, fs = 0, Hn = [], Wn = 0, Gn = 0, ds = 0;
      function Lt(e, t, o, i) {
        var s = ne, l = Object.create(s);
        return l.parent = s, l.ref = 0, l.global = !1, l.id = ++ds, nt.env, l.env = He ? { Promise: z, PromiseProp: { value: z, configurable: !0, writable: !0 }, all: z.all, race: z.race, allSettled: z.allSettled, any: z.any, resolve: z.resolve, reject: z.reject } : {}, t && _(l, t), ++s.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function pn() {
        return We.id || (We.id = ++fs), ++We.awaits, We.echoes += Ne, We.id;
      }
      function Kt() {
        return !!We.awaits && (--We.awaits == 0 && (We.id = 0), We.echoes = We.awaits * Ne, !0);
      }
      function Yn(e) {
        return We.echoes && e && e.constructor === $e ? (pn(), e.then(function(t) {
          return Kt(), t;
        }, function(t) {
          return Kt(), Fe(t);
        })) : e;
      }
      function ps() {
        var e = Hn[Hn.length - 1];
        Hn.pop(), Ft(e, !1);
      }
      function Ft(e, t) {
        var o, i = ne;
        (t ? !We.echoes || Wn++ && e === ne : !Wn || --Wn && e === ne) || queueMicrotask(t ? (function(s) {
          ++Gn, We.echoes && --We.echoes != 0 || (We.echoes = We.awaits = We.id = 0), Hn.push(ne), Ft(s, !0);
        }).bind(null, e) : ps), e !== ne && (ne = e, i === nt && (nt.env = ko()), He && (o = nt.env.Promise, t = e.env, (i.global || e.global) && (Object.defineProperty(f, "Promise", t.PromiseProp), o.all = t.all, o.race = t.race, o.resolve = t.resolve, o.reject = t.reject, t.allSettled && (o.allSettled = t.allSettled), t.any && (o.any = t.any))));
      }
      function ko() {
        var e = f.Promise;
        return He ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(f, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function zt(e, t, o, i, s) {
        var l = ne;
        try {
          return Ft(e, !0), t(o, i, s);
        } finally {
          Ft(l, !1);
        }
      }
      function Do(e, t, o, i) {
        return typeof e != "function" ? e : function() {
          var s = ne;
          o && pn(), Ft(t, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            Ft(s, !1), i && queueMicrotask(Kt);
          }
        };
      }
      function Fr(e) {
        Promise === $e && We.echoes === 0 ? Wn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + vt).indexOf("[native code]") === -1 && (pn = Kt = C);
      var Fe = z.reject, Jt = "￿", At = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Ro = "String expected.", hn = [], Xn = "__dbnames", Mr = "readonly", Br = "readwrite";
      function Zt(e, t) {
        return e ? t ? function() {
          return e.apply(this, arguments) && t.apply(this, arguments);
        } : e : t;
      }
      var jo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function Qn(e) {
        return typeof e != "string" || /\./.test(e) ? function(t) {
          return t;
        } : function(t) {
          return t[e] === void 0 && e in t && delete (t = ot(t))[e], t;
        };
      }
      function Lo() {
        throw K.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function be(e, t) {
        try {
          var o = Ko(e), i = Ko(t);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return t < e ? 1 : e < t ? -1 : 0;
            case "binary":
              return function(s, l) {
                for (var d = s.length, p = l.length, v = d < p ? d : p, b = 0; b < v; ++b) if (s[b] !== l[b]) return s[b] < l[b] ? -1 : 1;
                return d === p ? 0 : d < p ? -1 : 1;
              }(Fo(e), Fo(t));
            case "Array":
              return function(s, l) {
                for (var d = s.length, p = l.length, v = d < p ? d : p, b = 0; b < v; ++b) {
                  var E = be(s[b], l[b]);
                  if (E !== 0) return E;
                }
                return d === p ? 0 : d < p ? -1 : 1;
              }(e, t);
          }
        } catch {
        }
        return NaN;
      }
      function Ko(e) {
        var t = typeof e;
        return t != "object" ? t : ArrayBuffer.isView(e) ? "binary" : (e = kt(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function Fo(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function zn(e, t, o) {
        var i = e.schema.yProps;
        return i ? (t && 0 < o.numFailures && (t = t.filter(function(s, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(s) {
          return s = s.updatesTable, t ? e.db.table(s).where("k").anyOf(t).delete() : e.db.table(s).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Mo = (Pe.prototype._trans = function(e, t, o) {
        var i = this._tx || ne.trans, s = this.name, l = se && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function d(b, E, m) {
          if (!m.schema[s]) throw new K.NotFound("Table " + s + " not part of transaction");
          return t(m.idbtrans, m);
        }
        var p = fn();
        try {
          var v = i && i.db._novip === this.db._novip ? i === ne.trans ? i._promise(e, d, o) : Lt(function() {
            return i._promise(e, d, o);
          }, { trans: i, transless: ne.transless || ne }) : function b(E, m, N, g) {
            if (E.idbdb && (E._state.openComplete || ne.letThrough || E._vip)) {
              var w = E._createTransaction(m, N, E._dbSchema);
              try {
                w.create(), E._state.PR1398_maxLoop = 3;
              } catch (O) {
                return O.name === A.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                  return b(E, m, N, g);
                })) : Fe(O);
              }
              return w._promise(m, function(O, T) {
                return Lt(function() {
                  return ne.trans = w, g(O, T, w);
                });
              }).then(function(O) {
                if (m === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return m === "readonly" ? O : w._completion.then(function() {
                  return O;
                });
              });
            }
            if (E._state.openComplete) return Fe(new K.DatabaseClosed(E._state.dbOpenError));
            if (!E._state.isBeingOpened) {
              if (!E._state.autoOpen) return Fe(new K.DatabaseClosed());
              E.open().catch(C);
            }
            return E._state.dbReadyPromise.then(function() {
              return b(E, m, N, g);
            });
          }(this.db, e, [this.name], d);
          return l && (v._consoleTask = l, v = v.catch(function(b) {
            return console.trace(b), Fe(b);
          })), v;
        } finally {
          p && dn();
        }
      }, Pe.prototype.get = function(e, t) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(t) : e == null ? Fe(new K.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(s) {
            return o.hook.reading.fire(s);
          });
        }).then(t);
      }, Pe.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (y(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var t = h(e);
        if (t.length === 1) return this.where(t[0]).equals(e[t[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(p) {
          if (p.compound && t.every(function(b) {
            return 0 <= p.keyPath.indexOf(b);
          })) {
            for (var v = 0; v < t.length; ++v) if (t.indexOf(p.keyPath[v]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(p, v) {
          return p.keyPath.length - v.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== Jt) {
          var l = o.keyPath.slice(0, t.length);
          return this.where(l).equals(l.map(function(v) {
            return e[v];
          }));
        }
        !o && se && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(t.join("+"), "]"));
        var i = this.schema.idxByName;
        function s(p, v) {
          return be(p, v) === 0;
        }
        var d = t.reduce(function(m, v) {
          var b = m[0], E = m[1], m = i[v], N = e[v];
          return [b || m, b || !m ? Zt(E, m && m.multi ? function(g) {
            return g = Ce(g, v), y(g) && g.some(function(w) {
              return s(N, w);
            });
          } : function(g) {
            return s(N, Ce(g, v));
          }) : E];
        }, [null, null]), l = d[0], d = d[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(d) : o ? this.filter(d) : this.where(t).equals("");
      }, Pe.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Pe.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Pe.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Pe.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Pe.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Pe.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Pe.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Pe.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, y(e) ? "[".concat(e.join("+"), "]") : e));
      }, Pe.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Pe.prototype.mapToClass = function(e) {
        var t, o = this.db, i = this.name;
        function s() {
          return t !== null && t.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Lo && (function(v, b) {
          if (typeof b != "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function E() {
            this.constructor = v;
          }
          a(v, b), v.prototype = b === null ? Object.create(b) : (E.prototype = b.prototype, new E());
        }(s, t = e), Object.defineProperty(s.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), s.prototype.table = function() {
          return i;
        }, e = s);
        for (var l = /* @__PURE__ */ new Set(), d = e.prototype; d; d = j(d)) Object.getOwnPropertyNames(d).forEach(function(v) {
          return l.add(v);
        });
        function p(v) {
          if (!v) return v;
          var b, E = Object.create(e.prototype);
          for (b in v) if (!l.has(b)) try {
            E[b] = v[b];
          } catch {
          }
          return E;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = p, this.hook("reading", p), e;
      }, Pe.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          _(this, e);
        });
      }, Pe.prototype.add = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, d = e;
        return l && s && (d = Qn(l)(e)), this._trans("readwrite", function(p) {
          return o.core.mutate({ trans: p, type: "add", keys: t != null ? [t] : null, values: [d] });
        }).then(function(p) {
          return p.numFailures ? z.reject(p.failures[0]) : p.lastResult;
        }).then(function(p) {
          if (l) try {
            _e(e, l, p);
          } catch {
          }
          return p;
        });
      }, Pe.prototype.update = function(e, t) {
        return typeof e != "object" || y(e) ? this.where(":id").equals(e).modify(t) : (e = Ce(e, this.schema.primKey.keyPath), e === void 0 ? Fe(new K.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(t));
      }, Pe.prototype.put = function(e, t) {
        var o = this, i = this.schema.primKey, s = i.auto, l = i.keyPath, d = e;
        return l && s && (d = Qn(l)(e)), this._trans("readwrite", function(p) {
          return o.core.mutate({ trans: p, type: "put", values: [d], keys: t != null ? [t] : null });
        }).then(function(p) {
          return p.numFailures ? z.reject(p.failures[0]) : p.lastResult;
        }).then(function(p) {
          if (l) try {
            _e(e, l, p);
          } catch {
          }
          return p;
        });
      }, Pe.prototype.delete = function(e) {
        var t = this;
        return this._trans("readwrite", function(o) {
          return t.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return zn(t, [e], i);
          }).then(function(i) {
            return i.numFailures ? z.reject(i.failures[0]) : void 0;
          });
        });
      }, Pe.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(t) {
          return e.core.mutate({ trans: t, type: "deleteRange", range: jo }).then(function(o) {
            return zn(e, null, o);
          });
        }).then(function(t) {
          return t.numFailures ? z.reject(t.failures[0]) : void 0;
        });
      }, Pe.prototype.bulkGet = function(e) {
        var t = this;
        return this._trans("readonly", function(o) {
          return t.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(s) {
              return t.hook.reading.fire(s);
            });
          });
        });
      }, Pe.prototype.bulkAdd = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var b = i.schema.primKey, p = b.auto, b = b.keyPath;
          if (b && s) throw new K.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && p ? e.map(Qn(b)) : e;
          return i.core.mutate({ trans: d, type: "add", keys: s, values: b, wantResults: l }).then(function(w) {
            var m = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (m === 0) return l ? N : g;
            throw new wt("".concat(i.name, ".bulkAdd(): ").concat(m, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Pe.prototype.bulkPut = function(e, t, o) {
        var i = this, s = Array.isArray(t) ? t : void 0, l = (o = o || (s ? void 0 : t)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(d) {
          var b = i.schema.primKey, p = b.auto, b = b.keyPath;
          if (b && s) throw new K.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (s && s.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && p ? e.map(Qn(b)) : e;
          return i.core.mutate({ trans: d, type: "put", keys: s, values: b, wantResults: l }).then(function(w) {
            var m = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (m === 0) return l ? N : g;
            throw new wt("".concat(i.name, ".bulkPut(): ").concat(m, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Pe.prototype.bulkUpdate = function(e) {
        var t = this, o = this.core, i = e.map(function(d) {
          return d.key;
        }), s = e.map(function(d) {
          return d.changes;
        }), l = [];
        return this._trans("readwrite", function(d) {
          return o.getMany({ trans: d, keys: i, cache: "clone" }).then(function(p) {
            var v = [], b = [];
            e.forEach(function(m, N) {
              var g = m.key, w = m.changes, O = p[N];
              if (O) {
                for (var T = 0, S = Object.keys(w); T < S.length; T++) {
                  var P = S[T], I = w[P];
                  if (P === t.schema.primKey.keyPath) {
                    if (be(I, g) !== 0) throw new K.Constraint("Cannot update primary key in bulkUpdate()");
                  } else _e(O, P, I);
                }
                l.push(N), v.push(g), b.push(O);
              }
            });
            var E = v.length;
            return o.mutate({ trans: d, type: "put", keys: v, values: b, updates: { keys: i, changeSpecs: s } }).then(function(m) {
              var N = m.numFailures, g = m.failures;
              if (N === 0) return E;
              for (var w = 0, O = Object.keys(g); w < O.length; w++) {
                var T, S = O[w], P = l[Number(S)];
                P != null && (T = g[S], delete g[S], g[P] = T);
              }
              throw new wt("".concat(t.name, ".bulkUpdate(): ").concat(N, " of ").concat(E, " operations failed"), g);
            });
          });
        });
      }, Pe.prototype.bulkDelete = function(e) {
        var t = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return t.core.mutate({ trans: i, type: "delete", keys: e }).then(function(s) {
            return zn(t, e, s);
          });
        }).then(function(d) {
          var s = d.numFailures, l = d.lastResult, d = d.failures;
          if (s === 0) return l;
          throw new wt("".concat(t.name, ".bulkDelete(): ").concat(s, " of ").concat(o, " operations failed"), d);
        });
      }, Pe);
      function Pe() {
      }
      function En(e) {
        function t(d, p) {
          if (p) {
            for (var v = arguments.length, b = new Array(v - 1); --v; ) b[v - 1] = arguments[v];
            return o[d].subscribe.apply(null, b), e;
          }
          if (typeof d == "string") return o[d];
        }
        var o = {};
        t.addEventType = l;
        for (var i = 1, s = arguments.length; i < s; ++i) l(arguments[i]);
        return t;
        function l(d, p, v) {
          if (typeof d != "object") {
            var b;
            p = p || me;
            var E = { subscribers: [], fire: v = v || C, subscribe: function(m) {
              E.subscribers.indexOf(m) === -1 && (E.subscribers.push(m), E.fire = p(E.fire, m));
            }, unsubscribe: function(m) {
              E.subscribers = E.subscribers.filter(function(N) {
                return N !== m;
              }), E.fire = E.subscribers.reduce(p, v);
            } };
            return o[d] = t[d] = E;
          }
          h(b = d).forEach(function(m) {
            var N = b[m];
            if (y(N)) l(m, b[m][0], b[m][1]);
            else {
              if (N !== "asap") throw new K.InvalidArgument("Invalid event config");
              var g = l(m, F, function() {
                for (var w = arguments.length, O = new Array(w); w--; ) O[w] = arguments[w];
                g.subscribers.forEach(function(T) {
                  ge(function() {
                    T.apply(null, O);
                  });
                });
              });
            }
          });
        }
      }
      function Tn(e, t) {
        return re(t).from({ prototype: e }), t;
      }
      function mn(e, t) {
        return !(e.filter || e.algorithm || e.or) && (t ? e.justLimit : !e.replayFilter);
      }
      function qr(e, t) {
        e.filter = Zt(e.filter, t);
      }
      function $r(e, t, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return Zt(i(), t());
        } : t, e.justLimit = o && !i;
      }
      function Jn(e, t) {
        if (e.isPrimKey) return t.primaryKey;
        var o = t.getIndexByKeyPath(e.index);
        if (!o) throw new K.Schema("KeyPath " + e.index + " on object store " + t.name + " is not indexed");
        return o;
      }
      function Bo(e, t, o) {
        var i = Jn(e, t.schema);
        return t.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function Zn(e, t, o, i) {
        var s = e.replayFilter ? Zt(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, d = function(p, v, b) {
            var E, m;
            s && !s(v, b, function(N) {
              return v.stop(N);
            }, function(N) {
              return v.fail(N);
            }) || ((m = "" + (E = v.primaryKey)) == "[object ArrayBuffer]" && (m = "" + new Uint8Array(E)), R(l, m) || (l[m] = !0, t(p, v, b)));
          };
          return Promise.all([e.or._iterate(d, o), qo(Bo(e, i, o), e.algorithm, d, !e.keysOnly && e.valueMapper)]);
        }
        return qo(Bo(e, i, o), Zt(e.algorithm, s), t, !e.keysOnly && e.valueMapper);
      }
      function qo(e, t, o, i) {
        var s = De(i ? function(l, d, p) {
          return o(i(l), d, p);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var d = function() {
              return l.continue();
            };
            t && !t(l, function(p) {
              return d = p;
            }, function(p) {
              l.stop(p), d = C;
            }, function(p) {
              l.fail(p), d = C;
            }) || s(l.value, l, function(p) {
              return d = p;
            }), d();
          });
        });
      }
      var On = ($o.prototype.execute = function(e) {
        var t = this["@@propmod"];
        if (t.add !== void 0) {
          var o = t.add;
          if (y(o)) return c(c([], y(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (t.remove !== void 0) {
          var i = t.remove;
          if (y(i)) return y(e) ? e.filter(function(s) {
            return !i.includes(s);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = t.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? t.replacePrefix[1] + e.substring(o.length) : e;
      }, $o);
      function $o(e) {
        this["@@propmod"] = e;
      }
      var hs = (Te.prototype._read = function(e, t) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, Fe.bind(null, o.error)) : o.table._trans("readonly", e).then(t);
      }, Te.prototype._write = function(e) {
        var t = this._ctx;
        return t.error ? t.table._trans(null, Fe.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
      }, Te.prototype._addAlgorithm = function(e) {
        var t = this._ctx;
        t.algorithm = Zt(t.algorithm, e);
      }, Te.prototype._iterate = function(e, t) {
        return Zn(this._ctx, e, t, this._ctx.table.core);
      }, Te.prototype.clone = function(e) {
        var t = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && _(o, e), t._ctx = o, t;
      }, Te.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Te.prototype.each = function(e) {
        var t = this._ctx;
        return this._read(function(o) {
          return Zn(t, e, o, t.table.core);
        });
      }, Te.prototype.count = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx, s = i.table.core;
          if (mn(i, !0)) return s.count({ trans: o, query: { index: Jn(i, s.schema), range: i.range } }).then(function(d) {
            return Math.min(d, i.limit);
          });
          var l = 0;
          return Zn(i, function() {
            return ++l, !1;
          }, o, s).then(function() {
            return l;
          });
        }).then(e);
      }, Te.prototype.sortBy = function(e, t) {
        var o = e.split(".").reverse(), i = o[0], s = o.length - 1;
        function l(v, b) {
          return b ? l(v[o[b]], b - 1) : v[i];
        }
        var d = this._ctx.dir === "next" ? 1 : -1;
        function p(v, b) {
          return be(l(v, s), l(b, s)) * d;
        }
        return this.toArray(function(v) {
          return v.sort(p);
        }).then(t);
      }, Te.prototype.toArray = function(e) {
        var t = this;
        return this._read(function(o) {
          var i = t._ctx;
          if (i.dir === "next" && mn(i, !0) && 0 < i.limit) {
            var s = i.valueMapper, l = Jn(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(p) {
              return p = p.result, s ? p.map(s) : p;
            });
          }
          var d = [];
          return Zn(i, function(p) {
            return d.push(p);
          }, o, i.table.core).then(function() {
            return d;
          });
        }, e);
      }, Te.prototype.offset = function(e) {
        var t = this._ctx;
        return e <= 0 || (t.offset += e, mn(t) ? $r(t, function() {
          var o = e;
          return function(i, s) {
            return o === 0 || (o === 1 ? --o : s(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : $r(t, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Te.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), $r(this._ctx, function() {
          var t = e;
          return function(o, i, s) {
            return --t <= 0 && i(s), 0 <= t;
          };
        }, !0), this;
      }, Te.prototype.until = function(e, t) {
        return qr(this._ctx, function(o, i, s) {
          return !e(o.value) || (i(s), t);
        }), this;
      }, Te.prototype.first = function(e) {
        return this.limit(1).toArray(function(t) {
          return t[0];
        }).then(e);
      }, Te.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Te.prototype.filter = function(e) {
        var t;
        return qr(this._ctx, function(o) {
          return e(o.value);
        }), (t = this._ctx).isMatch = Zt(t.isMatch, e), this;
      }, Te.prototype.and = function(e) {
        return this.filter(e);
      }, Te.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Te.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Te.prototype.desc = function() {
        return this.reverse();
      }, Te.prototype.eachKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, Te.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Te.prototype.eachPrimaryKey = function(e) {
        var t = this._ctx;
        return t.keysOnly = !t.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, Te.prototype.keys = function(e) {
        var t = this._ctx;
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Te.prototype.primaryKeys = function(e) {
        var t = this._ctx;
        if (t.dir === "next" && mn(t, !0) && 0 < t.limit) return this._read(function(i) {
          var s = Jn(t, t.table.core.schema);
          return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: s, range: t.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        t.keysOnly = !t.isMatch;
        var o = [];
        return this.each(function(i, s) {
          o.push(s.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Te.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Te.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(t) {
          return t[0];
        }).then(e);
      }, Te.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Te.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var t = {};
        return qr(this._ctx, function(s) {
          var i = s.primaryKey.toString(), s = R(t, i);
          return t[i] = !0, !s;
        }), this;
      }, Te.prototype.modify = function(e) {
        var t = this, o = this._ctx;
        return this._write(function(i) {
          var s, l, d;
          d = typeof e == "function" ? e : (s = h(e), l = s.length, function(S) {
            for (var P = !1, I = 0; I < l; ++I) {
              var k = s[I], q = e[k], Y = Ce(S, k);
              q instanceof On ? (_e(S, k, q.execute(Y)), P = !0) : Y !== q && (_e(S, k, q), P = !0);
            }
            return P;
          });
          var p = o.table.core, m = p.schema.primaryKey, v = m.outbound, b = m.extractKey, E = 200, m = t.db._options.modifyChunkSize;
          m && (E = typeof m == "object" ? m[p.name] || m["*"] || 200 : m);
          function N(S, k) {
            var I = k.failures, k = k.numFailures;
            w += S - k;
            for (var q = 0, Y = h(I); q < Y.length; q++) {
              var U = Y[q];
              g.push(I[U]);
            }
          }
          var g = [], w = 0, O = [], T = e === Uo;
          return t.clone().primaryKeys().then(function(S) {
            function P(k) {
              var q = Math.min(E, S.length - k), Y = S.slice(k, k + q);
              return (T ? Promise.resolve([]) : p.getMany({ trans: i, keys: Y, cache: "immutable" })).then(function(U) {
                var H = [], Q = [], X = v ? [] : null, Z = T ? Y : [];
                if (!T) for (var he = 0; he < q; ++he) {
                  var we = U[he], de = { value: ot(we), primKey: S[k + he] };
                  d.call(de, de.value, de) !== !1 && (de.value == null ? Z.push(S[k + he]) : v || be(b(we), b(de.value)) === 0 ? (Q.push(de.value), v && X.push(S[k + he])) : (Z.push(S[k + he]), H.push(de.value)));
                }
                return Promise.resolve(0 < H.length && p.mutate({ trans: i, type: "add", values: H }).then(function(je) {
                  for (var ce in je.failures) Z.splice(parseInt(ce), 1);
                  N(H.length, je);
                })).then(function() {
                  return (0 < Q.length || I && typeof e == "object") && p.mutate({ trans: i, type: "put", keys: X, values: Q, criteria: I, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < k }).then(function(je) {
                    return N(Q.length, je);
                  });
                }).then(function() {
                  return (0 < Z.length || I && T) && p.mutate({ trans: i, type: "delete", keys: Z, criteria: I, isAdditionalChunk: 0 < k }).then(function(je) {
                    return zn(o.table, Z, je);
                  }).then(function(je) {
                    return N(Z.length, je);
                  });
                }).then(function() {
                  return S.length > k + q && P(k + E);
                });
              });
            }
            var I = mn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return P(0).then(function() {
              if (0 < g.length) throw new an("Error modifying one or more objects", g, w, O);
              return S.length;
            });
          });
        });
      }, Te.prototype.delete = function() {
        var e = this._ctx, t = e.range;
        return !mn(e) || e.table.schema.yProps || !e.isPrimKey && t.type !== 3 ? this.modify(Uo) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, s = t;
          return e.table.core.count({ trans: o, query: { index: i, range: s } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: s }).then(function(v) {
              var p = v.failures, v = v.numFailures;
              if (v) throw new an("Could not delete some values", Object.keys(p).map(function(b) {
                return p[b];
              }), l - v);
              return l - v;
            });
          });
        });
      }, Te);
      function Te() {
      }
      var Uo = function(e, t) {
        return t.value = null;
      };
      function ms(e, t) {
        return e < t ? -1 : e === t ? 0 : 1;
      }
      function ys(e, t) {
        return t < e ? -1 : e === t ? 0 : 1;
      }
      function ft(e, t, o) {
        return e = e instanceof Ho ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(t), e;
      }
      function yn(e) {
        return new e.Collection(e, function() {
          return Vo("");
        }).limit(0);
      }
      function er(e, t, o, i) {
        var s, l, d, p, v, b, E, m = o.length;
        if (!o.every(function(w) {
          return typeof w == "string";
        })) return ft(e, Ro);
        function N(w) {
          s = w === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = w === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, d = w === "next" ? ms : ys;
          var O = o.map(function(T) {
            return { lower: l(T), upper: s(T) };
          }).sort(function(T, S) {
            return d(T.lower, S.lower);
          });
          p = O.map(function(T) {
            return T.upper;
          }), v = O.map(function(T) {
            return T.lower;
          }), E = (b = w) === "next" ? "" : i;
        }
        N("next"), e = new e.Collection(e, function() {
          return Mt(p[0], v[m - 1] + i);
        }), e._ondirectionchange = function(w) {
          N(w);
        };
        var g = 0;
        return e._addAlgorithm(function(w, O, T) {
          var S = w.key;
          if (typeof S != "string") return !1;
          var P = l(S);
          if (t(P, v, g)) return !0;
          for (var I = null, k = g; k < m; ++k) {
            var q = function(Y, U, H, Q, X, Z) {
              for (var he = Math.min(Y.length, Q.length), we = -1, de = 0; de < he; ++de) {
                var je = U[de];
                if (je !== Q[de]) return X(Y[de], H[de]) < 0 ? Y.substr(0, de) + H[de] + H.substr(de + 1) : X(Y[de], Q[de]) < 0 ? Y.substr(0, de) + Q[de] + H.substr(de + 1) : 0 <= we ? Y.substr(0, we) + U[we] + H.substr(we + 1) : null;
                X(Y[de], je) < 0 && (we = de);
              }
              return he < Q.length && Z === "next" ? Y + H.substr(Y.length) : he < Y.length && Z === "prev" ? Y.substr(0, H.length) : we < 0 ? null : Y.substr(0, we) + Q[we] + H.substr(we + 1);
            }(S, P, p[k], v[k], d, b);
            q === null && I === null ? g = k + 1 : (I === null || 0 < d(I, q)) && (I = q);
          }
          return O(I !== null ? function() {
            w.continue(I + E);
          } : T), !1;
        }), e;
      }
      function Mt(e, t, o, i) {
        return { type: 2, lower: e, upper: t, lowerOpen: o, upperOpen: i };
      }
      function Vo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var Ho = (Object.defineProperty(Ge.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Ge.prototype.between = function(e, t, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, t) || this._cmp(e, t) === 0 && (o || i) && (!o || !i) ? yn(this) : new this.Collection(this, function() {
            return Mt(e, t, !o, !i);
          });
        } catch {
          return ft(this, At);
        }
      }, Ge.prototype.equals = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Vo(e);
        });
      }, Ge.prototype.above = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(e, void 0, !0);
        });
      }, Ge.prototype.aboveOrEqual = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(e, void 0, !1);
        });
      }, Ge.prototype.below = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(void 0, e, !1, !0);
        });
      }, Ge.prototype.belowOrEqual = function(e) {
        return e == null ? ft(this, At) : new this.Collection(this, function() {
          return Mt(void 0, e);
        });
      }, Ge.prototype.startsWith = function(e) {
        return typeof e != "string" ? ft(this, Ro) : this.between(e, e + Jt, !0, !0);
      }, Ge.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : er(this, function(t, o) {
          return t.indexOf(o[0]) === 0;
        }, [e], Jt);
      }, Ge.prototype.equalsIgnoreCase = function(e) {
        return er(this, function(t, o) {
          return t === o[0];
        }, [e], "");
      }, Ge.prototype.anyOfIgnoreCase = function() {
        var e = at.apply(yt, arguments);
        return e.length === 0 ? yn(this) : er(this, function(t, o) {
          return o.indexOf(t) !== -1;
        }, e, "");
      }, Ge.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = at.apply(yt, arguments);
        return e.length === 0 ? yn(this) : er(this, function(t, o) {
          return o.some(function(i) {
            return t.indexOf(i) === 0;
          });
        }, e, Jt);
      }, Ge.prototype.anyOf = function() {
        var e = this, t = at.apply(yt, arguments), o = this._cmp;
        try {
          t.sort(o);
        } catch {
          return ft(this, At);
        }
        if (t.length === 0) return yn(this);
        var i = new this.Collection(this, function() {
          return Mt(t[0], t[t.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, t.sort(o);
        };
        var s = 0;
        return i._addAlgorithm(function(l, d, p) {
          for (var v = l.key; 0 < o(v, t[s]); ) if (++s === t.length) return d(p), !1;
          return o(v, t[s]) === 0 || (d(function() {
            l.continue(t[s]);
          }), !1);
        }), i;
      }, Ge.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Ge.prototype.noneOf = function() {
        var e = at.apply(yt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return ft(this, At);
        }
        var t = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
      }, Ge.prototype.inAnyRange = function(S, t) {
        var o = this, i = this._cmp, s = this._ascending, l = this._descending, d = this._min, p = this._max;
        if (S.length === 0) return yn(this);
        if (!S.every(function(P) {
          return P[0] !== void 0 && P[1] !== void 0 && s(P[0], P[1]) <= 0;
        })) return ft(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", K.InvalidArgument);
        var v = !t || t.includeLowers !== !1, b = t && t.includeUppers === !0, E, m = s;
        function N(P, I) {
          return m(P[0], I[0]);
        }
        try {
          (E = S.reduce(function(P, I) {
            for (var k = 0, q = P.length; k < q; ++k) {
              var Y = P[k];
              if (i(I[0], Y[1]) < 0 && 0 < i(I[1], Y[0])) {
                Y[0] = d(Y[0], I[0]), Y[1] = p(Y[1], I[1]);
                break;
              }
            }
            return k === q && P.push(I), P;
          }, [])).sort(N);
        } catch {
          return ft(this, At);
        }
        var g = 0, w = b ? function(P) {
          return 0 < s(P, E[g][1]);
        } : function(P) {
          return 0 <= s(P, E[g][1]);
        }, O = v ? function(P) {
          return 0 < l(P, E[g][0]);
        } : function(P) {
          return 0 <= l(P, E[g][0]);
        }, T = w, S = new this.Collection(this, function() {
          return Mt(E[0][0], E[E.length - 1][1], !v, !b);
        });
        return S._ondirectionchange = function(P) {
          m = P === "next" ? (T = w, s) : (T = O, l), E.sort(N);
        }, S._addAlgorithm(function(P, I, k) {
          for (var q, Y = P.key; T(Y); ) if (++g === E.length) return I(k), !1;
          return !w(q = Y) && !O(q) || (o._cmp(Y, E[g][1]) === 0 || o._cmp(Y, E[g][0]) === 0 || I(function() {
            m === s ? P.continue(E[g][0]) : P.continue(E[g][1]);
          }), !1);
        }), S;
      }, Ge.prototype.startsWithAnyOf = function() {
        var e = at.apply(yt, arguments);
        return e.every(function(t) {
          return typeof t == "string";
        }) ? e.length === 0 ? yn(this) : this.inAnyRange(e.map(function(t) {
          return [t, t + Jt];
        })) : ft(this, "startsWithAnyOf() only works with strings");
      }, Ge);
      function Ge() {
      }
      function xt(e) {
        return De(function(t) {
          return Nn(t), e(t.target.error), !1;
        });
      }
      function Nn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var Sn = "storagemutated", Ur = "x-storagemutated-1", Bt = En(null, Sn), vs = (Et.prototype._lock = function() {
        return ae(!ne.global), ++this._reculock, this._reculock !== 1 || ne.global || (ne.lockOwnerFor = this), this;
      }, Et.prototype._unlock = function() {
        if (ae(!ne.global), --this._reculock == 0) for (ne.global || (ne.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, Et.prototype._locked = function() {
        return this._reculock && ne.lockOwnerFor !== this;
      }, Et.prototype.create = function(e) {
        var t = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (ae(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new K.DatabaseClosed(i);
          case "MissingAPIError":
            throw new K.MissingAPI(i.message, i);
          default:
            throw new K.OpenFailed(i);
        }
        if (!this.active) throw new K.TransactionInactive();
        return ae(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = De(function(s) {
          Nn(s), t._reject(e.error);
        }), e.onabort = De(function(s) {
          Nn(s), t.active && t._reject(new K.Abort(e.error)), t.active = !1, t.on("abort").fire(s);
        }), e.oncomplete = De(function() {
          t.active = !1, t._resolve(), "mutatedParts" in e && Bt.storagemutated.fire(e.mutatedParts);
        }), this;
      }, Et.prototype._promise = function(e, t, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return Fe(new K.ReadOnly("Transaction is readonly"));
        if (!this.active) return Fe(new K.TransactionInactive());
        if (this._locked()) return new z(function(l, d) {
          i._blockedFuncs.push([function() {
            i._promise(e, t, o).then(l, d);
          }, ne]);
        });
        if (o) return Lt(function() {
          var l = new z(function(d, p) {
            i._lock();
            var v = t(d, p, i);
            v && v.then && v.then(d, p);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var s = new z(function(l, d) {
          var p = t(l, d, i);
          p && p.then && p.then(l, d);
        });
        return s._lib = !0, s;
      }, Et.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, Et.prototype.waitFor = function(e) {
        var t, o = this._root(), i = z.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], t = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (t.get(-1 / 0).onsuccess = l);
        }());
        var s = o._waitingFor;
        return new z(function(l, d) {
          i.then(function(p) {
            return o._waitingQueue.push(De(l.bind(null, p)));
          }, function(p) {
            return o._waitingQueue.push(De(d.bind(null, p)));
          }).finally(function() {
            o._waitingFor === s && (o._waitingFor = null);
          });
        });
      }, Et.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new K.Abort()));
      }, Et.prototype.table = function(e) {
        var t = this._memoizedTables || (this._memoizedTables = {});
        if (R(t, e)) return t[e];
        var o = this.schema[e];
        if (!o) throw new K.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), t[e] = o;
      }, Et);
      function Et() {
      }
      function Vr(e, t, o, i, s, l, d, p) {
        return { name: e, keyPath: t, unique: o, multi: i, auto: s, compound: l, src: (o && !d ? "&" : "") + (i ? "*" : "") + (s ? "++" : "") + Wo(t), type: p };
      }
      function Wo(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Hr(e, t, o) {
        return { name: e, primKey: t, indexes: o, mappedClass: null, idxByName: (i = function(s) {
          return [s.name, s];
        }, o.reduce(function(s, l, d) {
          return d = i(l, d), d && (s[d[0]] = d[1]), s;
        }, {})) };
        var i;
      }
      var Cn = function(e) {
        try {
          return e.only([[]]), Cn = function() {
            return [[]];
          }, [[]];
        } catch {
          return Cn = function() {
            return Jt;
          }, Jt;
        }
      };
      function Wr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (t = e).split(".").length === 1 ? function(o) {
          return o[t];
        } : function(o) {
          return Ce(o, t);
        } : function(o) {
          return Ce(o, e);
        };
        var t;
      }
      function Go(e) {
        return [].slice.call(e);
      }
      var gs = 0;
      function An(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function bs(e, t, v) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var g = T.lower, w = T.upper, O = T.lowerOpen, T = T.upperOpen;
          return g === void 0 ? w === void 0 ? null : t.upperBound(w, !!T) : w === void 0 ? t.lowerBound(g, !!O) : t.bound(g, w, !!O, !!T);
        }
        function s(N) {
          var g, w = N.name;
          return { name: w, schema: N, mutate: function(O) {
            var T = O.trans, S = O.type, P = O.keys, I = O.values, k = O.range;
            return new Promise(function(q, Y) {
              q = De(q);
              var U = T.objectStore(w), H = U.keyPath == null, Q = S === "put" || S === "add";
              if (!Q && S !== "delete" && S !== "deleteRange") throw new Error("Invalid operation type: " + S);
              var X, Z = (P || I || { length: 1 }).length;
              if (P && I && P.length !== I.length) throw new Error("Given keys array must have same length as given values array.");
              if (Z === 0) return q({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function he(rt) {
                ++je, Nn(rt);
              }
              var we = [], de = [], je = 0;
              if (S === "deleteRange") {
                if (k.type === 4) return q({ numFailures: je, failures: de, results: [], lastResult: void 0 });
                k.type === 3 ? we.push(X = U.clear()) : we.push(X = U.delete(i(k)));
              } else {
                var H = Q ? H ? [I, P] : [I, null] : [P, null], ce = H[0], ze = H[1];
                if (Q) for (var Je = 0; Je < Z; ++Je) we.push(X = ze && ze[Je] !== void 0 ? U[S](ce[Je], ze[Je]) : U[S](ce[Je])), X.onerror = he;
                else for (Je = 0; Je < Z; ++Je) we.push(X = U[S](ce[Je])), X.onerror = he;
              }
              function dr(rt) {
                rt = rt.target.result, we.forEach(function(nn, co) {
                  return nn.error != null && (de[co] = nn.error);
                }), q({ numFailures: je, failures: de, results: S === "delete" ? P : we.map(function(nn) {
                  return nn.result;
                }), lastResult: rt });
              }
              X.onerror = function(rt) {
                he(rt), dr(rt);
              }, X.onsuccess = dr;
            });
          }, getMany: function(O) {
            var T = O.trans, S = O.keys;
            return new Promise(function(P, I) {
              P = De(P);
              for (var k, q = T.objectStore(w), Y = S.length, U = new Array(Y), H = 0, Q = 0, X = function(we) {
                we = we.target, U[we._pos] = we.result, ++Q === H && P(U);
              }, Z = xt(I), he = 0; he < Y; ++he) S[he] != null && ((k = q.get(S[he]))._pos = he, k.onsuccess = X, k.onerror = Z, ++H);
              H === 0 && P(U);
            });
          }, get: function(O) {
            var T = O.trans, S = O.key;
            return new Promise(function(P, I) {
              P = De(P);
              var k = T.objectStore(w).get(S);
              k.onsuccess = function(q) {
                return P(q.target.result);
              }, k.onerror = xt(I);
            });
          }, query: (g = b, function(O) {
            return new Promise(function(T, S) {
              T = De(T);
              var P, I, k, H = O.trans, q = O.values, Y = O.limit, X = O.query, U = Y === 1 / 0 ? void 0 : Y, Q = X.index, X = X.range, H = H.objectStore(w), Q = Q.isPrimaryKey ? H : H.index(Q.name), X = i(X);
              if (Y === 0) return T({ result: [] });
              g ? ((U = q ? Q.getAll(X, U) : Q.getAllKeys(X, U)).onsuccess = function(Z) {
                return T({ result: Z.target.result });
              }, U.onerror = xt(S)) : (P = 0, I = !q && "openKeyCursor" in Q ? Q.openKeyCursor(X) : Q.openCursor(X), k = [], I.onsuccess = function(Z) {
                var he = I.result;
                return he ? (k.push(q ? he.value : he.primaryKey), ++P === Y ? T({ result: k }) : void he.continue()) : T({ result: k });
              }, I.onerror = xt(S));
            });
          }), openCursor: function(O) {
            var T = O.trans, S = O.values, P = O.query, I = O.reverse, k = O.unique;
            return new Promise(function(q, Y) {
              q = De(q);
              var Q = P.index, U = P.range, H = T.objectStore(w), H = Q.isPrimaryKey ? H : H.index(Q.name), Q = I ? k ? "prevunique" : "prev" : k ? "nextunique" : "next", X = !S && "openKeyCursor" in H ? H.openKeyCursor(i(U), Q) : H.openCursor(i(U), Q);
              X.onerror = xt(Y), X.onsuccess = De(function(Z) {
                var he, we, de, je, ce = X.result;
                ce ? (ce.___id = ++gs, ce.done = !1, he = ce.continue.bind(ce), we = (we = ce.continuePrimaryKey) && we.bind(ce), de = ce.advance.bind(ce), je = function() {
                  throw new Error("Cursor not stopped");
                }, ce.trans = T, ce.stop = ce.continue = ce.continuePrimaryKey = ce.advance = function() {
                  throw new Error("Cursor not started");
                }, ce.fail = De(Y), ce.next = function() {
                  var ze = this, Je = 1;
                  return this.start(function() {
                    return Je-- ? ze.continue() : ze.stop();
                  }).then(function() {
                    return ze;
                  });
                }, ce.start = function(ze) {
                  function Je() {
                    if (X.result) try {
                      ze();
                    } catch (rt) {
                      ce.fail(rt);
                    }
                    else ce.done = !0, ce.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, ce.stop();
                  }
                  var dr = new Promise(function(rt, nn) {
                    rt = De(rt), X.onerror = xt(nn), ce.fail = nn, ce.stop = function(co) {
                      ce.stop = ce.continue = ce.continuePrimaryKey = ce.advance = je, rt(co);
                    };
                  });
                  return X.onsuccess = De(function(rt) {
                    X.onsuccess = Je, Je();
                  }), ce.continue = he, ce.continuePrimaryKey = we, ce.advance = de, Je(), dr;
                }, q(ce)) : q(null);
              }, Y);
            });
          }, count: function(O) {
            var T = O.query, S = O.trans, P = T.index, I = T.range;
            return new Promise(function(k, q) {
              var Y = S.objectStore(w), U = P.isPrimaryKey ? Y : Y.index(P.name), Y = i(I), U = Y ? U.count(Y) : U.count();
              U.onsuccess = De(function(H) {
                return k(H.target.result);
              }), U.onerror = xt(q);
            });
          } };
        }
        var l, d, p, E = (d = v, p = Go((l = e).objectStoreNames), { schema: { name: l.name, tables: p.map(function(N) {
          return d.objectStore(N);
        }).map(function(N) {
          var g = N.keyPath, T = N.autoIncrement, w = y(g), O = {}, T = { name: N.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g == null, compound: w, keyPath: g, autoIncrement: T, unique: !0, extractKey: Wr(g) }, indexes: Go(N.indexNames).map(function(S) {
            return N.index(S);
          }).map(function(k) {
            var P = k.name, I = k.unique, q = k.multiEntry, k = k.keyPath, q = { name: P, compound: y(k), keyPath: k, unique: I, multiEntry: q, extractKey: Wr(k) };
            return O[An(k)] = q;
          }), getIndexByKeyPath: function(S) {
            return O[An(S)];
          } };
          return O[":id"] = T.primaryKey, g != null && (O[An(g)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < p.length && "getAll" in d.objectStore(p[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), v = E.schema, b = E.hasGetAll, E = v.tables.map(s), m = {};
        return E.forEach(function(N) {
          return m[N.name] = N;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(N) {
          if (!m[N]) throw new Error("Table '".concat(N, "' not found"));
          return m[N];
        }, MIN_KEY: -1 / 0, MAX_KEY: Cn(t), schema: v };
      }
      function _s(e, t, o, i) {
        var s = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = bs(t, s, i), e.dbcore.reduce(function(l, d) {
          return d = d.create, u(u({}, l), d(l));
        }, i)) };
      }
      function tr(e, i) {
        var o = i.db, i = _s(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(s) {
          var l = s.name;
          e.core.schema.tables.some(function(d) {
            return d.name === l;
          }) && (s.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = s.core));
        });
      }
      function nr(e, t, o, i) {
        o.forEach(function(s) {
          var l = i[s];
          t.forEach(function(d) {
            var p = function v(b, E) {
              return te(b, E) || (b = j(b)) && v(b, E);
            }(d, s);
            (!p || "value" in p && p.value === void 0) && (d === e.Transaction.prototype || d instanceof e.Transaction ? J(d, s, { get: function() {
              return this.table(s);
            }, set: function(v) {
              W(this, s, { value: v, writable: !0, configurable: !0, enumerable: !0 });
            } }) : d[s] = new e.Table(s, l));
          });
        });
      }
      function Gr(e, t) {
        t.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function ws(e, t) {
        return e._cfg.version - t._cfg.version;
      }
      function xs(e, t, o, i) {
        var s = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !s.$meta && (s.$meta = Hr("$meta", Xo("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, s);
        l.create(o), l._completion.catch(i);
        var d = l._reject.bind(l), p = ne.transless || ne;
        Lt(function() {
          return ne.trans = l, ne.transless = p, t !== 0 ? (tr(e, o), b = t, ((v = l).storeNames.includes("$meta") ? v.table("$meta").get("version").then(function(E) {
            return E ?? b;
          }) : z.resolve(b)).then(function(E) {
            return N = E, g = l, w = o, O = [], E = (m = e)._versions, T = m._dbSchema = or(0, m.idbdb, w), (E = E.filter(function(S) {
              return S._cfg.version >= N;
            })).length !== 0 ? (E.forEach(function(S) {
              O.push(function() {
                var P = T, I = S._cfg.dbschema;
                ir(m, P, w), ir(m, I, w), T = m._dbSchema = I;
                var k = Yr(P, I);
                k.add.forEach(function(Q) {
                  Xr(w, Q[0], Q[1].primKey, Q[1].indexes);
                }), k.change.forEach(function(Q) {
                  if (Q.recreate) throw new K.Upgrade("Not yet support for changing primary key");
                  var X = w.objectStore(Q.name);
                  Q.add.forEach(function(Z) {
                    return rr(X, Z);
                  }), Q.change.forEach(function(Z) {
                    X.deleteIndex(Z.name), rr(X, Z);
                  }), Q.del.forEach(function(Z) {
                    return X.deleteIndex(Z);
                  });
                });
                var q = S._cfg.contentUpgrade;
                if (q && S._cfg.version > N) {
                  tr(m, w), g._memoizedTables = {};
                  var Y = Ae(I);
                  k.del.forEach(function(Q) {
                    Y[Q] = P[Q];
                  }), Gr(m, [m.Transaction.prototype]), nr(m, [m.Transaction.prototype], h(Y), Y), g.schema = Y;
                  var U, H = bt(q);
                  return H && pn(), k = z.follow(function() {
                    var Q;
                    (U = q(g)) && H && (Q = Kt.bind(null, null), U.then(Q, Q));
                  }), U && typeof U.then == "function" ? z.resolve(U) : k.then(function() {
                    return U;
                  });
                }
              }), O.push(function(P) {
                var I, k, q = S._cfg.dbschema;
                I = q, k = P, [].slice.call(k.db.objectStoreNames).forEach(function(Y) {
                  return I[Y] == null && k.db.deleteObjectStore(Y);
                }), Gr(m, [m.Transaction.prototype]), nr(m, [m.Transaction.prototype], m._storeNames, m._dbSchema), g.schema = m._dbSchema;
              }), O.push(function(P) {
                m.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(m.idbdb.version / 10) === S._cfg.version ? (m.idbdb.deleteObjectStore("$meta"), delete m._dbSchema.$meta, m._storeNames = m._storeNames.filter(function(I) {
                  return I !== "$meta";
                })) : P.objectStore("$meta").put(S._cfg.version, "version"));
              });
            }), function S() {
              return O.length ? z.resolve(O.shift()(g.idbtrans)).then(S) : z.resolve();
            }().then(function() {
              Yo(T, w);
            })) : z.resolve();
            var m, N, g, w, O, T;
          }).catch(d)) : (h(s).forEach(function(E) {
            Xr(o, E, s[E].primKey, s[E].indexes);
          }), tr(e, o), void z.follow(function() {
            return e.on.populate.fire(l);
          }).catch(d));
          var v, b;
        });
      }
      function Es(e, t) {
        Yo(e._dbSchema, t), t.db.version % 10 != 0 || t.objectStoreNames.contains("$meta") || t.db.createObjectStore("$meta").add(Math.ceil(t.db.version / 10 - 1), "version");
        var o = or(0, e.idbdb, t);
        ir(e, e._dbSchema, t);
        for (var i = 0, s = Yr(o, e._dbSchema).change; i < s.length; i++) {
          var l = function(d) {
            if (d.change.length || d.recreate) return console.warn("Unable to patch indexes of table ".concat(d.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var p = t.objectStore(d.name);
            d.add.forEach(function(v) {
              se && console.debug("Dexie upgrade patch: Creating missing index ".concat(d.name, ".").concat(v.src)), rr(p, v);
            });
          }(s[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function Yr(e, t) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) t[o] || i.del.push(o);
        for (o in t) {
          var s = e[o], l = t[o];
          if (s) {
            var d = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (s.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || s.primKey.auto !== l.primKey.auto) d.recreate = !0, i.change.push(d);
            else {
              var p = s.idxByName, v = l.idxByName, b = void 0;
              for (b in p) v[b] || d.del.push(b);
              for (b in v) {
                var E = p[b], m = v[b];
                E ? E.src !== m.src && d.change.push(m) : d.add.push(m);
              }
              (0 < d.del.length || 0 < d.add.length || 0 < d.change.length) && i.change.push(d);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Xr(e, t, o, i) {
        var s = e.db.createObjectStore(t, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return rr(s, l);
        }), s;
      }
      function Yo(e, t) {
        h(e).forEach(function(o) {
          t.db.objectStoreNames.contains(o) || (se && console.debug("Dexie: Creating missing table", o), Xr(t, o, e[o].primKey, e[o].indexes));
        });
      }
      function rr(e, t) {
        e.createIndex(t.name, t.keyPath, { unique: t.unique, multiEntry: t.multi });
      }
      function or(e, t, o) {
        var i = {};
        return G(t.objectStoreNames, 0).forEach(function(s) {
          for (var l = o.objectStore(s), d = Vr(Wo(b = l.keyPath), b || "", !0, !1, !!l.autoIncrement, b && typeof b != "string", !0), p = [], v = 0; v < l.indexNames.length; ++v) {
            var E = l.index(l.indexNames[v]), b = E.keyPath, E = Vr(E.name, b, !!E.unique, !!E.multiEntry, !1, b && typeof b != "string", !1);
            p.push(E);
          }
          i[s] = Hr(s, d, p);
        }), i;
      }
      function ir(e, t, o) {
        for (var i = o.db.objectStoreNames, s = 0; s < i.length; ++s) {
          var l = i[s], d = o.objectStore(l);
          e._hasGetAll = "getAll" in d;
          for (var p = 0; p < d.indexNames.length; ++p) {
            var v = d.indexNames[p], b = d.index(v).keyPath, E = typeof b == "string" ? b : "[" + G(b).join("+") + "]";
            !t[l] || (b = t[l].idxByName[E]) && (b.name = v, delete t[l].idxByName[E], t[l].idxByName[v] = b);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && f.WorkerGlobalScope && f instanceof f.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function Xo(e) {
        return e.split(",").map(function(t, o) {
          var l = t.split(":"), i = (s = l[1]) === null || s === void 0 ? void 0 : s.trim(), s = (t = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(s) ? s.match(/^\[(.*)\]$/)[1].split("+") : s;
          return Vr(s, l || null, /\&/.test(t), /\*/.test(t), /\+\+/.test(t), y(l), o === 0, i);
        });
      }
      var Ts = (vn.prototype._createTableSchema = Hr, vn.prototype._parseIndexSyntax = Xo, vn.prototype._parseStoresSpec = function(e, t) {
        var o = this;
        h(e).forEach(function(i) {
          if (e[i] !== null) {
            var s = o._parseIndexSyntax(e[i]), l = s.shift();
            if (!l) throw new K.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new K.Schema("Primary key cannot be multiEntry*");
            s.forEach(function(d) {
              if (d.auto) throw new K.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!d.keyPath) throw new K.Schema("Index must have a name and cannot be an empty string");
            }), s = o._createTableSchema(i, l, s), t[i] = s;
          }
        });
      }, vn.prototype.stores = function(o) {
        var t = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? _(this._cfg.storesSource, o) : o;
        var o = t._versions, i = {}, s = {};
        return o.forEach(function(l) {
          _(i, l._cfg.storesSource), s = l._cfg.dbschema = {}, l._parseStoresSpec(i, s);
        }), t._dbSchema = s, Gr(t, [t._allTables, t, t.Transaction.prototype]), nr(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], h(s), s), t._storeNames = h(s), this;
      }, vn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = le(this._cfg.contentUpgrade || C, e), this;
      }, vn);
      function vn() {
      }
      function Qr(e, t) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Pt(Xn, { addons: [], indexedDB: e, IDBKeyRange: t })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function zr(e) {
        return e && typeof e.databases == "function";
      }
      function Jr(e) {
        return Lt(function() {
          return ne.letThrough = !0, e();
        });
      }
      function Zr(e) {
        return !("from" in e);
      }
      var Qe = function(e, t) {
        if (!this) {
          var o = new Qe();
          return e && "d" in e && _(o, e), o;
        }
        _(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? t : e } : { d: 0 });
      };
      function Pn(e, t, o) {
        var i = be(t, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (Zr(e)) return _(e, { from: t, to: o, d: 1 });
          var s = e.l, i = e.r;
          if (be(o, e.from) < 0) return s ? Pn(s, t, o) : e.l = { from: t, to: o, d: 1, l: null, r: null }, zo(e);
          if (0 < be(t, e.to)) return i ? Pn(i, t, o) : e.r = { from: t, to: o, d: 1, l: null, r: null }, zo(e);
          be(t, e.from) < 0 && (e.from = t, e.l = null, e.d = i ? i.d + 1 : 1), 0 < be(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, s && !e.l && In(e, s), i && o && In(e, i);
        }
      }
      function In(e, t) {
        Zr(t) || function o(i, v) {
          var l = v.from, d = v.to, p = v.l, v = v.r;
          Pn(i, l, d), p && o(i, p), v && o(i, v);
        }(e, t);
      }
      function Qo(e, t) {
        var o = sr(t), i = o.next();
        if (i.done) return !1;
        for (var s = i.value, l = sr(e), d = l.next(s.from), p = d.value; !i.done && !d.done; ) {
          if (be(p.from, s.to) <= 0 && 0 <= be(p.to, s.from)) return !0;
          be(s.from, p.from) < 0 ? s = (i = o.next(p.from)).value : p = (d = l.next(s.from)).value;
        }
        return !1;
      }
      function sr(e) {
        var t = Zr(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; t; ) switch (t.s) {
            case 0:
              if (t.s = 1, i) for (; t.n.l && be(o, t.n.from) < 0; ) t = { up: t, n: t.n.l, s: 1 };
              else for (; t.n.l; ) t = { up: t, n: t.n.l, s: 1 };
            case 1:
              if (t.s = 2, !i || be(o, t.n.to) <= 0) return { value: t.n, done: !1 };
            case 2:
              if (t.n.r) {
                t.s = 3, t = { up: t, n: t.n.r, s: 0 };
                continue;
              }
            case 3:
              t = t.up;
          }
          return { done: !0 };
        } };
      }
      function zo(e) {
        var t, o, i = (((t = e.r) === null || t === void 0 ? void 0 : t.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), s = 1 < i ? "r" : i < -1 ? "l" : "";
        s && (t = s == "r" ? "l" : "r", o = u({}, e), i = e[s], e.from = i.from, e.to = i.to, e[s] = i[s], o[s] = i[t], (e[t] = o).d = Jo(o)), e.d = Jo(e);
      }
      function Jo(o) {
        var t = o.r, o = o.l;
        return (t ? o ? Math.max(t.d, o.d) : t.d : o ? o.d : 0) + 1;
      }
      function ar(e, t) {
        return h(t).forEach(function(o) {
          e[o] ? In(e[o], t[o]) : e[o] = function i(s) {
            var l, d, p = {};
            for (l in s) R(s, l) && (d = s[l], p[l] = !d || typeof d != "object" || ct.has(d.constructor) ? d : i(d));
            return p;
          }(t[o]);
        }), e;
      }
      function eo(e, t) {
        return e.all || t.all || Object.keys(e).some(function(o) {
          return t[o] && Qo(t[o], e[o]);
        });
      }
      $(Qe.prototype, ((vt = { add: function(e) {
        return In(this, e), this;
      }, addKey: function(e) {
        return Pn(this, e, e), this;
      }, addKeys: function(e) {
        var t = this;
        return e.forEach(function(o) {
          return Pn(t, o, o);
        }), this;
      }, hasKey: function(e) {
        var t = sr(this).next(e).value;
        return t && be(t.from, e) <= 0 && 0 <= be(t.to, e);
      } })[tt] = function() {
        return sr(this);
      }, vt));
      var en = {}, to = {}, no = !1;
      function ur(e) {
        ar(to, e), no || (no = !0, setTimeout(function() {
          no = !1, ro(to, !(to = {}));
        }, 0));
      }
      function ro(e, t) {
        t === void 0 && (t = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, s = Object.values(en); i < s.length; i++) Zo(d = s[i], e, o, t);
        else for (var l in e) {
          var d, p = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          p && (l = p[1], p = p[2], (d = en["idb://".concat(l, "/").concat(p)]) && Zo(d, e, o, t));
        }
        o.forEach(function(v) {
          return v();
        });
      }
      function Zo(e, t, o, i) {
        for (var s = [], l = 0, d = Object.entries(e.queries.query); l < d.length; l++) {
          for (var p = d[l], v = p[0], b = [], E = 0, m = p[1]; E < m.length; E++) {
            var N = m[E];
            eo(t, N.obsSet) ? N.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && b.push(N);
          }
          i && s.push([v, b]);
        }
        if (i) for (var g = 0, w = s; g < w.length; g++) {
          var O = w[g], v = O[0], b = O[1];
          e.queries.query[v] = b;
        }
      }
      function Os(e) {
        var t = e._state, o = e._deps.indexedDB;
        if (t.isBeingOpened || e.idbdb) return t.dbReadyPromise.then(function() {
          return t.dbOpenError ? Fe(t.dbOpenError) : e;
        });
        t.isBeingOpened = !0, t.dbOpenError = null, t.openComplete = !1;
        var i = t.openCanceller, s = Math.round(10 * e.verno), l = !1;
        function d() {
          if (t.openCanceller !== i) throw new K.DatabaseClosed("db.open() was cancelled");
        }
        function p() {
          return new z(function(N, g) {
            if (d(), !o) throw new K.MissingAPI();
            var w = e.name, O = t.autoSchema || !s ? o.open(w) : o.open(w, s);
            if (!O) throw new K.MissingAPI();
            O.onerror = xt(g), O.onblocked = De(e._fireOnBlocked), O.onupgradeneeded = De(function(T) {
              var S;
              E = O.transaction, t.autoSchema && !e._options.allowEmptyDB ? (O.onerror = Nn, E.abort(), O.result.close(), (S = o.deleteDatabase(w)).onsuccess = S.onerror = De(function() {
                g(new K.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (E.onerror = xt(g), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, m = T < 1, e.idbdb = O.result, l && Es(e, E), xs(e, T / 10, E, g));
            }, g), O.onsuccess = De(function() {
              E = null;
              var T, S, P, I, k, q = e.idbdb = O.result, Y = G(q.objectStoreNames);
              if (0 < Y.length) try {
                var U = q.transaction((I = Y).length === 1 ? I[0] : I, "readonly");
                if (t.autoSchema) S = q, P = U, (T = e).verno = S.version / 10, P = T._dbSchema = or(0, S, P), T._storeNames = G(S.objectStoreNames, 0), nr(T, [T._allTables], h(P), P);
                else if (ir(e, e._dbSchema, U), ((k = Yr(or(0, (k = e).idbdb, U), k._dbSchema)).add.length || k.change.some(function(H) {
                  return H.add.length || H.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), q.close(), s = q.version + 1, l = !0, N(p());
                tr(e, U);
              } catch {
              }
              hn.push(e), q.onversionchange = De(function(H) {
                t.vcFired = !0, e.on("versionchange").fire(H);
              }), q.onclose = De(function(H) {
                e.on("close").fire(H);
              }), m && (k = e._deps, U = w, q = k.indexedDB, k = k.IDBKeyRange, zr(q) || U === Xn || Qr(q, k).put({ name: U }).catch(C)), N();
            }, g);
          }).catch(function(N) {
            switch (N?.name) {
              case "UnknownError":
                if (0 < t.PR1398_maxLoop) return t.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), p();
                break;
              case "VersionError":
                if (0 < s) return s = 0, p();
            }
            return z.reject(N);
          });
        }
        var v, b = t.dbReadyResolve, E = null, m = !1;
        return z.race([i, (typeof navigator > "u" ? z.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(N) {
          function g() {
            return indexedDB.databases().finally(N);
          }
          v = setInterval(g, 100), g();
        }).finally(function() {
          return clearInterval(v);
        }) : Promise.resolve()).then(p)]).then(function() {
          return d(), t.onReadyBeingFired = [], z.resolve(Jr(function() {
            return e.on.ready.fire(e.vip);
          })).then(function N() {
            if (0 < t.onReadyBeingFired.length) {
              var g = t.onReadyBeingFired.reduce(le, C);
              return t.onReadyBeingFired = [], z.resolve(Jr(function() {
                return g(e.vip);
              })).then(N);
            }
          });
        }).finally(function() {
          t.openCanceller === i && (t.onReadyBeingFired = null, t.isBeingOpened = !1);
        }).catch(function(N) {
          t.dbOpenError = N;
          try {
            E && E.abort();
          } catch {
          }
          return i === t.openCanceller && e._close(), Fe(N);
        }).finally(function() {
          t.openComplete = !0, b();
        }).then(function() {
          var N;
          return m && (N = {}, e.tables.forEach(function(g) {
            g.schema.indexes.forEach(function(w) {
              w.name && (N["idb://".concat(e.name, "/").concat(g.name, "/").concat(w.name)] = new Qe(-1 / 0, [[[]]]));
            }), N["idb://".concat(e.name, "/").concat(g.name, "/")] = N["idb://".concat(e.name, "/").concat(g.name, "/:dels")] = new Qe(-1 / 0, [[[]]]);
          }), Bt(Sn).fire(N), ro(N, !0)), e;
        });
      }
      function oo(e) {
        function t(l) {
          return e.next(l);
        }
        var o = s(t), i = s(function(l) {
          return e.throw(l);
        });
        function s(l) {
          return function(v) {
            var p = l(v), v = p.value;
            return p.done ? v : v && typeof v.then == "function" ? v.then(o, i) : y(v) ? Promise.all(v).then(o, i) : o(v);
          };
        }
        return s(t)();
      }
      function lr(e, t, o) {
        for (var i = y(e) ? e.slice() : [e], s = 0; s < o; ++s) i.push(t);
        return i;
      }
      var Ns = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema, s = {}, l = [];
          function d(m, N, g) {
            var w = An(m), O = s[w] = s[w] || [], T = m == null ? 0 : typeof m == "string" ? 1 : m.length, S = 0 < N, S = u(u({}, g), { name: S ? "".concat(w, "(virtual-from:").concat(g.name, ")") : g.name, lowLevelIndex: g, isVirtual: S, keyTail: N, keyLength: T, extractKey: Wr(m), unique: !S && g.unique });
            return O.push(S), S.isPrimaryKey || l.push(S), 1 < T && d(T === 2 ? m[0] : m.slice(0, T - 1), N + 1, g), O.sort(function(P, I) {
              return P.keyTail - I.keyTail;
            }), S;
          }
          t = d(i.primaryKey.keyPath, 0, i.primaryKey), s[":id"] = [t];
          for (var p = 0, v = i.indexes; p < v.length; p++) {
            var b = v[p];
            d(b.keyPath, 0, b);
          }
          function E(m) {
            var N, g = m.query.index;
            return g.isVirtual ? u(u({}, m), { query: { index: g.lowLevelIndex, range: (N = m.query.range, g = g.keyTail, { type: N.type === 1 ? 2 : N.type, lower: lr(N.lower, N.lowerOpen ? e.MAX_KEY : e.MIN_KEY, g), lowerOpen: !0, upper: lr(N.upper, N.upperOpen ? e.MIN_KEY : e.MAX_KEY, g), upperOpen: !0 }) } }) : m;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: t, indexes: l, getIndexByKeyPath: function(m) {
            return (m = s[An(m)]) && m[0];
          } }), count: function(m) {
            return o.count(E(m));
          }, query: function(m) {
            return o.query(E(m));
          }, openCursor: function(m) {
            var N = m.query.index, g = N.keyTail, w = N.isVirtual, O = N.keyLength;
            return w ? o.openCursor(E(m)).then(function(S) {
              return S && T(S);
            }) : o.openCursor(m);
            function T(S) {
              return Object.create(S, { continue: { value: function(P) {
                P != null ? S.continue(lr(P, m.reverse ? e.MAX_KEY : e.MIN_KEY, g)) : m.unique ? S.continue(S.key.slice(0, O).concat(m.reverse ? e.MIN_KEY : e.MAX_KEY, g)) : S.continue();
              } }, continuePrimaryKey: { value: function(P, I) {
                S.continuePrimaryKey(lr(P, e.MAX_KEY, g), I);
              } }, primaryKey: { get: function() {
                return S.primaryKey;
              } }, key: { get: function() {
                var P = S.key;
                return O === 1 ? P[0] : P.slice(0, O);
              } }, value: { get: function() {
                return S.value;
              } } });
            }
          } });
        } });
      } };
      function io(e, t, o, i) {
        return o = o || {}, i = i || "", h(e).forEach(function(s) {
          var l, d, p;
          R(t, s) ? (l = e[s], d = t[s], typeof l == "object" && typeof d == "object" && l && d ? (p = kt(l)) !== kt(d) ? o[i + s] = t[s] : p === "Object" ? io(l, d, o, i + s + ".") : l !== d && (o[i + s] = t[s]) : l !== d && (o[i + s] = t[s])) : o[i + s] = void 0;
        }), h(t).forEach(function(s) {
          R(e, s) || (o[i + s] = t[s]);
        }), o;
      }
      function so(e, t) {
        return t.type === "delete" ? t.keys : t.keys || t.values.map(e.extractKey);
      }
      var Ss = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(t) {
          var o = e.table(t), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(s) {
            var l = ne.trans, d = l.table(t).hook, p = d.deleting, v = d.creating, b = d.updating;
            switch (s.type) {
              case "add":
                if (v.fire === C) break;
                return l._promise("readwrite", function() {
                  return E(s);
                }, !0);
              case "put":
                if (v.fire === C && b.fire === C) break;
                return l._promise("readwrite", function() {
                  return E(s);
                }, !0);
              case "delete":
                if (p.fire === C) break;
                return l._promise("readwrite", function() {
                  return E(s);
                }, !0);
              case "deleteRange":
                if (p.fire === C) break;
                return l._promise("readwrite", function() {
                  return function m(N, g, w) {
                    return o.query({ trans: N, values: !1, query: { index: i, range: g }, limit: w }).then(function(O) {
                      var T = O.result;
                      return E({ type: "delete", keys: T, trans: N }).then(function(S) {
                        return 0 < S.numFailures ? Promise.reject(S.failures[0]) : T.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : m(N, u(u({}, g), { lower: T[T.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(s.trans, s.range, 1e4);
                }, !0);
            }
            return o.mutate(s);
            function E(m) {
              var N, g, w, O = ne.trans, T = m.keys || so(i, m);
              if (!T) throw new Error("Keys missing");
              return (m = m.type === "add" || m.type === "put" ? u(u({}, m), { keys: T }) : u({}, m)).type !== "delete" && (m.values = c([], m.values)), m.keys && (m.keys = c([], m.keys)), N = o, w = T, ((g = m).type === "add" ? Promise.resolve([]) : N.getMany({ trans: g.trans, keys: w, cache: "immutable" })).then(function(S) {
                var P = T.map(function(I, k) {
                  var q, Y, U, H = S[k], Q = { onerror: null, onsuccess: null };
                  return m.type === "delete" ? p.fire.call(Q, I, H, O) : m.type === "add" || H === void 0 ? (q = v.fire.call(Q, I, m.values[k], O), I == null && q != null && (m.keys[k] = I = q, i.outbound || _e(m.values[k], i.keyPath, I))) : (q = io(H, m.values[k]), (Y = b.fire.call(Q, q, I, H, O)) && (U = m.values[k], Object.keys(Y).forEach(function(X) {
                    R(U, X) ? U[X] = Y[X] : _e(U, X, Y[X]);
                  }))), Q;
                });
                return o.mutate(m).then(function(I) {
                  for (var k = I.failures, q = I.results, Y = I.numFailures, I = I.lastResult, U = 0; U < T.length; ++U) {
                    var H = (q || T)[U], Q = P[U];
                    H == null ? Q.onerror && Q.onerror(k[U]) : Q.onsuccess && Q.onsuccess(m.type === "put" && S[U] ? m.values[U] : H);
                  }
                  return { failures: k, results: q, numFailures: Y, lastResult: I };
                }).catch(function(I) {
                  return P.forEach(function(k) {
                    return k.onerror && k.onerror(I);
                  }), Promise.reject(I);
                });
              });
            }
          } });
        } });
      } };
      function ei(e, t, o) {
        try {
          if (!t || t.keys.length < e.length) return null;
          for (var i = [], s = 0, l = 0; s < t.keys.length && l < e.length; ++s) be(t.keys[s], e[l]) === 0 && (i.push(o ? ot(t.values[s]) : t.values[s]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Cs = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(t) {
          var o = e.table(t);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var s = ei(i.keys, i.trans._cache, i.cache === "clone");
            return s ? z.resolve(s) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? ot(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function ti(e, t) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !t.schema.primaryKey.outbound;
      }
      function ni(e, t) {
        switch (e) {
          case "query":
            return t.values && !t.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var As = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var t = e.schema.name, o = new Qe(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, s, l) {
          if (ne.subscr && s !== "readonly") throw new K.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(ne.querier));
          return e.transaction(i, s, l);
        }, table: function(i) {
          var s = e.table(i), l = s.schema, d = l.primaryKey, m = l.indexes, p = d.extractKey, v = d.outbound, b = d.autoIncrement && m.filter(function(g) {
            return g.compound && g.keyPath.includes(d.keyPath);
          }), E = u(u({}, s), { mutate: function(g) {
            function w(X) {
              return X = "idb://".concat(t, "/").concat(i, "/").concat(X), I[X] || (I[X] = new Qe());
            }
            var O, T, S, P = g.trans, I = g.mutatedParts || (g.mutatedParts = {}), k = w(""), q = w(":dels"), Y = g.type, Q = g.type === "deleteRange" ? [g.range] : g.type === "delete" ? [g.keys] : g.values.length < 50 ? [so(d, g).filter(function(X) {
              return X;
            }), g.values] : [], U = Q[0], H = Q[1], Q = g.trans._cache;
            return y(U) ? (k.addKeys(U), (Q = Y === "delete" || U.length === H.length ? ei(U, Q) : null) || q.addKeys(U), (Q || H) && (O = w, T = Q, S = H, l.indexes.forEach(function(X) {
              var Z = O(X.name || "");
              function he(de) {
                return de != null ? X.extractKey(de) : null;
              }
              function we(de) {
                return X.multiEntry && y(de) ? de.forEach(function(je) {
                  return Z.addKey(je);
                }) : Z.addKey(de);
              }
              (T || S).forEach(function(de, ze) {
                var ce = T && he(T[ze]), ze = S && he(S[ze]);
                be(ce, ze) !== 0 && (ce != null && we(ce), ze != null && we(ze));
              });
            }))) : U ? (H = { from: (H = U.lower) !== null && H !== void 0 ? H : e.MIN_KEY, to: (H = U.upper) !== null && H !== void 0 ? H : e.MAX_KEY }, q.add(H), k.add(H)) : (k.add(o), q.add(o), l.indexes.forEach(function(X) {
              return w(X.name).add(o);
            })), s.mutate(g).then(function(X) {
              return !U || g.type !== "add" && g.type !== "put" || (k.addKeys(X.results), b && b.forEach(function(Z) {
                for (var he = g.values.map(function(ce) {
                  return Z.extractKey(ce);
                }), we = Z.keyPath.findIndex(function(ce) {
                  return ce === d.keyPath;
                }), de = 0, je = X.results.length; de < je; ++de) he[de][we] = X.results[de];
                w(Z.name).addKeys(he);
              })), P.mutatedParts = ar(P.mutatedParts || {}, I), X;
            });
          } }), m = function(w) {
            var O = w.query, w = O.index, O = O.range;
            return [w, new Qe((w = O.lower) !== null && w !== void 0 ? w : e.MIN_KEY, (O = O.upper) !== null && O !== void 0 ? O : e.MAX_KEY)];
          }, N = { get: function(g) {
            return [d, new Qe(g.key)];
          }, getMany: function(g) {
            return [d, new Qe().addKeys(g.keys)];
          }, count: m, query: m, openCursor: m };
          return h(N).forEach(function(g) {
            E[g] = function(w) {
              var O = ne.subscr, T = !!O, S = ti(ne, s) && ni(g, w) ? w.obsSet = {} : O;
              if (T) {
                var P = function(H) {
                  return H = "idb://".concat(t, "/").concat(i, "/").concat(H), S[H] || (S[H] = new Qe());
                }, I = P(""), k = P(":dels"), O = N[g](w), T = O[0], O = O[1];
                if ((g === "query" && T.isPrimaryKey && !w.values ? k : P(T.name || "")).add(O), !T.isPrimaryKey) {
                  if (g !== "count") {
                    var q = g === "query" && v && w.values && s.query(u(u({}, w), { values: !1 }));
                    return s[g].apply(this, arguments).then(function(H) {
                      if (g === "query") {
                        if (v && w.values) return q.then(function(he) {
                          return he = he.result, I.addKeys(he), H;
                        });
                        var Q = w.values ? H.result.map(p) : H.result;
                        (w.values ? I : k).addKeys(Q);
                      } else if (g === "openCursor") {
                        var X = H, Z = w.values;
                        return X && Object.create(X, { key: { get: function() {
                          return k.addKey(X.primaryKey), X.key;
                        } }, primaryKey: { get: function() {
                          var he = X.primaryKey;
                          return k.addKey(he), he;
                        } }, value: { get: function() {
                          return Z && I.addKey(X.primaryKey), X.value;
                        } } });
                      }
                      return H;
                    });
                  }
                  k.add(o);
                }
              }
              return s[g].apply(this, arguments);
            };
          }), E;
        } });
      } };
      function ri(e, t, o) {
        if (o.numFailures === 0) return t;
        if (t.type === "deleteRange") return null;
        var i = t.keys ? t.keys.length : "values" in t && t.values ? t.values.length : 1;
        return o.numFailures === i ? null : (t = u({}, t), y(t.keys) && (t.keys = t.keys.filter(function(s, l) {
          return !(l in o.failures);
        })), "values" in t && y(t.values) && (t.values = t.values.filter(function(s, l) {
          return !(l in o.failures);
        })), t);
      }
      function ao(e, t) {
        return o = e, ((i = t).lower === void 0 || (i.lowerOpen ? 0 < be(o, i.lower) : 0 <= be(o, i.lower))) && (e = e, (t = t).upper === void 0 || (t.upperOpen ? be(e, t.upper) < 0 : be(e, t.upper) <= 0));
        var o, i;
      }
      function oi(e, t, N, i, s, l) {
        if (!N || N.length === 0) return e;
        var d = t.query.index, p = d.multiEntry, v = t.query.range, b = i.schema.primaryKey.extractKey, E = d.extractKey, m = (d.lowLevelIndex || d).extractKey, N = N.reduce(function(g, w) {
          var O = g, T = [];
          if (w.type === "add" || w.type === "put") for (var S = new Qe(), P = w.values.length - 1; 0 <= P; --P) {
            var I, k = w.values[P], q = b(k);
            S.hasKey(q) || (I = E(k), (p && y(I) ? I.some(function(X) {
              return ao(X, v);
            }) : ao(I, v)) && (S.addKey(q), T.push(k)));
          }
          switch (w.type) {
            case "add":
              var Y = new Qe().addKeys(t.values ? g.map(function(Z) {
                return b(Z);
              }) : g), O = g.concat(t.values ? T.filter(function(Z) {
                return Z = b(Z), !Y.hasKey(Z) && (Y.addKey(Z), !0);
              }) : T.map(function(Z) {
                return b(Z);
              }).filter(function(Z) {
                return !Y.hasKey(Z) && (Y.addKey(Z), !0);
              }));
              break;
            case "put":
              var U = new Qe().addKeys(w.values.map(function(Z) {
                return b(Z);
              }));
              O = g.filter(function(Z) {
                return !U.hasKey(t.values ? b(Z) : Z);
              }).concat(t.values ? T : T.map(function(Z) {
                return b(Z);
              }));
              break;
            case "delete":
              var H = new Qe().addKeys(w.keys);
              O = g.filter(function(Z) {
                return !H.hasKey(t.values ? b(Z) : Z);
              });
              break;
            case "deleteRange":
              var Q = w.range;
              O = g.filter(function(Z) {
                return !ao(b(Z), Q);
              });
          }
          return O;
        }, e);
        return N === e ? e : (N.sort(function(g, w) {
          return be(m(g), m(w)) || be(b(g), b(w));
        }), t.limit && t.limit < 1 / 0 && (N.length > t.limit ? N.length = t.limit : e.length === t.limit && N.length < t.limit && (s.dirty = !0)), l ? Object.freeze(N) : N);
      }
      function ii(e, t) {
        return be(e.lower, t.lower) === 0 && be(e.upper, t.upper) === 0 && !!e.lowerOpen == !!t.lowerOpen && !!e.upperOpen == !!t.upperOpen;
      }
      function Ps(e, t) {
        return function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = be(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, t.lower, e.lowerOpen, t.lowerOpen) <= 0 && 0 <= function(o, i, s, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = be(o, i)) === 0) {
            if (s && l) return 0;
            if (s) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, t.upper, e.upperOpen, t.upperOpen);
      }
      function Is(e, t, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var s, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (s = e, l = t, setTimeout(function() {
            s.subscribers.size === 0 && Le(l, s);
          }, 3e3));
        });
      }
      var ks = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var t = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, s) {
          var l, d, p = e.transaction(o, i, s);
          return i === "readwrite" && (d = (l = new AbortController()).signal, s = function(v) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var b = /* @__PURE__ */ new Set(), E = 0, m = o; E < m.length; E++) {
                  var N = m[E], g = en["idb://".concat(t, "/").concat(N)];
                  if (g) {
                    var w = e.table(N), O = g.optimisticOps.filter(function(Z) {
                      return Z.trans === p;
                    });
                    if (p._explicit && v && p.mutatedParts) for (var T = 0, S = Object.values(g.queries.query); T < S.length; T++) for (var P = 0, I = (Y = S[T]).slice(); P < I.length; P++) eo((U = I[P]).obsSet, p.mutatedParts) && (Le(Y, U), U.subscribers.forEach(function(Z) {
                      return b.add(Z);
                    }));
                    else if (0 < O.length) {
                      g.optimisticOps = g.optimisticOps.filter(function(Z) {
                        return Z.trans !== p;
                      });
                      for (var k = 0, q = Object.values(g.queries.query); k < q.length; k++) for (var Y, U, H, Q = 0, X = (Y = q[k]).slice(); Q < X.length; Q++) (U = X[Q]).res != null && p.mutatedParts && (v && !U.dirty ? (H = Object.isFrozen(U.res), H = oi(U.res, U.req, O, w, U, H), U.dirty ? (Le(Y, U), U.subscribers.forEach(function(Z) {
                        return b.add(Z);
                      })) : H !== U.res && (U.res = H, U.promise = z.resolve({ result: H }))) : (U.dirty && Le(Y, U), U.subscribers.forEach(function(Z) {
                        return b.add(Z);
                      })));
                    }
                  }
                }
                b.forEach(function(Z) {
                  return Z();
                });
              }
            };
          }, p.addEventListener("abort", s(!1), { signal: d }), p.addEventListener("error", s(!1), { signal: d }), p.addEventListener("complete", s(!0), { signal: d })), p;
        }, table: function(o) {
          var i = e.table(o), s = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var d = ne.trans;
            if (s.outbound || d.db._options.cache === "disabled" || d.explicit || d.idbtrans.mode !== "readwrite") return i.mutate(l);
            var p = en["idb://".concat(t, "/").concat(o)];
            return p ? (d = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || so(s, l).some(function(v) {
              return v == null;
            })) ? (p.optimisticOps.push(l), l.mutatedParts && ur(l.mutatedParts), d.then(function(v) {
              0 < v.numFailures && (Le(p.optimisticOps, l), (v = ri(0, l, v)) && p.optimisticOps.push(v), l.mutatedParts && ur(l.mutatedParts));
            }), d.catch(function() {
              Le(p.optimisticOps, l), l.mutatedParts && ur(l.mutatedParts);
            })) : d.then(function(v) {
              var b = ri(0, u(u({}, l), { values: l.values.map(function(E, m) {
                var N;
                return v.failures[m] || (E = (N = s.keyPath) !== null && N !== void 0 && N.includes(".") ? ot(E) : u({}, E), _e(E, s.keyPath, v.results[m])), E;
              }) }), v);
              p.optimisticOps.push(b), queueMicrotask(function() {
                return l.mutatedParts && ur(l.mutatedParts);
              });
            }), d) : i.mutate(l);
          }, query: function(l) {
            if (!ti(ne, i) || !ni("query", l)) return i.query(l);
            var d = ((b = ne.trans) === null || b === void 0 ? void 0 : b.db._options.cache) === "immutable", m = ne, p = m.requery, v = m.signal, b = function(w, O, T, S) {
              var P = en["idb://".concat(w, "/").concat(O)];
              if (!P) return [];
              if (!(O = P.queries[T])) return [null, !1, P, null];
              var I = O[(S.query ? S.query.index.name : null) || ""];
              if (!I) return [null, !1, P, null];
              switch (T) {
                case "query":
                  var k = I.find(function(q) {
                    return q.req.limit === S.limit && q.req.values === S.values && ii(q.req.query.range, S.query.range);
                  });
                  return k ? [k, !0, P, I] : [I.find(function(q) {
                    return ("limit" in q.req ? q.req.limit : 1 / 0) >= S.limit && (!S.values || q.req.values) && Ps(q.req.query.range, S.query.range);
                  }), !1, P, I];
                case "count":
                  return k = I.find(function(q) {
                    return ii(q.req.query.range, S.query.range);
                  }), [k, !!k, P, I];
              }
            }(t, o, "query", l), E = b[0], m = b[1], N = b[2], g = b[3];
            return E && m ? E.obsSet = l.obsSet : (m = i.query(l).then(function(w) {
              var O = w.result;
              if (E && (E.res = O), d) {
                for (var T = 0, S = O.length; T < S; ++T) Object.freeze(O[T]);
                Object.freeze(O);
              } else w.result = ot(O);
              return w;
            }).catch(function(w) {
              return g && E && Le(g, E), Promise.reject(w);
            }), E = { obsSet: l.obsSet, promise: m, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, g ? g.push(E) : (g = [E], (N = N || (en["idb://".concat(t, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = g)), Is(E, g, p, v), E.promise.then(function(w) {
              return { result: oi(w.result, l, N?.optimisticOps, i, E, d) };
            });
          } });
        } });
      } };
      function cr(e, t) {
        return new Proxy(e, { get: function(o, i, s) {
          return i === "db" ? t : Reflect.get(o, i, s);
        } });
      }
      var Pt = (Me.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new K.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new K.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var t = this._versions, o = t.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), t.push(o), t.sort(ws), o.stores({}), this._state.autoSchema = !1, o);
      }, Me.prototype._whenReady = function(e) {
        var t = this;
        return this.idbdb && (this._state.openComplete || ne.letThrough || this._vip) ? e() : new z(function(o, i) {
          if (t._state.openComplete) return i(new K.DatabaseClosed(t._state.dbOpenError));
          if (!t._state.isBeingOpened) {
            if (!t._state.autoOpen) return void i(new K.DatabaseClosed());
            t.open().catch(C);
          }
          t._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, Me.prototype.use = function(e) {
        var t = e.stack, o = e.create, i = e.level, s = e.name;
        return s && this.unuse({ stack: t, name: s }), e = this._middlewares[t] || (this._middlewares[t] = []), e.push({ stack: t, create: o, level: i ?? 10, name: s }), e.sort(function(l, d) {
          return l.level - d.level;
        }), this;
      }, Me.prototype.unuse = function(e) {
        var t = e.stack, o = e.name, i = e.create;
        return t && this._middlewares[t] && (this._middlewares[t] = this._middlewares[t].filter(function(s) {
          return i ? s.create !== i : !!o && s.name !== o;
        })), this;
      }, Me.prototype.open = function() {
        var e = this;
        return zt(nt, function() {
          return Os(e);
        });
      }, Me.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, t = hn.indexOf(this);
        if (0 <= t && hn.splice(t, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new z(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new z(function(o, i) {
          e.cancelOpen = i;
        }));
      }, Me.prototype.close = function(o) {
        var t = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        t ? (o.isBeingOpened && o.cancelOpen(new K.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new K.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, Me.prototype.delete = function(e) {
        var t = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new z(function(s, l) {
          function d() {
            t.close(e);
            var p = t._deps.indexedDB.deleteDatabase(t.name);
            p.onsuccess = De(function() {
              var v, b, E;
              v = t._deps, b = t.name, E = v.indexedDB, v = v.IDBKeyRange, zr(E) || b === Xn || Qr(E, v).delete(b).catch(C), s();
            }), p.onerror = xt(l), p.onblocked = t._fireOnBlocked;
          }
          if (o) throw new K.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(d) : d();
        });
      }, Me.prototype.backendDB = function() {
        return this.idbdb;
      }, Me.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, Me.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, Me.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, Me.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(Me.prototype, "tables", { get: function() {
        var e = this;
        return h(this._allTables).map(function(t) {
          return e._allTables[t];
        });
      }, enumerable: !1, configurable: !0 }), Me.prototype.transaction = function() {
        var e = (function(t, o, i) {
          var s = arguments.length;
          if (s < 2) throw new K.InvalidArgument("Too few arguments");
          for (var l = new Array(s - 1); --s; ) l[s - 1] = arguments[s];
          return i = l.pop(), [t, Xe(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, Me.prototype._transaction = function(e, t, o) {
        var i = this, s = ne.trans;
        s && s.db === this && e.indexOf("!") === -1 || (s = null);
        var l, d, p = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (d = t.map(function(b) {
            if (b = b instanceof i.Table ? b.name : b, typeof b != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return b;
          }), e == "r" || e === Mr) l = Mr;
          else {
            if (e != "rw" && e != Br) throw new K.InvalidArgument("Invalid transaction mode: " + e);
            l = Br;
          }
          if (s) {
            if (s.mode === Mr && l === Br) {
              if (!p) throw new K.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              s = null;
            }
            s && d.forEach(function(b) {
              if (s && s.storeNames.indexOf(b) === -1) {
                if (!p) throw new K.SubTransaction("Table " + b + " not included in parent transaction.");
                s = null;
              }
            }), p && s && !s.active && (s = null);
          }
        } catch (b) {
          return s ? s._promise(null, function(E, m) {
            m(b);
          }) : Fe(b);
        }
        var v = (function b(E, m, N, g, w) {
          return z.resolve().then(function() {
            var O = ne.transless || ne, T = E._createTransaction(m, N, E._dbSchema, g);
            if (T.explicit = !0, O = { trans: T, transless: O }, g) T.idbtrans = g.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, E._state.PR1398_maxLoop = 3;
            } catch (I) {
              return I.name === A.InvalidState && E.isOpen() && 0 < --E._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), E.close({ disableAutoOpen: !1 }), E.open().then(function() {
                return b(E, m, N, null, w);
              })) : Fe(I);
            }
            var S, P = bt(w);
            return P && pn(), O = z.follow(function() {
              var I;
              (S = w.call(T, T)) && (P ? (I = Kt.bind(null, null), S.then(I, I)) : typeof S.next == "function" && typeof S.throw == "function" && (S = oo(S)));
            }, O), (S && typeof S.then == "function" ? z.resolve(S).then(function(I) {
              return T.active ? I : Fe(new K.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : O.then(function() {
              return S;
            })).then(function(I) {
              return g && T._resolve(), T._completion.then(function() {
                return I;
              });
            }).catch(function(I) {
              return T._reject(I), Fe(I);
            });
          });
        }).bind(null, this, l, d, s, o);
        return s ? s._promise(l, v, "lock") : ne.trans ? zt(ne.transless, function() {
          return i._whenReady(v);
        }) : this._whenReady(v);
      }, Me.prototype.table = function(e) {
        if (!R(this._allTables, e)) throw new K.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, Me);
      function Me(e, t) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = Me.dependencies;
        this._options = t = u({ addons: Me.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, t), this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange }, i = t.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var s, l, d, p, v, b = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: C, dbReadyPromise: null, cancelOpen: C, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: t.autoOpen };
        b.dbReadyPromise = new z(function(m) {
          b.dbReadyResolve = m;
        }), b.openCanceller = new z(function(m, N) {
          b.cancelOpen = N;
        }), this._state = b, this.name = e, this.on = En(this, "populate", "blocked", "versionchange", "close", { ready: [le, C] }), this.once = function(m, N) {
          var g = function() {
            for (var w = [], O = 0; O < arguments.length; O++) w[O] = arguments[O];
            o.on(m).unsubscribe(g), N.apply(o, w);
          };
          return o.on(m, g);
        }, this.on.ready.subscribe = fe(this.on.ready.subscribe, function(m) {
          return function(N, g) {
            Me.vip(function() {
              var w, O = o._state;
              O.openComplete ? (O.dbOpenError || z.resolve().then(N), g && m(N)) : O.onReadyBeingFired ? (O.onReadyBeingFired.push(N), g && m(N)) : (m(N), w = o, g || m(function T() {
                w.on.ready.unsubscribe(N), w.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (s = this, Tn(hs.prototype, function(S, T) {
          this.db = s;
          var g = jo, w = null;
          if (T) try {
            g = T();
          } catch (P) {
            w = P;
          }
          var O = S._ctx, T = O.table, S = T.hook.reading.fire;
          this._ctx = { table: T, index: O.index, isPrimKey: !O.index || T.schema.primKey.keyPath && O.index === T.schema.primKey.name, range: g, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: O.or, valueMapper: S !== F ? S : null };
        })), this.Table = (l = this, Tn(Mo.prototype, function(m, N, g) {
          this.db = l, this._tx = g, this.name = m, this.schema = N, this.hook = l._allTables[m] ? l._allTables[m].hook : En(null, { creating: [ue, C], reading: [ee, F], updating: [pe, C], deleting: [ie, C] });
        })), this.Transaction = (d = this, Tn(vs.prototype, function(m, N, g, w, O) {
          var T = this;
          m !== "readonly" && N.forEach(function(S) {
            S = (S = g[S]) === null || S === void 0 ? void 0 : S.yProps, S && (N = N.concat(S.map(function(P) {
              return P.updatesTable;
            })));
          }), this.db = d, this.mode = m, this.storeNames = N, this.schema = g, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = En(this, "complete", "error", "abort"), this.parent = O || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new z(function(S, P) {
            T._resolve = S, T._reject = P;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(S) {
            var P = T.active;
            return T.active = !1, T.on.error.fire(S), T.parent ? T.parent._reject(S) : P && T.idbtrans && T.idbtrans.abort(), Fe(S);
          });
        })), this.Version = (p = this, Tn(Ts.prototype, function(m) {
          this.db = p, this._cfg = { version: m, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (v = this, Tn(Ho.prototype, function(m, N, g) {
          if (this.db = v, this._ctx = { table: m, index: N === ":id" ? null : N, or: g }, this._cmp = this._ascending = be, this._descending = function(w, O) {
            return be(O, w);
          }, this._max = function(w, O) {
            return 0 < be(w, O) ? w : O;
          }, this._min = function(w, O) {
            return be(w, O) < 0 ? w : O;
          }, this._IDBKeyRange = v._deps.IDBKeyRange, !this._IDBKeyRange) throw new K.MissingAPI();
        })), this.on("versionchange", function(m) {
          0 < m.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(m) {
          !m.newVersion || m.newVersion < m.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(m.oldVersion / 10));
        }), this._maxKey = Cn(t.IDBKeyRange), this._createTransaction = function(m, N, g, w) {
          return new o.Transaction(m, N, g, o._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(m) {
          o.on("blocked").fire(m), hn.filter(function(N) {
            return N.name === o.name && N !== o && !N._state.vcFired;
          }).map(function(N) {
            return N.on("versionchange").fire(m);
          });
        }, this.use(Cs), this.use(ks), this.use(As), this.use(Ns), this.use(Ss);
        var E = new Proxy(this, { get: function(m, N, g) {
          if (N === "_vip") return !0;
          if (N === "table") return function(O) {
            return cr(o.table(O), E);
          };
          var w = Reflect.get(m, N, g);
          return w instanceof Mo ? cr(w, E) : N === "tables" ? w.map(function(O) {
            return cr(O, E);
          }) : N === "_createTransaction" ? function() {
            return cr(w.apply(this, arguments), E);
          } : w;
        } });
        this.vip = E, i.forEach(function(m) {
          return m(o);
        });
      }
      var fr, vt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ds = (uo.prototype.subscribe = function(e, t, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: o });
      }, uo.prototype[vt] = function() {
        return this;
      }, uo);
      function uo(e) {
        this._subscribe = e;
      }
      try {
        fr = { indexedDB: f.indexedDB || f.mozIndexedDB || f.webkitIndexedDB || f.msIndexedDB, IDBKeyRange: f.IDBKeyRange || f.webkitIDBKeyRange };
      } catch {
        fr = { indexedDB: null, IDBKeyRange: null };
      }
      function si(e) {
        var t, o = !1, i = new Ds(function(s) {
          var l = bt(e), d, p = !1, v = {}, b = {}, E = { get closed() {
            return p;
          }, unsubscribe: function() {
            p || (p = !0, d && d.abort(), m && Bt.storagemutated.unsubscribe(g));
          } };
          s.start && s.start(E);
          var m = !1, N = function() {
            return Fr(w);
          }, g = function(O) {
            ar(v, O), eo(b, v) && N();
          }, w = function() {
            var O, T, S;
            !p && fr.indexedDB && (v = {}, O = {}, d && d.abort(), d = new AbortController(), S = function(P) {
              var I = fn();
              try {
                l && pn();
                var k = Lt(e, P);
                return k = l ? k.finally(Kt) : k;
              } finally {
                I && dn();
              }
            }(T = { subscr: O, signal: d.signal, requery: N, querier: e, trans: null }), Promise.resolve(S).then(function(P) {
              o = !0, t = P, p || T.signal.aborted || (v = {}, function(I) {
                for (var k in I) if (R(I, k)) return;
                return 1;
              }(b = O) || m || (Bt(Sn, g), m = !0), Fr(function() {
                return !p && s.next && s.next(P);
              }));
            }, function(P) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(P?.name) || p || Fr(function() {
                p || s.error && s.error(P);
              });
            }));
          };
          return setTimeout(N, 0), E;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return t;
        }, i;
      }
      var tn = Pt;
      function lo(e) {
        var t = qt;
        try {
          qt = !0, Bt.storagemutated.fire(e), ro(e, !0);
        } finally {
          qt = t;
        }
      }
      $(tn, u(u({}, Ue), { delete: function(e) {
        return new tn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new tn(e, { addons: [] }).open().then(function(t) {
          return t.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return t = tn.dependencies, o = t.indexedDB, t = t.IDBKeyRange, (zr(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(s) {
              return s.name;
            }).filter(function(s) {
              return s !== Xn;
            });
          }) : Qr(o, t).toCollection().primaryKeys()).then(e);
        } catch {
          return Fe(new K.MissingAPI());
        }
        var t, o;
      }, defineClass: function() {
        return function(e) {
          _(this, e);
        };
      }, ignoreTransaction: function(e) {
        return ne.trans ? zt(ne.transless, e) : e();
      }, vip: Jr, async: function(e) {
        return function() {
          try {
            var t = oo(e.apply(this, arguments));
            return t && typeof t.then == "function" ? t : z.resolve(t);
          } catch (o) {
            return Fe(o);
          }
        };
      }, spawn: function(e, t, o) {
        try {
          var i = oo(e.apply(o, t || []));
          return i && typeof i.then == "function" ? i : z.resolve(i);
        } catch (s) {
          return Fe(s);
        }
      }, currentTransaction: { get: function() {
        return ne.trans || null;
      } }, waitFor: function(e, t) {
        return t = z.resolve(typeof e == "function" ? tn.ignoreTransaction(e) : e).timeout(t || 6e4), ne.trans ? ne.trans.waitFor(t) : t;
      }, Promise: z, debug: { get: function() {
        return se;
      }, set: function(e) {
        Oe(e);
      } }, derive: re, extend: _, props: $, override: fe, Events: En, on: Bt, liveQuery: si, extendObservabilitySet: ar, getByKeyPath: Ce, setByKeyPath: _e, delByKeyPath: function(e, t) {
        typeof t == "string" ? _e(e, t, void 0) : "length" in t && [].map.call(t, function(o) {
          _e(e, o, void 0);
        });
      }, shallowClone: Ae, deepClone: ot, getObjectDiff: io, cmp: be, asap: ge, minKey: -1 / 0, addons: [], connections: hn, errnames: A, dependencies: fr, cache: en, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, t, o) {
        return e + t / Math.pow(10, 2 * o);
      }) })), tn.maxKey = Cn(tn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Bt(Sn, function(e) {
        qt || (e = new CustomEvent(Ur, { detail: e }), qt = !0, dispatchEvent(e), qt = !1);
      }), addEventListener(Ur, function(e) {
        e = e.detail, qt || lo(e);
      }));
      var _n, qt = !1, ai = function() {
      };
      return typeof BroadcastChannel < "u" && ((ai = function() {
        (_n = new BroadcastChannel(Ur)).onmessage = function(e) {
          return e.data && lo(e.data);
        };
      })(), typeof _n.unref == "function" && _n.unref(), Bt(Sn, function(e) {
        qt || _n.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Pt.disableBfCache && e.persisted) {
          se && console.debug("Dexie: handling persisted pagehide"), _n?.close();
          for (var t = 0, o = hn; t < o.length; t++) o[t].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Pt.disableBfCache && e.persisted && (se && console.debug("Dexie: handling persisted pageshow"), ai(), lo({ all: new Qe(-1 / 0, [[]]) }));
      })), z.rejectionMapper = function(e, t) {
        return !e || e instanceof Rt || e instanceof TypeError || e instanceof SyntaxError || !e.name || !V[e.name] ? e : (t = new V[e.name](t || e.message, e), "stack" in e && J(t, "stack", { get: function() {
          return this.inner.stack;
        } }), t);
      }, Oe(se), u(Pt, Object.freeze({ __proto__: null, Dexie: Pt, liveQuery: si, Entity: Lo, cmp: be, PropModification: On, replacePrefix: function(e, t) {
        return new On({ replacePrefix: [e, t] });
      }, add: function(e) {
        return new On({ add: e });
      }, remove: function(e) {
        return new On({ remove: e });
      }, default: Pt, RangeSet: Qe, mergeRanges: In, rangesOverlap: Qo }), { default: Pt }), Pt;
    });
  }(ua)), ua.exports;
}
var sp = ip();
const la = /* @__PURE__ */ Zd(sp), Ou = Symbol.for("Dexie"), ca = globalThis[Ou] || (globalThis[Ou] = la);
if (la.semVer !== ca.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${la.semVer} and ${ca.semVer}`);
const {
  liveQuery: Sm,
  mergeRanges: Cm,
  rangesOverlap: Am,
  RangeSet: Pm,
  cmp: Im,
  Entity: km,
  PropModification: Dm,
  replacePrefix: Rm,
  add: jm,
  remove: Lm,
  DexieYProvider: Km
} = ca, gt = "sclElements";
function Vl(n) {
  return {
    addRecord: r,
    findChildRecordsByTagName: h,
    ensureRelationship: u,
    removeRelationship: c,
    findParentRecordsWithinDepthAndGivenTagName: y,
    db: n
  };
  async function r(_) {
    const j = { ..._, id: crypto.randomUUID() };
    try {
      return await n.table(gt).add(j), j;
    } catch (D) {
      const R = {
        msg: "could not add record",
        db: n.name,
        newRecord: j,
        err: D
      };
      throw console.error(R), new Error(JSON.stringify(R));
    }
  }
  async function a(_) {
    try {
      if (await n.table(gt).update(_.id, _) < 1) {
        const D = { msg: "nothing has been updated", record: _ };
        throw console.error(D), new Error(JSON.stringify(D));
      }
    } catch (j) {
      console.error(j);
    }
  }
  async function u(_, j) {
    const D = _.children?.some(($) => $.id === j.id), R = j.parent?.id === _.id;
    if (D || await n.table(gt).where({ id: _.id }).modify(($) => {
      $.children.push({ id: j.id, tagName: j.tagName });
    }), !R) {
      const $ = {
        id: _.id,
        tagName: _.tagName
      };
      await n.table(gt).update(j.id, { parent: $ });
    }
  }
  async function c(_, j) {
    j.parent = null, await a(j), _.children && (_.children = _.children.filter((D) => D.id !== j.id), await a(_));
  }
  async function f(_) {
    return _.children?.length ? await n.table(gt).where({ "parent.id": _.id }).toArray() : [];
  }
  async function h(_, j) {
    return (await f(_)).filter((R) => j.includes(R.tagName));
  }
  async function y(_, j, D = []) {
    const R = [];
    let $ = _;
    for (let W = 0; W < j; W++) {
      if (!$.parent)
        return R;
      const J = await n.table(gt).get($.parent.id);
      if (!J) {
        const re = {
          msg: "Parent record not found",
          table: $.parent.tagName,
          id: $.parent.id
        };
        throw console.error(re), new Error(JSON.stringify(re));
      }
      (D.length == 0 || D.length > 0 && D.includes(J.tagName)) && R.push(J), $ = J;
    }
    return R;
  }
}
function ap(n, r) {
  return n.attributes?.find((a) => a.name === r);
}
function Be(n, r) {
  return n?.attributes?.find((a) => a.name === r)?.value;
}
const as = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
};
function up(n) {
  const r = Vl(n), a = Dr();
  return {
    createControlledConnection: c,
    createConnection: u,
    createSourcePlaceholder: h,
    createDestinationPlaceholder: f,
    calculateNextInputInstance: y,
    calculateNextOutputInstance: _,
    findExistingInputs: j,
    findExistingOutputs: D
  };
  async function u(R, $, W) {
    const J = await ki(r, W);
    await lp(r, $, J, R), await cp(r, $, R), a.refreshConnections();
  }
  async function c(R, $, W) {
    const J = await Hs(r, $), re = dp(
      R,
      W
    ), te = await fp(n, r, re);
    await r.ensureRelationship(J, te);
    const M = await us(r, W), G = {
      name: R.controlledSignal,
      desc: ""
    }, fe = await Wl(r, G);
    await r.ensureRelationship(M[0], fe), a.refreshConnections();
  }
  async function f(R, $) {
    const W = await ki(r, $), J = await Mi(
      r,
      pp(R)
    );
    await r.ensureRelationship(W, J), a.refreshConnections();
  }
  async function h(R, $) {
    let W = [{ name: "inputName", value: $.inputName }];
    $.preferredLNode && W.push({ name: "pLN", value: $.preferredLNode }), $.dataflowType && W.push({ name: "service", value: $.dataflowType }), $.processResource && W.push({ name: "resourceName", value: $.processResource });
    const J = $.dataAttribute, re = await r.db.table(gt).get(J);
    if (!re) throw new Error(`DAS element with id ${J} not found`);
    const te = await r.addRecord({
      tagName: "SubscriberLNode",
      attributes: W,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(re, te), a.refreshLNode(R);
  }
  async function y(R, $, W) {
    const J = await ki(r, W), M = (await r.findChildRecordsByTagName(J, [
      "SourceRef"
    ])).map((G) => ({
      input: Be(G, "input"),
      pDA: Be(G, "pDA")
    })).filter(
      (G) => G.input === R && G.pDA === $
    );
    return M.length === 0 ? 1 : M.length + 1;
  }
  async function _(R, $) {
    const W = await Hs(r, $), te = (await r.findChildRecordsByTagName(W, [
      "ControlRef"
    ])).map((M) => Be(M, "output")).filter((M) => !!M).filter(
      (M) => M === R
    );
    return te.length === 0 ? 1 : te.length + 1;
  }
  async function j(R) {
    const $ = await ki(r, R), J = (await r.findChildRecordsByTagName($, [
      "SourceRef"
    ])).map((te) => Be(te, "input")).filter((te) => !!te);
    return Array.from(new Set(J));
  }
  async function D(R) {
    const $ = await Hs(r, R), J = (await r.findChildRecordsByTagName($, [
      "ControlRef"
    ])).map((te) => Be(te, "output")).filter((te) => !!te);
    return Array.from(new Set(J));
  }
}
async function ki(n, r) {
  const a = await us(n, r), u = await n.findChildRecordsByTagName(a[0], [
    "LNodeInputs"
  ]);
  if (u.length != 1) {
    const c = {
      msg: `LNodeInputs element not found or more than one element found in LNode with uuid ${r.uuid}`
    };
    throw console.error(c), new Error(JSON.stringify(c));
  }
  return u[0];
}
async function Hs(n, r) {
  const a = await us(n, r), u = await n.findChildRecordsByTagName(a[0], [
    "LNodeOutputs"
  ]);
  if (u.length != 1) {
    const c = {
      msg: `LNodeOutputs element not found or more than one element found in LNode with uuid ${r.uuid}`
    };
    throw console.error(c), new Error(JSON.stringify(c));
  }
  return u[0];
}
async function lp(n, r, a, u) {
  const c = await Mi(
    n,
    Ws(u, r)
  );
  if (await n.ensureRelationship(a, c), u.includeQuality) {
    const f = {
      ...u,
      attribute: "q"
      // Set to 'q' for Quality
    }, h = await Mi(
      n,
      Ws(f, r)
    );
    await n.ensureRelationship(a, h);
  }
  if (u.includeTimestamp) {
    const f = {
      ...u,
      attribute: "t"
      // Set to 't' for Timestamp
    }, h = await Mi(
      n,
      Ws(f, r)
    );
    await n.ensureRelationship(a, h);
  }
}
async function us(n, r) {
  const a = await n.db.table(gt).get(r.id);
  if (!a || !a.children || a.children.length == 0) {
    const f = {
      msg: `LNode element with uuid ${r.uuid} not found or empty`
    };
    throw console.error(f), new Error(JSON.stringify(f));
  }
  const u = await n.findChildRecordsByTagName(a, ["Private"]);
  if (!u.filter((f) => ap(f, "type")?.value === "eIEC61850-6-100").at(0)) {
    const f = {
      msg: `Private element of type 'eIEC61850-6-100' not found in LNode with uuid ${r.uuid}`
    };
    throw console.error(f), new Error(JSON.stringify(f));
  }
  return u;
}
async function Mi(n, r) {
  const a = {
    tagName: "SourceRef",
    namespace: as,
    attributes: [
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pDA",
        value: r.pDA
      },
      {
        name: "input",
        value: r.inputName
      },
      {
        name: "inputInst",
        value: r.inputInstance
      },
      {
        name: "service",
        value: r.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: r.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: r.sourceDoName
      },
      {
        name: "sourceDaName",
        value: r.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: r.resourceName
      },
      {
        name: "source",
        value: await Hl(
          n.db,
          r.sourceLNodeUuid,
          r.sourceDoName,
          r.sourceDaName
        )
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(a);
}
async function cp(n, r, a) {
  const u = r.dataObjectSpecifications?.filter((f) => f.name === a.signal) ?? [];
  let c;
  for (const f of u) {
    const h = f.dataAttributeSpecifications.find((y) => y.name === a.attribute);
    if (h) {
      c = h;
      break;
    }
  }
  if (!c && u[0]) {
    const f = await n.db.table(gt).get(u[0].id), h = {
      name: a.attribute,
      desc: ""
    }, y = await Nu(
      n,
      h
    );
    f ? await n.ensureRelationship(f, y) : console.error("Could not find find matching DOS in db");
  } else if (!c && !u[0]) {
    const f = await us(n, r), h = {
      name: a.signal,
      desc: ""
    }, y = await Wl(n, h);
    await n.ensureRelationship(f[0], y);
    const _ = {
      name: a.attribute,
      desc: ""
    }, j = await Nu(
      n,
      _
    );
    await n.ensureRelationship(y, j);
  }
}
async function fp(n, r, a) {
  const u = {
    tagName: "ControlRef",
    namespace: as,
    attributes: [
      {
        name: "pDO",
        value: a.pDO
      },
      {
        name: "pLN",
        value: a.pLN
      },
      {
        name: "controlled",
        value: await Hl(
          n,
          a.controlledLNodeUuid,
          a.controlledDoName
        )
      },
      {
        name: "output",
        value: a.output
      },
      {
        name: "outputInst",
        value: a.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: a.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: a.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await r.addRecord(u);
}
async function Hl(n, r, a, u) {
  if (!r) return "";
  const c = await n.table(gt).where({ tagName: "LNode" }).toArray().then(
    (R) => R.find(
      ($) => $.attributes?.some((W) => W.name === "uuid" && W.value === r)
    )
  );
  if (!c) return "";
  const f = [];
  let h = c;
  const y = ["LNode", "SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
  for (; h && h.parent; ) {
    if (y.includes(h.tagName)) {
      const R = Be(h, "name");
      R && f.unshift(R);
    }
    h = await n.table(gt).get(h.parent.id);
  }
  const _ = (() => {
    const R = c.attributes?.find((J) => J.name === "prefix")?.value || "", $ = c.attributes?.find((J) => J.name === "lnClass")?.value || "", W = c.attributes?.find((J) => J.name === "lnInst")?.value || "";
    return `${R}${$}${W}`;
  })();
  f.push(_);
  let D = `${f.join("/")}.${a}`;
  return u && (D += "." + u), D;
}
function Ws(n, r) {
  return {
    dataflowType: n.type,
    inputName: n.inputName,
    inputInstance: n.inputInstance,
    sourceLNodeUuid: r.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: n.signal,
    sourceDaName: n.attribute,
    pLN: r.lnClass,
    // SETRULE: set lnClass of source LNode also as preferred LN
    pDO: n.signal,
    // SETRULE: set signal/data object also as preferred DO
    pDA: n.attribute
    // SETRULE: set data attribute also as preferred DA
  };
}
function dp(n, r) {
  return {
    pDO: "",
    // TODO
    pLN: "",
    // TODO
    output: n.outputName,
    outputInst: n.outputInstance,
    controlledLNodeUuid: r.uuid,
    controlledDoName: n.controlledSignal
  };
}
function pp(n) {
  return {
    dataflowType: n.dataflowType,
    inputName: n.inputName,
    inputInstance: n.inputInstance,
    sourceLNodeUuid: "",
    resourceName: n.processResource,
    sourceDoName: "",
    sourceDaName: "",
    pLN: n.preferredLNode,
    pDO: n.preferredDataObject,
    pDA: n.preferredDataAttribute
  };
}
async function Wl(n, r) {
  const a = {
    tagName: "DOS",
    namespace: as,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(a);
}
async function Nu(n, r) {
  const a = {
    tagName: "DAS",
    namespace: as,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await n.addRecord(a);
}
function hp(n) {
  return {
    findAllEnrichedLNodes: r,
    findAllLNodeTypes: a,
    enrichWithDataObjectSpecifications: f
  };
  async function r() {
    const y = await h();
    return y.length ? await f(y) : [];
  }
  async function a() {
    const y = await n.table(gt).where({ tagName: "LNodeType" }).toArray(), _ = [];
    for (const j of y)
      _.push({
        id: j.id,
        typeId: Be(j, "id") ?? "",
        lnClass: Be(j, "lnClass") ?? "",
        dataObjects: await u(j)
      });
    return _;
  }
  async function u(y) {
    if (!y.children) return [];
    const _ = [];
    for (const j of y.children) {
      if (j.tagName !== "DO") continue;
      const D = await n.table(gt).get(j.id);
      D && _.push({
        id: D.id,
        name: Be(D, "name") ?? "",
        type: Be(D, "type") ?? "",
        desc: Be(D, "desc") ?? "",
        dataAttributes: await c(D),
        lnodeTypeId: y.id
      });
    }
    return _;
  }
  async function c(y) {
    const _ = Be(y, "type");
    if (!_) return [];
    const j = (await n.table(gt).where({ tagName: "DOType" }).toArray()).find((R) => R.attributes?.find(($) => $.name === "id" && $.value === _));
    if (!j || !j.children) return [];
    const D = [];
    for (const R of j.children) {
      if (R.tagName !== "DA") continue;
      const $ = await n.table(gt).get(R.id);
      $ && D.push({
        id: $.id,
        name: Be($, "name") ?? "",
        type: Be($, "type") ?? "",
        desc: Be($, "desc") ?? "",
        bType: Be($, "bType") ?? "",
        fc: Be($, "fc") ?? "",
        dataObjectId: y.id
      });
    }
    return D;
  }
  async function f(y) {
    const _ = await n.table(gt).where({ tagName: "Private" }).toArray(), j = await n.table(gt).where({ tagName: "DOS" }).toArray(), D = await n.table(gt).where({ tagName: "DAS" }).toArray(), R = await n.table(gt).where({ tagName: "SubscriberLNode" }).toArray();
    return Promise.all(
      y.map(async ($) => {
        const W = _.find(
          (re) => re.parent?.id === $.id && re.parent?.tagName === "LNode" && Be(re, "type") === "eIEC61850-6-100"
        );
        if (!W || !W.children)
          return { ...$, dataObjectSpecifications: [] };
        const J = [];
        for (const re of W.children) {
          if (re.tagName !== "DOS") continue;
          const te = j.find((G) => G.id === re.id);
          if (!te) continue;
          const M = [];
          if (te.children)
            for (const G of te.children) {
              if (G.tagName !== "DAS") continue;
              const fe = D.find((ge) => ge.id === G.id);
              if (!fe) continue;
              let ae = [];
              if (fe.children) {
                const ge = fe.children.filter((_e) => _e.tagName === "SubscriberLNode"), Ce = R.filter(
                  (_e) => ge.some((Ae) => Ae.id === _e.id)
                );
                for (const _e of Ce)
                  ae.push({
                    id: _e.id,
                    inputName: Be(_e, "inputName") ?? "",
                    service: Gl(_e, "service"),
                    pLN: Be(_e, "pLN") ?? ""
                  });
              }
              M.push({
                id: fe.id,
                name: Be(fe, "name") ?? "",
                desc: Be(fe, "desc") ?? "",
                dataObjectSpecificationId: te.id,
                subscriberLNodes: ae
              });
            }
          J.push({
            id: te.id,
            name: Be(te, "name") ?? "",
            desc: Be(te, "desc") ?? "",
            dataAttributeSpecifications: M,
            lNodeId: $.id
          });
        }
        return { ...$, dataObjectSpecifications: J };
      })
    );
  }
  async function h() {
    return (await n.table(gt).where({ tagName: "LNode" }).toArray()).map((_) => ({
      id: _.id,
      uuid: Be(_, "uuid") ?? "",
      iedName: Be(_, "iedName") ?? "",
      prefix: Be(_, "prefix") ?? "",
      lnClass: Be(_, "lnClass") ?? "",
      lnInst: Be(_, "lnInst") ?? "",
      lnType: Be(_, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function Gl(n, r) {
  const a = n?.attributes?.find((c) => c.name === r)?.value;
  if (!a) return;
  switch (a.toUpperCase()) {
    case "GOOSE":
      return Nt.GOOSE;
    case "SMV":
      return Nt.SMV;
    case "REPORT":
      return Nt.REPORT;
    case "WIRED":
      return Nt.WIRED;
    case "CONTROL":
      return Nt.CONTROL;
    case "INTERNAL":
      return Nt.INTERNAL;
    default:
      return;
  }
}
function mp(n) {
  const r = Vl(n);
  return {
    findAllExistingConnections: a,
    findAllExistingControlledConnections: u
  };
  async function a() {
    const c = await n.table(gt).where({ tagName: "SourceRef" }).toArray();
    if (!c.length) return [];
    const f = [];
    for (const h of c) {
      if (!h.attributes) continue;
      const y = Be(h, "sourceLNodeUuid"), _ = await n.table(gt).where({ tagName: "LNode" }).toArray().then(
        (R) => R.find(
          ($) => $.attributes?.some(
            (W) => W.name === "uuid" && W.value === y
          )
        )?.id
      ) || null, j = await r.findParentRecordsWithinDepthAndGivenTagName(
        h,
        3,
        ["LNode"]
      );
      if (j.length != 1) {
        const R = {
          msg: "LNode record not found for SourceRef id",
          id: h.id
        };
        throw console.error(R), new Error(JSON.stringify(R));
      }
      const D = {
        id: h.id,
        sourceLNodeId: _,
        destinationLNodeId: j[0].id,
        sourceDataObject: Be(h, "sourceDoName") || "",
        sourceDataAttribute: Be(h, "sourceDaName") || "",
        dataflowType: Gl(h, "service"),
        inputInstance: Be(h, "inputInst") || "",
        input: Be(h, "input") || "",
        preferredLNode: Be(h, "pLN") || "",
        preferredDataObject: Be(h, "pDO") || "",
        preferredDataAttribute: Be(h, "pDA") || "",
        processResource: Be(h, "resourceName") || ""
      };
      f.push(D);
    }
    return f;
  }
  async function u() {
    const c = await n.table(gt).where({ tagName: "ControlRef" }).toArray();
    if (!c.length) return [];
    const f = [];
    for (const h of c) {
      if (!h.attributes) continue;
      const y = Be(h, "controlledLNodeUuid"), _ = Be(h, "controlledDoName"), j = await n.table(gt).where({ tagName: "LNode" }).toArray().then(
        ($) => $.find(
          (W) => W.attributes?.some(
            (J) => J.name === "uuid" && J.value === y
          )
        )?.id
      ) || null, D = await r.findParentRecordsWithinDepthAndGivenTagName(
        h,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (D.length != 1) {
        const $ = {
          msg: "LNode record not found for ControlRef id",
          id: h.id
        };
        throw console.error($), new Error(JSON.stringify($));
      }
      const R = {
        controllerLNodeId: D[0].id,
        controlledLNodeId: j,
        controlledDataObject: _ || "",
        dataflowType: Nt.CONTROL,
        outputInstance: Be(h, "outputInst") || "",
        outputName: Be(h, "output") || ""
      };
      f.push(R);
    }
    return f;
  }
}
const Dr = /* @__PURE__ */ $l("dataflow/app", () => {
  let n = null;
  const r = lt(""), a = lt([]), u = lt([]), c = lt([]), f = lt([]), h = Ri(), y = Ri(), _ = Ri();
  async function j(W) {
    D(), n = new Xi(W), await n.open(), _.value = hp(n), y.value = mp(n), r.value = W, h.value = up(n), a.value = await _.value.findAllEnrichedLNodes(), u.value = await _.value.findAllLNodeTypes(), c.value = await y.value.findAllExistingConnections(), f.value = await y.value.findAllExistingControlledConnections();
  }
  function D() {
    n && (n.close(), n = null);
  }
  async function R() {
    c.value = await y.value.findAllExistingConnections(), f.value = await y.value.findAllExistingControlledConnections();
  }
  async function $(W) {
    const re = (await _.value.findAllEnrichedLNodes()).find((te) => te.id === W);
    if (re) {
      const te = a.value.findIndex((M) => M.id === W);
      te !== -1 && (a.value[te] = re);
    }
  }
  return {
    // states
    activeFilename: r,
    lnodes: a,
    lnodeTypes: u,
    connections: c,
    controlledConnections: f,
    // getters
    dataflowSdk: h,
    // actions
    initApp: j,
    closeDatabase: D,
    refreshConnections: R,
    refreshLNode: $
  };
}), yp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, vp = { class: "modal-box" }, gp = { class: "grid grid-cols-2 gap-4 mt-4" }, bp = ["value"], _p = { class: "grid grid-cols-2 gap-4 mt-4" }, wp = { class: "grid grid-cols-2 gap-4 mt-4" }, xp = ["value", "disabled"], Ep = { class: "grid grid-cols-2 gap-4 mt-4" }, Tp = ["value"], Op = { class: "grid grid-cols-2 gap-4 mt-4" }, Np = ["value"], Sp = { class: "grid grid-cols-2 gap-4 mt-4" }, Cp = ["value"], Ap = { class: "grid grid-cols-2 gap-4 mt-4" }, Pp = /* @__PURE__ */ Yt({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {}
  },
  setup(n) {
    const r = n, a = Dr(), { lnodeTypes: u, dataflowSdk: c } = kr(a), f = lt(
      R()
    );
    let h = lt(!0), y = lt([]);
    const _ = fl("dialog");
    cn(
      () => r.destinationLNode,
      async (te) => {
        y.value = await c.value.findExistingInputs(te);
      },
      { immediate: !0 }
    ), cn(
      [
        () => f.value.inputName,
        () => f.value.preferredDataAttribute
      ],
      async ([te, M]) => {
        if (!te) {
          f.value.inputInstance = "";
          return;
        }
        const G = await c.value.calculateNextInputInstance(
          te,
          M,
          r.destinationLNode
        );
        f.value.inputInstance = G.toString();
      }
    );
    const j = It(() => {
      const te = u.value.find(
        (M) => M.lnClass === f.value.preferredLNode
      );
      return te ? f.value.dataflowType ? te.dataObjects.filter(
        (M) => M.dataAttributes.some(
          (G) => Yi[f.value.dataflowType].includes(G.fc)
        )
      ).map((M) => M.name) : te.dataObjects.map((M) => M.name) : [];
    }), D = It(() => {
      const te = u.value.find(
        (G) => G.lnClass === f.value.preferredLNode
      );
      if (!te) return [];
      const M = te.dataObjects.find(
        (G) => G.name === f.value.preferredDataObject
      );
      return M ? f.value.dataflowType ? M.dataAttributes.filter(
        (G) => Yi[f.value.dataflowType].includes(G.fc)
      ).map((G) => G.name) : M.dataAttributes.map((G) => G.name) : [];
    });
    function R() {
      return {
        dataflowType: null,
        inputName: "",
        inputInstance: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    async function $() {
      try {
        await c.value.createDestinationPlaceholder(
          f.value,
          r.destinationLNode
        ), W();
      } catch (te) {
        console.error("Error creating destination placeholder port:", te), alert(`Error creating placeholder: ${te instanceof Error ? te.message : "Unknown error"}`);
      }
    }
    function W() {
      f.value = R(), h.value = !0;
    }
    function J(te) {
      for (const M of te)
        f.value[M] = "";
    }
    function re(te) {
      te?.showModal(), W();
    }
    return (te, M) => (ve(), Ee("div", yp, [
      L("button", {
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center",
        onClick: M[0] || (M[0] = (G) => re(_.value)),
        "aria-label": "Add destination placeholder"
      }, M[14] || (M[14] = [
        L("svg", {
          width: "16px",
          height: "16px",
          viewBox: "0 0 20 20",
          fill: "currentColor",
          xmlns: "http://www.w3.org/2000/svg"
        }, [
          L("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          L("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      L("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: _
      }, [
        L("div", vp, [
          M[29] || (M[29] = L("h3", { class: "text-lg font-bold" }, "Create Placeholder - Receive data from", -1)),
          M[30] || (M[30] = L("form", { method: "dialog" }, [
            L("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close destination placeholder creation"
            }, [
              L("svg", {
                xmlns: "http://www.w3.org/2000/svg",
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                L("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          L("form", {
            method: "dialog",
            onSubmit: $
          }, [
            L("div", gp, [
              L("fieldset", null, [
                M[17] || (M[17] = L("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
                L("div", null, [
                  et(L("input", {
                    type: "radio",
                    id: "existing-input",
                    name: "input",
                    "onUpdate:modelValue": M[1] || (M[1] = (G) => st(h) ? h.value = G : h = G),
                    value: !0,
                    class: "mr-2"
                  }, null, 512), [
                    [Ir, Ve(h)]
                  ]),
                  M[15] || (M[15] = L("label", { for: "existing-input" }, "Existing Input", -1))
                ]),
                L("div", null, [
                  et(L("input", {
                    type: "radio",
                    id: "new-input",
                    name: "input",
                    "onUpdate:modelValue": M[2] || (M[2] = (G) => st(h) ? h.value = G : h = G),
                    value: !1,
                    class: "mr-2"
                  }, null, 512), [
                    [Ir, Ve(h)]
                  ]),
                  M[16] || (M[16] = L("label", { for: "new-input" }, "New Input", -1))
                ])
              ]),
              Ve(h) ? Vt("", !0) : et((ve(), Ee("input", {
                key: 0,
                "aria-label": "New Input Name",
                required: "",
                type: "text",
                placeholder: "Input Name",
                class: "input col-start-2",
                "onUpdate:modelValue": M[3] || (M[3] = (G) => f.value.inputName = G)
              }, null, 512)), [
                [br, f.value.inputName]
              ]),
              Ve(h) ? et((ve(), Ee("select", {
                key: 1,
                "aria-label": "Existing Input Name Select",
                required: "",
                class: "input col-start-2",
                "onUpdate:modelValue": M[4] || (M[4] = (G) => f.value.inputName = G)
              }, [
                (ve(!0), Ee(Ye, null, St(Ve(y), (G) => (ve(), Ee("option", {
                  key: G,
                  value: G
                }, Re(G), 9, bp))), 128))
              ], 512)), [
                [ln, f.value.inputName]
              ]) : Vt("", !0)
            ]),
            L("div", _p, [
              M[18] || (M[18] = L("label", {
                for: "input-instance-input",
                class: "col-start-1 self-center"
              }, "Input Instance", -1)),
              et(L("input", {
                id: "input-instance-input",
                required: "",
                disabled: "",
                type: "text",
                class: "input col-start-2",
                "onUpdate:modelValue": M[5] || (M[5] = (G) => f.value.inputInstance = G)
              }, null, 512), [
                [br, f.value.inputInstance]
              ])
            ]),
            L("div", wp, [
              M[20] || (M[20] = L("label", {
                for: "dataflow-type-select",
                class: "col-start-1 self-center"
              }, "Dataflow Type", -1)),
              et(L("select", {
                id: "dataflow-type-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[6] || (M[6] = (G) => f.value.dataflowType = G),
                onChange: M[7] || (M[7] = (G) => J(["preferredDataObject"]))
              }, [
                (ve(!0), Ee(Ye, null, St(Object.values(Ve(Nt)), (G) => (ve(), Ee("option", {
                  key: G,
                  value: G,
                  disabled: G === Ve(Nt).CONTROL
                }, Re(G), 9, xp))), 128)),
                M[19] || (M[19] = L("option", {
                  key: "empty",
                  value: null
                }, "-", -1))
              ], 544), [
                [ln, f.value.dataflowType]
              ])
            ]),
            L("div", Ep, [
              M[22] || (M[22] = L("label", {
                for: "preferred-lnode-select",
                class: "col-start-1 self-center"
              }, "Preferred LNode", -1)),
              et(L("select", {
                id: "preferred-lnode-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[8] || (M[8] = (G) => f.value.preferredLNode = G),
                onChange: M[9] || (M[9] = (G) => J(["preferredDataObject"]))
              }, [
                (ve(!0), Ee(Ye, null, St(Ve(u), (G) => (ve(), Ee("option", {
                  key: G.lnClass,
                  value: G.lnClass
                }, Re(G.lnClass), 9, Tp))), 128)),
                M[21] || (M[21] = L("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 544), [
                [ln, f.value.preferredLNode]
              ])
            ]),
            L("div", Op, [
              M[24] || (M[24] = L("label", {
                for: "data-object-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Object", -1)),
              et(L("select", {
                id: "data-object-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[10] || (M[10] = (G) => f.value.preferredDataObject = G),
                onChange: M[11] || (M[11] = (G) => J(["preferredDataAttribute"]))
              }, [
                (ve(!0), Ee(Ye, null, St(j.value, (G) => (ve(), Ee("option", {
                  key: G,
                  value: G
                }, Re(G), 9, Np))), 128)),
                M[23] || (M[23] = L("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 544), [
                [ln, f.value.preferredDataObject]
              ])
            ]),
            L("div", Sp, [
              M[26] || (M[26] = L("label", {
                for: "data-attribute-select",
                class: "col-start-1 self-center"
              }, "Preferred Data Attribute", -1)),
              et(L("select", {
                id: "data-attribute-select",
                class: "select col-start-2",
                "onUpdate:modelValue": M[12] || (M[12] = (G) => f.value.preferredDataAttribute = G)
              }, [
                (ve(!0), Ee(Ye, null, St(D.value, (G) => (ve(), Ee("option", {
                  key: G,
                  value: G
                }, Re(G), 9, Cp))), 128)),
                M[25] || (M[25] = L("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 512), [
                [ln, f.value.preferredDataAttribute]
              ])
            ]),
            L("div", Ap, [
              M[27] || (M[27] = L("label", {
                for: "process-resource-input",
                class: "col-start-1 self-center"
              }, "Process Resource", -1)),
              et(L("input", {
                id: "process-resource-input",
                type: "text",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": M[13] || (M[13] = (G) => f.value.processResource = G)
              }, null, 512), [
                [br, f.value.processResource]
              ])
            ]),
            M[28] || (M[28] = L("div", { class: "modal-action" }, [
              L("button", {
                class: "btn bg-(--color-primary) border-none text-white",
                type: "submit"
              }, " Save ")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), Ip = { key: 0 }, kp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm"
}, Dp = /* @__PURE__ */ Yt({
  __name: "source-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(n) {
    return (r, a) => (ve(), Ee("div", null, [
      (ve(), Ee("div", Ip, [
        a[0] || (a[0] = L("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder Details", -1)),
        r.placeholder.dataflowType ? (ve(), Ee("span", kp, Re(r.placeholder.dataflowType), 1)) : Vt("", !0),
        L("p", null, "Input: " + Re(r.placeholder.input), 1),
        L("p", null, "Data Object: " + Re(r.placeholder.dataObject || "-"), 1),
        L("p", null, "Data Attribute: " + Re(r.placeholder.dataAttribute || "-"), 1),
        L("p", null, "Preferred LNode: " + Re(r.placeholder.preferredLNode || "-"), 1),
        L("p", null, "Process Resource: " + Re(r.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Rp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12 *:pointer-events-auto" }, jp = ["onClick"], Lp = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Kp = ["onClick"], Fp = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, Mp = ["onClick"], Bp = {
  height: "12",
  width: "24"
}, qp = { class: "ml-2" }, $p = /* @__PURE__ */ Yt({
  __name: "source-placeholder-ports",
  props: {
    dataObjectSpecifications: {}
  },
  setup(n) {
    const r = n, a = It(
      () => r.dataObjectSpecifications.flatMap(
        (h) => h.dataAttributeSpecifications.flatMap(
          (y) => y.subscriberLNodes?.map(
            (_) => ({
              id: _.id,
              dataObject: h.name,
              dataAttribute: y.name,
              dataflowType: _.service,
              preferredLNode: _.pLN,
              input: _.inputName,
              processResource: ""
            })
          ) ?? []
        )
      )
    ), u = Ul(), { activeElement: c } = kr(u);
    function f(h) {
      const y = h == c.value ? null : h;
      u.setActiveElement(y);
    }
    return (h, y) => (ve(!0), Ee(Ye, null, St(a.value, (_) => (ve(), Ee("div", Rp, [
      L("div", {
        onClick: (j) => f(_.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        L("span", Lp, Re(_.dataObject) + "." + Re(_.dataAttribute), 1)
      ], 8, jp),
      L("div", {
        onClick: (j) => f(_.id),
        class: vo([{
          "bg-(--color-primary)": Ve(c) === _.id
        }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
      }, null, 10, Kp),
      L("div", Fp, [
        L("div", {
          class: "inline-flex items-center h-full max-w-max hover:cursor-pointer",
          onClick: (j) => f(_.id)
        }, [
          (ve(), Ee("svg", Bp, [
            L("line", {
              x1: "0",
              y1: "6",
              x2: "24",
              y2: "6",
              stroke: "currentColor",
              "stroke-width": "2",
              class: vo({
                "text-(--color-primary)": Ve(c) === _.id,
                "text-(--color-ocean-gray-100)": Ve(c) !== _.id
              })
            }, null, 2)
          ])),
          L("span", qp, Re(_.input), 1)
        ], 8, Mp)
      ]),
      Ve(c) == _.id ? (ve(), kn(ul, {
        key: 0,
        to: "#sidebar-details"
      }, [
        Ct(Dp, { placeholder: _ }, null, 8, ["placeholder"])
      ])) : Vt("", !0)
    ]))), 256));
  }
}), Up = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, Vp = { class: "col-start-1 col-span-1 self-center justify-self-end" }, Hp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Wp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Gp = ["data-testid"], Yp = { class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1" }, Xp = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Qp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, zp = /* @__PURE__ */ Yt({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(n) {
    return (r, a) => (ve(!0), Ee(Ye, null, St(r.controlledConnections, (u, c) => (ve(), Ee("div", Up, [
      L("div", Vp, [
        L("span", Hp, Re(u.outputName), 1),
        L("span", Wp, Re(u.outputInstance), 1)
      ]),
      a[0] || (a[0] = L("div", { class: "rounded-full w-[20px] h-[20px] col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[9px]" }, null, -1)),
      L("div", {
        class: "col-start-3 col-span-1 h-[2px] bg-(--color-ocean-gray-100) self-center row-start-1",
        "data-testid": `dataflow-controlled-connection-line-${c}`
      }, null, 8, Gp),
      a[1] || (a[1] = L("svg", {
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        L("polygon", {
          points: "0,0 8,6 0,12",
          style: { fill: "var(--color-ocean-gray-100)" }
        })
      ], -1)),
      L("div", Yp, Re(u.dataflowType), 1),
      a[2] || (a[2] = L("div", { class: "rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px]" }, null, -1)),
      L("div", Xp, [
        L("span", Qp, Re(u.controlledDataObject), 1)
      ])
    ]))), 256));
  }
}), Jp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] grid-rows-1" }, Zp = { class: "modal-box" }, eh = { class: "grid grid-cols-2 gap-4 items-center" }, th = { class: "grid grid-cols-2 gap-4 items-center" }, nh = ["value", "disabled"], rh = { class: "grid grid-cols-2 gap-4 items-center" }, oh = ["value"], ih = { class: "grid grid-cols-2 gap-4 items-center" }, sh = { class: "grid grid-cols-2 gap-4 items-center" }, ah = ["value"], uh = /* @__PURE__ */ Yt({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {}
  },
  setup(n) {
    const r = n, a = Dr(), { lnodeTypes: u, dataflowSdk: c } = kr(a), f = lt(
      D()
    );
    async function h($) {
      try {
        await c.value.createSourcePlaceholder(
          r.sourceLNode.id,
          f.value
        ), R();
      } catch (W) {
        console.error("Error creating source placeholder port:", W), alert(`Error creating placeholder: ${W instanceof Error ? W.message : "Unknown error"}`);
      }
    }
    const y = It(() => (r.sourceLNode.dataObjectSpecifications ?? []).flatMap((re) => re.dataAttributeSpecifications).filter((re) => {
      const te = f.value.dataflowType;
      return !te || !re.subscriberLNode?.service ? !0 : te == re.subscriberLNode.service;
    }).map((re) => ({ id: re.id, name: re.name })).sort((re, te) => re.name.localeCompare(te.name))), _ = fl("dialog");
    function j($) {
      $?.showModal(), R();
    }
    function D() {
      return {
        dataAttribute: "",
        inputName: "",
        dataflowType: "",
        processResource: "",
        preferredLNode: ""
      };
    }
    function R() {
      f.value = D();
    }
    return ($, W) => (ve(), Ee("div", Jp, [
      L("button", {
        onClick: W[0] || (W[0] = (J) => j(_.value)),
        "aria-label": "Add source placeholder",
        class: "btn btn-primary btn-circle size-5 col-start-3 col-span-1 -ml-[12px] self-center relative z-10"
      }, W[6] || (W[6] = [
        L("svg", {
          width: "16",
          height: "16",
          viewBox: "0 0 20 20",
          fill: "currentColor"
        }, [
          L("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }),
          L("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" })
        ], -1)
      ])),
      L("dialog", {
        class: "modal",
        ref_key: "dialog",
        ref: _
      }, [
        L("div", Zp, [
          W[16] || (W[16] = L("h3", { class: "text-lg font-bold" }, "Create Placeholder - Provide data", -1)),
          W[17] || (W[17] = L("form", { method: "dialog" }, [
            L("button", {
              class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
              "aria-label": "Close source placeholder creation"
            }, [
              L("svg", {
                width: "28",
                height: "28",
                viewBox: "0 0 64 64"
              }, [
                L("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
              ])
            ])
          ], -1)),
          L("form", {
            onSubmit: h,
            method: "dialog",
            class: "flex flex-col gap-4 mt-4"
          }, [
            L("div", eh, [
              W[7] || (W[7] = L("label", { for: "input-name" }, "Input Name", -1)),
              et(L("input", {
                required: "",
                id: "input-name",
                name: "inputName",
                "onUpdate:modelValue": W[1] || (W[1] = (J) => f.value.inputName = J),
                placeholder: "Input Name",
                class: "input col-start-2"
              }, null, 512), [
                [br, f.value.inputName]
              ])
            ]),
            L("div", th, [
              W[9] || (W[9] = L("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
              et(L("select", {
                id: "dataflow-type-select",
                name: "dataflowType",
                class: "select col-start-2",
                "onUpdate:modelValue": W[2] || (W[2] = (J) => f.value.dataflowType = J)
              }, [
                W[8] || (W[8] = L("option", { value: "" }, "-", -1)),
                (ve(!0), Ee(Ye, null, St(Object.values(Ve(Nt)), (J) => (ve(), Ee("option", {
                  key: J,
                  value: J,
                  disabled: J === Ve(Nt).CONTROL
                }, Re(J), 9, nh))), 128))
              ], 512), [
                [ln, f.value.dataflowType]
              ])
            ]),
            L("div", rh, [
              W[11] || (W[11] = L("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
              et(L("select", {
                required: "",
                id: "data-attribute-select",
                name: "attribute",
                "onUpdate:modelValue": W[3] || (W[3] = (J) => f.value.dataAttribute = J),
                class: "select col-start-2",
                placeholder: "No Attribute"
              }, [
                W[10] || (W[10] = L("option", {
                  value: "",
                  disabled: ""
                }, "-", -1)),
                (ve(!0), Ee(Ye, null, St(y.value, (J) => (ve(), Ee("option", {
                  key: J.id,
                  value: J.id
                }, Re(J.name), 9, oh))), 128))
              ], 512), [
                [ln, f.value.dataAttribute]
              ])
            ]),
            L("div", ih, [
              W[12] || (W[12] = L("label", { for: "process-resource-input" }, "Process Resource", -1)),
              et(L("input", {
                id: "process-resource-input",
                name: "processResource",
                placeholder: "Process Resource",
                class: "input col-start-2",
                "onUpdate:modelValue": W[4] || (W[4] = (J) => f.value.processResource = J)
              }, null, 512), [
                [br, f.value.processResource]
              ])
            ]),
            L("div", sh, [
              W[14] || (W[14] = L("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
              et(L("select", {
                id: "preferred-lnode-select",
                name: "preferredLNode",
                class: "select col-start-2",
                "onUpdate:modelValue": W[5] || (W[5] = (J) => f.value.preferredLNode = J)
              }, [
                (ve(!0), Ee(Ye, null, St(Ve(u), (J) => (ve(), Ee("option", {
                  key: J.lnClass,
                  value: J.lnClass
                }, Re(J.lnClass), 9, ah))), 128)),
                W[13] || (W[13] = L("option", {
                  key: "empty",
                  value: ""
                }, "-", -1))
              ], 512), [
                [ln, f.value.preferredLNode]
              ])
            ]),
            W[15] || (W[15] = L("div", { class: "modal-action" }, [
              L("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
            ], -1))
          ], 32)
        ])
      ], 512)
    ]));
  }
}), lh = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, ch = ["value"], fh = ["value"], dh = ["value"], ph = ["value"], hh = { class: "col-span-full row-start-2" }, mh = { class: "grid" }, yh = { class: "col-start-1 row-start-1 pointer-events-none" }, vh = { class: "col-start-1 row-start-1 -order-1" }, gh = /* @__PURE__ */ Yt({
  __name: "dataflow-visualisation",
  emits: ["sourceLNodeChange", "destinationLNodeChange"],
  setup(n, { emit: r }) {
    const a = r, u = Dr(), { lnodes: c, connections: f, controlledConnections: h } = kr(u), y = lt(), _ = lt(), j = lt(), D = lt();
    cn(
      () => c.value,
      () => {
        y.value = void 0, _.value = void 0;
      }
    );
    const R = It(
      () => c.value.filter((ae) => ae.id !== _.value).sort((ae, ge) => Bn(ae).localeCompare(Bn(ge)))
    ), $ = It(() => c.value.find((ge) => ge.id === y.value)?.dataObjectSpecifications ?? []), W = It(
      () => c.value.filter((ae) => ae.id !== y.value).sort((ae, ge) => Bn(ae).localeCompare(Bn(ge)))
    ), J = It(() => !y.value || !_.value ? [] : f.value.filter(
      (ae) => ae.sourceLNodeId === y.value && ae.destinationLNodeId === _.value
    )), re = It(() => !y.value || !_.value ? [] : h.value.filter(
      (ae) => ae.controllerLNodeId === y.value && ae.controlledLNodeId === _.value
    )), te = It(() => _.value ? f.value.filter(
      (ae) => ae.destinationLNodeId === _.value && !ae.sourceLNodeId
    ) : []);
    function M(ae) {
      return c.value.find((ge) => ge.id === ae) ?? void 0;
    }
    function G(ae) {
      y.value = ae, j.value = M(ae), a("sourceLNodeChange", ae);
    }
    function fe(ae) {
      _.value = ae, D.value = M(ae), a("destinationLNodeChange", ae);
    }
    return (ae, ge) => (ve(), Ee("div", lh, [
      ge[5] || (ge[5] = L("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      L("select", {
        value: y.value ?? "",
        onChange: ge[0] || (ge[0] = (Ce) => G(Ce.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        ge[2] || (ge[2] = Dl(" > ")),
        ge[3] || (ge[3] = L("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ve(!0), Ee(Ye, null, St(R.value, (Ce) => (ve(), Ee("option", {
          key: Ce.id,
          value: Ce.id
        }, Re(Ve(Bn)(Ce)), 9, fh))), 128))
      ], 40, ch),
      ge[6] || (ge[6] = L("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      L("select", {
        value: _.value ?? "",
        onChange: ge[1] || (ge[1] = (Ce) => fe(Ce.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        ge[4] || (ge[4] = L("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ve(!0), Ee(Ye, null, St(W.value, (Ce) => (ve(), Ee("option", {
          key: Ce.id,
          value: Ce.id
        }, Re(Ve(Bn)(Ce)), 9, ph))), 128))
      ], 40, dh),
      L("div", hh, [
        J.value.length > 0 ? (ve(), kn(Dd, {
          key: 0,
          connections: J.value
        }, null, 8, ["connections"])) : Vt("", !0),
        re.value.length > 0 ? (ve(), kn(zp, {
          key: 1,
          controlledConnections: re.value
        }, null, 8, ["controlledConnections"])) : Vt("", !0),
        L("div", mh, [
          L("div", yh, [
            Ct($p, { dataObjectSpecifications: $.value }, null, 8, ["dataObjectSpecifications"])
          ]),
          L("div", vh, [
            Ct(Wd, { destinationPlaceHolderPorts: te.value }, null, 8, ["destinationPlaceHolderPorts"])
          ])
        ])
      ]),
      j.value ? (ve(), kn(uh, {
        key: j.value.id,
        sourceLNode: j.value,
        class: "col-span-full row-start-3"
      }, null, 8, ["sourceLNode"])) : Vt("", !0),
      D.value ? (ve(), kn(Pp, {
        key: 1,
        destinationLNode: D.value,
        class: "col-span-full row-start-3"
      }, null, 8, ["destinationLNode"])) : Vt("", !0)
    ]));
  }
}), bh = { class: "grid grid-cols-2 gap-4 mt-4" }, _h = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, wh = ["value"], xh = { class: "grid grid-cols-2 gap-4 mt-4" }, Eh = ["value", "title"], Th = { class: "grid grid-cols-2 gap-4 mt-4" }, Oh = ["value", "title"], Nh = { class: "grid grid-cols-2 gap-4 mt-4" }, Sh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Ch = ["value"], Ah = { class: "grid grid-cols-2 gap-4 mt-4" }, Ph = ["value"], Ih = { class: "grid grid-cols-2 gap-4 mt-4" }, kh = { class: "mt-4" }, Dh = { class: "mt-4" }, Rh = /* @__PURE__ */ Yt({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {},
    isVisible: { type: Boolean }
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const a = n, u = r, c = Dr(), { lnodeTypes: f, dataflowSdk: h } = kr(c), y = lt($());
    let _ = lt(!0), j = lt([]);
    cn(
      () => a.isVisible,
      (M, G) => {
        !M && G && te();
      }
    ), cn(_, (M) => {
      M ? y.value.inputName = "" : y.value.inputName = y.value.signal;
    }), cn(
      [
        () => y.value.inputName,
        () => y.value.attribute
      ],
      async ([M, G]) => {
        const fe = await h.value.calculateNextInputInstance(
          M,
          G,
          a.destinationLNode
        );
        y.value.inputInstance = fe.toString();
      }
    ), cn(
      () => a.destinationLNode,
      async (M) => {
        j.value = await h.value.findExistingInputs(M);
      },
      { immediate: !0 }
    ), Tf(() => {
      switch (te(), y.value.type = a.dataflowType, a.dataflowType) {
        case Nt.GOOSE:
        case Nt.SMV:
          y.value.includeQuality = !0, y.value.includeTimestamp = !1;
          break;
        case Nt.REPORT:
          y.value.includeQuality = !0, y.value.includeTimestamp = !0;
          break;
        default:
          y.value.includeQuality = !1, y.value.includeTimestamp = !1;
      }
    });
    const D = It(() => !a.dataflowType || !a.sourceLNode ? [] : f.value.find((M) => M.typeId === a.sourceLNode.lnType)?.dataObjects.filter(
      (M) => M.dataAttributes.some(
        (G) => Yi[a.dataflowType]?.includes(G.fc)
      )
    ).map((M) => ({
      name: M.name,
      desc: M.type
    })) || []), R = It(() => !a.dataflowType || !a.sourceLNode ? [] : f.value.find((M) => M.typeId === a.sourceLNode.lnType)?.dataObjects.find((M) => M.name === y.value.signal)?.dataAttributes.filter(
      (M) => Yi[a.dataflowType]?.includes(M.fc)
    ).filter((M) => M.name !== "t" && M.name !== "q").map((M) => ({
      name: M.name,
      desc: M.type
    })) || []);
    function $() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function W(M) {
      for (const G of M)
        y.value[G] = "";
    }
    async function J() {
      try {
        if (!re(y.value))
          return;
        await h.value.createConnection(
          y.value,
          a.sourceLNode,
          a.destinationLNode
        ), u("connectionCreated"), te();
      } catch (M) {
        console.error("Error creating dataflow:", M), alert(`Error creating dataflow: ${M instanceof Error ? M.message : "Unknown error"}`);
      }
    }
    function re(M) {
      return M.type ? M.signal ? M.attribute ? M.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function te() {
      y.value = $(), _.value = !0;
    }
    return (M, G) => (ve(), Ee(Ye, null, [
      G[22] || (G[22] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", bh, [
        G[10] || (G[10] = L("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Source", -1)),
        L("select", _h, [
          L("option", {
            value: a.sourceLNode.id
          }, Re(Ve(Bn)(M.sourceLNode)), 9, wh)
        ])
      ]),
      L("div", xh, [
        G[12] || (G[12] = L("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Signal (DO)", -1)),
        et(L("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": G[0] || (G[0] = (fe) => y.value.signal = fe),
          onChange: G[1] || (G[1] = (fe) => W(["attribute"]))
        }, [
          (ve(!0), Ee(Ye, null, St(D.value, (fe) => (ve(), Ee("option", {
            key: fe.name,
            value: fe.name,
            title: fe.desc ? `Desc: ${fe.desc}` : ""
          }, Re(fe.desc ? fe.name + " ⓘ" : fe.name), 9, Eh))), 128)),
          G[11] || (G[11] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 544), [
          [ln, y.value.signal]
        ])
      ]),
      L("div", Th, [
        G[14] || (G[14] = L("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Attribute (DA)", -1)),
        et(L("select", {
          id: "data-attribute-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": G[2] || (G[2] = (fe) => y.value.attribute = fe)
        }, [
          (ve(!0), Ee(Ye, null, St(R.value, (fe) => (ve(), Ee("option", {
            key: fe.name,
            value: fe.name,
            title: fe.desc ? `Desc: ${fe.desc}` : ""
          }, Re(fe.desc ? fe.name + " ⓘ" : fe.name), 9, Oh))), 128)),
          G[13] || (G[13] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [ln, y.value.attribute]
        ])
      ]),
      G[23] || (G[23] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", Nh, [
        G[15] || (G[15] = L("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Destination", -1)),
        L("select", Sh, [
          L("option", {
            value: a.destinationLNode.id
          }, Re(Ve(Bn)(M.destinationLNode)), 9, Ch)
        ])
      ]),
      L("div", Ah, [
        L("fieldset", null, [
          G[18] || (G[18] = L("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
          L("div", null, [
            et(L("input", {
              type: "radio",
              id: "existing-input",
              name: "input",
              "onUpdate:modelValue": G[3] || (G[3] = (fe) => st(_) ? _.value = fe : _ = fe),
              value: !0,
              class: "mr-2"
            }, null, 512), [
              [Ir, Ve(_)]
            ]),
            G[16] || (G[16] = L("label", { for: "existing-input" }, "Existing Input", -1))
          ]),
          L("div", null, [
            et(L("input", {
              type: "radio",
              id: "new-input",
              name: "input",
              "onUpdate:modelValue": G[4] || (G[4] = (fe) => st(_) ? _.value = fe : _ = fe),
              value: !1,
              class: "mr-2"
            }, null, 512), [
              [Ir, Ve(_)]
            ]),
            G[17] || (G[17] = L("label", { for: "new-input" }, "New Input", -1))
          ])
        ]),
        Ve(_) ? Vt("", !0) : et((ve(), Ee("input", {
          key: 0,
          "aria-label": "New Input Name",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": G[5] || (G[5] = (fe) => y.value.inputName = fe)
        }, null, 512)), [
          [br, y.value.inputName]
        ]),
        Ve(_) ? et((ve(), Ee("select", {
          key: 1,
          "aria-label": "Existing Input Name Select",
          required: "",
          class: "input col-start-2",
          "onUpdate:modelValue": G[6] || (G[6] = (fe) => y.value.inputName = fe)
        }, [
          (ve(!0), Ee(Ye, null, St(Ve(j), (fe) => (ve(), Ee("option", {
            key: fe,
            value: fe
          }, Re(fe), 9, Ph))), 128))
        ], 512)), [
          [ln, y.value.inputName]
        ]) : Vt("", !0)
      ]),
      L("div", Ih, [
        G[19] || (G[19] = L("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        et(L("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": G[7] || (G[7] = (fe) => y.value.inputInstance = fe)
        }, null, 512), [
          [br, y.value.inputInstance]
        ])
      ]),
      G[24] || (G[24] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", kh, [
        et(L("input", {
          type: "checkbox",
          "onUpdate:modelValue": G[8] || (G[8] = (fe) => y.value.includeQuality = fe),
          class: "checkbox mr-2",
          id: "checkbox-include-quality"
        }, null, 512), [
          [pu, y.value.includeQuality]
        ]),
        G[20] || (G[20] = L("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
      ]),
      L("div", Dh, [
        et(L("input", {
          type: "checkbox",
          "onUpdate:modelValue": G[9] || (G[9] = (fe) => y.value.includeTimestamp = fe),
          class: "checkbox mr-2",
          id: "checkbox-include-timestamp"
        }, null, 512), [
          [pu, y.value.includeTimestamp]
        ]),
        G[21] || (G[21] = L("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
      ]),
      L("div", { class: "modal-action" }, [
        L("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: J,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), jh = { class: "grid grid-cols-2 gap-4 mt-4" }, Lh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Kh = ["value"], Fh = { class: "grid grid-cols-2 gap-4 mt-4" }, Mh = ["value", "title"], Bh = { class: "grid grid-cols-2 gap-4 mt-4" }, qh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, $h = ["value"], Uh = { class: "grid grid-cols-2 gap-4 mt-4" }, Vh = ["value"], Hh = { class: "grid grid-cols-2 gap-4 mt-4" }, Wh = /* @__PURE__ */ Yt({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {}
  },
  emits: ["connectionCreated"],
  setup(n, { emit: r }) {
    const a = n, u = r, c = Dr(), { lnodeTypes: f, dataflowSdk: h } = kr(c), y = lt(
      R()
    );
    let _ = lt(!0), j = lt([]);
    cn(_, (re) => {
      re ? y.value.outputName = "" : y.value.outputName = y.value.controlledSignal;
    }), cn(
      () => a.sourceLNode,
      async (re) => {
        j.value = await h.value.findExistingOutputs(re);
      },
      { immediate: !0 }
    ), cn(
      () => y.value.outputName,
      async (re) => {
        const te = await h.value.calculateNextOutputInstance(
          re,
          a.sourceLNode
        );
        y.value.outputInstance = te.toString();
      }
    );
    const D = It(() => a.destinationLNode ? f.value.find((te) => te.typeId === a.destinationLNode.lnType)?.dataObjects.map((te) => ({
      name: te.name,
      desc: te.type
    })) || [] : []);
    function R() {
      return {
        type: Nt.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function $() {
      try {
        if (!W(y.value))
          return;
        await h.value.createControlledConnection(
          y.value,
          a.sourceLNode,
          a.destinationLNode
        ), u("connectionCreated"), J();
      } catch (re) {
        console.error("Error creating controlled dataflow:", re), alert(`Error creating controlled dataflow: ${re instanceof Error ? re.message : "Unknown error"}`);
      }
    }
    function W(re) {
      return re.type ? re.outputName ? re.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function J() {
      y.value = R(), _.value = !0;
    }
    return (re, te) => (ve(), Ee(Ye, null, [
      te[14] || (te[14] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", jh, [
        te[6] || (te[6] = L("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        L("select", Lh, [
          L("option", {
            value: a.destinationLNode.id
          }, Re(Ve(Bn)(re.destinationLNode)), 9, Kh)
        ])
      ]),
      L("div", Fh, [
        te[8] || (te[8] = L("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        et(L("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": te[0] || (te[0] = (M) => y.value.controlledSignal = M)
        }, [
          (ve(!0), Ee(Ye, null, St(D.value, (M) => (ve(), Ee("option", {
            key: M.name,
            value: M.name,
            title: M.desc ? `Desc: ${M.desc}` : ""
          }, Re(M.desc ? M.name + " ⓘ" : M.name), 9, Mh))), 128)),
          te[7] || (te[7] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1))
        ], 512), [
          [ln, y.value.controlledSignal]
        ])
      ]),
      te[15] || (te[15] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", Bh, [
        te[9] || (te[9] = L("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        L("select", qh, [
          L("option", {
            value: a.sourceLNode.id
          }, Re(Ve(Bn)(re.sourceLNode)), 9, $h)
        ])
      ]),
      L("div", Uh, [
        L("fieldset", null, [
          te[12] || (te[12] = L("legend", { class: "col-start-1 self-start" }, "Controller Output Name", -1)),
          L("div", null, [
            et(L("input", {
              type: "radio",
              id: "existing-output",
              name: "output",
              "onUpdate:modelValue": te[1] || (te[1] = (M) => st(_) ? _.value = M : _ = M),
              value: !0,
              class: "mr-2"
            }, null, 512), [
              [Ir, Ve(_)]
            ]),
            te[10] || (te[10] = L("label", { for: "existing-output" }, "Existing Output", -1))
          ]),
          L("div", null, [
            et(L("input", {
              type: "radio",
              id: "new-output",
              name: "output",
              "onUpdate:modelValue": te[2] || (te[2] = (M) => st(_) ? _.value = M : _ = M),
              value: !1,
              class: "mr-2"
            }, null, 512), [
              [Ir, Ve(_)]
            ]),
            te[11] || (te[11] = L("label", { for: "new-output" }, "New Output", -1))
          ])
        ]),
        Ve(_) ? Vt("", !0) : et((ve(), Ee("input", {
          key: 0,
          "aria-label": "New Output Name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": te[3] || (te[3] = (M) => y.value.outputName = M)
        }, null, 512)), [
          [br, y.value.outputName]
        ]),
        Ve(_) ? et((ve(), Ee("select", {
          key: 1,
          "aria-label": "Existing Output Name Select",
          required: "",
          class: "input col-start-2",
          "onUpdate:modelValue": te[4] || (te[4] = (M) => y.value.outputName = M)
        }, [
          (ve(!0), Ee(Ye, null, St(Ve(j), (M) => (ve(), Ee("option", {
            key: M,
            value: M
          }, Re(M), 9, Vh))), 128))
        ], 512)), [
          [ln, y.value.outputName]
        ]) : Vt("", !0)
      ]),
      L("div", Hh, [
        te[13] || (te[13] = L("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Ouput Instance", -1)),
        et(L("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": te[5] || (te[5] = (M) => y.value.outputInstance = M)
        }, null, 512), [
          [br, y.value.outputInstance]
        ])
      ]),
      te[16] || (te[16] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", { class: "modal-action" }, [
        L("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: $,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), Gh = ["disabled"], Yh = ["open"], Xh = { class: "modal-box" }, Qh = { class: "grid grid-cols-2 gap-4 mt-4" }, zh = ["value", "disabled"], Jh = /* @__PURE__ */ Yt({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {}
  },
  setup(n) {
    const r = n, a = lt(!1), u = lt(null), c = It(
      () => Object.values(Nt).filter((D) => D !== Nt.INTERNAL)
    ), f = It(
      () => r.sourceLNode?.lnClass === "IHMI" || r.sourceLNode?.lnClass === "ITCI"
    );
    function h(D) {
      const R = D.target.value;
      u.value = R;
    }
    function y() {
      j();
    }
    function _() {
      a.value = !0;
    }
    function j() {
      a.value = !1, u.value = null;
    }
    return (D, R) => (ve(), Ee(Ye, null, [
      L("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: _,
        disabled: !r.sourceLNode || !r.destinationLNode,
        "aria-label": "Add connection"
      }, " + ", 8, Gh),
      r.sourceLNode && r.destinationLNode ? (ve(), Ee("dialog", {
        key: 0,
        class: "modal",
        open: a.value
      }, [
        L("div", Xh, [
          R[4] || (R[4] = L("h3", { class: "text-lg font-bold" }, "Create Connection", -1)),
          L("button", {
            class: "absolute top-[1.5rem] right-[1.5rem] cursor-pointer",
            onClick: j,
            "aria-label": "Close dataflow creation",
            "data-testId": "close-dataflow-creation"
          }, R[1] || (R[1] = [
            L("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              width: "28",
              height: "28",
              viewBox: "0 0 64 64"
            }, [
              L("path", { d: "M 16 14 C 15.488 14 14.976938 14.194937 14.585938 14.585938 C 13.804937 15.366937 13.804937 16.633063 14.585938 17.414062 L 29.171875 32 L 14.585938 46.585938 C 13.804938 47.366938 13.804937 48.633063 14.585938 49.414062 C 14.976937 49.805062 15.488 50 16 50 C 16.512 50 17.023062 49.805062 17.414062 49.414062 L 32 34.828125 L 46.585938 49.414062 C 47.366938 50.195063 48.633063 50.195062 49.414062 49.414062 C 50.195063 48.633062 50.195062 47.366937 49.414062 46.585938 L 34.828125 32 L 49.414062 17.414062 C 50.195063 16.633063 50.195062 15.366938 49.414062 14.585938 C 48.633062 13.804938 47.366937 13.804938 46.585938 14.585938 L 32 29.171875 L 17.414062 14.585938 C 17.023062 14.194938 16.512 14 16 14 z" })
            ], -1)
          ])),
          L("div", Qh, [
            R[3] || (R[3] = L("label", {
              for: "dataflow-type-select",
              class: "col-start-1 self-center"
            }, "Dataflow Type", -1)),
            et(L("select", {
              id: "dataflow-type-select",
              required: "",
              class: "select col-start-2",
              "onUpdate:modelValue": R[0] || (R[0] = ($) => u.value = $),
              onChange: h
            }, [
              (ve(!0), Ee(Ye, null, St(c.value, ($) => (ve(), Ee("option", {
                key: $,
                value: $,
                disabled: $ === Ve(Nt).CONTROL && !f.value
              }, Re($), 9, zh))), 128)),
              R[2] || (R[2] = L("option", {
                key: "empty",
                value: null
              }, "-", -1))
            ], 544), [
              [ln, u.value]
            ])
          ]),
          u.value !== Ve(Nt).CONTROL ? (ve(), kn(Rh, {
            key: 0,
            sourceLNode: r.sourceLNode,
            destinationLNode: r.destinationLNode,
            dataflowType: u.value,
            onConnectionCreated: y,
            isVisible: a.value
          }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType", "isVisible"])) : (ve(), kn(Wh, {
            key: 1,
            sourceLNode: r.sourceLNode,
            destinationLNode: r.destinationLNode,
            dataflowType: u.value,
            onConnectionCreated: y
          }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType"]))
        ])
      ], 8, Yh)) : Vt("", !0)
    ], 64));
  }
}), Zh = { class: "flex flex-col items-center justify-center w-full" }, em = /* @__PURE__ */ Yt({
  __name: "dataflow-view",
  setup(n) {
    const r = lt(), a = lt(), u = Dr(), { lnodes: c } = kr(u);
    function f(_) {
      r.value = y(_);
    }
    function h(_) {
      a.value = y(_);
    }
    function y(_) {
      return c.value.find((j) => j.id === _) ?? void 0;
    }
    return (_, j) => (ve(), Ee("div", Zh, [
      Ct(gh, {
        onSourceLNodeChange: f,
        onDestinationLNodeChange: h
      }),
      Ct(Jh, {
        sourceLNode: r.value,
        destinationLNode: a.value
      }, null, 8, ["sourceLNode", "destinationLNode"])
    ]));
  }
}), Yl = (n, r) => {
  const a = n.__vccOpts || n;
  for (const [u, c] of r)
    a[u] = c;
  return a;
}, tm = {}, nm = { class: "layout" }, rm = { class: "main" }, om = { class: "sidebar" };
function im(n, r) {
  return ve(), Ee("div", nm, [
    L("div", rm, [
      Ua(n.$slots, "main", {}, void 0)
    ]),
    L("div", om, [
      Ua(n.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const sm = /* @__PURE__ */ Yl(tm, [["render", im], ["__scopeId", "data-v-5f95d421"]]), am = {
  name: "sidebar",
  class: "root"
}, um = { class: "tabs tabs-box" }, lm = { key: 0 }, cm = { key: 1 }, fm = /* @__PURE__ */ Yt({
  __name: "sidebar",
  setup(n) {
    const r = lt("details");
    return (a, u) => (ve(), Ee("div", am, [
      L("div", um, [
        et(L("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": u[0] || (u[0] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [Ir, r.value]
        ]),
        et(L("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": u[1] || (u[1] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [Ir, r.value]
        ])
      ]),
      L("div", null, [
        r.value === "details" ? (ve(), Ee("div", lm, u[2] || (u[2] = [
          L("div", { id: "sidebar-details" }, null, -1)
        ]))) : Vt("", !0),
        r.value === "advanced" ? (ve(), Ee("div", cm)) : Vt("", !0)
      ])
    ]));
  }
}), dm = /* @__PURE__ */ Yl(fm, [["__scopeId", "data-v-ec5c053a"]]), pm = ["id"], hm = { class: "p-10" }, mm = /* @__PURE__ */ Yt({
  __name: "app",
  props: {
    api: {}
  },
  setup(n) {
    const r = "dataflow", a = n, u = Dr();
    let c = () => {
    };
    return hl(() => {
      c = a.api.activeFileName.subscribe((f) => {
        u.initApp(f);
      }), u.initApp(a.api.activeFileName.value);
    }), Ca(() => {
      u.closeDatabase(), c();
    }), (f, h) => (ve(), Ee("article", {
      id: Ve(r),
      style: { height: "100%" }
    }, [
      Ct(sm, null, {
        main: zs(() => [
          L("div", hm, [
            Ct(em)
          ])
        ]),
        sidebar: zs(() => [
          Ct(dm)
        ]),
        _: 1
      })
    ], 8, pm));
  }
});
function Fm(n, r) {
  if (!document.getElementById(n)) {
    console.error({ msg: "could not found root element", rootId: n });
    return;
  }
  const u = md(mm, { api: r });
  return u.use(gd()), u.mount(`#${n}`), u.unmount;
}
export {
  Fm as default
};
