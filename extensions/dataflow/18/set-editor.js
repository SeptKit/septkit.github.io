(function(){"use strict";try{if(typeof document<"u"){var o=document.createElement("style");o.appendChild(document.createTextNode(`.layout[data-v-5f95d421]{display:grid;height:100%;grid-template-columns:1fr 20rem}.sidebar[data-v-5f95d421]{padding:1.5rem;border-left:1px solid var(--border-color);height:100%}.main[data-v-5f95d421]{padding:1rem;height:100%}.root[data-v-ec5c053a]{display:flex;flex-direction:column;gap:1rem}.tab[data-v-ec5c053a]{transition:all .2s}.tabs[data-v-ec5c053a]{width:auto;display:inline-block;margin:0 auto}/*! tailwindcss v4.1.11 | MIT License | https://tailwindcss.com */@layer properties{@supports (((-webkit-hyphens:none)) and (not (margin-trim:inline))) or ((-moz-orient:inline) and (not (color:rgb(from red r g b)))){*,:before,:after,::backdrop{--tw-border-style:solid;--tw-font-weight:initial;--tw-blur:initial;--tw-brightness:initial;--tw-contrast:initial;--tw-grayscale:initial;--tw-hue-rotate:initial;--tw-invert:initial;--tw-opacity:initial;--tw-saturate:initial;--tw-sepia:initial;--tw-drop-shadow:initial;--tw-drop-shadow-color:initial;--tw-drop-shadow-alpha:100%;--tw-drop-shadow-size:initial}}}@layer theme{:root,:host{--font-sans:ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";--font-mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;--color-white:#fff;--spacing:.25rem;--text-sm:.875rem;--text-sm--line-height:calc(1.25/.875);--text-lg:1.125rem;--text-lg--line-height:calc(1.75/1.125);--text-2xl:1.5rem;--text-2xl--line-height:calc(2/1.5);--font-weight-bold:700;--radius-sm:.25rem;--radius-xl:.75rem;--default-transition-duration:.15s;--default-transition-timing-function:cubic-bezier(.4,0,.2,1);--default-font-family:var(--font-sans);--default-mono-font-family:var(--font-mono)}}@layer base{*,:after,:before,::backdrop{box-sizing:border-box;border:0 solid;margin:0;padding:0}::file-selector-button{box-sizing:border-box;border:0 solid;margin:0;padding:0}html,:host{-webkit-text-size-adjust:100%;tab-size:4;line-height:1.5;font-family:var(--default-font-family,ui-sans-serif,system-ui,sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji");font-feature-settings:var(--default-font-feature-settings,normal);font-variation-settings:var(--default-font-variation-settings,normal);-webkit-tap-highlight-color:transparent}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;-webkit-text-decoration:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,samp,pre{font-family:var(--default-mono-font-family,ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace);font-feature-settings:var(--default-mono-font-feature-settings,normal);font-variation-settings:var(--default-mono-font-variation-settings,normal);font-size:1em}small{font-size:80%}sub,sup{vertical-align:baseline;font-size:75%;line-height:0;position:relative}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}:-moz-focusring{outline:auto}progress{vertical-align:baseline}summary{display:list-item}ol,ul,menu{list-style:none}img,svg,video,canvas,audio,iframe,embed,object{vertical-align:middle;display:block}img,video{max-width:100%;height:auto}button,input,select,optgroup,textarea{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}::file-selector-button{font:inherit;font-feature-settings:inherit;font-variation-settings:inherit;letter-spacing:inherit;color:inherit;opacity:1;background-color:#0000;border-radius:0}:where(select:is([multiple],[size])) optgroup{font-weight:bolder}:where(select:is([multiple],[size])) optgroup option{padding-inline-start:20px}::file-selector-button{margin-inline-end:4px}::placeholder{opacity:1}@supports (not ((-webkit-appearance:-apple-pay-button))) or (contain-intrinsic-size:1px){::placeholder{color:currentColor}@supports (color:color-mix(in lab,red,red)){::placeholder{color:color-mix(in oklab,currentcolor 50%,transparent)}}}textarea{resize:vertical}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-date-and-time-value{min-height:1lh;text-align:inherit}::-webkit-datetime-edit{display:inline-flex}::-webkit-datetime-edit-fields-wrapper{padding:0}::-webkit-datetime-edit{padding-block:0}::-webkit-datetime-edit-year-field{padding-block:0}::-webkit-datetime-edit-month-field{padding-block:0}::-webkit-datetime-edit-day-field{padding-block:0}::-webkit-datetime-edit-hour-field{padding-block:0}::-webkit-datetime-edit-minute-field{padding-block:0}::-webkit-datetime-edit-second-field{padding-block:0}::-webkit-datetime-edit-millisecond-field{padding-block:0}::-webkit-datetime-edit-meridiem-field{padding-block:0}::-webkit-calendar-picker-indicator{line-height:1}:-moz-ui-invalid{box-shadow:none}button,input:where([type=button],[type=reset],[type=submit]){appearance:button}::file-selector-button{appearance:button}::-webkit-inner-spin-button{height:auto}::-webkit-outer-spin-button{height:auto}[hidden]:where(:not([hidden=until-found])){display:none!important}:root{--fx-noise:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='a'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.34' numOctaves='4' stitchTiles='stitch'%3E%3C/feTurbulence%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23a)' opacity='0.2'%3E%3C/rect%3E%3C/svg%3E")}:root,[data-theme]{background-color:var(--root-bg,var(--color-base-100));color:var(--color-base-content)}:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not([class*=drawer-open])>.drawer-toggle:checked){overflow:hidden}@property --radialprogress{syntax: "<percentage>"; inherits: true; initial-value: 0%;}:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){scrollbar-gutter:stable;background-image:linear-gradient(var(--color-base-100),var(--color-base-100));--root-bg:var(--color-base-100)}@supports (color:color-mix(in lab,red,red)){:where(:root:has(.modal-open,.modal[open],.modal:target,.modal-toggle:checked,.drawer:not(.drawer-open)>.drawer-toggle:checked)){--root-bg:color-mix(in srgb,var(--color-base-100),oklch(0% 0 0) 40%)}}:where(.modal[open],.modal-open,.modal-toggle:checked+.modal):not(.modal-start,.modal-end){scrollbar-gutter:stable}:root{scrollbar-color:currentColor #0000}@supports (color:color-mix(in lab,red,red)){:root{scrollbar-color:color-mix(in oklch,currentColor 35%,#0000)#0000}}:where(:root),:root:has(input.theme-controller[value=ocean-light]:checked),[data-theme=ocean-light]{color-scheme:light;--color-base-100:oklch(98% 0 0);--color-base-200:oklch(97% 0 0);--color-base-300:oklch(92% 0 0);--color-base-content:oklch(37% 0 0);--color-primary:oklch(58.13% .0903 209.8);--color-primary-content:oklch(100% 0 0);--color-secondary:oklch(65.24% .0821 207.95);--color-secondary-content:oklch(100% 0 0);--color-accent:oklch(60% .118 184.704);--color-accent-content:oklch(98% .001 106.423);--color-neutral:oklch(55% .013 58.071);--color-neutral-content:oklch(98% .031 120.757);--color-info:oklch(70% .165 254.624);--color-info-content:oklch(98% .001 106.423);--color-success:oklch(72% .219 149.579);--color-success-content:oklch(98% .001 106.423);--color-warning:oklch(87% .169 91.605);--color-warning-content:oklch(98% .001 106.423);--color-error:oklch(63% .237 25.331);--color-error-content:oklch(98% .001 106.423);--radius-selector:.25rem;--radius-field:.25rem;--radius-box:.25rem;--size-selector:.21875rem;--size-field:.21875rem;--border:1.5px;--depth:1;--noise:1;--border-color:var(--color-base-content)}}@layer components;@layer utilities{.modal{pointer-events:none;visibility:hidden;width:100%;max-width:none;height:100%;max-height:none;color:inherit;transition:translate .3s ease-out,visibility .3s allow-discrete,background-color .3s ease-out,opacity .1s ease-out;overscroll-behavior:contain;z-index:999;background-color:#0000;place-items:center;margin:0;padding:0;display:grid;position:fixed;inset:0;overflow:hidden}.modal::backdrop{display:none}.modal.modal-open,.modal[open],.modal:target{pointer-events:auto;visibility:visible;opacity:1;background-color:#0006}:is(.modal.modal-open,.modal[open],.modal:target) .modal-box{opacity:1;translate:0;scale:1}@starting-style{.modal.modal-open,.modal[open],.modal:target{visibility:hidden;opacity:0}}.tab{cursor:pointer;appearance:none;text-align:center;webkit-user-select:none;-webkit-user-select:none;user-select:none;flex-wrap:wrap;justify-content:center;align-items:center;display:inline-flex;position:relative}@media (hover:hover){.tab:hover{color:var(--color-base-content)}}.tab{--tab-p:1rem;--tab-bg:var(--color-base-100);--tab-border-color:var(--color-base-300);--tab-radius-ss:0;--tab-radius-se:0;--tab-radius-es:0;--tab-radius-ee:0;--tab-order:0;--tab-radius-min:calc(.75rem - var(--border));order:var(--tab-order);height:var(--tab-height);border-color:#0000;padding-inline-start:var(--tab-p);padding-inline-end:var(--tab-p);font-size:.875rem}.tab:is(input[type=radio]){min-width:fit-content}.tab:is(input[type=radio]):after{content:attr(aria-label)}.tab:is(label){position:relative}.tab:is(label) input{cursor:pointer;appearance:none;opacity:0;position:absolute;inset:0}:is(.tab:checked,.tab:is(label:has(:checked)),.tab:is(.tab-active,[aria-selected=true]))+.tab-content{height:calc(100% - var(--tab-height) + var(--border));display:block}.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.tab:not(:checked,label:has(:checked),:hover,.tab-active,[aria-selected=true]){color:color-mix(in oklab,var(--color-base-content)50%,transparent)}}.tab:not(input):empty{cursor:default;flex-grow:1}.tab:focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.tab:focus{outline-offset:2px;outline:2px solid #0000}}.tab:focus-visible,.tab:is(label:has(:checked:focus-visible)){outline-offset:-5px;outline:2px solid}.tab[disabled]{pointer-events:none;opacity:.4}.dropdown{position-area:var(--anchor-v,bottom)var(--anchor-h,span-right);display:inline-block;position:relative}.dropdown>:not(summary):focus{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.dropdown>:not(summary):focus{outline-offset:2px;outline:2px solid #0000}}.dropdown .dropdown-content{position:absolute}.dropdown:not(details,.dropdown-open,.dropdown-hover:hover,:focus-within) .dropdown-content{transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover],.dropdown .dropdown-content{z-index:999;transition-behavior:allow-discrete;transition-property:opacity,scale,display;transition-duration:.2s;transition-timing-function:cubic-bezier(.4,0,.2,1);animation:.2s dropdown}@starting-style{.dropdown[popover],.dropdown .dropdown-content{opacity:0;scale:95%}}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within)>[tabindex]:first-child{pointer-events:none}:is(.dropdown.dropdown-open,.dropdown:not(.dropdown-hover):focus,.dropdown:focus-within) .dropdown-content{opacity:1}.dropdown.dropdown-hover:hover .dropdown-content{opacity:1;scale:100%}.dropdown:is(details) summary::-webkit-details-marker{display:none}:is(.dropdown.dropdown-open,.dropdown:focus,.dropdown:focus-within) .dropdown-content{scale:100%}.dropdown:where([popover]){background:0 0}.dropdown[popover]{color:inherit;position:fixed}@supports not (position-area:bottom){.dropdown[popover]{margin:auto}.dropdown[popover].dropdown-open:not(:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}.dropdown[popover]::backdrop{background-color:oklab(0% none none/.3)}}.dropdown[popover]:not(.dropdown-open,:popover-open){transform-origin:top;opacity:0;display:none;scale:95%}:where(.btn){width:unset}.btn{cursor:pointer;text-align:center;vertical-align:middle;outline-offset:2px;webkit-user-select:none;-webkit-user-select:none;user-select:none;padding-inline:var(--btn-p);color:var(--btn-fg);--tw-prose-links:var(--btn-fg);height:var(--size);font-size:var(--fontsize,.875rem);outline-color:var(--btn-color,var(--color-base-content));background-color:var(--btn-bg);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--btn-noise);border-width:var(--border);border-style:solid;border-color:var(--btn-border);text-shadow:0 .5px oklch(100% 0 0/calc(var(--depth)*.15));touch-action:manipulation;box-shadow:0 .5px 0 .5px oklch(100% 0 0/calc(var(--depth)*6%)) inset,var(--btn-shadow);--size:calc(var(--size-field,.25rem)*10);--btn-bg:var(--btn-color,var(--color-base-200));--btn-fg:var(--color-base-content);--btn-p:1rem;--btn-border:var(--btn-bg);border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-wrap:nowrap;flex-shrink:0;justify-content:center;align-items:center;gap:.375rem;font-weight:600;transition-property:color,background-color,border-color,box-shadow;transition-duration:.2s;transition-timing-function:cubic-bezier(0,0,.2,1);display:inline-flex}@supports (color:color-mix(in lab,red,red)){.btn{--btn-border:color-mix(in oklab,var(--btn-bg),#000 calc(var(--depth)*5%))}}.btn{--btn-shadow:0 3px 2px -2px var(--btn-bg),0 4px 3px -2px var(--btn-bg)}@supports (color:color-mix(in lab,red,red)){.btn{--btn-shadow:0 3px 2px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000),0 4px 3px -2px color-mix(in oklab,var(--btn-bg)calc(var(--depth)*30%),#0000)}}.btn{--btn-noise:var(--fx-noise)}.prose .btn{text-decoration-line:none}@media (hover:hover){.btn:hover{--btn-bg:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:hover{--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}}.btn:focus-visible{isolation:isolate;outline-width:2px;outline-style:solid}.btn:active:not(.btn-active){--btn-bg:var(--btn-color,var(--color-base-200));translate:0 .5px}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-bg:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 5%)}}.btn:active:not(.btn-active){--btn-border:var(--btn-color,var(--color-base-200))}@supports (color:color-mix(in lab,red,red)){.btn:active:not(.btn-active){--btn-border:color-mix(in oklab,var(--btn-color,var(--color-base-200)),#000 7%)}}.btn:active:not(.btn-active){--btn-shadow:0 0 0 0 oklch(0% 0 0/0),0 0 0 0 oklch(0% 0 0/0)}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){background-color:color-mix(in oklab,var(--color-base-content)10%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):not(.btn-link,.btn-ghost){box-shadow:none}.btn:is(:disabled,[disabled],.btn-disabled){pointer-events:none;--btn-border:#0000;--btn-noise:none;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled){--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}@media (hover:hover){.btn:is(:disabled,[disabled],.btn-disabled):hover{pointer-events:none;background-color:var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{background-color:color-mix(in oklab,var(--color-neutral)20%,transparent)}}.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-border:#0000;--btn-fg:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.btn:is(:disabled,[disabled],.btn-disabled):hover{--btn-fg:color-mix(in oklch,var(--color-base-content)20%,#0000)}}}.btn:is(input[type=checkbox],input[type=radio]){appearance:none}.btn:is(input[type=checkbox],input[type=radio]):after{content:attr(aria-label)}.btn:where(input:checked:not(.filter .btn)){--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content);isolation:isolate}.\\!pointer-events-none{pointer-events:none!important}.pointer-events-none{pointer-events:none}.input{cursor:text;border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;white-space:nowrap;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;border-color:var(--input-color);box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.5rem;padding-inline:.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.input{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.input{--size:calc(var(--size-field,.25rem)*10);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.input:where(input){display:inline-flex}.input :where(input){appearance:none;background-color:#0000;border:none;width:100%;height:100%;display:inline-flex}.input :where(input):focus,.input :where(input):focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.input :where(input):focus,.input :where(input):focus-within{outline-offset:2px;outline:2px solid #0000}}.input :where(input[type=url]),.input :where(input[type=email]){direction:ltr}.input :where(input[type=date]){display:inline-block}.input:focus,.input:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.input:focus,.input:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.input:focus,.input:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.input:has(>input[disabled]),.input:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.input:has(>input[disabled]),.input:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.input:has(>input[disabled]),.input:is(:disabled,[disabled]){box-shadow:none}.input:has(>input[disabled])>input[disabled]{cursor:not-allowed}.input::-webkit-date-and-time-value{text-align:inherit}.input[type=number]::-webkit-inner-spin-button{margin-block:-.75rem;margin-inline-end:-.75rem}.input::-webkit-calendar-picker-indicator{position:absolute;inset-inline-end:.75em}.table{border-radius:var(--radius-box);text-align:left;width:100%;font-size:.875rem;position:relative}.table:where(:dir(rtl),[dir=rtl],[dir=rtl] *){text-align:right}@media (hover:hover){:is(.table tr.row-hover,.table tr.row-hover:nth-child(2n)):hover{background-color:var(--color-base-200)}}.table :where(th,td){vertical-align:middle;padding-block:.75rem;padding-inline:1rem}.table :where(thead,tfoot){white-space:nowrap;color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead,tfoot){color:color-mix(in oklab,var(--color-base-content)60%,transparent)}}.table :where(thead,tfoot){font-size:.875rem;font-weight:600}.table :where(tfoot){border-top:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(tfoot){border-top:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.table :where(.table-pin-rows thead tr){z-index:1;background-color:var(--color-base-100);position:sticky;top:0}.table :where(.table-pin-rows tfoot tr){z-index:1;background-color:var(--color-base-100);position:sticky;bottom:0}.table :where(.table-pin-cols tr th){background-color:var(--color-base-100);position:sticky;left:0;right:0}.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.table :where(thead tr,tbody tr:not(:last-child)){border-bottom:var(--border)solid color-mix(in oklch,var(--color-base-content)5%,#0000)}}.select{border:var(--border)solid #0000;appearance:none;background-color:var(--color-base-100);vertical-align:middle;width:clamp(3rem,20rem,100%);height:var(--size);touch-action:manipulation;text-overflow:ellipsis;box-shadow:0 1px var(--input-color) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-image:linear-gradient(45deg,#0000 50%,currentColor 50%),linear-gradient(135deg,currentColor 50%,#0000 50%);background-position:calc(100% - 20px) calc(1px + 50%),calc(100% - 16.1px) calc(1px + 50%);background-repeat:no-repeat;background-size:4px 4px,4px 4px;border-start-start-radius:var(--join-ss,var(--radius-field));border-start-end-radius:var(--join-se,var(--radius-field));border-end-end-radius:var(--join-ee,var(--radius-field));border-end-start-radius:var(--join-es,var(--radius-field));flex-shrink:1;align-items:center;gap:.375rem;padding-inline:1rem 1.75rem;font-size:.875rem;display:inline-flex;position:relative}@supports (color:color-mix(in lab,red,red)){.select{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000) inset,0 -1px oklch(100% 0 0/calc(var(--depth)*.1)) inset}}.select{border-color:var(--input-color);--input-color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select{--input-color:color-mix(in oklab,var(--color-base-content)20%,#0000)}}.select{--size:calc(var(--size-field,.25rem)*10)}[dir=rtl] .select{background-position:12px calc(1px + 50%),16px calc(1px + 50%)}.select select{appearance:none;background:inherit;border-radius:inherit;border-style:none;width:calc(100% + 2.75rem);height:calc(100% - 2px);margin-inline:-1rem -1.75rem;padding-inline:1rem 1.75rem}.select select:focus,.select select:focus-within{--tw-outline-style:none;outline-style:none}@media (forced-colors:active){.select select:focus,.select select:focus-within{outline-offset:2px;outline:2px solid #0000}}.select select:not(:last-child){background-image:none;margin-inline-end:-1.375rem}.select:focus,.select:focus-within{--input-color:var(--color-base-content);box-shadow:0 1px var(--input-color)}@supports (color:color-mix(in lab,red,red)){.select:focus,.select:focus-within{box-shadow:0 1px color-mix(in oklab,var(--input-color)calc(var(--depth)*10%),#0000)}}.select:focus,.select:focus-within{outline:2px solid var(--input-color);outline-offset:2px;isolation:isolate;z-index:1}.select:has(>select[disabled]),.select:is(:disabled,[disabled]){cursor:not-allowed;border-color:var(--color-base-200);background-color:var(--color-base-200);color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){.select:has(>select[disabled]),.select:is(:disabled,[disabled]){color:color-mix(in oklab,var(--color-base-content)40%,transparent)}}:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:var(--color-base-content)}@supports (color:color-mix(in lab,red,red)){:is(.select:has(>select[disabled]),.select:is(:disabled,[disabled]))::placeholder{color:color-mix(in oklab,var(--color-base-content)20%,transparent)}}.select:has(>select[disabled])>select[disabled]{cursor:not-allowed}.checkbox{border:var(--border)solid var(--input-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.checkbox{border:var(--border)solid var(--input-color,color-mix(in oklab,var(--color-base-content)20%,#0000))}}.checkbox{cursor:pointer;appearance:none;border-radius:var(--radius-selector);vertical-align:middle;color:var(--color-base-content);box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 0 #0000 inset,0 0 #0000;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);flex-shrink:0;padding:.25rem;transition:background-color .2s,box-shadow .2s;display:inline-block;position:relative}.checkbox:before{--tw-content:"";content:var(--tw-content);opacity:0;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,70% 80%,70% 100%);width:100%;height:100%;box-shadow:0 3px oklch(100% 0 0/calc(var(--depth)*.1)) inset;background-color:currentColor;font-size:1rem;line-height:.75;transition:clip-path .3s .1s,opacity .1s .1s,rotate .3s .1s,translate .3s .1s;display:block;rotate:45deg}.checkbox:focus-visible{outline:2px solid var(--input-color,currentColor);outline-offset:2px}.checkbox:checked,.checkbox[aria-checked=true]{background-color:var(--input-color,#0000);box-shadow:0 0 #0000 inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1))}:is(.checkbox:checked,.checkbox[aria-checked=true]):before{clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 0%,70% 0%,70% 100%);opacity:1}@media (forced-colors:active){:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}@media print{:is(.checkbox:checked,.checkbox[aria-checked=true]):before{--tw-content:"✔︎";clip-path:none;background-color:#0000;rotate:none}}.checkbox:indeterminate:before{opacity:1;clip-path:polygon(20% 100%,20% 80%,50% 80%,50% 80%,80% 80%,80% 100%);translate:0 -35%;rotate:none}.checkbox:disabled{cursor:not-allowed;opacity:.2}.radio{cursor:pointer;appearance:none;vertical-align:middle;border:var(--border)solid var(--input-color,currentColor);border-radius:3.40282e38px;flex-shrink:0;padding:.25rem;display:inline-block;position:relative}@supports (color:color-mix(in lab,red,red)){.radio{border:var(--border)solid var(--input-color,color-mix(in srgb,currentColor 20%,#0000))}}.radio{box-shadow:0 1px oklch(0% 0 0/calc(var(--depth)*.1)) inset;--size:calc(var(--size-selector,.25rem)*6);width:var(--size);height:var(--size);color:var(--input-color,currentColor)}.radio:before{--tw-content:"";content:var(--tw-content);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);border-radius:3.40282e38px;width:100%;height:100%;display:block}.radio:focus-visible{outline:2px solid}.radio:checked,.radio[aria-checked=true]{background-color:var(--color-base-100);border-color:currentColor;animation:.2s ease-out radio}:is(.radio:checked,.radio[aria-checked=true]):before{box-shadow:0 -1px oklch(0% 0 0/calc(var(--depth)*.1)) inset,0 8px 0 -4px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px oklch(0% 0 0/calc(var(--depth)*.1));background-color:currentColor}@media (forced-colors:active){:is(.radio:checked,.radio[aria-checked=true]):before{outline-style:var(--tw-outline-style);outline-offset:-1px;outline-width:1px}}@media print{:is(.radio:checked,.radio[aria-checked=true]):before{outline-offset:-1rem;outline:.25rem solid}}.radio:disabled{cursor:not-allowed;opacity:.2}.absolute{position:absolute}.relative{position:relative}.top-2{top:calc(var(--spacing)*2)}.right-2{right:calc(var(--spacing)*2)}.-z-1{z-index:-1}.z-1{z-index:1}.z-10{z-index:10}.-order-1{order:-1}.col-span-1{grid-column:span 1/span 1}.col-span-2{grid-column:span 2/span 2}.col-span-full{grid-column:1/-1}.modal-box{background-color:var(--color-base-100);border-top-left-radius:var(--modal-tl,var(--radius-box));border-top-right-radius:var(--modal-tr,var(--radius-box));border-bottom-left-radius:var(--modal-bl,var(--radius-box));border-bottom-right-radius:var(--modal-br,var(--radius-box));opacity:0;overscroll-behavior:contain;grid-row-start:1;grid-column-start:1;width:91.6667%;max-width:32rem;max-height:100vh;padding:1.5rem;transition:translate .3s ease-out,scale .3s ease-out,opacity .2s ease-out 50ms,box-shadow .3s ease-out;overflow-y:auto;scale:95%;box-shadow:0 25px 50px -12px #00000040}.col-start-1{grid-column-start:1}.col-start-2{grid-column-start:2}.col-start-3{grid-column-start:3}.col-start-4{grid-column-start:4}.col-start-5{grid-column-start:5}.row-span-full{grid-row:1/-1}.row-start-1{grid-row-start:1}.row-start-2{grid-row-start:2}.row-start-3{grid-row-start:3}.container{width:100%}@media (min-width:40rem){.container{max-width:40rem}}@media (min-width:48rem){.container{max-width:48rem}}@media (min-width:64rem){.container{max-width:64rem}}@media (min-width:80rem){.container{max-width:80rem}}@media (min-width:96rem){.container{max-width:96rem}}.filter{flex-wrap:wrap;display:flex}.filter input[type=radio]{width:auto}.filter input{opacity:1;transition:margin .1s,opacity .3s,padding .3s,border-width .1s;overflow:hidden;scale:1}.filter input:not(:last-child){margin-inline-end:.25rem}.filter input.filter-reset{aspect-ratio:1}.filter input.filter-reset:after{content:"×"}.filter:not(:has(input:checked:not(.filter-reset))) .filter-reset,.filter:not(:has(input:checked:not(.filter-reset))) input[type=reset],.filter:has(input:checked:not(.filter-reset)) input:not(:checked,.filter-reset,input[type=reset]){opacity:0;border-width:0;width:0;margin-inline:0;padding-inline:0;scale:0}.label{white-space:nowrap;color:currentColor;align-items:center;gap:.375rem;display:inline-flex}@supports (color:color-mix(in lab,red,red)){.label{color:color-mix(in oklab,currentColor 60%,transparent)}}.label:has(input){cursor:pointer}.label:is(.input>*,.select>*){white-space:nowrap;height:calc(100% - .5rem);font-size:inherit;align-items:center;padding-inline:.75rem;display:flex}.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid currentColor;margin-inline:-.75rem .75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):first-child{border-inline-end:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid currentColor;margin-inline:.75rem -.75rem}@supports (color:color-mix(in lab,red,red)){.label:is(.input>*,.select>*):last-child{border-inline-start:var(--border)solid color-mix(in oklab,currentColor 10%,#0000)}}.modal-action{justify-content:flex-end;gap:.5rem;margin-top:1.5rem;display:flex}.mt-4{margin-top:calc(var(--spacing)*4)}.-mr-\\[8\\.5px\\]{margin-right:-8.5px}.-mr-\\[9px\\]{margin-right:-9px}.mr-2{margin-right:calc(var(--spacing)*2)}.mr-\\[9px\\]{margin-right:9px}.mb-2{margin-bottom:calc(var(--spacing)*2)}.mb-4{margin-bottom:calc(var(--spacing)*4)}.mb-8{margin-bottom:calc(var(--spacing)*8)}.-ml-\\[9px\\]{margin-left:-9px}.-ml-\\[12px\\]{margin-left:-12px}.ml-2{margin-left:calc(var(--spacing)*2)}.tabs{--tabs-height:auto;--tabs-direction:row;--tab-height:calc(var(--size-field,.25rem)*10);height:var(--tabs-height);flex-wrap:wrap;flex-direction:var(--tabs-direction);display:flex}.alert{border-radius:var(--radius-box);color:var(--color-base-content);background-color:var(--alert-color,var(--color-base-200));text-align:start;border:var(--border)solid var(--color-base-200);background-size:auto,calc(var(--noise)*100%);background-image:none,var(--fx-noise);box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px #000,0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08));grid-template-columns:auto;grid-auto-flow:column;justify-content:start;place-items:center start;gap:1rem;padding-block:.75rem;padding-inline:1rem;font-size:.875rem;line-height:1.25rem;display:grid}@supports (color:color-mix(in lab,red,red)){.alert{box-shadow:0 3px 0 -2px oklch(100% 0 0/calc(var(--depth)*.08)) inset,0 1px color-mix(in oklab,color-mix(in oklab,#000 20%,var(--alert-color,var(--color-base-200)))calc(var(--depth)*20%),#0000),0 4px 3px -2px oklch(0% 0 0/calc(var(--depth)*.08))}}.alert:has(:nth-child(2)){grid-template-columns:auto minmax(auto,1fr)}.alert.alert-outline{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none}.alert.alert-dash{color:var(--alert-color);box-shadow:none;background-color:#0000;background-image:none;border-style:dashed}.alert.alert-soft{color:var(--alert-color,var(--color-base-content));background:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{background:color-mix(in oklab,var(--alert-color,var(--color-base-content))8%,var(--color-base-100))}}.alert.alert-soft{border-color:var(--alert-color,var(--color-base-content))}@supports (color:color-mix(in lab,red,red)){.alert.alert-soft{border-color:color-mix(in oklab,var(--alert-color,var(--color-base-content))10%,var(--color-base-100))}}.alert.alert-soft{box-shadow:none;background-image:none}.flex{display:flex}.grid{display:grid}.inline-block{display:inline-block}.inline-flex{display:inline-flex}.table{display:table}.btn-circle{width:var(--size);height:var(--size);border-radius:3.40282e38px;padding-inline:0}.size-5{width:calc(var(--spacing)*5);height:calc(var(--spacing)*5)}.h-12{height:calc(var(--spacing)*12)}.h-\\[2px\\]{height:2px}.h-\\[20px\\]{height:20px}.h-\\[50px\\]{height:50px}.h-full{height:100%}.min-h-\\[450px\\]{min-height:450px}.w-\\[20px\\]{width:20px}.w-full{width:100%}.max-w-max{max-width:max-content}.grid-cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}.grid-cols-\\[1fr_20px_1fr_20px_1fr\\]{grid-template-columns:1fr 20px 1fr 20px 1fr}.grid-rows-\\[100px_1fr_80px\\]{grid-template-rows:100px 1fr 80px}.flex-col{flex-direction:column}.items-center{align-items:center}.justify-center{justify-content:center}.gap-4{gap:calc(var(--spacing)*4)}.self-center{align-self:center}.self-start{align-self:flex-start}.justify-self-center{justify-self:center}.justify-self-end{justify-self:flex-end}.justify-self-start{justify-self:flex-start}.tabs-box{background-color:var(--color-base-200);--tabs-box-radius:calc(var(--radius-field) + var(--radius-field) + var(--radius-field));border-radius:calc(var(--radius-field) + min(.25rem,var(--tabs-box-radius)));box-shadow:0 -.5px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 .5px oklch(0% 0 0/calc(var(--depth)*.05)) inset;padding:.25rem}.tabs-box .tab{border-radius:var(--radius-field);border-style:none}.tabs-box .tab:focus-visible,.tabs-box .tab:is(label:has(:checked:focus-visible)){outline-offset:2px}.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){background-color:var(--tab-bg,var(--color-base-100));box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px var(--color-neutral),0 1px 6px -4px var(--color-neutral)}@supports (color:color-mix(in lab,red,red)){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){box-shadow:0 1px oklch(100% 0 0/calc(var(--depth)*.1)) inset,0 1px 1px -1px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*50%),#0000),0 1px 6px -4px color-mix(in oklab,var(--color-neutral)calc(var(--depth)*100%),#0000)}}@media (forced-colors:active){.tabs-box>:is(.tab-active,[aria-selected=true]):not(.tab-disabled,[disabled]),.tabs-box>:is(input:checked),.tabs-box>:is(label:has(:checked)){border:1px solid}}.rounded-full{border-radius:3.40282e38px}.rounded-sm{border-radius:var(--radius-sm)}.rounded-xl{border-radius:var(--radius-xl)}.border-2{border-style:var(--tw-border-style);border-width:2px}.border-3{border-style:var(--tw-border-style);border-width:3px}.border-dashed{--tw-border-style:dashed;border-style:dashed}.border-none{--tw-border-style:none;border-style:none}.border-\\(--color-ocean-gray-100\\){border-color:var(--color-ocean-gray-100)}.bg-\\(--color-ocean-gray-50\\){background-color:var(--color-ocean-gray-50)}.bg-\\(--color-ocean-gray-100\\){background-color:var(--color-ocean-gray-100)}.bg-\\(--color-primary\\){background-color:var(--color-primary)}.radio-sm{padding:.1875rem}.radio-sm[type=radio]{--size:calc(var(--size-selector,.25rem)*5)}.p-1{padding:calc(var(--spacing)*1)}.p-10{padding:calc(var(--spacing)*10)}.px-2{padding-inline:calc(var(--spacing)*2)}.py-1{padding-block:calc(var(--spacing)*1)}.text-center{text-align:center}.text-2xl{font-size:var(--text-2xl);line-height:var(--tw-leading,var(--text-2xl--line-height))}.text-lg{font-size:var(--text-lg);line-height:var(--tw-leading,var(--text-lg--line-height))}.text-sm{font-size:var(--text-sm);line-height:var(--tw-leading,var(--text-sm--line-height))}.font-bold{--tw-font-weight:var(--font-weight-bold);font-weight:var(--font-weight-bold)}.text-\\(--color-ocean-gray-100\\){color:var(--color-ocean-gray-100)}.text-\\(--color-primary\\){color:var(--color-primary)}.text-white{color:var(--color-white)}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none}.btn-ghost:not(.btn-active,:hover,:active:focus,:focus-visible):not(:disabled,[disabled],.btn-disabled){--btn-fg:currentColor;outline-color:currentColor}@media (hover:none){.btn-ghost:hover:not(.btn-active,:active,:focus-visible,:disabled,[disabled],.btn-disabled){--btn-shadow:"";--btn-bg:#0000;--btn-border:#0000;--btn-noise:none;--btn-fg:currentColor}}.filter{filter:var(--tw-blur,)var(--tw-brightness,)var(--tw-contrast,)var(--tw-grayscale,)var(--tw-hue-rotate,)var(--tw-invert,)var(--tw-saturate,)var(--tw-sepia,)var(--tw-drop-shadow,)}.transition{transition-property:color,background-color,border-color,outline-color,text-decoration-color,fill,stroke,--tw-gradient-from,--tw-gradient-via,--tw-gradient-to,opacity,box-shadow,transform,translate,scale,rotate,filter,-webkit-backdrop-filter,backdrop-filter,display,visibility,content-visibility,overlay,pointer-events;transition-timing-function:var(--tw-ease,var(--default-transition-timing-function));transition-duration:var(--tw-duration,var(--default-transition-duration))}.btn-sm{--fontsize:.75rem;--btn-p:.75rem;--size:calc(var(--size-field,.25rem)*8)}.btn-primary{--btn-color:var(--color-primary);--btn-fg:var(--color-primary-content)}:is(.\\*\\:pointer-events-auto>*){pointer-events:auto}@media (hover:hover){.hover\\:cursor-pointer:hover{cursor:pointer}}.disabled\\:text-\\(--color-ocean-gray-300\\):disabled{color:var(--color-ocean-gray-300)}}:root{--color-ocean-gray-00:#fff;--color-ocean-gray-25:#fafbfb;--color-ocean-gray-50:#f5f6f7;--color-ocean-gray-75:#eaeeef;--color-ocean-gray-100:#e1e4e6;--color-ocean-gray-150:#c6ced1;--color-ocean-gray-200:#bac1c4;--color-ocean-gray-250:#9fadb2;--color-ocean-gray-300:#889499;--color-ocean-gray-350:#72858c;--color-ocean-gray-400:#617177;--color-ocean-gray-450:#3f555e;--color-ocean-gray-500:#394d55;--color-ocean-gray-550:#34464d;--color-ocean-gray-600:#2e3e44;--color-ocean-gray-650:#27353b;--color-ocean-gray-700:#222e33;--color-ocean-gray-750:#1f272b;--color-ocean-gray-800:#171f22;--color-ocean-gray-850:#11171a;--color-ocean-gray-900:#0b0f11;--color-chart-1:#f7931e;--color-chart-2:#40535b;--color-chart-3:#2798aa;--color-chart-4:#6da89c;--color-chart-5:#a4cadd;--color-chart-6:#97b42d;--color-chart-7:#ffcb05;--color-chart-8:#ee652e;--color-chart-9:#528694;--color-chart-10:#a10f3b}@keyframes progress{50%{background-position-x:-115%}}@keyframes rating{0%,40%{filter:brightness(1.05)contrast(1.05);scale:1.1}}@keyframes skeleton{0%{background-position:150%}to{background-position:-50%}}@keyframes dropdown{0%{opacity:0}}@keyframes radio{0%{padding:5px}50%{padding:3px}}@keyframes toast{0%{opacity:0;scale:.9}to{opacity:1;scale:1}}@property --tw-border-style{syntax:"*";inherits:false;initial-value:solid}@property --tw-font-weight{syntax:"*";inherits:false}@property --tw-blur{syntax:"*";inherits:false}@property --tw-brightness{syntax:"*";inherits:false}@property --tw-contrast{syntax:"*";inherits:false}@property --tw-grayscale{syntax:"*";inherits:false}@property --tw-hue-rotate{syntax:"*";inherits:false}@property --tw-invert{syntax:"*";inherits:false}@property --tw-opacity{syntax:"*";inherits:false}@property --tw-saturate{syntax:"*";inherits:false}@property --tw-sepia{syntax:"*";inherits:false}@property --tw-drop-shadow{syntax:"*";inherits:false}@property --tw-drop-shadow-color{syntax:"*";inherits:false}@property --tw-drop-shadow-alpha{syntax:"<percentage>";inherits:false;initial-value:100%}@property --tw-drop-shadow-size{syntax:"*";inherits:false}`)),document.head.appendChild(o)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})();
/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Na(t) {
  const r = /* @__PURE__ */ Object.create(null);
  for (const s of t.split(",")) r[s] = 1;
  return (s) => s in r;
}
const ft = {}, So = [], Hn = () => {
}, ac = () => !1, as = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter
(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), Ca = (t) => t.startsWith("onUpdate:"), Xt = Object.assign, Sa = (t, r) => {
  const s = t.indexOf(r);
  s > -1 && t.splice(s, 1);
}, uc = Object.prototype.hasOwnProperty, ut = (t, r) => uc.call(t, r), ke = Array.isArray, Ao = (t) => Fi(t) === "[object Map]", Lo = (t) => Fi(t) === "[object Set]", za = (t) => Fi(t) === "[object Date]", Me = (t) => typeof t == "function", Tt = (t) => typeof t == "string", Mn = (t) => typeof t == "symbol", gt = (t) => t !== null && typeof t == "object", Wu = (t) => (gt(t) || Me(t)) && Me(t.then) && Me(t.catch), Hu = Object.prototype.toString, Fi = (t) => Hu.call(t), lc = (t) => Fi(t).slice(8, -1), Gu = (t) => Fi(t) === "[object Object]", Aa = (t) => Tt(t) && t !== "NaN" && t[0] !== "-" && "" + parseInt(t, 10) === t, wi = /* @__PURE__ */ Na(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), us = (t) => {
  const r = /* @__PURE__ */ Object.create(null);
  return (s) => r[s] || (r[s] = t(s));
}, cc = /-(\w)/g, Sn = us(
  (t) => t.replace(cc, (r, s) => s ? s.toUpperCase() : "")
), fc = /\B([A-Z])/g, Oo = us(
  (t) => t.replace(fc, "-$1").toLowerCase()
), ls = us((t) => t.charAt(0).toUpperCase() + t.slice(1)), Hs = us(
  (t) => t ? `on${ls(t)}` : ""
), Ir = (t, r) => !Object.is(t, r), Hi = (t, ...r) => {
  for (let s = 0; s < t.length; s++)
    t[s](...r);
}, sa = (t, r, s, u = !1) => {
  Object.defineProperty(t, r, {
    configurable: !0,
    enumerable: !1,
    writable: u,
    value: s
  });
}, Ji = (t) => {
  const r = parseFloat(t);
  return isNaN(r) ? t : r;
};
let Ja;
const cs = () => Ja || (Ja = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Fo(t) {
  if (ke(t)) {
    const r = {};
    for (let s = 0; s < t.length; s++) {
      const u = t[s], c = Tt(u) ? mc(u) : Fo(u);
      if (c)
        for (const d in c)
          r[d] = c[d];
    }
    return r;
  } else if (Tt(t) || gt(t))
    return t;
}
const dc = /;(?![^(]*\))/g, pc = /:([^]+)/, hc = /\/\*[^]*?\*\//g;
function mc(t) {
  const r = {};
  return t.replace(hc, "").split(dc).forEach((s) => {
    if (s) {
      const u = s.split(pc);
      u.length > 1 && (r[u[0].trim()] = u[1].trim());
    }
  }), r;
}
function pn(t) {
  let r = "";
  if (Tt(t))
    r = t;
  else if (ke(t))
    for (let s = 0; s < t.length; s++) {
      const u = pn(t[s]);
      u && (r += u + " ");
    }
  else if (gt(t))
    for (const s in t)
      t[s] && (r += s + " ");
  return r.trim();
}
function yc(t) {
  if (!t) return null;
  let { class: r, style: s } = t;
  return r && !Tt(r) && (t.class = pn(r)), s && (t.style = Fo(s)), t;
}
const vc = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", gc = /* @__PURE__ */ Na(vc);
function Yu(t) {
  return !!t || t === "";
}
function bc(t, r) {
  if (t.length !== r.length) return !1;
  let s = !0;
  for (let u = 0; s && u < t.length; u++)
    s = _o(t[u], r[u]);
  return s;
}
function _o(t, r) {
  if (t === r) return !0;
  let s = za(t), u = za(r);
  if (s || u)
    return s && u ? t.getTime() === r.getTime() : !1;
  if (s = Mn(t), u = Mn(r), s || u)
    return t === r;
  if (s = ke(t), u = ke(r), s || u)
    return s && u ? bc(t, r) : !1;
  if (s = gt(t), u = gt(r), s || u) {
    if (!s || !u)
      return !1;
    const c = Object.keys(t).length, d = Object.keys(r).length;
    if (c !== d)
      return !1;
    for (const f in t) {
      const h = t.hasOwnProperty(f), _ = r.hasOwnProperty(f);
      if (h && !_ || !h && _ || !_o(t[f], r[f]))
        return !1;
    }
  }
  return String(t) === String(r);
}
function Ra(t, r) {
  return t.findIndex((s) => _o(s, r));
}
const Qu = (t) => !!(t && t.__v_isRef === !0), Te = (t) => Tt(t) ? t : t == null ? "" : ke(t) || gt(t) && (t.toString === Hu || !Me(t.toString)) ? Qu(t) ? Te(t.value) : JSON.stringify(t, Xu, 2) : String(t), Xu = (t, r) => Qu(r) ? Xu(t, r.value) : Ao(r) ? {
  [`Map(${r.size})`]: [...r.entries()].reduce(
    (s, [u, c], d) => (s[Gs(u, d) + " =>"] = c, s),
    {}
  )
} : Lo(r) ? {
  [`Set(${r.size})`]: [...r.values()].map((s) => Gs(s))
} : Mn(r) ? Gs(r) : gt(r) && !ke(r) && !Gu(r) ? String(r) : r, Gs = (t, r = "") => {
  var s;
  return (
    // Symbol.description in es2019+ so we need to cast here to pass
    // the lib: es2016 check
    Mn(t) ? `Symbol(${(s = t.description) != null ? s : r})` : t
  );
};
/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Gt;
class zu {
  constructor(r = !1) {
    this.detached = r, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = Gt, !r && Gt && (this.index = (Gt.scopes || (Gt.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  pause() {
    if (this._active) {
      this._isPaused = !0;
      let r, s;
      if (this.scopes)
        for (r = 0, s = this.scopes.length; r < s; r++)
          this.scopes[r].pause();
      for (r = 0, s = this.effects.length; r < s; r++)
        this.effects[r].pause();
    }
  }
  /**
   * Resumes the effect scope, including all child scopes and effects.
   */
  resume() {
    if (this._active && this._isPaused) {
      this._isPaused = !1;
      let r, s;
      if (this.scopes)
        for (r = 0, s = this.scopes.length; r < s; r++)
          this.scopes[r].resume();
      for (r = 0, s = this.effects.length; r < s; r++)
        this.effects[r].resume();
    }
  }
  run(r) {
    if (this._active) {
      const s = Gt;
      try {
        return Gt = this, r();
      } finally {
        Gt = s;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    ++this._on === 1 && (this.prevScope = Gt, Gt = this);
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    this._on > 0 && --this._on === 0 && (Gt = this.prevScope, this.prevScope = void 0);
  }
  stop(r) {
    if (this._active) {
      this._active = !1;
      let s, u;
      for (s = 0, u = this.effects.length; s < u; s++)
        this.effects[s].stop();
      for (this.effects.length = 0, s = 0, u = this.cleanups.length; s < u; s++)
        this.cleanups[s]();
      if (this.cleanups.length = 0, this.scopes) {
        for (s = 0, u = this.scopes.length; s < u; s++)
          this.scopes[s].stop(!0);
        this.scopes.length = 0;
      }
      if (!this.detached && this.parent && !r) {
        const c = this.parent.scopes.pop();
        c && c !== this && (this.parent.scopes[this.index] = c, c.index = this.index);
      }
      this.parent = void 0;
    }
  }
}
function Ju(t) {
  return new zu(t);
}
function Zu() {
  return Gt;
}
function wc(t, r = !1) {
  Gt && Gt.cleanups.push(t);
}
let yt;
const Ys = /* @__PURE__ */ new WeakSet();
class el {
  constructor(r) {
    this.fn = r, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, Gt && Gt.active && Gt.effects.push(this);
  }
  pause() {
    this.flags |= 64;
  }
  resume() {
    this.flags & 64 && (this.flags &= -65, Ys.has(this) && (Ys.delete(this), this.trigger()));
  }
  /**
   * @internal
   */
  notify() {
    this.flags & 2 && !(this.flags & 32) || this.flags & 8 || nl(this);
  }
  run() {
    if (!(this.flags & 1))
      return this.fn();
    this.flags |= 2, Za(this), rl(this);
    const r = yt, s = Kn;
    yt = this, Kn = !0;
    try {
      return this.fn();
    } finally {
      ol(this), yt = r, Kn = s, this.flags &= -3;
    }
  }
  stop() {
    if (this.flags & 1) {
      for (let r = this.deps; r; r = r.nextDep)
        Ia(r);
      this.deps = this.depsTail = void 0, Za(this), this.onStop && this.onStop(), this.flags &= -2;
    }
  }
  trigger() {
    this.flags & 64 ? Ys.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty();
  }
  /**
   * @internal
   */
  runIfDirty() {
    aa(this) && this.run();
  }
  get dirty() {
    return aa(this);
  }
}
let tl = 0, _i, xi;
function nl(t, r = !1) {
  if (t.flags |= 8, r) {
    t.next = xi, xi = t;
    return;
  }
  t.next = _i, _i = t;
}
function Da() {
  tl++;
}
function Pa() {
  if (--tl > 0)
    return;
  if (xi) {
    let r = xi;
    for (xi = void 0; r; ) {
      const s = r.next;
      r.next = void 0, r.flags &= -9, r = s;
    }
  }
  let t;
  for (; _i; ) {
    let r = _i;
    for (_i = void 0; r; ) {
      const s = r.next;
      if (r.next = void 0, r.flags &= -9, r.flags & 1)
        try {
          r.trigger();
        } catch (u) {
          t || (t = u);
        }
      r = s;
    }
  }
  if (t) throw t;
}
function rl(t) {
  for (let r = t.deps; r; r = r.nextDep)
    r.version = -1, r.prevActiveLink = r.dep.activeLink, r.dep.activeLink = r;
}
function ol(t) {
  let r, s = t.depsTail, u = s;
  for (; u; ) {
    const c = u.prevDep;
    u.version === -1 ? (u === s && (s = c), Ia(u), _c(u)) : r = u, u.dep.activeLink = u.prevActiveLink, u.prevActiveLink = void 0, u = c;
  }
  t.deps = r, t.depsTail = s;
}
function aa(t) {
  for (let r = t.deps; r; r = r.nextDep)
    if (r.dep.version !== r.version || r.dep.computed && (il(r.dep.computed) || r.dep.version !== r.version))
      return !0;
  return !!t._dirty;
}
function il(t) {
  if (t.flags & 4 && !(t.flags & 16) || (t.flags &= -17, t.globalVersion === Ai) || (t.globalVersion = Ai, !t.isSSR && t.flags & 128 && (!t.deps && !t._dirty || !aa(t))))
    return;
  t.flags |= 2;
  const r = t.dep, s = yt, u = Kn;
  yt = t, Kn = !0;
  try {
    rl(t);
    const c = t.fn(t._value);
    (r.version === 0 || Ir(c, t._value)) && (t.flags |= 128, t._value = c, r.version++);
  } catch (c) {
    throw r.version++, c;
  } finally {
    yt = s, Kn = u, ol(t), t.flags &= -3;
  }
}
function Ia(t, r = !1) {
  const { dep: s, prevSub: u, nextSub: c } = t;
  if (u && (u.nextSub = c, t.prevSub = void 0), c && (c.prevSub = u, t.nextSub = void 0), s.subs === t && (s.subs = u, !u && s.computed)) {
    s.computed.flags &= -5;
    for (let d = s.computed.deps; d; d = d.nextDep)
      Ia(d, !0);
  }
  !r && !--s.sc && s.map && s.map.delete(s.key);
}
function _c(t) {
  const { prevDep: r, nextDep: s } = t;
  r && (r.nextDep = s, t.prevDep = void 0), s && (s.prevDep = r, t.nextDep = void 0);
}
let Kn = !0;
const sl = [];
function Er() {
  sl.push(Kn), Kn = !1;
}
function Nr() {
  const t = sl.pop();
  Kn = t === void 0 ? !0 : t;
}
function Za(t) {
  const { cleanup: r } = t;
  if (t.cleanup = void 0, r) {
    const s = yt;
    yt = void 0;
    try {
      r();
    } finally {
      yt = s;
    }
  }
}
let Ai = 0;
class xc {
  constructor(r, s) {
    this.sub = r, this.dep = s, this.version = s.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0;
  }
}
class ka {
  // TODO isolatedDeclarations "__v_skip"
  constructor(r) {
    this.computed = r, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.__v_skip = !0;
  }
  track(r) {
    if (!yt || !Kn || yt === this.computed)
      return;
    let s = this.activeLink;
    if (s === void 0 || s.sub !== yt)
      s = this.activeLink = new xc(yt, this), yt.deps ? (s.prevDep = yt.depsTail, yt.depsTail.nextDep = s, yt.depsTail = s) : yt.deps = yt.depsTail = s, al(s);
    else if (s.version === -1 && (s.version = this.version, s.nextDep)) {
      const u = s.nextDep;
      u.prevDep = s.prevDep, s.prevDep && (s.prevDep.nextDep = u), s.prevDep = yt.depsTail, s.nextDep = void 0, yt.depsTail.nextDep = s, yt.depsTail = s, yt.deps === s && (yt.deps = u);
    }
    return s;
  }
  trigger(r) {
    this.version++, Ai++, this.notify(r);
  }
  notify(r) {
    Da();
    try {
      for (let s = this.subs; s; s = s.prevSub)
        s.sub.notify() && s.sub.dep.notify();
    } finally {
      Pa();
    }
  }
}
function al(t) {
  if (t.dep.sc++, t.sub.flags & 4) {
    const r = t.dep.computed;
    if (r && !t.dep.subs) {
      r.flags |= 20;
      for (let u = r.deps; u; u = u.nextDep)
        al(u);
    }
    const s = t.dep.subs;
    s !== t && (t.prevSub = s, s && (s.nextSub = t)), t.dep.subs = t;
  }
}
const Zi = /* @__PURE__ */ new WeakMap(), go = Symbol(
  ""
), ua = Symbol(
  ""
), Ri = Symbol(
  ""
);
function Yt(t, r, s) {
  if (Kn && yt) {
    let u = Zi.get(t);
    u || Zi.set(t, u = /* @__PURE__ */ new Map());
    let c = u.get(s);
    c || (u.set(s, c = new ka()), c.map = u, c.key = s), c.track();
  }
}
function wr(t, r, s, u, c, d) {
  const f = Zi.get(t);
  if (!f) {
    Ai++;
    return;
  }
  const h = (_) => {
    _ && _.trigger();
  };
  if (Da(), r === "clear")
    f.forEach(h);
  else {
    const _ = ke(t), k = _ && Aa(s);
    if (_ && s === "length") {
      const D = Number(u);
      f.forEach((j, B) => {
        (B === "length" || B === Ri || !Mn(B) && B >= D) && h(j);
      });
    } else
      switch ((s !== void 0 || f.has(void 0)) && h(f.get(s)), k && h(f.get(Ri)), r) {
        case "add":
          _ ? k && h(f.get("length")) : (h(f.get(go)), Ao(t) && h(f.get(ua)));
          break;
        case "delete":
          _ || (h(f.get(go)), Ao(t) && h(f.get(ua)));
          break;
        case "set":
          Ao(t) && h(f.get(go));
          break;
      }
  }
  Pa();
}
function Oc(t, r) {
  const s = Zi.get(t);
  return s && s.get(r);
}
function Eo(t) {
  const r = et(t);
  return r === t ? r : (Yt(r, "iterate", Ri), Nn(t) ? r : r.map(Wt));
}
function fs(t) {
  return Yt(t = et(t), "iterate", Ri), t;
}
const Tc = {
  __proto__: null,
  [Symbol.iterator]() {
    return Qs(this, Symbol.iterator, Wt);
  },
  concat(...t) {
    return Eo(this).concat(
      ...t.map((r) => ke(r) ? Eo(r) : r)
    );
  },
  entries() {
    return Qs(this, "entries", (t) => (t[1] = Wt(t[1]), t));
  },
  every(t, r) {
    return gr(this, "every", t, r, void 0, arguments);
  },
  filter(t, r) {
    return gr(this, "filter", t, r, (s) => s.map(Wt), arguments);
  },
  find(t, r) {
    return gr(this, "find", t, r, Wt, arguments);
  },
  findIndex(t, r) {
    return gr(this, "findIndex", t, r, void 0, arguments);
  },
  findLast(t, r) {
    return gr(this, "findLast", t, r, Wt, arguments);
  },
  findLastIndex(t, r) {
    return gr(this, "findLastIndex", t, r, void 0, arguments);
  },
  // flat, flatMap could benefit from ARRAY_ITERATE but are not straight-forward to implement
  forEach(t, r) {
    return gr(this, "forEach", t, r, void 0, arguments);
  },
  includes(...t) {
    return Xs(this, "includes", t);
  },
  indexOf(...t) {
    return Xs(this, "indexOf", t);
  },
  join(t) {
    return Eo(this).join(t);
  },
  // keys() iterator only reads `length`, no optimisation required
  lastIndexOf(...t) {
    return Xs(this, "lastIndexOf", t);
  },
  map(t, r) {
    return gr(this, "map", t, r, void 0, arguments);
  },
  pop() {
    return vi(this, "pop");
  },
  push(...t) {
    return vi(this, "push", t);
  },
  reduce(t, ...r) {
    return eu(this, "reduce", t, r);
  },
  reduceRight(t, ...r) {
    return eu(this, "reduceRight", t, r);
  },
  shift() {
    return vi(this, "shift");
  },
  // slice could use ARRAY_ITERATE but also seems to beg for range tracking
  some(t, r) {
    return gr(this, "some", t, r, void 0, arguments);
  },
  splice(...t) {
    return vi(this, "splice", t);
  },
  toReversed() {
    return Eo(this).toReversed();
  },
  toSorted(t) {
    return Eo(this).toSorted(t);
  },
  toSpliced(...t) {
    return Eo(this).toSpliced(...t);
  },
  unshift(...t) {
    return vi(this, "unshift", t);
  },
  values() {
    return Qs(this, "values", Wt);
  }
};
function Qs(t, r, s) {
  const u = fs(t), c = u[r]();
  return u !== t && !Nn(t) && (c._next = c.next, c.next = () => {
    const d = c._next();
    return d.value && (d.value = s(d.value)), d;
  }), c;
}
const Ec = Array.prototype;
function gr(t, r, s, u, c, d) {
  const f = fs(t), h = f !== t && !Nn(t), _ = f[r];
  if (_ !== Ec[r]) {
    const j = _.apply(t, d);
    return h ? Wt(j) : j;
  }
  let k = s;
  f !== t && (h ? k = function(j, B) {
    return s.call(this, Wt(j), B, t);
  } : s.length > 2 && (k = function(j, B) {
    return s.call(this, j, B, t);
  }));
  const D = _.call(f, k, u);
  return h && c ? c(D) : D;
}
function eu(t, r, s, u) {
  const c = fs(t);
  let d = s;
  return c !== t && (Nn(t) ? s.length > 3 && (d = function(f, h, _) {
    return s.call(this, f, h, _, t);
  }) : d = function(f, h, _) {
    return s.call(this, f, Wt(h), _, t);
  }), c[r](d, ...u);
}
function Xs(t, r, s) {
  const u = et(t);
  Yt(u, "iterate", Ri);
  const c = u[r](...s);
  return (c === -1 || c === !1) && Fa(s[0]) ? (s[0] = et(s[0]), u[r](...s)) : c;
}
function vi(t, r, s = []) {
  Er(), Da();
  const u = et(t)[r].apply(t, s);
  return Pa(), Nr(), u;
}
const Nc = /* @__PURE__ */ Na("__proto__,__v_isRef,__isVue"), ul = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== "arguments" && t !== "caller").map((t) => Symbol[t]).filter(Mn)
);
function Cc(t) {
  Mn(t) || (t = String(t));
  const r = et(this);
  return Yt(r, "has", t), r.hasOwnProperty(t);
}
class ll {
  constructor(r = !1, s = !1) {
    this._isReadonly = r, this._isShallow = s;
  }
  get(r, s, u) {
    if (s === "__v_skip") return r.__v_skip;
    const c = this._isReadonly, d = this._isShallow;
    if (s === "__v_isReactive")
      return !c;
    if (s === "__v_isReadonly")
      return c;
    if (s === "__v_isShallow")
      return d;
    if (s === "__v_raw")
      return u === (c ? d ? Fc : pl : d ? dl : fl).get(r) || // receiver is not the reactive proxy, but has the same prototype
      // this means the receiver is a user proxy of the reactive proxy
      Object.getPrototypeOf(r) === Object.getPrototypeOf(u) ? r : void 0;
    const f = ke(r);
    if (!c) {
      let _;
      if (f && (_ = Tc[s]))
        return _;
      if (s === "hasOwnProperty")
        return Cc;
    }
    const h = Reflect.get(
      r,
      s,
      // if this is a proxy wrapping a ref, return methods using the raw ref
      // as receiver so that we don't have to call `toRaw` on the ref in all
      // its class methods
      Ot(r) ? r : u
    );
    return (Mn(s) ? ul.has(s) : Nc(s)) || (c || Yt(r, "get", s), d) ? h : Ot(h) ? f && Aa(s) ? h : h.value : gt(h) ? c ? hl(h) : Ki(h) : h;
  }
}
class cl extends ll {
  constructor(r = !1) {
    super(!1, r);
  }
  set(r, s, u, c) {
    let d = r[s];
    if (!this._isShallow) {
      const _ = kr(d);
      if (!Nn(u) && !kr(u) && (d = et(d), u = et(u)), !ke(r) && Ot(d) && !Ot(u))
        return _ ? !1 : (d.value = u, !0);
    }
    const f = ke(r) && Aa(s) ? Number(s) < r.length : ut(r, s), h = Reflect.set(
      r,
      s,
      u,
      Ot(r) ? r : c
    );
    return r === et(c) && (f ? Ir(u, d) && wr(r, "set", s, u) : wr(r, "add", s, u)), h;
  }
  deleteProperty(r, s) {
    const u = ut(r, s);
    r[s];
    const c = Reflect.deleteProperty(r, s);
    return c && u && wr(r, "delete", s, void 0), c;
  }
  has(r, s) {
    const u = Reflect.has(r, s);
    return (!Mn(s) || !ul.has(s)) && Yt(r, "has", s), u;
  }
  ownKeys(r) {
    return Yt(
      r,
      "iterate",
      ke(r) ? "length" : go
    ), Reflect.ownKeys(r);
  }
}
class Sc extends ll {
  constructor(r = !1) {
    super(!0, r);
  }
  set(r, s) {
    return !0;
  }
  deleteProperty(r, s) {
    return !0;
  }
}
const Ac = /* @__PURE__ */ new cl(), Rc = /* @__PURE__ */ new Sc(), Dc = /* @__PURE__ */ new cl(!0);
const la = (t) => t, $i = (t) => Reflect.getPrototypeOf(t);
function Pc(t, r, s) {
  return function(...u) {
    const c = this.__v_raw, d = et(c), f = Ao(d), h = t === "entries" || t === Symbol.iterator && f, _ = t === "keys" && f, k = c[t](...u), D = s ? la : r ? es : Wt;
    return !r && Yt(
      d,
      "iterate",
      _ ? ua : go
    ), {
      // iterator protocol
      next() {
        const { value: j, done: B } = k.next();
        return B ? { value: j, done: B } : {
          value: h ? [D(j[0]), D(j[1])] : D(j),
          done: B
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function qi(t) {
  return function(...r) {
    return t === "delete" ? !1 : t === "clear" ? void 0 : this;
  };
}
function Ic(t, r) {
  const s = {
    get(c) {
      const d = this.__v_raw, f = et(d), h = et(c);
      t || (Ir(c, h) && Yt(f, "get", c), Yt(f, "get", h));
      const { has: _ } = $i(f), k = r ? la : t ? es : Wt;
      if (_.call(f, c))
        return k(d.get(c));
      if (_.call(f, h))
        return k(d.get(h));
      d !== f && d.get(c);
    },
    get size() {
      const c = this.__v_raw;
      return !t && Yt(et(c), "iterate", go), Reflect.get(c, "size", c);
    },
    has(c) {
      const d = this.__v_raw, f = et(d), h = et(c);
      return t || (Ir(c, h) && Yt(f, "has", c), Yt(f, "has", h)), c === h ? d.has(c) : d.has(c) || d.has(h);
    },
    forEach(c, d) {
      const f = this, h = f.__v_raw, _ = et(h), k = r ? la : t ? es : Wt;
      return !t && Yt(_, "iterate", go), h.forEach((D, j) => c.call(d, k(D), k(j), f));
    }
  };
  return Xt(
    s,
    t ? {
      add: qi("add"),
      set: qi("set"),
      delete: qi("delete"),
      clear: qi("clear")
    } : {
      add(c) {
        !r && !Nn(c) && !kr(c) && (c = et(c));
        const d = et(this);
        return $i(d).has.call(d, c) || (d.add(c), wr(d, "add", c, c)), this;
      },
      set(c, d) {
        !r && !Nn(d) && !kr(d) && (d = et(d));
        const f = et(this), { has: h, get: _ } = $i(f);
        let k = h.call(f, c);
        k || (c = et(c), k = h.call(f, c));
        const D = _.call(f, c);
        return f.set(c, d), k ? Ir(d, D) && wr(f, "set", c, d) : wr(f, "add", c, d), this;
      },
      delete(c) {
        const d = et(this), { has: f, get: h } = $i(d);
        let _ = f.call(d, c);
        _ || (c = et(c), _ = f.call(d, c)), h && h.call(d, c);
        const k = d.delete(c);
        return _ && wr(d, "delete", c, void 0), k;
      },
      clear() {
        const c = et(this), d = c.size !== 0, f = c.clear();
        return d && wr(
          c,
          "clear",
          void 0,
          void 0
        ), f;
      }
    }
  ), [
    "keys",
    "values",
    "entries",
    Symbol.iterator
  ].forEach((c) => {
    s[c] = Pc(c, t, r);
  }), s;
}
function ja(t, r) {
  const s = Ic(t, r);
  return (u, c, d) => c === "__v_isReactive" ? !t : c === "__v_isReadonly" ? t : c === "__v_raw" ? u : Reflect.get(
    ut(s, c) && c in u ? s : u,
    c,
    d
  );
}
const kc = {
  get: /* @__PURE__ */ ja(!1, !1)
}, jc = {
  get: /* @__PURE__ */ ja(!1, !0)
}, Lc = {
  get: /* @__PURE__ */ ja(!0, !1)
};
const fl = /* @__PURE__ */ new WeakMap(), dl = /* @__PURE__ */ new WeakMap(), pl = /* @__PURE__ */ new WeakMap(), Fc = /* @__PURE__ */ new WeakMap();
function Kc(t) {
  switch (t) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function Mc(t) {
  return t.__v_skip || !Object.isExtensible(t) ? 0 : Kc(lc(t));
}
function Ki(t) {
  return kr(t) ? t : La(
    t,
    !1,
    Ac,
    kc,
    fl
  );
}
function Bc(t) {
  return La(
    t,
    !1,
    Dc,
    jc,
    dl
  );
}
function hl(t) {
  return La(
    t,
    !0,
    Rc,
    Lc,
    pl
  );
}
function La(t, r, s, u, c) {
  if (!gt(t) || t.__v_raw && !(r && t.__v_isReactive))
    return t;
  const d = Mc(t);
  if (d === 0)
    return t;
  const f = c.get(t);
  if (f)
    return f;
  const h = new Proxy(
    t,
    d === 2 ? u : s
  );
  return c.set(t, h), h;
}
function Or(t) {
  return kr(t) ? Or(t.__v_raw) : !!(t && t.__v_isReactive);
}
function kr(t) {
  return !!(t && t.__v_isReadonly);
}
function Nn(t) {
  return !!(t && t.__v_isShallow);
}
function Fa(t) {
  return t ? !!t.__v_raw : !1;
}
function et(t) {
  const r = t && t.__v_raw;
  return r ? et(r) : t;
}
function ds(t) {
  return !ut(t, "__v_skip") && Object.isExtensible(t) && sa(t, "__v_skip", !0), t;
}
const Wt = (t) => gt(t) ? Ki(t) : t, es = (t) => gt(t) ? hl(t) : t;
function Ot(t) {
  return t ? t.__v_isRef === !0 : !1;
}
function nt(t) {
  return ml(t, !1);
}
function bo(t) {
  return ml(t, !0);
}
function ml(t, r) {
  return Ot(t) ? t : new $c(t, r);
}
class $c {
  constructor(r, s) {
    this.dep = new ka(), this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = s ? r : et(r), this._value = s ? r : Wt(r), this.__v_isShallow = s;
  }
  get value() {
    return this.dep.track(), this._value;
  }
  set value(r) {
    const s = this._rawValue, u = this.__v_isShallow || Nn(r) || kr(r);
    r = u ? r : et(r), Ir(r, s) && (this._rawValue = r, this._value = u ? r : Wt(r), this.dep.trigger());
  }
}
function Ae(t) {
  return Ot(t) ? t.value : t;
}
const qc = {
  get: (t, r, s) => r === "__v_raw" ? t : Ae(Reflect.get(t, r, s)),
  set: (t, r, s, u) => {
    const c = t[r];
    return Ot(c) && !Ot(s) ? (c.value = s, !0) : Reflect.set(t, r, s, u);
  }
};
function yl(t) {
  return Or(t) ? t : new Proxy(t, qc);
}
function Uc(t) {
  const r = ke(t) ? new Array(t.length) : {};
  for (const s in t)
    r[s] = vl(t, s);
  return r;
}
class Vc {
  constructor(r, s, u) {
    this._object = r, this._key = s, this._defaultValue = u, this.__v_isRef = !0, this._value = void 0;
  }
  get value() {
    const r = this._object[this._key];
    return this._value = r === void 0 ? this._defaultValue : r;
  }
  set value(r) {
    this._object[this._key] = r;
  }
  get dep() {
    return Oc(et(this._object), this._key);
  }
}
class Wc {
  constructor(r) {
    this._getter = r, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0;
  }
  get value() {
    return this._value = this._getter();
  }
}
function Hc(t, r, s) {
  return Ot(t) ? t : Me(t) ? new Wc(t) : gt(t) && arguments.length > 1 ? vl(t, r, s) : nt(t);
}
function vl(t, r, s) {
  const u = t[r];
  return Ot(u) ? u : new Vc(t, r, s);
}
class Gc {
  constructor(r, s, u) {
    this.fn = r, this.setter = s, this._value = void 0, this.dep = new ka(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Ai - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !s, this.isSSR = u;
  }
  /**
   * @internal
   */
  notify() {
    if (this.flags |= 16, !(this.flags & 8) && // avoid infinite self recursion
    yt !== this)
      return nl(this, !0), !0;
  }
  get value() {
    const r = this.dep.track();
    return il(this), r && (r.version = this.dep.version), this._value;
  }
  set value(r) {
    this.setter && this.setter(r);
  }
}
function Yc(t, r, s = !1) {
  let u, c;
  return Me(t) ? u = t : (u = t.get, c = t.set), new Gc(u, c, s);
}
const Ui = {}, ts = /* @__PURE__ */ new WeakMap();
let vo;
function Qc(t, r = !1, s = vo) {
  if (s) {
    let u = ts.get(s);
    u || ts.set(s, u = []), u.push(t);
  }
}
function Xc(t, r, s = ft) {
  const { immediate: u, deep: c, once: d, scheduler: f, augmentJob: h, call: _ } = s, k = (fe) => c ? fe : Nn(fe) || c === !1 || c === 0 ? _r(fe, 1) : _r(fe);
  let D, j, B, ee, re = !1, Q = !1;
  if (Ot(t) ? (j = () => t.value, re = Nn(t)) : Or(t) ? (j = () => k(t), re = !0) : ke(t) ? (Q = !0, re = t.some((fe) => Or(fe) || Nn(fe)), j = () => t.map((fe) => {
    if (Ot(fe))
      return fe.value;
    if (Or(fe))
      return k(fe);
    if (Me(fe))
      return _ ? _(fe, 2) : fe();
  })) : Me(t) ? r ? j = _ ? () => _(t, 2) : t : j = () => {
    if (B) {
      Er();
      try {
        B();
      } finally {
        Nr();
      }
    }
    const fe = vo;
    vo = D;
    try {
      return _ ? _(t, 3, [ee]) : t(ee);
    } finally {
      vo = fe;
    }
  } : j = Hn, r && c) {
    const fe = j, _e = c === !0 ? 1 / 0 : c;
    j = () => _r(fe(), _e);
  }
  const W = Zu(), G = () => {
    D.stop(), W && W.active && Sa(W.effects, D);
  };
  if (d && r) {
    const fe = r;
    r = (..._e) => {
      fe(..._e), G();
    };
  }
  let $ = Q ? new Array(t.length).fill(Ui) : Ui;
  const q = (fe) => {
    if (!(!(D.flags & 1) || !D.dirty && !fe))
      if (r) {
        const _e = D.run();
        if (c || re || (Q ? _e.some((Pe, ue) => Ir(Pe, $[ue])) : Ir(_e, $))) {
          B && B();
          const Pe = vo;
          vo = D;
          try {
            const ue = [
              _e,
              // pass undefined as the old value when it's changed for the first time
              $ === Ui ? void 0 : Q && $[0] === Ui ? [] : $,
              ee
            ];
            $ = _e, _ ? _(r, 3, ue) : (
              // @ts-expect-error
              r(...ue)
            );
          } finally {
            vo = Pe;
          }
        }
      } else
        D.run();
  };
  return h && h(q), D = new el(j), D.scheduler = f ? () => f(q, !1) : q, ee = (fe) => Qc(fe, !1, D), B = D.onStop = () => {
    const fe = ts.get(D);
    if (fe) {
      if (_)
        _(fe, 4);
      else
        for (const _e of fe) _e();
      ts.delete(D);
    }
  }, r ? u ? q(!0) : $ = D.run() : f ? f(q.bind(null, !0), !0) : D.run(), G.pause = D.pause.bind(D), G.resume = D.resume.bind(D), G.stop = G, G;
}
function _r(t, r = 1 / 0, s) {
  if (r <= 0 || !gt(t) || t.__v_skip || (s = s || /* @__PURE__ */ new Set(), s.has(t)))
    return t;
  if (s.add(t), r--, Ot(t))
    _r(t.value, r, s);
  else if (ke(t))
    for (let u = 0; u < t.length; u++)
      _r(t[u], r, s);
  else if (Lo(t) || Ao(t))
    t.forEach((u) => {
      _r(u, r, s);
    });
  else if (Gu(t)) {
    for (const u in t)
      _r(t[u], r, s);
    for (const u of Object.getOwnPropertySymbols(t))
      Object.prototype.propertyIsEnumerable.call(t, u) && _r(t[u], r, s);
  }
  return t;
}
/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Mi(t, r, s, u) {
  try {
    return u ? t(...u) : t();
  } catch (c) {
    ps(c, r, s);
  }
}
function Gn(t, r, s, u) {
  if (Me(t)) {
    const c = Mi(t, r, s, u);
    return c && Wu(c) && c.catch((d) => {
      ps(d, r, s);
    }), c;
  }
  if (ke(t)) {
    const c = [];
    for (let d = 0; d < t.length; d++)
      c.push(Gn(t[d], r, s, u));
    return c;
  }
}
function ps(t, r, s, u = !0) {
  const c = r ? r.vnode : null, { errorHandler: d, throwUnhandledErrorInProduction: f } = r && r.appContext.config || ft;
  if (r) {
    let h = r.parent;
    const _ = r.proxy, k = `https://vuejs.org/error-reference/#runtime-${s}`;
    for (; h; ) {
      const D = h.ec;
      if (D) {
        for (let j = 0; j < D.length; j++)
          if (D[j](t, _, k) === !1)
            return;
      }
      h = h.parent;
    }
    if (d) {
      Er(), Mi(d, null, 10, [
        t,
        _,
        k
      ]), Nr();
      return;
    }
  }
  zc(t, s, c, u, f);
}
function zc(t, r, s, u = !0, c = !1) {
  if (c)
    throw t;
  console.error(t);
}
const un = [];
let Un = -1;
const Ro = [];
let Rr = null, Co = 0;
const gl = /* @__PURE__ */ Promise.resolve();
let ns = null;
function Ka(t) {
  const r = ns || gl;
  return t ? r.then(this ? t.bind(this) : t) : r;
}
function Jc(t) {
  let r = Un + 1, s = un.length;
  for (; r < s; ) {
    const u = r + s >>> 1, c = un[u], d = Di(c);
    d < t || d === t && c.flags & 2 ? r = u + 1 : s = u;
  }
  return r;
}
function Ma(t) {
  if (!(t.flags & 1)) {
    const r = Di(t), s = un[un.length - 1];
    !s || // fast path when the job id is larger than the tail
    !(t.flags & 2) && r >= Di(s) ? un.push(t) : un.splice(Jc(r), 0, t), t.flags |= 1, bl();
  }
}
function bl() {
  ns || (ns = gl.then(_l));
}
function Zc(t) {
  ke(t) ? Ro.push(...t) : Rr && t.id === -1 ? Rr.splice(Co + 1, 0, t) : t.flags & 1 || (Ro.push(t), t.flags |= 1), bl();
}
function tu(t, r, s = Un + 1) {
  for (; s < un.length; s++) {
    const u = un[s];
    if (u && u.flags & 2) {
      if (t && u.id !== t.uid)
        continue;
      un.splice(s, 1), s--, u.flags & 4 && (u.flags &= -2), u(), u.flags & 4 || (u.flags &= -2);
    }
  }
}
function wl(t) {
  if (Ro.length) {
    const r = [...new Set(Ro)].sort(
      (s, u) => Di(s) - Di(u)
    );
    if (Ro.length = 0, Rr) {
      Rr.push(...r);
      return;
    }
    for (Rr = r, Co = 0; Co < Rr.length; Co++) {
      const s = Rr[Co];
      s.flags & 4 && (s.flags &= -2), s.flags & 8 || s(), s.flags &= -2;
    }
    Rr = null, Co = 0;
  }
}
const Di = (t) => t.id == null ? t.flags & 2 ? -1 : 1 / 0 : t.id;
function _l(t) {
  try {
    for (Un = 0; Un < un.length; Un++) {
      const r = un[Un];
      r && !(r.flags & 8) && (r.flags & 4 && (r.flags &= -2), Mi(
        r,
        r.i,
        r.i ? 15 : 14
      ), r.flags & 4 || (r.flags &= -2));
    }
  } finally {
    for (; Un < un.length; Un++) {
      const r = un[Un];
      r && (r.flags &= -2);
    }
    Un = -1, un.length = 0, wl(), ns = null, (un.length || Ro.length) && _l();
  }
}
let It = null, xl = null;
function rs(t) {
  const r = It;
  return It = t, xl = t && t.type.__scopeId || null, r;
}
function ca(t, r = It, s) {
  if (!r || t._n)
    return t;
  const u = (...c) => {
    u._d && mu(-1);
    const d = rs(r);
    let f;
    try {
      f = t(...c);
    } finally {
      rs(d), u._d && mu(1);
    }
    return f;
  };
  return u._n = !0, u._c = !0, u._d = !0, u;
}
function We(t, r) {
  if (It === null)
    return t;
  const s = gs(It), u = t.dirs || (t.dirs = []);
  for (let c = 0; c < r.length; c++) {
    let [d, f, h, _ = ft] = r[c];
    d && (Me(d) && (d = {
      mounted: d,
      updated: d
    }), d.deep && _r(f), u.push({
      dir: d,
      instance: s,
      value: f,
      oldValue: void 0,
      arg: h,
      modifiers: _
    }));
  }
  return t;
}
function mo(t, r, s, u) {
  const c = t.dirs, d = r && r.dirs;
  for (let f = 0; f < c.length; f++) {
    const h = c[f];
    d && (h.oldValue = d[f].value);
    let _ = h.dir[u];
    _ && (Er(), Gn(_, s, 8, [
      t.el,
      h,
      t,
      r
    ]), Nr());
  }
}
const Ol = Symbol("_vte"), ef = (t) => t.__isTeleport, Oi = (t) => t && (t.disabled || t.disabled === ""), nu = (t) => t && (t.defer || t.defer === ""), ru = (t) => typeof SVGElement < "u" && t instanceof SVGElement, ou = (t) => typeof MathMLElement == "function" && t instanceof MathMLElement, fa = (t, r) => {
  const s = t && t.to;
  return Tt(s) ? r ? r(s) : null : s;
}, Tl = {
  name: "Teleport",
  __isTeleport: !0,
  process(t, r, s, u, c, d, f, h, _, k) {
    const {
      mc: D,
      pc: j,
      pbc: B,
      o: { insert: ee, querySelector: re, createText: Q, createComment: W }
    } = k, G = Oi(r.props);
    let { shapeFlag: $, children: q, dynamicChildren: fe } = r;
    if (t == null) {
      const _e = r.el = Q(""), Pe = r.anchor = Q("");
      ee(_e, s, u), ee(Pe, s, u);
      const ue = (F, Xe) => {
        $ & 16 && (c && c.isCE && (c.ce._teleportTarget = F), D(
          q,
          F,
          Xe,
          c,
          d,
          f,
          h,
          _
        ));
      }, de = () => {
        const F = r.target = fa(r.props, re), Xe = El(F, r, Q, ee);
        F && (f !== "svg" && ru(F) ? f = "svg" : f !== "mathml" && ou(F) && (f = "mathml"), G || (ue(F, Xe), Gi(r, !1)));
      };
      G && (ue(s, Pe), Gi(r, !0)), nu(r.props) ? (r.el.__isMounted = !1, an(() => {
        de(), delete r.el.__isMounted;
      }, d)) : de();
    } else {
      if (nu(r.props) && t.el.__isMounted === !1) {
        an(() => {
          Tl.process(
            t,
            r,
            s,
            u,
            c,
            d,
            f,
            h,
            _,
            k
          );
        }, d);
        return;
      }
      r.el = t.el, r.targetStart = t.targetStart;
      const _e = r.anchor = t.anchor, Pe = r.target = t.target, ue = r.targetAnchor = t.targetAnchor, de = Oi(t.props), F = de ? s : Pe, Xe = de ? _e : ue;
      if (f === "svg" || ru(Pe) ? f = "svg" : (f === "mathml" || ou(Pe)) && (f = "mathml"), fe ? (B(
        t.dynamicChildren,
        fe,
        F,
        c,
        d,
        f,
        h
      ), Va(t, r, !0)) : _ || j(
        t,
        r,
        F,
        Xe,
        c,
        d,
        f,
        h,
        !1
      ), G)
        de ? r.props && t.props && r.props.to !== t.props.to && (r.props.to = t.props.to) : Vi(
          r,
          s,
          _e,
          k,
          1
        );
      else if ((r.props && r.props.to) !== (t.props && t.props.to)) {
        const dt = r.target = fa(
          r.props,
          re
        );
        dt && Vi(
          r,
          dt,
          null,
          k,
          0
        );
      } else de && Vi(
        r,
        Pe,
        ue,
        k,
        1
      );
      Gi(r, G);
    }
  },
  remove(t, r, s, { um: u, o: { remove: c } }, d) {
    const {
      shapeFlag: f,
      children: h,
      anchor: _,
      targetStart: k,
      targetAnchor: D,
      target: j,
      props: B
    } = t;
    if (j && (c(k), c(D)), d && c(_), f & 16) {
      const ee = d || !Oi(B);
      for (let re = 0; re < h.length; re++) {
        const Q = h[re];
        u(
          Q,
          r,
          s,
          ee,
          !!Q.dynamicChildren
        );
      }
    }
  },
  move: Vi,
  hydrate: tf
};
function Vi(t, r, s, { o: { insert: u }, m: c }, d = 2) {
  d === 0 && u(t.targetAnchor, r, s);
  const { el: f, anchor: h, shapeFlag: _, children: k, props: D } = t, j = d === 2;
  if (j && u(f, r, s), (!j || Oi(D)) && _ & 16)
    for (let B = 0; B < k.length; B++)
      c(
        k[B],
        r,
        s,
        2
      );
  j && u(h, r, s);
}
function tf(t, r, s, u, c, d, {
  o: { nextSibling: f, parentNode: h, querySelector: _, insert: k, createText: D }
}, j) {
  const B = r.target = fa(
    r.props,
    _
  );
  if (B) {
    const ee = Oi(r.props), re = B._lpa || B.firstChild;
    if (r.shapeFlag & 16)
      if (ee)
        r.anchor = j(
          f(t),
          r,
          h(t),
          s,
          u,
          c,
          d
        ), r.targetStart = re, r.targetAnchor = re && f(re);
      else {
        r.anchor = f(t);
        let Q = re;
        for (; Q; ) {
          if (Q && Q.nodeType === 8) {
            if (Q.data === "teleport start anchor")
              r.targetStart = Q;
            else if (Q.data === "teleport anchor") {
              r.targetAnchor = Q, B._lpa = r.targetAnchor && f(r.targetAnchor);
              break;
            }
          }
          Q = f(Q);
        }
        r.targetAnchor || El(B, r, D, k), j(
          re && f(re),
          r,
          B,
          s,
          u,
          c,
          d
        );
      }
    Gi(r, ee);
  }
  return r.anchor && f(r.anchor);
}
const hs = Tl;
function Gi(t, r) {
  const s = t.ctx;
  if (s && s.ut) {
    let u, c;
    for (r ? (u = t.el, c = t.anchor) : (u = t.targetStart, c = t.targetAnchor); u && u !== c; )
      u.nodeType === 1 && u.setAttribute("data-v-owner", s.uid), u = u.nextSibling;
    s.ut();
  }
}
function El(t, r, s, u) {
  const c = r.targetStart = s(""), d = r.targetAnchor = s("");
  return c[Ol] = d, t && (u(c, t), u(d, t)), d;
}
function Ba(t, r) {
  t.shapeFlag & 6 && t.component ? (t.transition = r, Ba(t.component.subTree, r)) : t.shapeFlag & 128 ? (t.ssContent.transition = r.clone(t.ssContent), t.ssFallback.transition = r.clone(t.ssFallback)) : t.transition = r;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function kt(t, r) {
  return Me(t) ? (
    // #8236: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    Xt({ name: t.name }, r, { setup: t })
  ) : t;
}
function Nl(t) {
  t.ids = [t.ids[0] + t.ids[2]++ + "-", 0, 0];
}
function nf(t) {
  const r = td(), s = bo(null);
  if (r) {
    const c = r.refs === ft ? r.refs = {} : r.refs;
    Object.defineProperty(c, t, {
      enumerable: !0,
      get: () => s.value,
      set: (d) => s.value = d
    });
  }
  return s;
}
function Ti(t, r, s, u, c = !1) {
  if (ke(t)) {
    t.forEach(
      (re, Q) => Ti(
        re,
        r && (ke(r) ? r[Q] : r),
        s,
        u,
        c
      )
    );
    return;
  }
  if (Do(u) && !c) {
    u.shapeFlag & 512 && u.type.__asyncResolved && u.component.subTree.component && Ti(t, r, s, u.component.subTree);
    return;
  }
  const d = u.shapeFlag & 4 ? gs(u.component) : u.el, f = c ? null : d, { i: h, r: _ } = t, k = r && r.r, D = h.refs === ft ? h.refs = {} : h.refs, j = h.setupState, B = et(j), ee = j === ft ? () => !1 : (re) => ut(B, re);
  if (k != null && k !== _ && (Tt(k) ? (D[k] = null, ee(k) && (j[k] = null)) : Ot(k) && (k.value = null)), Me(_))
    Mi(_, h, 12, [f, D]);
  else {
    const re = Tt(_), Q = Ot(_);
    if (re || Q) {
      const W = () => {
        if (t.f) {
          const G = re ? ee(_) ? j[_] : D[_] : _.value;
          c ? ke(G) && Sa(G, d) : ke(G) ? G.includes(d) || G.push(d) : re ? (D[_] = [d], ee(_) && (j[_] = D[_])) : (_.value = [d], t.k && (D[t.k] = _.value));
        } else re ? (D[_] = f, ee(_) && (j[_] = f)) : Q && (_.value = f, t.k && (D[t.k] = f));
      };
      f ? (W.id = -1, an(W, s)) : W();
    }
  }
}
cs().requestIdleCallback;
cs().cancelIdleCallback;
const Do = (t) => !!t.type.__asyncLoader, Cl = (t) => t.type.__isKeepAlive;
function rf(t, r) {
  Sl(t, "a", r);
}
function of(t, r) {
  Sl(t, "da", r);
}
function Sl(t, r, s = Kt) {
  const u = t.__wdc || (t.__wdc = () => {
    let c = s;
    for (; c; ) {
      if (c.isDeactivated)
        return;
      c = c.parent;
    }
    return t();
  });
  if (ms(r, u, s), s) {
    let c = s.parent;
    for (; c && c.parent; )
      Cl(c.parent.vnode) && sf(u, r, s, c), c = c.parent;
  }
}
function sf(t, r, s, u) {
  const c = ms(
    r,
    t,
    u,
    !0
    /* prepend */
  );
  $a(() => {
    Sa(u[r], c);
  }, s);
}
function ms(t, r, s = Kt, u = !1) {
  if (s) {
    const c = s[t] || (s[t] = []), d = r.__weh || (r.__weh = (...f) => {
      Er();
      const h = Bi(s), _ = Gn(r, s, t, f);
      return h(), Nr(), _;
    });
    return u ? c.unshift(d) : c.push(d), d;
  }
}
const Sr = (t) => (r, s = Kt) => {
  (!Ii || t === "sp") && ms(t, (...u) => r(...u), s);
}, af = Sr("bm"), Ko = Sr("m"), uf = Sr(
  "bu"
), lf = Sr("u"), cf = Sr(
  "bum"
), $a = Sr("um"), ff = Sr(
  "sp"
), df = Sr("rtg"), pf = Sr("rtc");
function hf(t, r = Kt) {
  ms("ec", t, r);
}
const mf = "components", Al = Symbol.for("v-ndc");
function yf(t) {
  return Tt(t) ? vf(mf, t, !1) || t : t || Al;
}
function vf(t, r, s = !0, u = !1) {
  const c = It || Kt;
  if (c) {
    const d = c.type;
    {
      const h = sd(
        d,
        !1
      );
      if (h && (h === r || h === Sn(r) || h === ls(Sn(r))))
        return d;
    }
    const f = (
      // local registration
      // check instance[type] first which is resolved for options API
      iu(c[t] || d[t], r) || // global registration
      iu(c.appContext[t], r)
    );
    return !f && u ? d : f;
  }
}
function iu(t, r) {
  return t && (t[r] || t[Sn(r)] || t[ls(Sn(r))]);
}
function At(t, r, s, u) {
  let c;
  const d = s, f = ke(t);
  if (f || Tt(t)) {
    const h = f && Or(t);
    let _ = !1, k = !1;
    h && (_ = !Nn(t), k = kr(t), t = fs(t)), c = new Array(t.length);
    for (let D = 0, j = t.length; D < j; D++)
      c[D] = r(
        _ ? k ? es(Wt(t[D])) : Wt(t[D]) : t[D],
        D,
        void 0,
        d
      );
  } else if (typeof t == "number") {
    c = new Array(t);
    for (let h = 0; h < t; h++)
      c[h] = r(h + 1, h, void 0, d);
  } else if (gt(t))
    if (t[Symbol.iterator])
      c = Array.from(
        t,
        (h, _) => r(h, _, void 0, d)
      );
    else {
      const h = Object.keys(t);
      c = new Array(h.length);
      for (let _ = 0, k = h.length; _ < k; _++) {
        const D = h[_];
        c[_] = r(t[D], D, _, d);
      }
    }
  else
    c = [];
  return c;
}
function su(t, r, s = {}, u, c) {
  if (It.ce || It.parent && Do(It.parent) && It.parent.ce)
    return r !== "default" && (s.name = r), ce(), On(
      Qe,
      null,
      [_t("slot", s, u)],
      64
    );
  let d = t[r];
  d && d._c && (d._d = !1), ce();
  const f = d && Rl(d(s)), h = s.key || // slot content array of a dynamic conditional slot may have a branch
  // key attached in the `createSlots` helper, respect that
  f && f.key, _ = On(
    Qe,
    {
      key: (h && !Mn(h) ? h : `_${r}`) + // #7256 force differentiate fallback content from actual content
      (!f && u ? "_fb" : "")
    },
    f || [],
    f && t._ === 1 ? 64 : -2
  );
  return d && d._c && (d._d = !0), _;
}
function Rl(t) {
  return t.some((r) => Ha(r) ? !(r.type === Cr || r.type === Qe && !Rl(r.children)) : !0) ? t : null;
}
const da = (t) => t ? Xl(t) ? gs(t) : da(t.parent) : null, Ei = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Xt(/* @__PURE__ */ Object.create(null), {
    $: (t) => t,
    $el: (t) => t.vnode.el,
    $data: (t) => t.data,
    $props: (t) => t.props,
    $attrs: (t) => t.attrs,
    $slots: (t) => t.slots,
    $refs: (t) => t.refs,
    $parent: (t) => da(t.parent),
    $root: (t) => da(t.root),
    $host: (t) => t.ce,
    $emit: (t) => t.emit,
    $options: (t) => Pl(t),
    $forceUpdate: (t) => t.f || (t.f = () => {
      Ma(t.update);
    }),
    $nextTick: (t) => t.n || (t.n = Ka.bind(t.proxy)),
    $watch: (t) => $f.bind(t)
  })
), zs = (t, r) => t !== ft && !t.__isScriptSetup && ut(t, r), gf = {
  get({ _: t }, r) {
    if (r === "__v_skip")
      return !0;
    const { ctx: s, setupState: u, data: c, props: d, accessCache: f, type: h, appContext: _ } = t;
    let k;
    if (r[0] !== "$") {
      const ee = f[r];
      if (ee !== void 0)
        switch (ee) {
          case 1:
            return u[r];
          case 2:
            return c[r];
          case 4:
            return s[r];
          case 3:
            return d[r];
        }
      else {
        if (zs(u, r))
          return f[r] = 1, u[r];
        if (c !== ft && ut(c, r))
          return f[r] = 2, c[r];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (k = t.propsOptions[0]) && ut(k, r)
        )
          return f[r] = 3, d[r];
        if (s !== ft && ut(s, r))
          return f[r] = 4, s[r];
        pa && (f[r] = 0);
      }
    }
    const D = Ei[r];
    let j, B;
    if (D)
      return r === "$attrs" && Yt(t.attrs, "get", ""), D(t);
    if (
      // css module (injected by vue-loader)
      (j = h.__cssModules) && (j = j[r])
    )
      return j;
    if (s !== ft && ut(s, r))
      return f[r] = 4, s[r];
    if (
      // global properties
      B = _.config.globalProperties, ut(B, r)
    )
      return B[r];
  },
  set({ _: t }, r, s) {
    const { data: u, setupState: c, ctx: d } = t;
    return zs(c, r) ? (c[r] = s, !0) : u !== ft && ut(u, r) ? (u[r] = s, !0) : ut(t.props, r) || r[0] === "$" && r.slice(1) in t ? !1 : (d[r] = s, !0);
  },
  has({
    _: { data: t, setupState: r, accessCache: s, ctx: u, appContext: c, propsOptions: d }
  }, f) {
    let h;
    return !!s[f] || t !== ft && ut(t, f) || zs(r, f) || (h = d[0]) && ut(h, f) || ut(u, f) || ut(Ei, f) || ut(c.config.globalProperties, f);
  },
  defineProperty(t, r, s) {
    return s.get != null ? t._.accessCache[r] = 0 : ut(s, "value") && this.set(t, r, s.value, null), Reflect.defineProperty(t, r, s);
  }
};
function au(t) {
  return ke(t) ? t.reduce(
    (r, s) => (r[s] = null, r),
    {}
  ) : t;
}
let pa = !0;
function bf(t) {
  const r = Pl(t), s = t.proxy, u = t.ctx;
  pa = !1, r.beforeCreate && uu(r.beforeCreate, t, "bc");
  const {
    // state
    data: c,
    computed: d,
    methods: f,
    watch: h,
    provide: _,
    inject: k,
    // lifecycle
    created: D,
    beforeMount: j,
    mounted: B,
    beforeUpdate: ee,
    updated: re,
    activated: Q,
    deactivated: W,
    beforeDestroy: G,
    beforeUnmount: $,
    destroyed: q,
    unmounted: fe,
    render: _e,
    renderTracked: Pe,
    renderTriggered: ue,
    errorCaptured: de,
    serverPrefetch: F,
    // public API
    expose: Xe,
    inheritAttrs: dt,
    // assets
    components: Be,
    directives: at,
    filters: Tn
  } = r;
  if (k && wf(k, u, null), f)
    for (const Ee in f) {
      const Ke = f[Ee];
      Me(Ke) && (u[Ee] = Ke.bind(s));
    }
  if (c) {
    const Ee = c.call(s, s);
    gt(Ee) && (t.data = Ki(Ee));
  }
  if (pa = !0, d)
    for (const Ee in d) {
      const Ke = d[Ee], bt = Me(Ke) ? Ke.bind(s, s) : Me(Ke.get) ? Ke.get.bind(s, s) : Hn, ct = !Me(Ke) && Me(Ke.set) ? Ke.set.bind(s) : Hn, xt = tt({
        get: bt,
        set: ct
      });
      Object.defineProperty(u, Ee, {
        enumerable: !0,
        configurable: !0,
        get: () => xt.value,
        set: (Lt) => xt.value = Lt
      });
    }
  if (h)
    for (const Ee in h)
      Dl(h[Ee], u, s, Ee);
  if (_) {
    const Ee = Me(_) ? _.call(s) : _;
    Reflect.ownKeys(Ee).forEach((Ke) => {
      Nf(Ke, Ee[Ke]);
    });
  }
  D && uu(D, t, "c");
  function rt(Ee, Ke) {
    ke(Ke) ? Ke.forEach((bt) => Ee(bt.bind(s))) : Ke && Ee(Ke.bind(s));
  }
  if (rt(af, j), rt(Ko, B), rt(uf, ee), rt(lf, re), rt(rf, Q), rt(of, W), rt(hf, de), rt(pf, Pe), rt(df, ue), rt(cf, $), rt($a, fe), rt(ff, F), ke(Xe))
    if (Xe.length) {
      const Ee = t.exposed || (t.exposed = {});
      Xe.forEach((Ke) => {
        Object.defineProperty(Ee, Ke, {
          get: () => s[Ke],
          set: (bt) => s[Ke] = bt
        });
      });
    } else t.exposed || (t.exposed = {});
  _e && t.render === Hn && (t.render = _e), dt != null && (t.inheritAttrs = dt), Be && (t.components = Be), at && (t.directives = at), F && Nl(t);
}
function wf(t, r, s = Hn) {
  ke(t) && (t = ha(t));
  for (const u in t) {
    const c = t[u];
    let d;
    gt(c) ? "default" in c ? d = Ni(
      c.from || u,
      c.default,
      !0
    ) : d = Ni(c.from || u) : d = Ni(c), Ot(d) ? Object.defineProperty(r, u, {
      enumerable: !0,
      configurable: !0,
      get: () => d.value,
      set: (f) => d.value = f
    }) : r[u] = d;
  }
}
function uu(t, r, s) {
  Gn(
    ke(t) ? t.map((u) => u.bind(r.proxy)) : t.bind(r.proxy),
    r,
    s
  );
}
function Dl(t, r, s, u) {
  let c = u.includes(".") ? Ul(s, u) : () => s[u];
  if (Tt(t)) {
    const d = r[t];
    Me(d) && xn(c, d);
  } else if (Me(t))
    xn(c, t.bind(s));
  else if (gt(t))
    if (ke(t))
      t.forEach((d) => Dl(d, r, s, u));
    else {
      const d = Me(t.handler) ? t.handler.bind(s) : r[t.handler];
      Me(d) && xn(c, d, t);
    }
}
function Pl(t) {
  const r = t.type, { mixins: s, extends: u } = r, {
    mixins: c,
    optionsCache: d,
    config: { optionMergeStrategies: f }
  } = t.appContext, h = d.get(r);
  let _;
  return h ? _ = h : !c.length && !s && !u ? _ = r : (_ = {}, c.length && c.forEach(
    (k) => os(_, k, f, !0)
  ), os(_, r, f)), gt(r) && d.set(r, _), _;
}
function os(t, r, s, u = !1) {
  const { mixins: c, extends: d } = r;
  d && os(t, d, s, !0), c && c.forEach(
    (f) => os(t, f, s, !0)
  );
  for (const f in r)
    if (!(u && f === "expose")) {
      const h = _f[f] || s && s[f];
      t[f] = h ? h(t[f], r[f]) : r[f];
    }
  return t;
}
const _f = {
  data: lu,
  props: cu,
  emits: cu,
  // objects
  methods: bi,
  computed: bi,
  // lifecycle
  beforeCreate: sn,
  created: sn,
  beforeMount: sn,
  mounted: sn,
  beforeUpdate: sn,
  updated: sn,
  beforeDestroy: sn,
  beforeUnmount: sn,
  destroyed: sn,
  unmounted: sn,
  activated: sn,
  deactivated: sn,
  errorCaptured: sn,
  serverPrefetch: sn,
  // assets
  components: bi,
  directives: bi,
  // watch
  watch: Of,
  // provide / inject
  provide: lu,
  inject: xf
};
function lu(t, r) {
  return r ? t ? function() {
    return Xt(
      Me(t) ? t.call(this, this) : t,
      Me(r) ? r.call(this, this) : r
    );
  } : r : t;
}
function xf(t, r) {
  return bi(ha(t), ha(r));
}
function ha(t) {
  if (ke(t)) {
    const r = {};
    for (let s = 0; s < t.length; s++)
      r[t[s]] = t[s];
    return r;
  }
  return t;
}
function sn(t, r) {
  return t ? [...new Set([].concat(t, r))] : r;
}
function bi(t, r) {
  return t ? Xt(/* @__PURE__ */ Object.create(null), t, r) : r;
}
function cu(t, r) {
  return t ? ke(t) && ke(r) ? [.../* @__PURE__ */ new Set([...t, ...r])] : Xt(
    /* @__PURE__ */ Object.create(null),
    au(t),
    au(r ?? {})
  ) : r;
}
function Of(t, r) {
  if (!t) return r;
  if (!r) return t;
  const s = Xt(/* @__PURE__ */ Object.create(null), t);
  for (const u in r)
    s[u] = sn(t[u], r[u]);
  return s;
}
function Il() {
  return {
    app: null,
    config: {
      isNativeTag: ac,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Tf = 0;
function Ef(t, r) {
  return function(u, c = null) {
    Me(u) || (u = Xt({}, u)), c != null && !gt(c) && (c = null);
    const d = Il(), f = /* @__PURE__ */ new WeakSet(), h = [];
    let _ = !1;
    const k = d.app = {
      _uid: Tf++,
      _component: u,
      _props: c,
      _container: null,
      _context: d,
      _instance: null,
      version: ud,
      get config() {
        return d.config;
      },
      set config(D) {
      },
      use(D, ...j) {
        return f.has(D) || (D && Me(D.install) ? (f.add(D), D.install(k, ...j)) : Me(D) && (f.add(D), D(k, ...j))), k;
      },
      mixin(D) {
        return d.mixins.includes(D) || d.mixins.push(D), k;
      },
      component(D, j) {
        return j ? (d.components[D] = j, k) : d.components[D];
      },
      directive(D, j) {
        return j ? (d.directives[D] = j, k) : d.directives[D];
      },
      mount(D, j, B) {
        if (!_) {
          const ee = k._ceVNode || _t(u, c);
          return ee.appContext = d, B === !0 ? B = "svg" : B === !1 && (B = void 0), t(ee, D, B), _ = !0, k._container = D, D.__vue_app__ = k, gs(ee.component);
        }
      },
      onUnmount(D) {
        h.push(D);
      },
      unmount() {
        _ && (Gn(
          h,
          k._instance,
          16
        ), t(null, k._container), delete k._container.__vue_app__);
      },
      provide(D, j) {
        return d.provides[D] = j, k;
      },
      runWithContext(D) {
        const j = wo;
        wo = k;
        try {
          return D();
        } finally {
          wo = j;
        }
      }
    };
    return k;
  };
}
let wo = null;
function Nf(t, r) {
  if (Kt) {
    let s = Kt.provides;
    const u = Kt.parent && Kt.parent.provides;
    u === s && (s = Kt.provides = Object.create(u)), s[t] = r;
  }
}
function Ni(t, r, s = !1) {
  const u = Kt || It;
  if (u || wo) {
    let c = wo ? wo._context.provides : u ? u.parent == null || u.ce ? u.vnode.appContext && u.vnode.appContext.provides : u.parent.provides : void 0;
    if (c && t in c)
      return c[t];
    if (arguments.length > 1)
      return s && Me(r) ? r.call(u && u.proxy) : r;
  }
}
function Cf() {
  return !!(Kt || It || wo);
}
const kl = {}, jl = () => Object.create(kl), Ll = (t) => Object.getPrototypeOf(t) === kl;
function Sf(t, r, s, u = !1) {
  const c = {}, d = jl();
  t.propsDefaults = /* @__PURE__ */ Object.create(null), Fl(t, r, c, d);
  for (const f in t.propsOptions[0])
    f in c || (c[f] = void 0);
  s ? t.props = u ? c : Bc(c) : t.type.props ? t.props = c : t.props = d, t.attrs = d;
}
function Af(t, r, s, u) {
  const {
    props: c,
    attrs: d,
    vnode: { patchFlag: f }
  } = t, h = et(c), [_] = t.propsOptions;
  let k = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (u || f > 0) && !(f & 16)
  ) {
    if (f & 8) {
      const D = t.vnode.dynamicProps;
      for (let j = 0; j < D.length; j++) {
        let B = D[j];
        if (ys(t.emitsOptions, B))
          continue;
        const ee = r[B];
        if (_)
          if (ut(d, B))
            ee !== d[B] && (d[B] = ee, k = !0);
          else {
            const re = Sn(B);
            c[re] = ma(
              _,
              h,
              re,
              ee,
              t,
              !1
            );
          }
        else
          ee !== d[B] && (d[B] = ee, k = !0);
      }
    }
  } else {
    Fl(t, r, c, d) && (k = !0);
    let D;
    for (const j in h)
      (!r || // for camelCase
      !ut(r, j) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((D = Oo(j)) === j || !ut(r, D))) && (_ ? s && // for camelCase
      (s[j] !== void 0 || // for kebab-case
      s[D] !== void 0) && (c[j] = ma(
        _,
        h,
        j,
        void 0,
        t,
        !0
      )) : delete c[j]);
    if (d !== h)
      for (const j in d)
        (!r || !ut(r, j)) && (delete d[j], k = !0);
  }
  k && wr(t.attrs, "set", "");
}
function Fl(t, r, s, u) {
  const [c, d] = t.propsOptions;
  let f = !1, h;
  if (r)
    for (let _ in r) {
      if (wi(_))
        continue;
      const k = r[_];
      let D;
      c && ut(c, D = Sn(_)) ? !d || !d.includes(D) ? s[D] = k : (h || (h = {}))[D] = k : ys(t.emitsOptions, _) || (!(_ in u) || k !== u[_]) && (u[_] = k, f = !0);
    }
  if (d) {
    const _ = et(s), k = h || ft;
    for (let D = 0; D < d.length; D++) {
      const j = d[D];
      s[j] = ma(
        c,
        _,
        j,
        k[j],
        t,
        !ut(k, j)
      );
    }
  }
  return f;
}
function ma(t, r, s, u, c, d) {
  const f = t[s];
  if (f != null) {
    const h = ut(f, "default");
    if (h && u === void 0) {
      const _ = f.default;
      if (f.type !== Function && !f.skipFactory && Me(_)) {
        const { propsDefaults: k } = c;
        if (s in k)
          u = k[s];
        else {
          const D = Bi(c);
          u = k[s] = _.call(
            null,
            r
          ), D();
        }
      } else
        u = _;
      c.ce && c.ce._setProp(s, u);
    }
    f[
      0
      /* shouldCast */
    ] && (d && !h ? u = !1 : f[
      1
      /* shouldCastTrue */
    ] && (u === "" || u === Oo(s)) && (u = !0));
  }
  return u;
}
const Rf = /* @__PURE__ */ new WeakMap();
function Kl(t, r, s = !1) {
  const u = s ? Rf : r.propsCache, c = u.get(t);
  if (c)
    return c;
  const d = t.props, f = {}, h = [];
  let _ = !1;
  if (!Me(t)) {
    const D = (j) => {
      _ = !0;
      const [B, ee] = Kl(j, r, !0);
      Xt(f, B), ee && h.push(...ee);
    };
    !s && r.mixins.length && r.mixins.forEach(D), t.extends && D(t.extends), t.mixins && t.mixins.forEach(D);
  }
  if (!d && !_)
    return gt(t) && u.set(t, So), So;
  if (ke(d))
    for (let D = 0; D < d.length; D++) {
      const j = Sn(d[D]);
      fu(j) && (f[j] = ft);
    }
  else if (d)
    for (const D in d) {
      const j = Sn(D);
      if (fu(j)) {
        const B = d[D], ee = f[j] = ke(B) || Me(B) ? { type: B } : Xt({}, B), re = ee.type;
        let Q = !1, W = !0;
        if (ke(re))
          for (let G = 0; G < re.length; ++G) {
            const $ = re[G], q = Me($) && $.name;
            if (q === "Boolean") {
              Q = !0;
              break;
            } else q === "String" && (W = !1);
          }
        else
          Q = Me(re) && re.name === "Boolean";
        ee[
          0
          /* shouldCast */
        ] = Q, ee[
          1
          /* shouldCastTrue */
        ] = W, (Q || ut(ee, "default")) && h.push(j);
      }
    }
  const k = [f, h];
  return gt(t) && u.set(t, k), k;
}
function fu(t) {
  return t[0] !== "$" && !wi(t);
}
const qa = (t) => t[0] === "_" || t === "$stable", Ua = (t) => ke(t) ? t.map(Vn) : [Vn(t)], Df = (t, r, s) => {
  if (r._n)
    return r;
  const u = ca((...c) => Ua(r(...c)), s);
  return u._c = !1, u;
}, Ml = (t, r, s) => {
  const u = t._ctx;
  for (const c in t) {
    if (qa(c)) continue;
    const d = t[c];
    if (Me(d))
      r[c] = Df(c, d, u);
    else if (d != null) {
      const f = Ua(d);
      r[c] = () => f;
    }
  }
}, Bl = (t, r) => {
  const s = Ua(r);
  t.slots.default = () => s;
}, $l = (t, r, s) => {
  for (const u in r)
    (s || !qa(u)) && (t[u] = r[u]);
}, Pf = (t, r, s) => {
  const u = t.slots = jl();
  if (t.vnode.shapeFlag & 32) {
    const c = r.__;
    c && sa(u, "__", c, !0);
    const d = r._;
    d ? ($l(u, r, s), s && sa(u, "_", d, !0)) : Ml(r, u);
  } else r && Bl(t, r);
}, If = (t, r, s) => {
  const { vnode: u, slots: c } = t;
  let d = !0, f = ft;
  if (u.shapeFlag & 32) {
    const h = r._;
    h ? s && h === 1 ? d = !1 : $l(c, r, s) : (d = !r.$stable, Ml(r, c)), f = r;
  } else r && (Bl(t, r), f = { default: 1 });
  if (d)
    for (const h in c)
      !qa(h) && f[h] == null && delete c[h];
}, an = Yf;
function kf(t) {
  return jf(t);
}
function jf(t, r) {
  const s = cs();
  s.__VUE__ = !0;
  const {
    insert: u,
    remove: c,
    patchProp: d,
    createElement: f,
    createText: h,
    createComment: _,
    setText: k,
    setElementText: D,
    parentNode: j,
    nextSibling: B,
    setScopeId: ee = Hn,
    insertStaticContent: re
  } = t, Q = (S, M, ne, ie = null, le = null, se = null, ve = void 0, be = null, pe = !!M.dynamicChildren) => {
    if (S === M)
      return;
    S && !gi(S, M) && (ie = A(S), Lt(S, le, se, !0), S = null), M.patchFlag === -2 && (pe = !1, M.dynamicChildren = null);
    const { type: ae, ref: Ce, shapeFlag: we } = M;
    switch (ae) {
      case vs:
        W(S, M, ne, ie);
        break;
      case Cr:
        G(S, M, ne, ie);
        break;
      case Zs:
        S == null && $(M, ne, ie, ve);
        break;
      case Qe:
        Be(
          S,
          M,
          ne,
          ie,
          le,
          se,
          ve,
          be,
          pe
        );
        break;
      default:
        we & 1 ? _e(
          S,
          M,
          ne,
          ie,
          le,
          se,
          ve,
          be,
          pe
        ) : we & 6 ? at(
          S,
          M,
          ne,
          ie,
          le,
          se,
          ve,
          be,
          pe
        ) : (we & 64 || we & 128) && ae.process(
          S,
          M,
          ne,
          ie,
          le,
          se,
          ve,
          be,
          pe,
          H
        );
    }
    Ce != null && le ? Ti(Ce, S && S.ref, se, M || S, !M) : Ce == null && S && S.ref != null && Ti(S.ref, null, se, S, !0);
  }, W = (S, M, ne, ie) => {
    if (S == null)
      u(
        M.el = h(M.children),
        ne,
        ie
      );
    else {
      const le = M.el = S.el;
      M.children !== S.children && k(le, M.children);
    }
  }, G = (S, M, ne, ie) => {
    S == null ? u(
      M.el = _(M.children || ""),
      ne,
      ie
    ) : M.el = S.el;
  }, $ = (S, M, ne, ie) => {
    [S.el, S.anchor] = re(
      S.children,
      M,
      ne,
      ie,
      S.el,
      S.anchor
    );
  }, q = ({ el: S, anchor: M }, ne, ie) => {
    let le;
    for (; S && S !== M; )
      le = B(S), u(S, ne, ie), S = le;
    u(M, ne, ie);
  }, fe = ({ el: S, anchor: M }) => {
    let ne;
    for (; S && S !== M; )
      ne = B(S), c(S), S = ne;
    c(M);
  }, _e = (S, M, ne, ie, le, se, ve, be, pe) => {
    M.type === "svg" ? ve = "svg" : M.type === "math" && (ve = "mathml"), S == null ? Pe(
      M,
      ne,
      ie,
      le,
      se,
      ve,
      be,
      pe
    ) : F(
      S,
      M,
      le,
      se,
      ve,
      be,
      pe
    );
  }, Pe = (S, M, ne, ie, le, se, ve, be) => {
    let pe, ae;
    const { props: Ce, shapeFlag: we, transition: Se, dirs: Re } = S;
    if (pe = S.el = f(
      S.type,
      se,
      Ce && Ce.is,
      Ce
    ), we & 8 ? D(pe, S.children) : we & 16 && de(
      S.children,
      pe,
      null,
      ie,
      le,
      Js(S, se),
      ve,
      be
    ), Re && mo(S, null, ie, "created"), ue(pe, S, S.scopeId, ve, ie), Ce) {
      for (const Ue in Ce)
        Ue !== "value" && !wi(Ue) && d(pe, Ue, null, Ce[Ue], se, ie);
      "value" in Ce && d(pe, "value", null, Ce.value, se), (ae = Ce.onVnodeBeforeMount) && qn(ae, ie, S);
    }
    Re && mo(S, null, ie, "beforeMount");
    const je = Lf(le, Se);
    je && Se.beforeEnter(pe), u(pe, M, ne), ((ae = Ce && Ce.onVnodeMounted) || je || Re) && an(() => {
      ae && qn(ae, ie, S), je && Se.enter(pe), Re && mo(S, null, ie, "mounted");
    }, le);
  }, ue = (S, M, ne, ie, le) => {
    if (ne && ee(S, ne), ie)
      for (let se = 0; se < ie.length; se++)
        ee(S, ie[se]);
    if (le) {
      let se = le.subTree;
      if (M === se || Wl(se.type) && (se.ssContent === M || se.ssFallback === M)) {
        const ve = le.vnode;
        ue(
          S,
          ve,
          ve.scopeId,
          ve.slotScopeIds,
          le.parent
        );
      }
    }
  }, de = (S, M, ne, ie, le, se, ve, be, pe = 0) => {
    for (let ae = pe; ae < S.length; ae++) {
      const Ce = S[ae] = be ? Dr(S[ae]) : Vn(S[ae]);
      Q(
        null,
        Ce,
        M,
        ne,
        ie,
        le,
        se,
        ve,
        be
      );
    }
  }, F = (S, M, ne, ie, le, se, ve) => {
    const be = M.el = S.el;
    let { patchFlag: pe, dynamicChildren: ae, dirs: Ce } = M;
    pe |= S.patchFlag & 16;
    const we = S.props || ft, Se = M.props || ft;
    let Re;
    if (ne && yo(ne, !1), (Re = Se.onVnodeBeforeUpdate) && qn(Re, ne, M, S), Ce && mo(M, S, ne, "beforeUpdate"), ne && yo(ne, !0), (we.innerHTML && Se.innerHTML == null || we.textContent && Se.textContent == null) && D(be, ""), ae ? Xe(
      S.dynamicChildren,
      ae,
      be,
      ne,
      ie,
      Js(M, le),
      se
    ) : ve || Ke(
      S,
      M,
      be,
      null,
      ne,
      ie,
      Js(M, le),
      se,
      !1
    ), pe > 0) {
      if (pe & 16)
        dt(be, we, Se, ne, le);
      else if (pe & 2 && we.class !== Se.class && d(be, "class", null, Se.class, le), pe & 4 && d(be, "style", we.style, Se.style, le), pe & 8) {
        const je = M.dynamicProps;
        for (let Ue = 0; Ue < je.length; Ue++) {
          const He = je[Ue], ht = we[He], Et = Se[He];
          (Et !== ht || He === "value") && d(be, He, ht, Et, le, ne);
        }
      }
      pe & 1 && S.children !== M.children && D(be, M.children);
    } else !ve && ae == null && dt(be, we, Se, ne, le);
    ((Re = Se.onVnodeUpdated) || Ce) && an(() => {
      Re && qn(Re, ne, M, S), Ce && mo(M, S, ne, "updated");
    }, ie);
  }, Xe = (S, M, ne, ie, le, se, ve) => {
    for (let be = 0; be < M.length; be++) {
      const pe = S[be], ae = M[be], Ce = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        pe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (pe.type === Qe || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !gi(pe, ae) || // - In the case of a component, it could contain anything.
        pe.shapeFlag & 198) ? j(pe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          ne
        )
      );
      Q(
        pe,
        ae,
        Ce,
        null,
        ie,
        le,
        se,
        ve,
        !0
      );
    }
  }, dt = (S, M, ne, ie, le) => {
    if (M !== ne) {
      if (M !== ft)
        for (const se in M)
          !wi(se) && !(se in ne) && d(
            S,
            se,
            M[se],
            null,
            le,
            ie
          );
      for (const se in ne) {
        if (wi(se)) continue;
        const ve = ne[se], be = M[se];
        ve !== be && se !== "value" && d(S, se, be, ve, le, ie);
      }
      "value" in ne && d(S, "value", M.value, ne.value, le);
    }
  }, Be = (S, M, ne, ie, le, se, ve, be, pe) => {
    const ae = M.el = S ? S.el : h(""), Ce = M.anchor = S ? S.anchor : h("");
    let { patchFlag: we, dynamicChildren: Se, slotScopeIds: Re } = M;
    Re && (be = be ? be.concat(Re) : Re), S == null ? (u(ae, ne, ie), u(Ce, ne, ie), de(
      // #10007
      // such fragment like `<></>` will be compiled into
      // a fragment which doesn't have a children.
      // In this case fallback to an empty array
      M.children || [],
      ne,
      Ce,
      le,
      se,
      ve,
      be,
      pe
    )) : we > 0 && we & 64 && Se && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    S.dynamicChildren ? (Xe(
      S.dynamicChildren,
      Se,
      ne,
      le,
      se,
      ve,
      be
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (M.key != null || le && M === le.subTree) && Va(
      S,
      M,
      !0
      /* shallow */
    )) : Ke(
      S,
      M,
      ne,
      Ce,
      le,
      se,
      ve,
      be,
      pe
    );
  }, at = (S, M, ne, ie, le, se, ve, be, pe) => {
    M.slotScopeIds = be, S == null ? M.shapeFlag & 512 ? le.ctx.activate(
      M,
      ne,
      ie,
      ve,
      pe
    ) : Tn(
      M,
      ne,
      ie,
      le,
      se,
      ve,
      pe
    ) : jt(S, M, pe);
  }, Tn = (S, M, ne, ie, le, se, ve) => {
    const be = S.component = ed(
      S,
      ie,
      le
    );
    if (Cl(S) && (be.ctx.renderer = H), nd(be, !1, ve), be.asyncDep) {
      if (le && le.registerDep(be, rt, ve), !S.el) {
        const pe = be.subTree = _t(Cr);
        G(null, pe, M, ne);
      }
    } else
      rt(
        be,
        S,
        M,
        ne,
        le,
        se,
        ve
      );
  }, jt = (S, M, ne) => {
    const ie = M.component = S.component;
    if (Hf(S, M, ne))
      if (ie.asyncDep && !ie.asyncResolved) {
        Ee(ie, M, ne);
        return;
      } else
        ie.next = M, ie.update();
    else
      M.el = S.el, ie.vnode = M;
  }, rt = (S, M, ne, ie, le, se, ve) => {
    const be = () => {
      if (S.isMounted) {
        let { next: we, bu: Se, u: Re, parent: je, vnode: Ue } = S;
        {
          const mt = ql(S);
          if (mt) {
            we && (we.el = Ue.el, Ee(S, we, ve)), mt.asyncDep.then(() => {
              S.isUnmounted || be();
            });
            return;
          }
        }
        let He = we, ht;
        yo(S, !1), we ? (we.el = Ue.el, Ee(S, we, ve)) : we = Ue, Se && Hi(Se), (ht = we.props && we.props.onVnodeBeforeUpdate) && qn(ht, je, we, Ue), yo(S, !0);
        const Et = pu(S), Rt = S.subTree;
        S.subTree = Et, Q(
          Rt,
          Et,
          // parent may have changed if it's in a teleport
          j(Rt.el),
          // anchor may have changed if it's in a fragment
          A(Rt),
          S,
          le,
          se
        ), we.el = Et.el, He === null && Gf(S, Et.el), Re && an(Re, le), (ht = we.props && we.props.onVnodeUpdated) && an(
          () => qn(ht, je, we, Ue),
          le
        );
      } else {
        let we;
        const { el: Se, props: Re } = M, { bm: je, m: Ue, parent: He, root: ht, type: Et } = S, Rt = Do(M);
        yo(S, !1), je && Hi(je), !Rt && (we = Re && Re.onVnodeBeforeMount) && qn(we, He, M), yo(S, !0);
        {
          ht.ce && // @ts-expect-error _def is private
          ht.ce._def.shadowRoot !== !1 && ht.ce._injectChildStyle(Et);
          const mt = S.subTree = pu(S);
          Q(
            null,
            mt,
            ne,
            ie,
            S,
            le,
            se
          ), M.el = mt.el;
        }
        if (Ue && an(Ue, le), !Rt && (we = Re && Re.onVnodeMounted)) {
          const mt = M;
          an(
            () => qn(we, He, mt),
            le
          );
        }
        (M.shapeFlag & 256 || He && Do(He.vnode) && He.vnode.shapeFlag & 256) && S.a && an(S.a, le), S.isMounted = !0, M = ne = ie = null;
      }
    };
    S.scope.on();
    const pe = S.effect = new el(be);
    S.scope.off();
    const ae = S.update = pe.run.bind(pe), Ce = S.job = pe.runIfDirty.bind(pe);
    Ce.i = S, Ce.id = S.uid, pe.scheduler = () => Ma(Ce), yo(S, !0), ae();
  }, Ee = (S, M, ne) => {
    M.component = S;
    const ie = S.vnode.props;
    S.vnode = M, S.next = null, Af(S, M.props, ie, ne), If(S, M.children, ne), Er(), tu(S), Nr();
  }, Ke = (S, M, ne, ie, le, se, ve, be, pe = !1) => {
    const ae = S && S.children, Ce = S ? S.shapeFlag : 0, we = M.children, { patchFlag: Se, shapeFlag: Re } = M;
    if (Se > 0) {
      if (Se & 128) {
        ct(
          ae,
          we,
          ne,
          ie,
          le,
          se,
          ve,
          be,
          pe
        );
        return;
      } else if (Se & 256) {
        bt(
          ae,
          we,
          ne,
          ie,
          le,
          se,
          ve,
          be,
          pe
        );
        return;
      }
    }
    Re & 8 ? (Ce & 16 && Nt(ae, le, se), we !== ae && D(ne, we)) : Ce & 16 ? Re & 16 ? ct(
      ae,
      we,
      ne,
      ie,
      le,
      se,
      ve,
      be,
      pe
    ) : Nt(ae, le, se, !0) : (Ce & 8 && D(ne, ""), Re & 16 && de(
      we,
      ne,
      ie,
      le,
      se,
      ve,
      be,
      pe
    ));
  }, bt = (S, M, ne, ie, le, se, ve, be, pe) => {
    S = S || So, M = M || So;
    const ae = S.length, Ce = M.length, we = Math.min(ae, Ce);
    let Se;
    for (Se = 0; Se < we; Se++) {
      const Re = M[Se] = pe ? Dr(M[Se]) : Vn(M[Se]);
      Q(
        S[Se],
        Re,
        ne,
        null,
        le,
        se,
        ve,
        be,
        pe
      );
    }
    ae > Ce ? Nt(
      S,
      le,
      se,
      !0,
      !1,
      we
    ) : de(
      M,
      ne,
      ie,
      le,
      se,
      ve,
      be,
      pe,
      we
    );
  }, ct = (S, M, ne, ie, le, se, ve, be, pe) => {
    let ae = 0;
    const Ce = M.length;
    let we = S.length - 1, Se = Ce - 1;
    for (; ae <= we && ae <= Se; ) {
      const Re = S[ae], je = M[ae] = pe ? Dr(M[ae]) : Vn(M[ae]);
      if (gi(Re, je))
        Q(
          Re,
          je,
          ne,
          null,
          le,
          se,
          ve,
          be,
          pe
        );
      else
        break;
      ae++;
    }
    for (; ae <= we && ae <= Se; ) {
      const Re = S[we], je = M[Se] = pe ? Dr(M[Se]) : Vn(M[Se]);
      if (gi(Re, je))
        Q(
          Re,
          je,
          ne,
          null,
          le,
          se,
          ve,
          be,
          pe
        );
      else
        break;
      we--, Se--;
    }
    if (ae > we) {
      if (ae <= Se) {
        const Re = Se + 1, je = Re < Ce ? M[Re].el : ie;
        for (; ae <= Se; )
          Q(
            null,
            M[ae] = pe ? Dr(M[ae]) : Vn(M[ae]),
            ne,
            je,
            le,
            se,
            ve,
            be,
            pe
          ), ae++;
      }
    } else if (ae > Se)
      for (; ae <= we; )
        Lt(S[ae], le, se, !0), ae++;
    else {
      const Re = ae, je = ae, Ue = /* @__PURE__ */ new Map();
      for (ae = je; ae <= Se; ae++) {
        const ot = M[ae] = pe ? Dr(M[ae]) : Vn(M[ae]);
        ot.key != null && Ue.set(ot.key, ae);
      }
      let He, ht = 0;
      const Et = Se - je + 1;
      let Rt = !1, mt = 0;
      const zt = new Array(Et);
      for (ae = 0; ae < Et; ae++) zt[ae] = 0;
      for (ae = Re; ae <= we; ae++) {
        const ot = S[ae];
        if (ht >= Et) {
          Lt(ot, le, se, !0);
          continue;
        }
        let oe;
        if (ot.key != null)
          oe = Ue.get(ot.key);
        else
          for (He = je; He <= Se; He++)
            if (zt[He - je] === 0 && gi(ot, M[He])) {
              oe = He;
              break;
            }
        oe === void 0 ? Lt(ot, le, se, !0) : (zt[oe - je] = ae + 1, oe >= mt ? mt = oe : Rt = !0, Q(
          ot,
          M[oe],
          ne,
          null,
          le,
          se,
          ve,
          be,
          pe
        ), ht++);
      }
      const $n = Rt ? Ff(zt) : So;
      for (He = $n.length - 1, ae = Et - 1; ae >= 0; ae--) {
        const ot = je + ae, oe = M[ot], dn = ot + 1 < Ce ? M[ot + 1].el : ie;
        zt[ae] === 0 ? Q(
          null,
          oe,
          ne,
          dn,
          le,
          se,
          ve,
          be,
          pe
        ) : Rt && (He < 0 || ae !== $n[He] ? xt(oe, ne, dn, 2) : He--);
      }
    }
  }, xt = (S, M, ne, ie, le = null) => {
    const { el: se, type: ve, transition: be, children: pe, shapeFlag: ae } = S;
    if (ae & 6) {
      xt(S.component.subTree, M, ne, ie);
      return;
    }
    if (ae & 128) {
      S.suspense.move(M, ne, ie);
      return;
    }
    if (ae & 64) {
      ve.move(S, M, ne, H);
      return;
    }
    if (ve === Qe) {
      u(se, M, ne);
      for (let we = 0; we < pe.length; we++)
        xt(pe[we], M, ne, ie);
      u(S.anchor, M, ne);
      return;
    }
    if (ve === Zs) {
      q(S, M, ne);
      return;
    }
    if (ie !== 2 && ae & 1 && be)
      if (ie === 0)
        be.beforeEnter(se), u(se, M, ne), an(() => be.enter(se), le);
      else {
        const { leave: we, delayLeave: Se, afterLeave: Re } = be, je = () => {
          S.ctx.isUnmounted ? c(se) : u(se, M, ne);
        }, Ue = () => {
          we(se, () => {
            je(), Re && Re();
          });
        };
        Se ? Se(se, je, Ue) : Ue();
      }
    else
      u(se, M, ne);
  }, Lt = (S, M, ne, ie = !1, le = !1) => {
    const {
      type: se,
      props: ve,
      ref: be,
      children: pe,
      dynamicChildren: ae,
      shapeFlag: Ce,
      patchFlag: we,
      dirs: Se,
      cacheIndex: Re
    } = S;
    if (we === -2 && (le = !1), be != null && (Er(), Ti(be, null, ne, S, !0), Nr()), Re != null && (M.renderCache[Re] = void 0), Ce & 256) {
      M.ctx.deactivate(S);
      return;
    }
    const je = Ce & 1 && Se, Ue = !Do(S);
    let He;
    if (Ue && (He = ve && ve.onVnodeBeforeUnmount) && qn(He, M, S), Ce & 6)
      fn(S.component, ne, ie);
    else {
      if (Ce & 128) {
        S.suspense.unmount(ne, ie);
        return;
      }
      je && mo(S, null, M, "beforeUnmount"), Ce & 64 ? S.type.remove(
        S,
        M,
        ne,
        H,
        ie
      ) : ae && // #5154
      // when v-once is used inside a block, setBlockTracking(-1) marks the
      // parent block with hasOnce: true
      // so that it doesn't take the fast path during unmount - otherwise
      // components nested in v-once are never unmounted.
      !ae.hasOnce && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (se !== Qe || we > 0 && we & 64) ? Nt(
        ae,
        M,
        ne,
        !1,
        !0
      ) : (se === Qe && we & 384 || !le && Ce & 16) && Nt(pe, M, ne), ie && Ft(S);
    }
    (Ue && (He = ve && ve.onVnodeUnmounted) || je) && an(() => {
      He && qn(He, M, S), je && mo(S, null, M, "unmounted");
    }, ne);
  }, Ft = (S) => {
    const { type: M, el: ne, anchor: ie, transition: le } = S;
    if (M === Qe) {
      Bn(ne, ie);
      return;
    }
    if (M === Zs) {
      fe(S);
      return;
    }
    const se = () => {
      c(ne), le && !le.persisted && le.afterLeave && le.afterLeave();
    };
    if (S.shapeFlag & 1 && le && !le.persisted) {
      const { leave: ve, delayLeave: be } = le, pe = () => ve(ne, se);
      be ? be(S.el, se, pe) : pe();
    } else
      se();
  }, Bn = (S, M) => {
    let ne;
    for (; S !== M; )
      ne = B(S), c(S), S = ne;
    c(M);
  }, fn = (S, M, ne) => {
    const {
      bum: ie,
      scope: le,
      job: se,
      subTree: ve,
      um: be,
      m: pe,
      a: ae,
      parent: Ce,
      slots: { __: we }
    } = S;
    du(pe), du(ae), ie && Hi(ie), Ce && ke(we) && we.forEach((Se) => {
      Ce.renderCache[Se] = void 0;
    }), le.stop(), se && (se.flags |= 8, Lt(ve, S, M, ne)), be && an(be, M), an(() => {
      S.isUnmounted = !0;
    }, M), M && M.pendingBranch && !M.isUnmounted && S.asyncDep && !S.asyncResolved && S.suspenseId === M.pendingId && (M.deps--, M.deps === 0 && M.resolve());
  }, Nt = (S, M, ne, ie = !1, le = !1, se = 0) => {
    for (let ve = se; ve < S.length; ve++)
      Lt(S[ve], M, ne, ie, le);
  }, A = (S) => {
    if (S.shapeFlag & 6)
      return A(S.component.subTree);
    if (S.shapeFlag & 128)
      return S.suspense.next();
    const M = B(S.anchor || S.el), ne = M && M[Ol];
    return ne ? B(ne) : M;
  };
  let x = !1;
  const K = (S, M, ne) => {
    S == null ? M._vnode && Lt(M._vnode, null, null, !0) : Q(
      M._vnode || null,
      S,
      M,
      null,
      null,
      null,
      ne
    ), M._vnode = S, x || (x = !0, tu(), wl(), x = !1);
  }, H = {
    p: Q,
    um: Lt,
    m: xt,
    r: Ft,
    mt: Tn,
    mc: de,
    pc: Ke,
    pbc: Xe,
    n: A,
    o: t
  };
  return {
    render: K,
    hydrate: void 0,
    createApp: Ef(K)
  };
}
function Js({ type: t, props: r }, s) {
  return s === "svg" && t === "foreignObject" || s === "mathml" && t === "annotation-xml" && r && r.encoding && r.encoding.includes("html") ? void 0 : s;
}
function yo({ effect: t, job: r }, s) {
  s ? (t.flags |= 32, r.flags |= 4) : (t.flags &= -33, r.flags &= -5);
}
function Lf(t, r) {
  return (!t || t && !t.pendingBranch) && r && !r.persisted;
}
function Va(t, r, s = !1) {
  const u = t.children, c = r.children;
  if (ke(u) && ke(c))
    for (let d = 0; d < u.length; d++) {
      const f = u[d];
      let h = c[d];
      h.shapeFlag & 1 && !h.dynamicChildren && ((h.patchFlag <= 0 || h.patchFlag === 32) && (h = c[d] = Dr(c[d]), h.el = f.el), !s && h.patchFlag !== -2 && Va(f, h)), h.type === vs && (h.el = f.el), h.type === Cr && !h.el && (h.el = f.el);
    }
}
function Ff(t) {
  const r = t.slice(), s = [0];
  let u, c, d, f, h;
  const _ = t.length;
  for (u = 0; u < _; u++) {
    const k = t[u];
    if (k !== 0) {
      if (c = s[s.length - 1], t[c] < k) {
        r[u] = c, s.push(u);
        continue;
      }
      for (d = 0, f = s.length - 1; d < f; )
        h = d + f >> 1, t[s[h]] < k ? d = h + 1 : f = h;
      k < t[s[d]] && (d > 0 && (r[u] = s[d - 1]), s[d] = u);
    }
  }
  for (d = s.length, f = s[d - 1]; d-- > 0; )
    s[d] = f, f = r[f];
  return s;
}
function ql(t) {
  const r = t.subTree.component;
  if (r)
    return r.asyncDep && !r.asyncResolved ? r : ql(r);
}
function du(t) {
  if (t)
    for (let r = 0; r < t.length; r++)
      t[r].flags |= 8;
}
const Kf = Symbol.for("v-scx"), Mf = () => Ni(Kf);
function Bf(t, r) {
  return Wa(t, null, r);
}
function xn(t, r, s) {
  return Wa(t, r, s);
}
function Wa(t, r, s = ft) {
  const { immediate: u, deep: c, flush: d, once: f } = s, h = Xt({}, s), _ = r && u || !r && d !== "post";
  let k;
  if (Ii) {
    if (d === "sync") {
      const ee = Mf();
      k = ee.__watcherHandles || (ee.__watcherHandles = []);
    } else if (!_) {
      const ee = () => {
      };
      return ee.stop = Hn, ee.resume = Hn, ee.pause = Hn, ee;
    }
  }
  const D = Kt;
  h.call = (ee, re, Q) => Gn(ee, D, re, Q);
  let j = !1;
  d === "post" ? h.scheduler = (ee) => {
    an(ee, D && D.suspense);
  } : d !== "sync" && (j = !0, h.scheduler = (ee, re) => {
    re ? ee() : Ma(ee);
  }), h.augmentJob = (ee) => {
    r && (ee.flags |= 4), j && (ee.flags |= 2, D && (ee.id = D.uid, ee.i = D));
  };
  const B = Xc(t, r, h);
  return Ii && (k ? k.push(B) : _ && B()), B;
}
function $f(t, r, s) {
  const u = this.proxy, c = Tt(t) ? t.includes(".") ? Ul(u, t) : () => u[t] : t.bind(u, u);
  let d;
  Me(r) ? d = r : (d = r.handler, s = r);
  const f = Bi(this), h = Wa(c, d.bind(u), s);
  return f(), h;
}
function Ul(t, r) {
  const s = r.split(".");
  return () => {
    let u = t;
    for (let c = 0; c < s.length && u; c++)
      u = u[s[c]];
    return u;
  };
}
const qf = (t, r) => r === "modelValue" || r === "model-value" ? t.modelModifiers : t[`${r}Modifiers`] || t[`${Sn(r)}Modifiers`] || t[`${Oo(r)}Modifiers`];
function Uf(t, r, ...s) {
  if (t.isUnmounted) return;
  const u = t.vnode.props || ft;
  let c = s;
  const d = r.startsWith("update:"), f = d && qf(u, r.slice(7));
  f && (f.trim && (c = s.map((D) => Tt(D) ? D.trim() : D)), f.number && (c = s.map(Ji)));
  let h, _ = u[h = Hs(r)] || // also try camelCase event handler (#2249)
  u[h = Hs(Sn(r))];
  !_ && d && (_ = u[h = Hs(Oo(r))]), _ && Gn(
    _,
    t,
    6,
    c
  );
  const k = u[h + "Once"];
  if (k) {
    if (!t.emitted)
      t.emitted = {};
    else if (t.emitted[h])
      return;
    t.emitted[h] = !0, Gn(
      k,
      t,
      6,
      c
    );
  }
}
function Vl(t, r, s = !1) {
  const u = r.emitsCache, c = u.get(t);
  if (c !== void 0)
    return c;
  const d = t.emits;
  let f = {}, h = !1;
  if (!Me(t)) {
    const _ = (k) => {
      const D = Vl(k, r, !0);
      D && (h = !0, Xt(f, D));
    };
    !s && r.mixins.length && r.mixins.forEach(_), t.extends && _(t.extends), t.mixins && t.mixins.forEach(_);
  }
  return !d && !h ? (gt(t) && u.set(t, null), null) : (ke(d) ? d.forEach((_) => f[_] = null) : Xt(f, d), gt(t) && u.set(t, f), f);
}
function ys(t, r) {
  return !t || !as(r) ? !1 : (r = r.slice(2).replace(/Once$/, ""), ut(t, r[0].toLowerCase() + r.slice(1)) || ut(t, Oo(r)) || ut(t, r));
}
function pu(t) {
  const {
    type: r,
    vnode: s,
    proxy: u,
    withProxy: c,
    propsOptions: [d],
    slots: f,
    attrs: h,
    emit: _,
    render: k,
    renderCache: D,
    props: j,
    data: B,
    setupState: ee,
    ctx: re,
    inheritAttrs: Q
  } = t, W = rs(t);
  let G, $;
  try {
    if (s.shapeFlag & 4) {
      const fe = c || u, _e = fe;
      G = Vn(
        k.call(
          _e,
          fe,
          D,
          j,
          ee,
          B,
          re
        )
      ), $ = h;
    } else {
      const fe = r;
      G = Vn(
        fe.length > 1 ? fe(
          j,
          { attrs: h, slots: f, emit: _ }
        ) : fe(
          j,
          null
        )
      ), $ = r.props ? h : Vf(h);
    }
  } catch (fe) {
    Ci.length = 0, ps(fe, t, 1), G = _t(Cr);
  }
  let q = G;
  if ($ && Q !== !1) {
    const fe = Object.keys($), { shapeFlag: _e } = q;
    fe.length && _e & 7 && (d && fe.some(Ca) && ($ = Wf(
      $,
      d
    )), q = Io(q, $, !1, !0));
  }
  return s.dirs && (q = Io(q, null, !1, !0), q.dirs = q.dirs ? q.dirs.concat(s.dirs) : s.dirs), s.transition && Ba(q, s.transition), G = q, rs(W), G;
}
const Vf = (t) => {
  let r;
  for (const s in t)
    (s === "class" || s === "style" || as(s)) && ((r || (r = {}))[s] = t[s]);
  return r;
}, Wf = (t, r) => {
  const s = {};
  for (const u in t)
    (!Ca(u) || !(u.slice(9) in r)) && (s[u] = t[u]);
  return s;
};
function Hf(t, r, s) {
  const { props: u, children: c, component: d } = t, { props: f, children: h, patchFlag: _ } = r, k = d.emitsOptions;
  if (r.dirs || r.transition)
    return !0;
  if (s && _ >= 0) {
    if (_ & 1024)
      return !0;
    if (_ & 16)
      return u ? hu(u, f, k) : !!f;
    if (_ & 8) {
      const D = r.dynamicProps;
      for (let j = 0; j < D.length; j++) {
        const B = D[j];
        if (f[B] !== u[B] && !ys(k, B))
          return !0;
      }
    }
  } else
    return (c || h) && (!h || !h.$stable) ? !0 : u === f ? !1 : u ? f ? hu(u, f, k) : !0 : !!f;
  return !1;
}
function hu(t, r, s) {
  const u = Object.keys(r);
  if (u.length !== Object.keys(t).length)
    return !0;
  for (let c = 0; c < u.length; c++) {
    const d = u[c];
    if (r[d] !== t[d] && !ys(s, d))
      return !0;
  }
  return !1;
}
function Gf({ vnode: t, parent: r }, s) {
  for (; r; ) {
    const u = r.subTree;
    if (u.suspense && u.suspense.activeBranch === t && (u.el = t.el), u === t)
      (t = r.vnode).el = s, r = r.parent;
    else
      break;
  }
}
const Wl = (t) => t.__isSuspense;
function Yf(t, r) {
  r && r.pendingBranch ? ke(t) ? r.effects.push(...t) : r.effects.push(t) : Zc(t);
}
const Qe = Symbol.for("v-fgt"), vs = Symbol.for("v-txt"), Cr = Symbol.for("v-cmt"), Zs = Symbol.for("v-stc"), Ci = [];
let _n = null;
function ce(t = !1) {
  Ci.push(_n = t ? null : []);
}
function Qf() {
  Ci.pop(), _n = Ci[Ci.length - 1] || null;
}
let Pi = 1;
function mu(t, r = !1) {
  Pi += t, t < 0 && _n && r && (_n.hasOnce = !0);
}
function Hl(t) {
  return t.dynamicChildren = Pi > 0 ? _n || So : null, Qf(), Pi > 0 && _n && _n.push(t), t;
}
function ye(t, r, s, u, c, d) {
  return Hl(
    L(
      t,
      r,
      s,
      u,
      c,
      d,
      !0
    )
  );
}
function On(t, r, s, u, c) {
  return Hl(
    _t(
      t,
      r,
      s,
      u,
      c,
      !0
    )
  );
}
function Ha(t) {
  return t ? t.__v_isVNode === !0 : !1;
}
function gi(t, r) {
  return t.type === r.type && t.key === r.key;
}
const Gl = ({ key: t }) => t ?? null, Yi = ({
  ref: t,
  ref_key: r,
  ref_for: s
}) => (typeof t == "number" && (t = "" + t), t != null ? Tt(t) || Ot(t) || Me(t) ? { i: It, r: t, k: r, f: !!s } : t : null);
function L(t, r = null, s = null, u = 0, c = null, d = t === Qe ? 0 : 1, f = !1, h = !1) {
  const _ = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t,
    props: r,
    key: r && Gl(r),
    ref: r && Yi(r),
    scopeId: xl,
    slotScopeIds: null,
    children: s,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetStart: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: d,
    patchFlag: u,
    dynamicProps: c,
    dynamicChildren: null,
    appContext: null,
    ctx: It
  };
  return h ? (Ga(_, s), d & 128 && t.normalize(_)) : s && (_.shapeFlag |= Tt(s) ? 8 : 16), Pi > 0 && // avoid a block node from tracking itself
  !f && // has current parent block
  _n && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (_.patchFlag > 0 || d & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  _.patchFlag !== 32 && _n.push(_), _;
}
const _t = Xf;
function Xf(t, r = null, s = null, u = 0, c = null, d = !1) {
  if ((!t || t === Al) && (t = Cr), Ha(t)) {
    const h = Io(
      t,
      r,
      !0
      /* mergeRef: true */
    );
    return s && Ga(h, s), Pi > 0 && !d && _n && (h.shapeFlag & 6 ? _n[_n.indexOf(t)] = h : _n.push(h)), h.patchFlag = -2, h;
  }
  if (ad(t) && (t = t.__vccOpts), r) {
    r = zf(r);
    let { class: h, style: _ } = r;
    h && !Tt(h) && (r.class = pn(h)), gt(_) && (Fa(_) && !ke(_) && (_ = Xt({}, _)), r.style = Fo(_));
  }
  const f = Tt(t) ? 1 : Wl(t) ? 128 : ef(t) ? 64 : gt(t) ? 4 : Me(t) ? 2 : 0;
  return L(
    t,
    r,
    s,
    u,
    c,
    f,
    d,
    !0
  );
}
function zf(t) {
  return t ? Fa(t) || Ll(t) ? Xt({}, t) : t : null;
}
function Io(t, r, s = !1, u = !1) {
  const { props: c, ref: d, patchFlag: f, children: h, transition: _ } = t, k = r ? Ql(c || {}, r) : c, D = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: t.type,
    props: k,
    key: k && Gl(k),
    ref: r && r.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      s && d ? ke(d) ? d.concat(Yi(r)) : [d, Yi(r)] : Yi(r)
    ) : d,
    scopeId: t.scopeId,
    slotScopeIds: t.slotScopeIds,
    children: h,
    target: t.target,
    targetStart: t.targetStart,
    targetAnchor: t.targetAnchor,
    staticCount: t.staticCount,
    shapeFlag: t.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: r && t.type !== Qe ? f === -1 ? 16 : f | 16 : f,
    dynamicProps: t.dynamicProps,
    dynamicChildren: t.dynamicChildren,
    appContext: t.appContext,
    dirs: t.dirs,
    transition: _,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: t.component,
    suspense: t.suspense,
    ssContent: t.ssContent && Io(t.ssContent),
    ssFallback: t.ssFallback && Io(t.ssFallback),
    el: t.el,
    anchor: t.anchor,
    ctx: t.ctx,
    ce: t.ce
  };
  return _ && u && Ba(
    D,
    _.clone(D)
  ), D;
}
function Yl(t = " ", r = 0) {
  return _t(vs, null, t, r);
}
function lt(t = "", r = !1) {
  return r ? (ce(), On(Cr, null, t)) : _t(Cr, null, t);
}
function Vn(t) {
  return t == null || typeof t == "boolean" ? _t(Cr) : ke(t) ? _t(
    Qe,
    null,
    // #3666, avoid reference pollution when reusing vnode
    t.slice()
  ) : Ha(t) ? Dr(t) : _t(vs, null, String(t));
}
function Dr(t) {
  return t.el === null && t.patchFlag !== -1 || t.memo ? t : Io(t);
}
function Ga(t, r) {
  let s = 0;
  const { shapeFlag: u } = t;
  if (r == null)
    r = null;
  else if (ke(r))
    s = 16;
  else if (typeof r == "object")
    if (u & 65) {
      const c = r.default;
      c && (c._c && (c._d = !1), Ga(t, c()), c._c && (c._d = !0));
      return;
    } else {
      s = 32;
      const c = r._;
      !c && !Ll(r) ? r._ctx = It : c === 3 && It && (It.slots._ === 1 ? r._ = 1 : (r._ = 2, t.patchFlag |= 1024));
    }
  else Me(r) ? (r = { default: r, _ctx: It }, s = 32) : (r = String(r), u & 64 ? (s = 16, r = [Yl(r)]) : s = 8);
  t.children = r, t.shapeFlag |= s;
}
function Ql(...t) {
  const r = {};
  for (let s = 0; s < t.length; s++) {
    const u = t[s];
    for (const c in u)
      if (c === "class")
        r.class !== u.class && (r.class = pn([r.class, u.class]));
      else if (c === "style")
        r.style = Fo([r.style, u.style]);
      else if (as(c)) {
        const d = r[c], f = u[c];
        f && d !== f && !(ke(d) && d.includes(f)) && (r[c] = d ? [].concat(d, f) : f);
      } else c !== "" && (r[c] = u[c]);
  }
  return r;
}
function qn(t, r, s, u = null) {
  Gn(t, r, 7, [
    s,
    u
  ]);
}
const Jf = Il();
let Zf = 0;
function ed(t, r, s) {
  const u = t.type, c = (r ? r.appContext : t.appContext) || Jf, d = {
    uid: Zf++,
    vnode: t,
    type: u,
    parent: r,
    appContext: c,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    job: null,
    scope: new zu(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: r ? r.provides : Object.create(c.provides),
    ids: r ? r.ids : ["", 0, 0],
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: Kl(u, c),
    emitsOptions: Vl(u, c),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: ft,
    // inheritAttrs
    inheritAttrs: u.inheritAttrs,
    // state
    ctx: ft,
    data: ft,
    props: ft,
    attrs: ft,
    slots: ft,
    refs: ft,
    setupState: ft,
    setupContext: null,
    // suspense related
    suspense: s,
    suspenseId: s ? s.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return d.ctx = { _: d }, d.root = r ? r.root : d, d.emit = Uf.bind(null, d), t.ce && t.ce(d), d;
}
let Kt = null;
const td = () => Kt || It;
let is, ya;
{
  const t = cs(), r = (s, u) => {
    let c;
    return (c = t[s]) || (c = t[s] = []), c.push(u), (d) => {
      c.length > 1 ? c.forEach((f) => f(d)) : c[0](d);
    };
  };
  is = r(
    "__VUE_INSTANCE_SETTERS__",
    (s) => Kt = s
  ), ya = r(
    "__VUE_SSR_SETTERS__",
    (s) => Ii = s
  );
}
const Bi = (t) => {
  const r = Kt;
  return is(t), t.scope.on(), () => {
    t.scope.off(), is(r);
  };
}, yu = () => {
  Kt && Kt.scope.off(), is(null);
};
function Xl(t) {
  return t.vnode.shapeFlag & 4;
}
let Ii = !1;
function nd(t, r = !1, s = !1) {
  r && ya(r);
  const { props: u, children: c } = t.vnode, d = Xl(t);
  Sf(t, u, d, r), Pf(t, c, s || r);
  const f = d ? rd(t, r) : void 0;
  return r && ya(!1), f;
}
function rd(t, r) {
  const s = t.type;
  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = new Proxy(t.ctx, gf);
  const { setup: u } = s;
  if (u) {
    Er();
    const c = t.setupContext = u.length > 1 ? id(t) : null, d = Bi(t), f = Mi(
      u,
      t,
      0,
      [
        t.props,
        c
      ]
    ), h = Wu(f);
    if (Nr(), d(), (h || t.sp) && !Do(t) && Nl(t), h) {
      if (f.then(yu, yu), r)
        return f.then((_) => {
          vu(t, _);
        }).catch((_) => {
          ps(_, t, 0);
        });
      t.asyncDep = f;
    } else
      vu(t, f);
  } else
    zl(t);
}
function vu(t, r, s) {
  Me(r) ? t.type.__ssrInlineRender ? t.ssrRender = r : t.render = r : gt(r) && (t.setupState = yl(r)), zl(t);
}
function zl(t, r, s) {
  const u = t.type;
  t.render || (t.render = u.render || Hn);
  {
    const c = Bi(t);
    Er();
    try {
      bf(t);
    } finally {
      Nr(), c();
    }
  }
}
const od = {
  get(t, r) {
    return Yt(t, "get", ""), t[r];
  }
};
function id(t) {
  const r = (s) => {
    t.exposed = s || {};
  };
  return {
    attrs: new Proxy(t.attrs, od),
    slots: t.slots,
    emit: t.emit,
    expose: r
  };
}
function gs(t) {
  return t.exposed ? t.exposeProxy || (t.exposeProxy = new Proxy(yl(ds(t.exposed)), {
    get(r, s) {
      if (s in r)
        return r[s];
      if (s in Ei)
        return Ei[s](t);
    },
    has(r, s) {
      return s in r || s in Ei;
    }
  })) : t.proxy;
}
function sd(t, r = !0) {
  return Me(t) ? t.displayName || t.name : t.name || r && t.__name;
}
function ad(t) {
  return Me(t) && "__vccOpts" in t;
}
const tt = (t, r) => Yc(t, r, Ii), ud = "3.5.17";
/**
* @vue/runtime-dom v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let va;
const gu = typeof window < "u" && window.trustedTypes;
if (gu)
  try {
    va = /* @__PURE__ */ gu.createPolicy("vue", {
      createHTML: (t) => t
    });
  } catch {
  }
const Jl = va ? (t) => va.createHTML(t) : (t) => t, ld = "http://www.w3.org/2000/svg", cd = "http://www.w3.org/1998/Math/MathML", br = typeof document < "u" ? document : null, bu = br && /* @__PURE__ */ br.createElement("template"), fd = {
  insert: (t, r, s) => {
    r.insertBefore(t, s || null);
  },
  remove: (t) => {
    const r = t.parentNode;
    r && r.removeChild(t);
  },
  createElement: (t, r, s, u) => {
    const c = r === "svg" ? br.createElementNS(ld, t) : r === "mathml" ? br.createElementNS(cd, t) : s ? br.createElement(t, { is: s }) : br.createElement(t);
    return t === "select" && u && u.multiple != null && c.setAttribute("multiple", u.multiple), c;
  },
  createText: (t) => br.createTextNode(t),
  createComment: (t) => br.createComment(t),
  setText: (t, r) => {
    t.nodeValue = r;
  },
  setElementText: (t, r) => {
    t.textContent = r;
  },
  parentNode: (t) => t.parentNode,
  nextSibling: (t) => t.nextSibling,
  querySelector: (t) => br.querySelector(t),
  setScopeId(t, r) {
    t.setAttribute(r, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(t, r, s, u, c, d) {
    const f = s ? s.previousSibling : r.lastChild;
    if (c && (c === d || c.nextSibling))
      for (; r.insertBefore(c.cloneNode(!0), s), !(c === d || !(c = c.nextSibling)); )
        ;
    else {
      bu.innerHTML = Jl(
        u === "svg" ? `<svg>${t}</svg>` : u === "mathml" ? `<math>${t}</math>` : t
      );
      const h = bu.content;
      if (u === "svg" || u === "mathml") {
        const _ = h.firstChild;
        for (; _.firstChild; )
          h.appendChild(_.firstChild);
        h.removeChild(_);
      }
      r.insertBefore(h, s);
    }
    return [
      // first
      f ? f.nextSibling : r.firstChild,
      // last
      s ? s.previousSibling : r.lastChild
    ];
  }
}, dd = Symbol("_vtc");
function pd(t, r, s) {
  const u = t[dd];
  u && (r = (r ? [r, ...u] : [...u]).join(" ")), r == null ? t.removeAttribute("class") : s ? t.setAttribute("class", r) : t.className = r;
}
const wu = Symbol("_vod"), hd = Symbol("_vsh"), md = Symbol(""), yd = /(^|;)\s*display\s*:/;
function vd(t, r, s) {
  const u = t.style, c = Tt(s);
  let d = !1;
  if (s && !c) {
    if (r)
      if (Tt(r))
        for (const f of r.split(";")) {
          const h = f.slice(0, f.indexOf(":")).trim();
          s[h] == null && Qi(u, h, "");
        }
      else
        for (const f in r)
          s[f] == null && Qi(u, f, "");
    for (const f in s)
      f === "display" && (d = !0), Qi(u, f, s[f]);
  } else if (c) {
    if (r !== s) {
      const f = u[md];
      f && (s += ";" + f), u.cssText = s, d = yd.test(s);
    }
  } else r && t.removeAttribute("style");
  wu in t && (t[wu] = d ? u.display : "", t[hd] && (u.display = "none"));
}
const _u = /\s*!important$/;
function Qi(t, r, s) {
  if (ke(s))
    s.forEach((u) => Qi(t, r, u));
  else if (s == null && (s = ""), r.startsWith("--"))
    t.setProperty(r, s);
  else {
    const u = gd(t, r);
    _u.test(s) ? t.setProperty(
      Oo(u),
      s.replace(_u, ""),
      "important"
    ) : t[u] = s;
  }
}
const xu = ["Webkit", "Moz", "ms"], ea = {};
function gd(t, r) {
  const s = ea[r];
  if (s)
    return s;
  let u = Sn(r);
  if (u !== "filter" && u in t)
    return ea[r] = u;
  u = ls(u);
  for (let c = 0; c < xu.length; c++) {
    const d = xu[c] + u;
    if (d in t)
      return ea[r] = d;
  }
  return r;
}
const Ou = "http://www.w3.org/1999/xlink";
function Tu(t, r, s, u, c, d = gc(r)) {
  u && r.startsWith("xlink:") ? s == null ? t.removeAttributeNS(Ou, r.slice(6, r.length)) : t.setAttributeNS(Ou, r, s) : s == null || d && !Yu(s) ? t.removeAttribute(r) : t.setAttribute(
    r,
    d ? "" : Mn(s) ? String(s) : s
  );
}
function Eu(t, r, s, u, c) {
  if (r === "innerHTML" || r === "textContent") {
    s != null && (t[r] = r === "innerHTML" ? Jl(s) : s);
    return;
  }
  const d = t.tagName;
  if (r === "value" && d !== "PROGRESS" && // custom elements may use _value internally
  !d.includes("-")) {
    const h = d === "OPTION" ? t.getAttribute("value") || "" : t.value, _ = s == null ? (
      // #11647: value should be set as empty string for null and undefined,
      // but <input type="checkbox"> should be set as 'on'.
      t.type === "checkbox" ? "on" : ""
    ) : String(s);
    (h !== _ || !("_value" in t)) && (t.value = _), s == null && t.removeAttribute(r), t._value = s;
    return;
  }
  let f = !1;
  if (s === "" || s == null) {
    const h = typeof t[r];
    h === "boolean" ? s = Yu(s) : s == null && h === "string" ? (s = "", f = !0) : h === "number" && (s = 0, f = !0);
  }
  try {
    t[r] = s;
  } catch {
  }
  f && t.removeAttribute(c || r);
}
function xr(t, r, s, u) {
  t.addEventListener(r, s, u);
}
function bd(t, r, s, u) {
  t.removeEventListener(r, s, u);
}
const Nu = Symbol("_vei");
function wd(t, r, s, u, c = null) {
  const d = t[Nu] || (t[Nu] = {}), f = d[r];
  if (u && f)
    f.value = u;
  else {
    const [h, _] = _d(r);
    if (u) {
      const k = d[r] = Td(
        u,
        c
      );
      xr(t, h, k, _);
    } else f && (bd(t, h, f, _), d[r] = void 0);
  }
}
const Cu = /(?:Once|Passive|Capture)$/;
function _d(t) {
  let r;
  if (Cu.test(t)) {
    r = {};
    let u;
    for (; u = t.match(Cu); )
      t = t.slice(0, t.length - u[0].length), r[u[0].toLowerCase()] = !0;
  }
  return [t[2] === ":" ? t.slice(3) : Oo(t.slice(2)), r];
}
let ta = 0;
const xd = /* @__PURE__ */ Promise.resolve(), Od = () => ta || (xd.then(() => ta = 0), ta = Date.now());
function Td(t, r) {
  const s = (u) => {
    if (!u._vts)
      u._vts = Date.now();
    else if (u._vts <= s.attached)
      return;
    Gn(
      Ed(u, s.value),
      r,
      5,
      [u]
    );
  };
  return s.value = t, s.attached = Od(), s;
}
function Ed(t, r) {
  if (ke(r)) {
    const s = t.stopImmediatePropagation;
    return t.stopImmediatePropagation = () => {
      s.call(t), t._stopped = !0;
    }, r.map(
      (u) => (c) => !c._stopped && u && u(c)
    );
  } else
    return r;
}
const Su = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter
t.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, Nd = (t, r, s, u, c, d) => {
  const f = c === "svg";
  r === "class" ? pd(t, u, f) : r === "style" ? vd(t, s, u) : as(r) ? Ca(r) || wd(t, r, s, u, d) : (r[0] === "." ? (r = r.slice(1), !0) : r[0] === "^" ? (r = r.slice(1), !1) : Cd(t, r, u, f)) ? (Eu(t, r, u), !t.tagName.includes("-") && (r === "value" || r === "checked" || r === "selected") && Tu(t, r, u, f, d, r !== "value")) : /* #11081 force set props for possible async custom element */ t._isVueCE && (/[A-Z]/.test(r) || !Tt(u)) ? Eu(t, Sn(r), u, d, r) : (r === "true-value" ? t._trueValue = u : r === "false-value" && (t._falseValue = u), Tu(t, r, u, f));
};
function Cd(t, r, s, u) {
  if (u)
    return !!(r === "innerHTML" || r === "textContent" || r in t && Su(r) && Me(s));
  if (r === "spellcheck" || r === "draggable" || r === "translate" || r === "autocorrect" || r === "form" || r === "list" && t.tagName === "INPUT" || r === "type" && t.tagName === "TEXTAREA")
    return !1;
  if (r === "width" || r === "height") {
    const c = t.tagName;
    if (c === "IMG" || c === "VIDEO" || c === "CANVAS" || c === "SOURCE")
      return !1;
  }
  return Su(r) && Tt(s) ? !1 : r in t;
}
const jr = (t) => {
  const r = t.props["onUpdate:modelValue"] || !1;
  return ke(r) ? (s) => Hi(r, s) : r;
};
function Sd(t) {
  t.target.composing = !0;
}
function Au(t) {
  const r = t.target;
  r.composing && (r.composing = !1, r.dispatchEvent(new Event("input")));
}
const Cn = Symbol("_assign"), Tr = {
  created(t, { modifiers: { lazy: r, trim: s, number: u } }, c) {
    t[Cn] = jr(c);
    const d = u || c.props && c.props.type === "number";
    xr(t, r ? "change" : "input", (f) => {
      if (f.target.composing) return;
      let h = t.value;
      s && (h = h.trim()), d && (h = Ji(h)), t[Cn](h);
    }), s && xr(t, "change", () => {
      t.value = t.value.trim();
    }), r || (xr(t, "compositionstart", Sd), xr(t, "compositionend", Au), xr(t, "change", Au));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(t, { value: r }) {
    t.value = r ?? "";
  },
  beforeUpdate(t, { value: r, oldValue: s, modifiers: { lazy: u, trim: c, number: d } }, f) {
    if (t[Cn] = jr(f), t.composing) return;
    const h = (d || t.type === "number") && !/^0\d/.test(t.value) ? Ji(t.value) : t.value, _ = r ?? "";
    h !== _ && (document.activeElement === t && t.type !== "range" && (u && r === s || c && t.value.trim() === _) || (t.value = _));
  }
}, Po = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(t, r, s) {
    t[Cn] = jr(s), xr(t, "change", () => {
      const u = t._modelValue, c = ko(t), d = t.checked, f = t[Cn];
      if (ke(u)) {
        const h = Ra(u, c), _ = h !== -1;
        if (d && !_)
          f(u.concat(c));
        else if (!d && _) {
          const k = [...u];
          k.splice(h, 1), f(k);
        }
      } else if (Lo(u)) {
        const h = new Set(u);
        d ? h.add(c) : h.delete(c), f(h);
      } else
        f(Zl(t, d));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: Ru,
  beforeUpdate(t, r, s) {
    t[Cn] = jr(s), Ru(t, r, s);
  }
};
function Ru(t, { value: r, oldValue: s }, u) {
  t._modelValue = r;
  let c;
  if (ke(r))
    c = Ra(r, u.props.value) > -1;
  else if (Lo(r))
    c = r.has(u.props.value);
  else {
    if (r === s) return;
    c = _o(r, Zl(t, !0));
  }
  t.checked !== c && (t.checked = c);
}
const Lr = {
  created(t, { value: r }, s) {
    t.checked = _o(r, s.props.value), t[Cn] = jr(s), xr(t, "change", () => {
      t[Cn](ko(t));
    });
  },
  beforeUpdate(t, { value: r, oldValue: s }, u) {
    t[Cn] = jr(u), r !== s && (t.checked = _o(r, u.props.value));
  }
}, ln = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(t, { value: r, modifiers: { number: s } }, u) {
    const c = Lo(r);
    xr(t, "change", () => {
      const d = Array.prototype.filter.call(t.options, (f) => f.selected).map(
        (f) => s ? Ji(ko(f)) : ko(f)
      );
      t[Cn](
        t.multiple ? c ? new Set(d) : d : d[0]
      ), t._assigning = !0, Ka(() => {
        t._assigning = !1;
      });
    }), t[Cn] = jr(u);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(t, { value: r }) {
    Du(t, r);
  },
  beforeUpdate(t, r, s) {
    t[Cn] = jr(s);
  },
  updated(t, { value: r }) {
    t._assigning || Du(t, r);
  }
};
function Du(t, r) {
  const s = t.multiple, u = ke(r);
  if (!(s && !u && !Lo(r))) {
    for (let c = 0, d = t.options.length; c < d; c++) {
      const f = t.options[c], h = ko(f);
      if (s)
        if (u) {
          const _ = typeof h;
          _ === "string" || _ === "number" ? f.selected = r.some((k) => String(k) === String(h)) : f.selected = Ra(r, h) > -1;
        } else
          f.selected = r.has(h);
      else if (_o(ko(f), r)) {
        t.selectedIndex !== c && (t.selectedIndex = c);
        return;
      }
    }
    !s && t.selectedIndex !== -1 && (t.selectedIndex = -1);
  }
}
function ko(t) {
  return "_value" in t ? t._value : t.value;
}
function Zl(t, r) {
  const s = r ? "_trueValue" : "_falseValue";
  return s in t ? t[s] : r;
}
const Ad = /* @__PURE__ */ Xt({ patchProp: Nd }, fd);
let Pu;
function Rd() {
  return Pu || (Pu = kf(Ad));
}
const Dd = (...t) => {
  const r = Rd().createApp(...t), { mount: s } = r;
  return r.mount = (u) => {
    const c = Id(u);
    if (!c) return;
    const d = r._component;
    !Me(d) && !d.render && !d.template && (d.template = c.innerHTML), c.nodeType === 1 && (c.textContent = "");
    const f = s(c, !1, Pd(c));
    return c instanceof Element && (c.removeAttribute("v-cloak"), c.setAttribute("data-v-app", "")), f;
  }, r;
};
function Pd(t) {
  if (t instanceof SVGElement)
    return "svg";
  if (typeof MathMLElement == "function" && t instanceof MathMLElement)
    return "mathml";
}
function Id(t) {
  return Tt(t) ? document.querySelector(t) : t;
}
/*!
 * pinia v3.0.3
 * (c) 2025 Eduardo San Martin Morote
 * @license MIT
 */
let ec;
const bs = (t) => ec = t, tc = (
  /* istanbul ignore next */
  Symbol()
);
function ga(t) {
  return t && typeof t == "object" && Object.prototype.toString.call(t) === "[object Object]" && typeof t.toJSON != "function";
}
var Si;
(function(t) {
  t.direct = "direct", t.patchObject = "patch object", t.patchFunction = "patch function";
})(Si || (Si = {}));
function kd() {
  const t = Ju(!0), r = t.run(() => nt({}));
  let s = [], u = [];
  const c = ds({
    install(d) {
      bs(c), c._a = d, d.provide(tc, c), d.config.globalProperties.$pinia = c, u.forEach((f) => s.push(f)), u = [];
    },
    use(d) {
      return this._a ? s.push(d) : u.push(d), this;
    },
    _p: s,
    // it's actually undefined here
    // @ts-expect-error
    _a: null,
    _e: t,
    _s: /* @__PURE__ */ new Map(),
    state: r
  });
  return c;
}
const nc = () => {
};
function Iu(t, r, s, u = nc) {
  t.push(r);
  const c = () => {
    const d = t.indexOf(r);
    d > -1 && (t.splice(d, 1), u());
  };
  return !s && Zu() && wc(c), c;
}
function No(t, ...r) {
  t.slice().forEach((s) => {
    s(...r);
  });
}
const jd = (t) => t(), ku = Symbol(), na = Symbol();
function ba(t, r) {
  t instanceof Map && r instanceof Map ? r.forEach((s, u) => t.set(u, s)) : t instanceof Set && r instanceof Set && r.forEach(t.add, t);
  for (const s in r) {
    if (!r.hasOwnProperty(s))
      continue;
    const u = r[s], c = t[s];
    ga(c) && ga(u) && t.hasOwnProperty(s) && !Ot(u) && !Or(u) ? t[s] = ba(c, u) : t[s] = u;
  }
  return t;
}
const Ld = (
  /* istanbul ignore next */
  Symbol()
);
function Fd(t) {
  return !ga(t) || !Object.prototype.hasOwnProperty.call(t, Ld);
}
const { assign: Ar } = Object;
function Kd(t) {
  return !!(Ot(t) && t.effect);
}
function Md(t, r, s, u) {
  const { state: c, actions: d, getters: f } = r, h = s.state.value[t];
  let _;
  function k() {
    h || (s.state.value[t] = c ? c() : {});
    const D = Uc(s.state.value[t]);
    return Ar(D, d, Object.keys(f || {}).reduce((j, B) => (j[B] = ds(tt(() => {
      bs(s);
      const ee = s._s.get(t);
      return f[B].call(ee, ee);
    })), j), {}));
  }
  return _ = rc(t, k, r, s, u, !0), _;
}
function rc(t, r, s = {}, u, c, d) {
  let f;
  const h = Ar({ actions: {} }, s), _ = { deep: !0 };
  let k, D, j = [], B = [], ee;
  const re = u.state.value[t];
  !d && !re && (u.state.value[t] = {}), nt({});
  let Q;
  function W(de) {
    let F;
    k = D = !1, typeof de == "function" ? (de(u.state.value[t]), F = {
      type: Si.patchFunction,
      storeId: t,
      events: ee
    }) : (ba(u.state.value[t], de), F = {
      type: Si.patchObject,
      payload: de,
      storeId: t,
      events: ee
    });
    const Xe = Q = Symbol();
    Ka().then(() => {
      Q === Xe && (k = !0);
    }), D = !0, No(j, F, u.state.value[t]);
  }
  const G = d ? function() {
    const { state: F } = s, Xe = F ? F() : {};
    this.$patch((dt) => {
      Ar(dt, Xe);
    });
  } : (
    /* istanbul ignore next */
    nc
  );
  function $() {
    f.stop(), j = [], B = [], u._s.delete(t);
  }
  const q = (de, F = "") => {
    if (ku in de)
      return de[na] = F, de;
    const Xe = function() {
      bs(u);
      const dt = Array.from(arguments), Be = [], at = [];
      function Tn(Ee) {
        Be.push(Ee);
      }
      function jt(Ee) {
        at.push(Ee);
      }
      No(B, {
        args: dt,
        name: Xe[na],
        store: _e,
        after: Tn,
        onError: jt
      });
      let rt;
      try {
        rt = de.apply(this && this.$id === t ? this : _e, dt);
      } catch (Ee) {
        throw No(at, Ee), Ee;
      }
      return rt instanceof Promise ? rt.then((Ee) => (No(Be, Ee), Ee)).catch((Ee) => (No(at, Ee), Promise.reject(Ee))) : (No(Be, rt), rt);
    };
    return Xe[ku] = !0, Xe[na] = F, Xe;
  }, fe = {
    _p: u,
    // _s: scope,
    $id: t,
    $onAction: Iu.bind(null, B),
    $patch: W,
    $reset: G,
    $subscribe(de, F = {}) {
      const Xe = Iu(j, de, F.detached, () => dt()), dt = f.run(() => xn(() => u.state.value[t], (Be) => {
        (F.flush === "sync" ? D : k) && de({
          storeId: t,
          type: Si.direct,
          events: ee
        }, Be);
      }, Ar({}, _, F)));
      return Xe;
    },
    $dispose: $
  }, _e = Ki(fe);
  u._s.set(t, _e);
  const ue = (u._a && u._a.runWithContext || jd)(() => u._e.run(() => (f = Ju()).run(() => r({ action: q }))));
  for (const de in ue) {
    const F = ue[de];
    if (Ot(F) && !Kd(F) || Or(F))
      d || (re && Fd(F) && (Ot(F) ? F.value = re[de] : ba(F, re[de])), u.state.value[t][de] = F);
    else if (typeof F == "function") {
      const Xe = q(F, de);
      ue[de] = Xe, h.actions[de] = F;
    }
  }
  return Ar(_e, ue), Ar(et(_e), ue), Object.defineProperty(_e, "$state", {
    get: () => u.state.value[t],
    set: (de) => {
      W((F) => {
        Ar(F, de);
      });
    }
  }), u._p.forEach((de) => {
    Ar(_e, f.run(() => de({
      store: _e,
      app: u._a,
      pinia: u,
      options: h
    })));
  }), re && d && s.hydrate && s.hydrate(_e.$state, re), k = !0, D = !0, _e;
}
/*! #__NO_SIDE_EFFECTS__ */
// @__NO_SIDE_EFFECTS__
function Ya(t, r, s) {
  let u;
  const c = typeof r == "function";
  u = c ? s : r;
  function d(f, h) {
    const _ = Cf();
    return f = // in test mode, ignore the argument provided as we can always retrieve a
    // pinia instance with getActivePinia()
    f || (_ ? Ni(tc, null) : null), f && bs(f), f = ec, f._s.has(t) || (c ? rc(t, r, u, f) : Md(t, u, f)), f._s.get(t);
  }
  return d.$id = t, d;
}
function cn(t) {
  const r = et(t), s = {};
  for (const u in r) {
    const c = r[u];
    c.effect ? s[u] = // ...
    tt({
      get: () => t[u],
      set(d) {
        t[u] = d;
      }
    }) : (Ot(c) || Or(c)) && (s[u] = // ---
    Hc(t, u));
  }
  return s;
}
const ki = ["q", "t"];
function Wn(t) {
  return `${t.prefix} ${t.lnClass} ${t.lnInst}`;
}
const ws = /* @__PURE__ */ Ya("dataflow/sidebar", () => {
  const t = nt(null);
  function r(u) {
    t.value = u;
  }
  function s(u) {
    const c = u === t.value ? null : u;
    r(c);
  }
  return {
    activeElement: t,
    setActiveElement: r,
    setOrResetActiveElement: s
  };
});
var Bd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $d(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Xi = { exports: {} }, qd = Xi.exports, ju;
function Ud() {
  return ju || (ju = 1, function(t, r) {
    (function(s, u) {
      t.exports = u();
    })(qd, function() {
      var s = function(e, n) {
        return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (o[a] = i[a]);
        })(e, n);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var n, o = 1, i = arguments.length; o < i; o++) for (var a in n = arguments[o]) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, n, o) {
        for (var i, a = 0, l = n.length; a < l; a++) !i && a in n || ((i = i || Array.prototype.slice.call(n, 0, a))[a] = n[a]);
        return e.concat(i || Array.prototype.slice.call(n));
      }
      var d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Bd, f = Object.keys, h = Array.isArray;
      function _(e, n) {
        return typeof n != "object" || f(n).forEach(function(o) {
          e[o] = n[o];
        }), e;
      }
      typeof Promise > "u" || d.Promise || (d.Promise = Promise);
      var k = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function j(e, n) {
        return D.call(e, n);
      }
      function B(e, n) {
        typeof n == "function" && (n = n(k(e))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(n).forEach(function(o) {
          re(e, o, n[o]);
        });
      }
      var ee = Object.defineProperty;
      function re(e, n, o, i) {
        ee(e, n, _(o && j(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function Q(e) {
        return { from: function(n) {
          return e.prototype = Object.create(n.prototype), re(e.prototype, "constructor", e), { extend: B.bind(null, e.prototype) };
        } };
      }
      var W = Object.getOwnPropertyDescriptor, G = [].slice;
      function $(e, n, o) {
        return G.call(e, n, o);
      }
      function q(e, n) {
        return n(e);
      }
      function fe(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function _e(e) {
        d.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function Pe(e, n) {
        if (typeof n == "string" && j(e, n)) return e[n];
        if (!n) return e;
        if (typeof n != "string") {
          for (var o = [], i = 0, a = n.length; i < a; ++i) {
            var l = Pe(e, n[i]);
            o.push(l);
          }
          return o;
        }
        var p = n.indexOf(".");
        if (p !== -1) {
          var m = e[n.substr(0, p)];
          return m == null ? void 0 : Pe(m, n.substr(p + 1));
        }
      }
      function ue(e, n, o) {
        if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof n != "string" && "length" in n) {
          fe(typeof o != "string" && "length" in o);
          for (var i = 0, a = n.length; i < a; ++i) ue(e, n[i], o[i]);
        } else {
          var l, p, m = n.indexOf(".");
          m !== -1 ? (l = n.substr(0, m), (p = n.substr(m + 1)) === "" ? o === void 0 ? h(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : ue(m = !(m = e[l]) || !j(e, l) ? e[l] = {} : m, p, o)) : o === void 0 ? h(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = o;
        }
      }
      function de(e) {
        var n, o = {};
        for (n in e) j(e, n) && (o[n] = e[n]);
        return o;
      }
      var F = [].concat;
      function Xe(e) {
        return F.apply([], e);
      }
      var je = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Xe([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(n) {
          return n + e + "Array";
        });
      }))).filter(function(e) {
        return d[e];
      }), dt = new Set(je.map(function(e) {
        return d[e];
      })), Be = null;
      function at(e) {
        return Be = /* @__PURE__ */ new WeakMap(), e = function n(o) {
          if (!o || typeof o != "object") return o;
          var i = Be.get(o);
          if (i) return i;
          if (h(o)) {
            i = [], Be.set(o, i);
            for (var a = 0, l = o.length; a < l; ++a) i.push(n(o[a]));
          } else if (dt.has(o.constructor)) i = o;
          else {
            var p, m = k(o);
            for (p in i = m === Object.prototype ? {} : Object.create(m), Be.set(o, i), o) j(o, p) && (i[p] = n(o[p]));
          }
          return i;
        }(e), Be = null, e;
      }
      var Tn = {}.toString;
      function jt(e) {
        return Tn.call(e).slice(8, -1);
      }
      var rt = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ee = typeof rt == "symbol" ? function(e) {
        var n;
        return e != null && (n = e[rt]) && n.apply(e);
      } : function() {
        return null;
      };
      function Ke(e, n) {
        return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n;
      }
      var bt = {};
      function ct(e) {
        var n, o, i, a;
        if (arguments.length === 1) {
          if (h(e)) return e.slice();
          if (this === bt && typeof e == "string") return [e];
          if (a = Ee(e)) {
            for (o = []; !(i = a.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (n = e.length) != "number") return [e];
          for (o = new Array(n); n--; ) o[n] = e[n];
          return o;
        }
        for (n = arguments.length, o = new Array(n); n--; ) o[n] = arguments[n];
        return o;
      }
      var xt = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Re = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], wt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Re), Lt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Ft(e, n) {
        this.name = e, this.message = n;
      }
      function Bn(e, n) {
        return e + ". Errors: " + Object.keys(n).map(function(o) {
          return n[o].toString();
        }).filter(function(o, i, a) {
          return a.indexOf(o) === i;
        }).join(`
`);
      }
      function fn(e, n, o, i) {
        this.failures = n, this.failedKeys = i, this.successCount = o, this.message = Bn(e, n);
      }
      function Nt(e, n) {
        this.name = "BulkError", this.failures = Object.keys(n).map(function(o) {
          return n[o];
        }), this.failuresByPos = n, this.message = Bn(e, this.failures);
      }
      Q(Ft).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), Q(fn).from(Ft), Q(Nt).from(Ft);
      var A = wt.reduce(function(e, n) {
        return e[n] = n + "Error", e;
      }, {}), x = Ft, K = wt.reduce(function(e, n) {
        var o = n + "Error";
        function i(a, l) {
          this.name = o, a ? typeof a == "string" ? (this.message = "".concat(a).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof a == "object" && (this.message = "".concat(a.name, " ").concat(a.message), this.inner = a) : (this.message = Lt[n] || o, this.inner = null);
        }
        return Q(i).from(x), e[n] = i, e;
      }, {});
      K.Syntax = SyntaxError, K.Type = TypeError, K.Range = RangeError;
      var H = Re.reduce(function(e, n) {
        return e[n + "Error"] = K[n], e;
      }, {}), Ve = wt.reduce(function(e, n) {
        return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = K[n]), e;
      }, {});
      function S() {
      }
      function M(e) {
        return e;
      }
      function ne(e, n) {
        return e == null || e === M ? n : function(o) {
          return n(e(o));
        };
      }
      function ie(e, n) {
        return function() {
          e.apply(this, arguments), n.apply(this, arguments);
        };
      }
      function le(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, a = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = n.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? ie(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? ie(a, this.onerror) : a), l !== void 0 ? l : o;
        };
      }
      function se(e, n) {
        return e === S ? n : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, n.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? ie(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? ie(i, this.onerror) : i);
        };
      }
      function ve(e, n) {
        return e === S ? n : function(o) {
          var i = e.apply(this, arguments);
          _(o, i);
          var a = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = n.apply(this, arguments), a && (this.onsuccess = this.onsuccess ? ie(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? ie(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : _(i, o);
        };
      }
      function be(e, n) {
        return e === S ? n : function() {
          return n.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function pe(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, a = arguments.length, l = new Array(a); a--; ) l[a] = arguments[a];
            return o.then(function() {
              return n.apply(i, l);
            });
          }
          return n.apply(this, arguments);
        };
      }
      Ve.ModifyError = fn, Ve.DexieError = Ft, Ve.BulkError = Nt;
      var ae = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Ce(e) {
        ae = e;
      }
      var we = {}, Se = 100, je = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, k(e), e];
        var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [n, k(n), e];
      }(), Re = je[0], wt = je[1], je = je[2], wt = wt && wt.then, Ue = Re && Re.constructor, He = !!je, ht = function(e, n) {
        dn.push([e, n]), Rt && (queueMicrotask(xs), Rt = !1);
      }, Et = !0, Rt = !0, mt = [], zt = [], $n = M, ot = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: S, pgp: !1, env: {}, finalize: S }, oe = ot, dn = [], Jt = 0, Yn = [];
      function Z(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var n = this._PSD = oe;
        if (typeof e != "function") {
          if (e !== we) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Kr(this, this._value));
        }
        this._state = null, this._value = null, ++n.ref, function o(i, a) {
          try {
            a(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var p = i._lib && hn();
                l && typeof l.then == "function" ? o(i, function(m, v) {
                  l instanceof Z ? l._then(m, v) : l.then(m, v);
                }) : (i._state = !0, i._value = l, Bo(i)), p && mn();
              }
            }, Kr.bind(null, i));
          } catch (l) {
            Kr(i, l);
          }
        }(this, e);
      }
      var Fr = { get: function() {
        var e = oe, n = Jn;
        function o(i, a) {
          var l = this, p = !e.global && (e !== oe || n !== Jn), m = p && !Bt(), v = new Z(function(b, O) {
            Mr(l, new Mo(qo(i, e, p, m), qo(a, e, p, m), b, O, e));
          });
          return this._consoleTask && (v._consoleTask = this._consoleTask), v;
        }
        return o.prototype = we, o;
      }, set: function(e) {
        re(this, "then", e && e.prototype === we ? Fr : { get: function() {
          return e;
        }, set: Fr.set });
      } };
      function Mo(e, n, o, i, a) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = o, this.reject = i, this.psd = a;
      }
      function Kr(e, n) {
        var o, i;
        zt.push(n), e._state === null && (o = e._lib && hn(), n = $n(n), e._state = !1, e._value = n, i = e, mt.some(function(a) {
          return a._value === i._value;
        }) || mt.push(i), Bo(e), o && mn());
      }
      function Bo(e) {
        var n = e._listeners;
        e._listeners = [];
        for (var o = 0, i = n.length; o < i; ++o) Mr(e, n[o]);
        var a = e._PSD;
        --a.ref || a.finalize(), Jt === 0 && (++Jt, ht(function() {
          --Jt == 0 && Br();
        }, []));
      }
      function Mr(e, n) {
        if (e._state !== null) {
          var o = e._state ? n.onFulfilled : n.onRejected;
          if (o === null) return (e._state ? n.resolve : n.reject)(e._value);
          ++n.psd.ref, ++Jt, ht(_s, [o, e, n]);
        } else e._listeners.push(n);
      }
      function _s(e, n, o) {
        try {
          var i, a = n._value;
          !n._state && zt.length && (zt = []), i = ae && n._consoleTask ? n._consoleTask.run(function() {
            return e(a);
          }) : e(a), n._state || zt.indexOf(a) !== -1 || function(l) {
            for (var p = mt.length; p; ) if (mt[--p]._value === l._value) return mt.splice(p, 1);
          }(n), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Jt == 0 && Br(), --o.psd.ref || o.psd.finalize();
        }
      }
      function xs() {
        Zt(ot, function() {
          hn() && mn();
        });
      }
      function hn() {
        var e = Et;
        return Rt = Et = !1, e;
      }
      function mn() {
        var e, n, o;
        do
          for (; 0 < dn.length; ) for (e = dn, dn = [], o = e.length, n = 0; n < o; ++n) {
            var i = e[n];
            i[0].apply(null, i[1]);
          }
        while (0 < dn.length);
        Rt = Et = !0;
      }
      function Br() {
        var e = mt;
        mt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var n = Yn.slice(0), o = n.length; o; ) n[--o]();
      }
      function Qn(e) {
        return new Z(we, !1, e);
      }
      function Le(e, n) {
        var o = oe;
        return function() {
          var i = hn(), a = oe;
          try {
            return $t(o, !0), e.apply(this, arguments);
          } catch (l) {
            n && n(l);
          } finally {
            $t(a, !1), i && mn();
          }
        };
      }
      B(Z.prototype, { then: Fr, _then: function(e, n) {
        Mr(this, new Mo(null, null, e, n, oe));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var n = e, o = arguments[1];
        return typeof n == "function" ? this.then(null, function(i) {
          return (i instanceof n ? o : Qn)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === n ? o : Qn)(i);
        });
      }, finally: function(e) {
        return this.then(function(n) {
          return Z.resolve(e()).then(function() {
            return n;
          });
        }, function(n) {
          return Z.resolve(e()).then(function() {
            return Qn(n);
          });
        });
      }, timeout: function(e, n) {
        var o = this;
        return e < 1 / 0 ? new Z(function(i, a) {
          var l = setTimeout(function() {
            return a(new K.Timeout(n));
          }, e);
          o.then(i, a).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && re(Z.prototype, Symbol.toStringTag, "Dexie.Promise"), ot.env = $o(), B(Z, { all: function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n, o) {
          e.length === 0 && n([]);
          var i = e.length;
          e.forEach(function(a, l) {
            return Z.resolve(a).then(function(p) {
              e[l] = p, --i || n(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof Z ? e : e && typeof e.then == "function" ? new Z(function(n, o) {
          e.then(n, o);
        }) : new Z(we, !0, e);
      }, reject: Qn, race: function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n, o) {
          e.map(function(i) {
            return Z.resolve(i).then(n, o);
          });
        });
      }, PSD: { get: function() {
        return oe;
      }, set: function(e) {
        return oe = e;
      } }, totalEchoes: { get: function() {
        return Jn;
      } }, newPSD: Mt, usePSD: Zt, scheduler: { get: function() {
        return ht;
      }, set: function(e) {
        ht = e;
      } }, rejectionMapper: { get: function() {
        return $n;
      }, set: function(e) {
        $n = e;
      } }, follow: function(e, n) {
        return new Z(function(o, i) {
          return Mt(function(a, l) {
            var p = oe;
            p.unhandleds = [], p.onunhandled = l, p.finalize = ie(function() {
              var m, v = this;
              m = function() {
                v.unhandleds.length === 0 ? a() : l(v.unhandleds[0]);
              }, Yn.push(function b() {
                m(), Yn.splice(Yn.indexOf(b), 1);
              }), ++Jt, ht(function() {
                --Jt == 0 && Br();
              }, []);
            }, p.finalize), e();
          }, n, o, i);
        });
      } }), Ue && (Ue.allSettled && re(Z, "allSettled", function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n) {
          e.length === 0 && n([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(a, l) {
            return Z.resolve(a).then(function(p) {
              return i[l] = { status: "fulfilled", value: p };
            }, function(p) {
              return i[l] = { status: "rejected", reason: p };
            }).then(function() {
              return --o || n(i);
            });
          });
        });
      }), Ue.any && typeof AggregateError < "u" && re(Z, "any", function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, a = new Array(i);
          e.forEach(function(l, p) {
            return Z.resolve(l).then(function(m) {
              return n(m);
            }, function(m) {
              a[p] = m, --i || o(new AggregateError(a));
            });
          });
        });
      }), Ue.withResolvers && (Z.withResolvers = Ue.withResolvers));
      var Ge = { awaits: 0, echoes: 0, id: 0 }, Os = 0, Xn = [], zn = 0, Jn = 0, Ts = 0;
      function Mt(e, n, o, i) {
        var a = oe, l = Object.create(a);
        return l.parent = a, l.ref = 0, l.global = !1, l.id = ++Ts, ot.env, l.env = He ? { Promise: Z, PromiseProp: { value: Z, configurable: !0, writable: !0 }, all: Z.all, race: Z.race, allSettled: Z.allSettled, any: Z.any, resolve: Z.resolve, reject: Z.reject } : {}, n && _(l, n), ++a.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = Zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function yn() {
        return Ge.id || (Ge.id = ++Os), ++Ge.awaits, Ge.echoes += Se, Ge.id;
      }
      function Bt() {
        return !!Ge.awaits && (--Ge.awaits == 0 && (Ge.id = 0), Ge.echoes = Ge.awaits * Se, !0);
      }
      function Zn(e) {
        return Ge.echoes && e && e.constructor === Ue ? (yn(), e.then(function(n) {
          return Bt(), n;
        }, function(n) {
          return Bt(), $e(n);
        })) : e;
      }
      function Es() {
        var e = Xn[Xn.length - 1];
        Xn.pop(), $t(e, !1);
      }
      function $t(e, n) {
        var o, i = oe;
        (n ? !Ge.echoes || zn++ && e === oe : !zn || --zn && e === oe) || queueMicrotask(n ? (function(a) {
          ++Jn, Ge.echoes && --Ge.echoes != 0 || (Ge.echoes = Ge.awaits = Ge.id = 0), Xn.push(oe), $t(a, !0);
        }).bind(null, e) : Es), e !== oe && (oe = e, i === ot && (ot.env = $o()), He && (o = ot.env.Promise, n = e.env, (i.global || e.global) && (Object.defineProperty(d, "Promise", n.PromiseProp), o.all = n.all, o.race = n.race, o.resolve = n.resolve, o.reject = n.reject, n.allSettled && (o.allSettled = n.allSettled), n.any && (o.any = n.any))));
      }
      function $o() {
        var e = d.Promise;
        return He ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(d, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function Zt(e, n, o, i, a) {
        var l = oe;
        try {
          return $t(e, !0), n(o, i, a);
        } finally {
          $t(l, !1);
        }
      }
      function qo(e, n, o, i) {
        return typeof e != "function" ? e : function() {
          var a = oe;
          o && yn(), $t(n, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            $t(a, !1), i && queueMicrotask(Bt);
          }
        };
      }
      function $r(e) {
        Promise === Ue && Ge.echoes === 0 ? zn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + wt).indexOf("[native code]") === -1 && (yn = Bt = S);
      var $e = Z.reject, en = "￿", Dt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Uo = "String expected.", vn = [], er = "__dbnames", qr = "readonly", Ur = "readwrite";
      function tn(e, n) {
        return e ? n ? function() {
          return e.apply(this, arguments) && n.apply(this, arguments);
        } : e : n;
      }
      var Vo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function tr(e) {
        return typeof e != "string" || /\./.test(e) ? function(n) {
          return n;
        } : function(n) {
          return n[e] === void 0 && e in n && delete (n = at(n))[e], n;
        };
      }
      function Wo() {
        throw K.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function xe(e, n) {
        try {
          var o = Ho(e), i = Ho(n);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return n < e ? 1 : e < n ? -1 : 0;
            case "binary":
              return function(a, l) {
                for (var p = a.length, m = l.length, v = p < m ? p : m, b = 0; b < v; ++b) if (a[b] !== l[b]) return a[b] < l[b] ? -1 : 1;
                return p === m ? 0 : p < m ? -1 : 1;
              }(Go(e), Go(n));
            case "Array":
              return function(a, l) {
                for (var p = a.length, m = l.length, v = p < m ? p : m, b = 0; b < v; ++b) {
                  var O = xe(a[b], l[b]);
                  if (O !== 0) return O;
                }
                return p === m ? 0 : p < m ? -1 : 1;
              }(e, n);
          }
        } catch {
        }
        return NaN;
      }
      function Ho(e) {
        var n = typeof e;
        return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = jt(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function Go(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function nr(e, n, o) {
        var i = e.schema.yProps;
        return i ? (n && 0 < o.numFailures && (n = n.filter(function(a, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(a) {
          return a = a.updatesTable, n ? e.db.table(a).where("k").anyOf(n).delete() : e.db.table(a).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Yo = (Ie.prototype._trans = function(e, n, o) {
        var i = this._tx || oe.trans, a = this.name, l = ae && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(b, O, y) {
          if (!y.schema[a]) throw new K.NotFound("Table " + a + " not part of transaction");
          return n(y.idbtrans, y);
        }
        var m = hn();
        try {
          var v = i && i.db._novip === this.db._novip ? i === oe.trans ? i._promise(e, p, o) : Mt(function() {
            return i._promise(e, p, o);
          }, { trans: i, transless: oe.transless || oe }) : function b(O, y, N, g) {
            if (O.idbdb && (O._state.openComplete || oe.letThrough || O._vip)) {
              var w = O._createTransaction(y, N, O._dbSchema);
              try {
                w.create(), O._state.PR1398_maxLoop = 3;
              } catch (E) {
                return E.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                  return b(O, y, N, g);
                })) : $e(E);
              }
              return w._promise(y, function(E, T) {
                return Mt(function() {
                  return oe.trans = w, g(E, T, w);
                });
              }).then(function(E) {
                if (y === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return y === "readonly" ? E : w._completion.then(function() {
                  return E;
                });
              });
            }
            if (O._state.openComplete) return $e(new K.DatabaseClosed(O._state.dbOpenError));
            if (!O._state.isBeingOpened) {
              if (!O._state.autoOpen) return $e(new K.DatabaseClosed());
              O.open().catch(S);
            }
            return O._state.dbReadyPromise.then(function() {
              return b(O, y, N, g);
            });
          }(this.db, e, [this.name], p);
          return l && (v._consoleTask = l, v = v.catch(function(b) {
            return console.trace(b), $e(b);
          })), v;
        } finally {
          m && mn();
        }
      }, Ie.prototype.get = function(e, n) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(n) : e == null ? $e(new K.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(a) {
            return o.hook.reading.fire(a);
          });
        }).then(n);
      }, Ie.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (h(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var n = f(e);
        if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(m) {
          if (m.compound && n.every(function(b) {
            return 0 <= m.keyPath.indexOf(b);
          })) {
            for (var v = 0; v < n.length; ++v) if (n.indexOf(m.keyPath[v]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(m, v) {
          return m.keyPath.length - v.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== en) {
          var l = o.keyPath.slice(0, n.length);
          return this.where(l).equals(l.map(function(v) {
            return e[v];
          }));
        }
        !o && ae && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
        var i = this.schema.idxByName;
        function a(m, v) {
          return xe(m, v) === 0;
        }
        var p = n.reduce(function(y, v) {
          var b = y[0], O = y[1], y = i[v], N = e[v];
          return [b || y, b || !y ? tn(O, y && y.multi ? function(g) {
            return g = Pe(g, v), h(g) && g.some(function(w) {
              return a(N, w);
            });
          } : function(g) {
            return a(N, Pe(g, v));
          }) : O];
        }, [null, null]), l = p[0], p = p[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(p) : o ? this.filter(p) : this.where(n).equals("");
      }, Ie.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Ie.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Ie.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Ie.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Ie.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Ie.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Ie.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ie.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, h(e) ? "[".concat(e.join("+"), "]") : e));
      }, Ie.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ie.prototype.mapToClass = function(e) {
        var n, o = this.db, i = this.name;
        function a() {
          return n !== null && n.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Wo && (function(v, b) {
          if (typeof b != "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function O() {
            this.constructor = v;
          }
          s(v, b), v.prototype = b === null ? Object.create(b) : (O.prototype = b.prototype, new O());
        }(a, n = e), Object.defineProperty(a.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), a.prototype.table = function() {
          return i;
        }, e = a);
        for (var l = /* @__PURE__ */ new Set(), p = e.prototype; p; p = k(p)) Object.getOwnPropertyNames(p).forEach(function(v) {
          return l.add(v);
        });
        function m(v) {
          if (!v) return v;
          var b, O = Object.create(e.prototype);
          for (b in v) if (!l.has(b)) try {
            O[b] = v[b];
          } catch {
          }
          return O;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = m, this.hook("reading", m), e;
      }, Ie.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          _(this, e);
        });
      }, Ie.prototype.add = function(e, n) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, p = e;
        return l && a && (p = tr(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "add", keys: n != null ? [n] : null, values: [p] });
        }).then(function(m) {
          return m.numFailures ? Z.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            ue(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.update = function(e, n) {
        return typeof e != "object" || h(e) ? this.where(":id").equals(e).modify(n) : (e = Pe(e, this.schema.primKey.keyPath), e === void 0 ? $e(new K.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n));
      }, Ie.prototype.put = function(e, n) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, p = e;
        return l && a && (p = tr(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "put", values: [p], keys: n != null ? [n] : null });
        }).then(function(m) {
          return m.numFailures ? Z.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            ue(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.delete = function(e) {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return nr(n, [e], i);
          }).then(function(i) {
            return i.numFailures ? Z.reject(i.failures[0]) : void 0;
          });
        });
      }, Ie.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(n) {
          return e.core.mutate({ trans: n, type: "deleteRange", range: Vo }).then(function(o) {
            return nr(e, null, o);
          });
        }).then(function(n) {
          return n.numFailures ? Z.reject(n.failures[0]) : void 0;
        });
      }, Ie.prototype.bulkGet = function(e) {
        var n = this;
        return this._trans("readonly", function(o) {
          return n.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(a) {
              return n.hook.reading.fire(a);
            });
          });
        });
      }, Ie.prototype.bulkAdd = function(e, n, o) {
        var i = this, a = Array.isArray(n) ? n : void 0, l = (o = o || (a ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var b = i.schema.primKey, m = b.auto, b = b.keyPath;
          if (b && a) throw new K.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && m ? e.map(tr(b)) : e;
          return i.core.mutate({ trans: p, type: "add", keys: a, values: b, wantResults: l }).then(function(w) {
            var y = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (y === 0) return l ? N : g;
            throw new Nt("".concat(i.name, ".bulkAdd(): ").concat(y, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Ie.prototype.bulkPut = function(e, n, o) {
        var i = this, a = Array.isArray(n) ? n : void 0, l = (o = o || (a ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var b = i.schema.primKey, m = b.auto, b = b.keyPath;
          if (b && a) throw new K.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && m ? e.map(tr(b)) : e;
          return i.core.mutate({ trans: p, type: "put", keys: a, values: b, wantResults: l }).then(function(w) {
            var y = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (y === 0) return l ? N : g;
            throw new Nt("".concat(i.name, ".bulkPut(): ").concat(y, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Ie.prototype.bulkUpdate = function(e) {
        var n = this, o = this.core, i = e.map(function(p) {
          return p.key;
        }), a = e.map(function(p) {
          return p.changes;
        }), l = [];
        return this._trans("readwrite", function(p) {
          return o.getMany({ trans: p, keys: i, cache: "clone" }).then(function(m) {
            var v = [], b = [];
            e.forEach(function(y, N) {
              var g = y.key, w = y.changes, E = m[N];
              if (E) {
                for (var T = 0, C = Object.keys(w); T < C.length; T++) {
                  var R = C[T], P = w[R];
                  if (R === n.schema.primKey.keyPath) {
                    if (xe(P, g) !== 0) throw new K.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ue(E, R, P);
                }
                l.push(N), v.push(g), b.push(E);
              }
            });
            var O = v.length;
            return o.mutate({ trans: p, type: "put", keys: v, values: b, updates: { keys: i, changeSpecs: a } }).then(function(y) {
              var N = y.numFailures, g = y.failures;
              if (N === 0) return O;
              for (var w = 0, E = Object.keys(g); w < E.length; w++) {
                var T, C = E[w], R = l[Number(C)];
                R != null && (T = g[C], delete g[C], g[R] = T);
              }
              throw new Nt("".concat(n.name, ".bulkUpdate(): ").concat(N, " of ").concat(O, " operations failed"), g);
            });
          });
        });
      }, Ie.prototype.bulkDelete = function(e) {
        var n = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return n.core.mutate({ trans: i, type: "delete", keys: e }).then(function(a) {
            return nr(n, e, a);
          });
        }).then(function(p) {
          var a = p.numFailures, l = p.lastResult, p = p.failures;
          if (a === 0) return l;
          throw new Nt("".concat(n.name, ".bulkDelete(): ").concat(a, " of ").concat(o, " operations failed"), p);
        });
      }, Ie);
      function Ie() {
      }
      function An(e) {
        function n(p, m) {
          if (m) {
            for (var v = arguments.length, b = new Array(v - 1); --v; ) b[v - 1] = arguments[v];
            return o[p].subscribe.apply(null, b), e;
          }
          if (typeof p == "string") return o[p];
        }
        var o = {};
        n.addEventType = l;
        for (var i = 1, a = arguments.length; i < a; ++i) l(arguments[i]);
        return n;
        function l(p, m, v) {
          if (typeof p != "object") {
            var b;
            m = m || be;
            var O = { subscribers: [], fire: v = v || S, subscribe: function(y) {
              O.subscribers.indexOf(y) === -1 && (O.subscribers.push(y), O.fire = m(O.fire, y));
            }, unsubscribe: function(y) {
              O.subscribers = O.subscribers.filter(function(N) {
                return N !== y;
              }), O.fire = O.subscribers.reduce(m, v);
            } };
            return o[p] = n[p] = O;
          }
          f(b = p).forEach(function(y) {
            var N = b[y];
            if (h(N)) l(y, b[y][0], b[y][1]);
            else {
              if (N !== "asap") throw new K.InvalidArgument("Invalid event config");
              var g = l(y, M, function() {
                for (var w = arguments.length, E = new Array(w); w--; ) E[w] = arguments[w];
                g.subscribers.forEach(function(T) {
                  _e(function() {
                    T.apply(null, E);
                  });
                });
              });
            }
          });
        }
      }
      function Rn(e, n) {
        return Q(n).from({ prototype: e }), n;
      }
      function gn(e, n) {
        return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter);
      }
      function Vr(e, n) {
        e.filter = tn(e.filter, n);
      }
      function Wr(e, n, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return tn(i(), n());
        } : n, e.justLimit = o && !i;
      }
      function rr(e, n) {
        if (e.isPrimKey) return n.primaryKey;
        var o = n.getIndexByKeyPath(e.index);
        if (!o) throw new K.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
        return o;
      }
      function Qo(e, n, o) {
        var i = rr(e, n.schema);
        return n.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function or(e, n, o, i) {
        var a = e.replayFilter ? tn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, p = function(m, v, b) {
            var O, y;
            a && !a(v, b, function(N) {
              return v.stop(N);
            }, function(N) {
              return v.fail(N);
            }) || ((y = "" + (O = v.primaryKey)) == "[object ArrayBuffer]" && (y = "" + new Uint8Array(O)), j(l, y) || (l[y] = !0, n(m, v, b)));
          };
          return Promise.all([e.or._iterate(p, o), Xo(Qo(e, i, o), e.algorithm, p, !e.keysOnly && e.valueMapper)]);
        }
        return Xo(Qo(e, i, o), tn(e.algorithm, a), n, !e.keysOnly && e.valueMapper);
      }
      function Xo(e, n, o, i) {
        var a = Le(i ? function(l, p, m) {
          return o(i(l), p, m);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var p = function() {
              return l.continue();
            };
            n && !n(l, function(m) {
              return p = m;
            }, function(m) {
              l.stop(m), p = S;
            }, function(m) {
              l.fail(m), p = S;
            }) || a(l.value, l, function(m) {
              return p = m;
            }), p();
          });
        });
      }
      var Dn = (zo.prototype.execute = function(e) {
        var n = this["@@propmod"];
        if (n.add !== void 0) {
          var o = n.add;
          if (h(o)) return c(c([], h(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (n.remove !== void 0) {
          var i = n.remove;
          if (h(i)) return h(e) ? e.filter(function(a) {
            return !i.includes(a);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = n.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? n.replacePrefix[1] + e.substring(o.length) : e;
      }, zo);
      function zo(e) {
        this["@@propmod"] = e;
      }
      var Ns = (Ne.prototype._read = function(e, n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, $e.bind(null, o.error)) : o.table._trans("readonly", e).then(n);
      }, Ne.prototype._write = function(e) {
        var n = this._ctx;
        return n.error ? n.table._trans(null, $e.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
      }, Ne.prototype._addAlgorithm = function(e) {
        var n = this._ctx;
        n.algorithm = tn(n.algorithm, e);
      }, Ne.prototype._iterate = function(e, n) {
        return or(this._ctx, e, n, this._ctx.table.core);
      }, Ne.prototype.clone = function(e) {
        var n = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && _(o, e), n._ctx = o, n;
      }, Ne.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ne.prototype.each = function(e) {
        var n = this._ctx;
        return this._read(function(o) {
          return or(n, e, o, n.table.core);
        });
      }, Ne.prototype.count = function(e) {
        var n = this;
        return this._read(function(o) {
          var i = n._ctx, a = i.table.core;
          if (gn(i, !0)) return a.count({ trans: o, query: { index: rr(i, a.schema), range: i.range } }).then(function(p) {
            return Math.min(p, i.limit);
          });
          var l = 0;
          return or(i, function() {
            return ++l, !1;
          }, o, a).then(function() {
            return l;
          });
        }).then(e);
      }, Ne.prototype.sortBy = function(e, n) {
        var o = e.split(".").reverse(), i = o[0], a = o.length - 1;
        function l(v, b) {
          return b ? l(v[o[b]], b - 1) : v[i];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function m(v, b) {
          return xe(l(v, a), l(b, a)) * p;
        }
        return this.toArray(function(v) {
          return v.sort(m);
        }).then(n);
      }, Ne.prototype.toArray = function(e) {
        var n = this;
        return this._read(function(o) {
          var i = n._ctx;
          if (i.dir === "next" && gn(i, !0) && 0 < i.limit) {
            var a = i.valueMapper, l = rr(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(m) {
              return m = m.result, a ? m.map(a) : m;
            });
          }
          var p = [];
          return or(i, function(m) {
            return p.push(m);
          }, o, i.table.core).then(function() {
            return p;
          });
        }, e);
      }, Ne.prototype.offset = function(e) {
        var n = this._ctx;
        return e <= 0 || (n.offset += e, gn(n) ? Wr(n, function() {
          var o = e;
          return function(i, a) {
            return o === 0 || (o === 1 ? --o : a(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : Wr(n, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Ne.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Wr(this._ctx, function() {
          var n = e;
          return function(o, i, a) {
            return --n <= 0 && i(a), 0 <= n;
          };
        }, !0), this;
      }, Ne.prototype.until = function(e, n) {
        return Vr(this._ctx, function(o, i, a) {
          return !e(o.value) || (i(a), n);
        }), this;
      }, Ne.prototype.first = function(e) {
        return this.limit(1).toArray(function(n) {
          return n[0];
        }).then(e);
      }, Ne.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Ne.prototype.filter = function(e) {
        var n;
        return Vr(this._ctx, function(o) {
          return e(o.value);
        }), (n = this._ctx).isMatch = tn(n.isMatch, e), this;
      }, Ne.prototype.and = function(e) {
        return this.filter(e);
      }, Ne.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Ne.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ne.prototype.desc = function() {
        return this.reverse();
      }, Ne.prototype.eachKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, Ne.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Ne.prototype.eachPrimaryKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, Ne.prototype.keys = function(e) {
        var n = this._ctx;
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Ne.prototype.primaryKeys = function(e) {
        var n = this._ctx;
        if (n.dir === "next" && gn(n, !0) && 0 < n.limit) return this._read(function(i) {
          var a = rr(n, n.table.core.schema);
          return n.table.core.query({ trans: i, values: !1, limit: n.limit, query: { index: a, range: n.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Ne.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Ne.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(n) {
          return n[0];
        }).then(e);
      }, Ne.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Ne.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var n = {};
        return Vr(this._ctx, function(a) {
          var i = a.primaryKey.toString(), a = j(n, i);
          return n[i] = !0, !a;
        }), this;
      }, Ne.prototype.modify = function(e) {
        var n = this, o = this._ctx;
        return this._write(function(i) {
          var a, l, p;
          p = typeof e == "function" ? e : (a = f(e), l = a.length, function(C) {
            for (var R = !1, P = 0; P < l; ++P) {
              var I = a[P], U = e[I], X = Pe(C, I);
              U instanceof Dn ? (ue(C, I, U.execute(X)), R = !0) : X !== U && (ue(C, I, U), R = !0);
            }
            return R;
          });
          var m = o.table.core, y = m.schema.primaryKey, v = y.outbound, b = y.extractKey, O = 200, y = n.db._options.modifyChunkSize;
          y && (O = typeof y == "object" ? y[m.name] || y["*"] || 200 : y);
          function N(C, I) {
            var P = I.failures, I = I.numFailures;
            w += C - I;
            for (var U = 0, X = f(P); U < X.length; U++) {
              var V = X[U];
              g.push(P[V]);
            }
          }
          var g = [], w = 0, E = [], T = e === Jo;
          return n.clone().primaryKeys().then(function(C) {
            function R(I) {
              var U = Math.min(O, C.length - I), X = C.slice(I, I + U);
              return (T ? Promise.resolve([]) : m.getMany({ trans: i, keys: X, cache: "immutable" })).then(function(V) {
                var Y = [], J = [], z = v ? [] : null, te = T ? X : [];
                if (!T) for (var ge = 0; ge < U; ++ge) {
                  var Oe = V[ge], me = { value: at(Oe), primKey: C[I + ge] };
                  p.call(me, me.value, me) !== !1 && (me.value == null ? te.push(C[I + ge]) : v || xe(b(Oe), b(me.value)) === 0 ? (J.push(me.value), v && z.push(C[I + ge])) : (te.push(C[I + ge]), Y.push(me.value)));
                }
                return Promise.resolve(0 < Y.length && m.mutate({ trans: i, type: "add", values: Y }).then(function(Fe) {
                  for (var he in Fe.failures) te.splice(parseInt(he), 1);
                  N(Y.length, Fe);
                })).then(function() {
                  return (0 < J.length || P && typeof e == "object") && m.mutate({ trans: i, type: "put", keys: z, values: J, criteria: P, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < I }).then(function(Fe) {
                    return N(J.length, Fe);
                  });
                }).then(function() {
                  return (0 < te.length || P && T) && m.mutate({ trans: i, type: "delete", keys: te, criteria: P, isAdditionalChunk: 0 < I }).then(function(Fe) {
                    return nr(o.table, te, Fe);
                  }).then(function(Fe) {
                    return N(te.length, Fe);
                  });
                }).then(function() {
                  return C.length > I + U && R(I + O);
                });
              });
            }
            var P = gn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return R(0).then(function() {
              if (0 < g.length) throw new fn("Error modifying one or more objects", g, w, E);
              return C.length;
            });
          });
        });
      }, Ne.prototype.delete = function() {
        var e = this._ctx, n = e.range;
        return !gn(e) || e.table.schema.yProps || !e.isPrimKey && n.type !== 3 ? this.modify(Jo) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, a = n;
          return e.table.core.count({ trans: o, query: { index: i, range: a } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: a }).then(function(v) {
              var m = v.failures, v = v.numFailures;
              if (v) throw new fn("Could not delete some values", Object.keys(m).map(function(b) {
                return m[b];
              }), l - v);
              return l - v;
            });
          });
        });
      }, Ne);
      function Ne() {
      }
      var Jo = function(e, n) {
        return n.value = null;
      };
      function Cs(e, n) {
        return e < n ? -1 : e === n ? 0 : 1;
      }
      function Ss(e, n) {
        return n < e ? -1 : e === n ? 0 : 1;
      }
      function pt(e, n, o) {
        return e = e instanceof ei ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(n), e;
      }
      function bn(e) {
        return new e.Collection(e, function() {
          return Zo("");
        }).limit(0);
      }
      function ir(e, n, o, i) {
        var a, l, p, m, v, b, O, y = o.length;
        if (!o.every(function(w) {
          return typeof w == "string";
        })) return pt(e, Uo);
        function N(w) {
          a = w === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = w === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, p = w === "next" ? Cs : Ss;
          var E = o.map(function(T) {
            return { lower: l(T), upper: a(T) };
          }).sort(function(T, C) {
            return p(T.lower, C.lower);
          });
          m = E.map(function(T) {
            return T.upper;
          }), v = E.map(function(T) {
            return T.lower;
          }), O = (b = w) === "next" ? "" : i;
        }
        N("next"), e = new e.Collection(e, function() {
          return qt(m[0], v[y - 1] + i);
        }), e._ondirectionchange = function(w) {
          N(w);
        };
        var g = 0;
        return e._addAlgorithm(function(w, E, T) {
          var C = w.key;
          if (typeof C != "string") return !1;
          var R = l(C);
          if (n(R, v, g)) return !0;
          for (var P = null, I = g; I < y; ++I) {
            var U = function(X, V, Y, J, z, te) {
              for (var ge = Math.min(X.length, J.length), Oe = -1, me = 0; me < ge; ++me) {
                var Fe = V[me];
                if (Fe !== J[me]) return z(X[me], Y[me]) < 0 ? X.substr(0, me) + Y[me] + Y.substr(me + 1) : z(X[me], J[me]) < 0 ? X.substr(0, me) + J[me] + Y.substr(me + 1) : 0 <= Oe ? X.substr(0, Oe) + V[Oe] + Y.substr(Oe + 1) : null;
                z(X[me], Fe) < 0 && (Oe = me);
              }
              return ge < J.length && te === "next" ? X + Y.substr(X.length) : ge < X.length && te === "prev" ? X.substr(0, Y.length) : Oe < 0 ? null : X.substr(0, Oe) + J[Oe] + Y.substr(Oe + 1);
            }(C, R, m[I], v[I], p, b);
            U === null && P === null ? g = I + 1 : (P === null || 0 < p(P, U)) && (P = U);
          }
          return E(P !== null ? function() {
            w.continue(P + O);
          } : T), !1;
        }), e;
      }
      function qt(e, n, o, i) {
        return { type: 2, lower: e, upper: n, lowerOpen: o, upperOpen: i };
      }
      function Zo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var ei = (Object.defineProperty(Ye.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Ye.prototype.between = function(e, n, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (o || i) && (!o || !i) ? bn(this) : new this.Collection(this, function() {
            return qt(e, n, !o, !i);
          });
        } catch {
          return pt(this, Dt);
        }
      }, Ye.prototype.equals = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return Zo(e);
        });
      }, Ye.prototype.above = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(e, void 0, !0);
        });
      }, Ye.prototype.aboveOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(e, void 0, !1);
        });
      }, Ye.prototype.below = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(void 0, e, !1, !0);
        });
      }, Ye.prototype.belowOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(void 0, e);
        });
      }, Ye.prototype.startsWith = function(e) {
        return typeof e != "string" ? pt(this, Uo) : this.between(e, e + en, !0, !0);
      }, Ye.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : ir(this, function(n, o) {
          return n.indexOf(o[0]) === 0;
        }, [e], en);
      }, Ye.prototype.equalsIgnoreCase = function(e) {
        return ir(this, function(n, o) {
          return n === o[0];
        }, [e], "");
      }, Ye.prototype.anyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? bn(this) : ir(this, function(n, o) {
          return o.indexOf(n) !== -1;
        }, e, "");
      }, Ye.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? bn(this) : ir(this, function(n, o) {
          return o.some(function(i) {
            return n.indexOf(i) === 0;
          });
        }, e, en);
      }, Ye.prototype.anyOf = function() {
        var e = this, n = ct.apply(bt, arguments), o = this._cmp;
        try {
          n.sort(o);
        } catch {
          return pt(this, Dt);
        }
        if (n.length === 0) return bn(this);
        var i = new this.Collection(this, function() {
          return qt(n[0], n[n.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, n.sort(o);
        };
        var a = 0;
        return i._addAlgorithm(function(l, p, m) {
          for (var v = l.key; 0 < o(v, n[a]); ) if (++a === n.length) return p(m), !1;
          return o(v, n[a]) === 0 || (p(function() {
            l.continue(n[a]);
          }), !1);
        }), i;
      }, Ye.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.noneOf = function() {
        var e = ct.apply(bt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return pt(this, Dt);
        }
        var n = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.inAnyRange = function(C, n) {
        var o = this, i = this._cmp, a = this._ascending, l = this._descending, p = this._min, m = this._max;
        if (C.length === 0) return bn(this);
        if (!C.every(function(R) {
          return R[0] !== void 0 && R[1] !== void 0 && a(R[0], R[1]) <= 0;
        })) return pt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", K.InvalidArgument);
        var v = !n || n.includeLowers !== !1, b = n && n.includeUppers === !0, O, y = a;
        function N(R, P) {
          return y(R[0], P[0]);
        }
        try {
          (O = C.reduce(function(R, P) {
            for (var I = 0, U = R.length; I < U; ++I) {
              var X = R[I];
              if (i(P[0], X[1]) < 0 && 0 < i(P[1], X[0])) {
                X[0] = p(X[0], P[0]), X[1] = m(X[1], P[1]);
                break;
              }
            }
            return I === U && R.push(P), R;
          }, [])).sort(N);
        } catch {
          return pt(this, Dt);
        }
        var g = 0, w = b ? function(R) {
          return 0 < a(R, O[g][1]);
        } : function(R) {
          return 0 <= a(R, O[g][1]);
        }, E = v ? function(R) {
          return 0 < l(R, O[g][0]);
        } : function(R) {
          return 0 <= l(R, O[g][0]);
        }, T = w, C = new this.Collection(this, function() {
          return qt(O[0][0], O[O.length - 1][1], !v, !b);
        });
        return C._ondirectionchange = function(R) {
          y = R === "next" ? (T = w, a) : (T = E, l), O.sort(N);
        }, C._addAlgorithm(function(R, P, I) {
          for (var U, X = R.key; T(X); ) if (++g === O.length) return P(I), !1;
          return !w(U = X) && !E(U) || (o._cmp(X, O[g][1]) === 0 || o._cmp(X, O[g][0]) === 0 || P(function() {
            y === a ? R.continue(O[g][0]) : R.continue(O[g][1]);
          }), !1);
        }), C;
      }, Ye.prototype.startsWithAnyOf = function() {
        var e = ct.apply(bt, arguments);
        return e.every(function(n) {
          return typeof n == "string";
        }) ? e.length === 0 ? bn(this) : this.inAnyRange(e.map(function(n) {
          return [n, n + en];
        })) : pt(this, "startsWithAnyOf() only works with strings");
      }, Ye);
      function Ye() {
      }
      function Ct(e) {
        return Le(function(n) {
          return Pn(n), e(n.target.error), !1;
        });
      }
      function Pn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var In = "storagemutated", Hr = "x-storagemutated-1", Ut = An(null, In), As = (St.prototype._lock = function() {
        return fe(!oe.global), ++this._reculock, this._reculock !== 1 || oe.global || (oe.lockOwnerFor = this), this;
      }, St.prototype._unlock = function() {
        if (fe(!oe.global), --this._reculock == 0) for (oe.global || (oe.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            Zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, St.prototype._locked = function() {
        return this._reculock && oe.lockOwnerFor !== this;
      }, St.prototype.create = function(e) {
        var n = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (fe(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new K.DatabaseClosed(i);
          case "MissingAPIError":
            throw new K.MissingAPI(i.message, i);
          default:
            throw new K.OpenFailed(i);
        }
        if (!this.active) throw new K.TransactionInactive();
        return fe(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Le(function(a) {
          Pn(a), n._reject(e.error);
        }), e.onabort = Le(function(a) {
          Pn(a), n.active && n._reject(new K.Abort(e.error)), n.active = !1, n.on("abort").fire(a);
        }), e.oncomplete = Le(function() {
          n.active = !1, n._resolve(), "mutatedParts" in e && Ut.storagemutated.fire(e.mutatedParts);
        }), this;
      }, St.prototype._promise = function(e, n, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return $e(new K.ReadOnly("Transaction is readonly"));
        if (!this.active) return $e(new K.TransactionInactive());
        if (this._locked()) return new Z(function(l, p) {
          i._blockedFuncs.push([function() {
            i._promise(e, n, o).then(l, p);
          }, oe]);
        });
        if (o) return Mt(function() {
          var l = new Z(function(p, m) {
            i._lock();
            var v = n(p, m, i);
            v && v.then && v.then(p, m);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var a = new Z(function(l, p) {
          var m = n(l, p, i);
          m && m.then && m.then(l, p);
        });
        return a._lib = !0, a;
      }, St.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, St.prototype.waitFor = function(e) {
        var n, o = this._root(), i = Z.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], n = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (n.get(-1 / 0).onsuccess = l);
        }());
        var a = o._waitingFor;
        return new Z(function(l, p) {
          i.then(function(m) {
            return o._waitingQueue.push(Le(l.bind(null, m)));
          }, function(m) {
            return o._waitingQueue.push(Le(p.bind(null, m)));
          }).finally(function() {
            o._waitingFor === a && (o._waitingFor = null);
          });
        });
      }, St.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new K.Abort()));
      }, St.prototype.table = function(e) {
        var n = this._memoizedTables || (this._memoizedTables = {});
        if (j(n, e)) return n[e];
        var o = this.schema[e];
        if (!o) throw new K.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), n[e] = o;
      }, St);
      function St() {
      }
      function Gr(e, n, o, i, a, l, p, m) {
        return { name: e, keyPath: n, unique: o, multi: i, auto: a, compound: l, src: (o && !p ? "&" : "") + (i ? "*" : "") + (a ? "++" : "") + ti(n), type: m };
      }
      function ti(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Yr(e, n, o) {
        return { name: e, primKey: n, indexes: o, mappedClass: null, idxByName: (i = function(a) {
          return [a.name, a];
        }, o.reduce(function(a, l, p) {
          return p = i(l, p), p && (a[p[0]] = p[1]), a;
        }, {})) };
        var i;
      }
      var kn = function(e) {
        try {
          return e.only([[]]), kn = function() {
            return [[]];
          }, [[]];
        } catch {
          return kn = function() {
            return en;
          }, en;
        }
      };
      function Qr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (n = e).split(".").length === 1 ? function(o) {
          return o[n];
        } : function(o) {
          return Pe(o, n);
        } : function(o) {
          return Pe(o, e);
        };
        var n;
      }
      function ni(e) {
        return [].slice.call(e);
      }
      var Rs = 0;
      function jn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Ds(e, n, v) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var g = T.lower, w = T.upper, E = T.lowerOpen, T = T.upperOpen;
          return g === void 0 ? w === void 0 ? null : n.upperBound(w, !!T) : w === void 0 ? n.lowerBound(g, !!E) : n.bound(g, w, !!E, !!T);
        }
        function a(N) {
          var g, w = N.name;
          return { name: w, schema: N, mutate: function(E) {
            var T = E.trans, C = E.type, R = E.keys, P = E.values, I = E.range;
            return new Promise(function(U, X) {
              U = Le(U);
              var V = T.objectStore(w), Y = V.keyPath == null, J = C === "put" || C === "add";
              if (!J && C !== "delete" && C !== "deleteRange") throw new Error("Invalid operation type: " + C);
              var z, te = (R || P || { length: 1 }).length;
              if (R && P && R.length !== P.length) throw new Error("Given keys array must have same length as given values array.");
              if (te === 0) return U({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ge(it) {
                ++Fe, Pn(it);
              }
              var Oe = [], me = [], Fe = 0;
              if (C === "deleteRange") {
                if (I.type === 4) return U({ numFailures: Fe, failures: me, results: [], lastResult: void 0 });
                I.type === 3 ? Oe.push(z = V.clear()) : Oe.push(z = V.delete(i(I)));
              } else {
                var Y = J ? Y ? [P, R] : [P, null] : [R, null], he = Y[0], Je = Y[1];
                if (J) for (var Ze = 0; Ze < te; ++Ze) Oe.push(z = Je && Je[Ze] !== void 0 ? V[C](he[Ze], Je[Ze]) : V[C](he[Ze])), z.onerror = ge;
                else for (Ze = 0; Ze < te; ++Ze) Oe.push(z = V[C](he[Ze])), z.onerror = ge;
              }
              function vr(it) {
                it = it.target.result, Oe.forEach(function(on, ho) {
                  return on.error != null && (me[ho] = on.error);
                }), U({ numFailures: Fe, failures: me, results: C === "delete" ? R : Oe.map(function(on) {
                  return on.result;
                }), lastResult: it });
              }
              z.onerror = function(it) {
                ge(it), vr(it);
              }, z.onsuccess = vr;
            });
          }, getMany: function(E) {
            var T = E.trans, C = E.keys;
            return new Promise(function(R, P) {
              R = Le(R);
              for (var I, U = T.objectStore(w), X = C.length, V = new Array(X), Y = 0, J = 0, z = function(Oe) {
                Oe = Oe.target, V[Oe._pos] = Oe.result, ++J === Y && R(V);
              }, te = Ct(P), ge = 0; ge < X; ++ge) C[ge] != null && ((I = U.get(C[ge]))._pos = ge, I.onsuccess = z, I.onerror = te, ++Y);
              Y === 0 && R(V);
            });
          }, get: function(E) {
            var T = E.trans, C = E.key;
            return new Promise(function(R, P) {
              R = Le(R);
              var I = T.objectStore(w).get(C);
              I.onsuccess = function(U) {
                return R(U.target.result);
              }, I.onerror = Ct(P);
            });
          }, query: (g = b, function(E) {
            return new Promise(function(T, C) {
              T = Le(T);
              var R, P, I, Y = E.trans, U = E.values, X = E.limit, z = E.query, V = X === 1 / 0 ? void 0 : X, J = z.index, z = z.range, Y = Y.objectStore(w), J = J.isPrimaryKey ? Y : Y.index(J.name), z = i(z);
              if (X === 0) return T({ result: [] });
              g ? ((V = U ? J.getAll(z, V) : J.getAllKeys(z, V)).onsuccess = function(te) {
                return T({ result: te.target.result });
              }, V.onerror = Ct(C)) : (R = 0, P = !U && "openKeyCursor" in J ? J.openKeyCursor(z) : J.openCursor(z), I = [], P.onsuccess = function(te) {
                var ge = P.result;
                return ge ? (I.push(U ? ge.value : ge.primaryKey), ++R === X ? T({ result: I }) : void ge.continue()) : T({ result: I });
              }, P.onerror = Ct(C));
            });
          }), openCursor: function(E) {
            var T = E.trans, C = E.values, R = E.query, P = E.reverse, I = E.unique;
            return new Promise(function(U, X) {
              U = Le(U);
              var J = R.index, V = R.range, Y = T.objectStore(w), Y = J.isPrimaryKey ? Y : Y.index(J.name), J = P ? I ? "prevunique" : "prev" : I ? "nextunique" : "next", z = !C && "openKeyCursor" in Y ? Y.openKeyCursor(i(V), J) : Y.openCursor(i(V), J);
              z.onerror = Ct(X), z.onsuccess = Le(function(te) {
                var ge, Oe, me, Fe, he = z.result;
                he ? (he.___id = ++Rs, he.done = !1, ge = he.continue.bind(he), Oe = (Oe = he.continuePrimaryKey) && Oe.bind(he), me = he.advance.bind(he), Fe = function() {
                  throw new Error("Cursor not stopped");
                }, he.trans = T, he.stop = he.continue = he.continuePrimaryKey = he.advance = function() {
                  throw new Error("Cursor not started");
                }, he.fail = Le(X), he.next = function() {
                  var Je = this, Ze = 1;
                  return this.start(function() {
                    return Ze-- ? Je.continue() : Je.stop();
                  }).then(function() {
                    return Je;
                  });
                }, he.start = function(Je) {
                  function Ze() {
                    if (z.result) try {
                      Je();
                    } catch (it) {
                      he.fail(it);
                    }
                    else he.done = !0, he.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, he.stop();
                  }
                  var vr = new Promise(function(it, on) {
                    it = Le(it), z.onerror = Ct(on), he.fail = on, he.stop = function(ho) {
                      he.stop = he.continue = he.continuePrimaryKey = he.advance = Fe, it(ho);
                    };
                  });
                  return z.onsuccess = Le(function(it) {
                    z.onsuccess = Ze, Ze();
                  }), he.continue = ge, he.continuePrimaryKey = Oe, he.advance = me, Ze(), vr;
                }, U(he)) : U(null);
              }, X);
            });
          }, count: function(E) {
            var T = E.query, C = E.trans, R = T.index, P = T.range;
            return new Promise(function(I, U) {
              var X = C.objectStore(w), V = R.isPrimaryKey ? X : X.index(R.name), X = i(P), V = X ? V.count(X) : V.count();
              V.onsuccess = Le(function(Y) {
                return I(Y.target.result);
              }), V.onerror = Ct(U);
            });
          } };
        }
        var l, p, m, O = (p = v, m = ni((l = e).objectStoreNames), { schema: { name: l.name, tables: m.map(function(N) {
          return p.objectStore(N);
        }).map(function(N) {
          var g = N.keyPath, T = N.autoIncrement, w = h(g), E = {}, T = { name: N.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g == null, compound: w, keyPath: g, autoIncrement: T, unique: !0, extractKey: Qr(g) }, indexes: ni(N.indexNames).map(function(C) {
            return N.index(C);
          }).map(function(I) {
            var R = I.name, P = I.unique, U = I.multiEntry, I = I.keyPath, U = { name: R, compound: h(I), keyPath: I, unique: P, multiEntry: U, extractKey: Qr(I) };
            return E[jn(I)] = U;
          }), getIndexByKeyPath: function(C) {
            return E[jn(C)];
          } };
          return E[":id"] = T.primaryKey, g != null && (E[jn(g)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < m.length && "getAll" in p.objectStore(m[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), v = O.schema, b = O.hasGetAll, O = v.tables.map(a), y = {};
        return O.forEach(function(N) {
          return y[N.name] = N;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(N) {
          if (!y[N]) throw new Error("Table '".concat(N, "' not found"));
          return y[N];
        }, MIN_KEY: -1 / 0, MAX_KEY: kn(n), schema: v };
      }
      function Ps(e, n, o, i) {
        var a = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = Ds(n, a, i), e.dbcore.reduce(function(l, p) {
          return p = p.create, u(u({}, l), p(l));
        }, i)) };
      }
      function sr(e, i) {
        var o = i.db, i = Ps(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(a) {
          var l = a.name;
          e.core.schema.tables.some(function(p) {
            return p.name === l;
          }) && (a.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = a.core));
        });
      }
      function ar(e, n, o, i) {
        o.forEach(function(a) {
          var l = i[a];
          n.forEach(function(p) {
            var m = function v(b, O) {
              return W(b, O) || (b = k(b)) && v(b, O);
            }(p, a);
            (!m || "value" in m && m.value === void 0) && (p === e.Transaction.prototype || p instanceof e.Transaction ? re(p, a, { get: function() {
              return this.table(a);
            }, set: function(v) {
              ee(this, a, { value: v, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[a] = new e.Table(a, l));
          });
        });
      }
      function Xr(e, n) {
        n.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function Is(e, n) {
        return e._cfg.version - n._cfg.version;
      }
      function ks(e, n, o, i) {
        var a = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !a.$meta && (a.$meta = Yr("$meta", oi("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, a);
        l.create(o), l._completion.catch(i);
        var p = l._reject.bind(l), m = oe.transless || oe;
        Mt(function() {
          return oe.trans = l, oe.transless = m, n !== 0 ? (sr(e, o), b = n, ((v = l).storeNames.includes("$meta") ? v.table("$meta").get("version").then(function(O) {
            return O ?? b;
          }) : Z.resolve(b)).then(function(O) {
            return N = O, g = l, w = o, E = [], O = (y = e)._versions, T = y._dbSchema = lr(0, y.idbdb, w), (O = O.filter(function(C) {
              return C._cfg.version >= N;
            })).length !== 0 ? (O.forEach(function(C) {
              E.push(function() {
                var R = T, P = C._cfg.dbschema;
                cr(y, R, w), cr(y, P, w), T = y._dbSchema = P;
                var I = zr(R, P);
                I.add.forEach(function(J) {
                  Jr(w, J[0], J[1].primKey, J[1].indexes);
                }), I.change.forEach(function(J) {
                  if (J.recreate) throw new K.Upgrade("Not yet support for changing primary key");
                  var z = w.objectStore(J.name);
                  J.add.forEach(function(te) {
                    return ur(z, te);
                  }), J.change.forEach(function(te) {
                    z.deleteIndex(te.name), ur(z, te);
                  }), J.del.forEach(function(te) {
                    return z.deleteIndex(te);
                  });
                });
                var U = C._cfg.contentUpgrade;
                if (U && C._cfg.version > N) {
                  sr(y, w), g._memoizedTables = {};
                  var X = de(P);
                  I.del.forEach(function(J) {
                    X[J] = R[J];
                  }), Xr(y, [y.Transaction.prototype]), ar(y, [y.Transaction.prototype], f(X), X), g.schema = X;
                  var V, Y = xt(U);
                  return Y && yn(), I = Z.follow(function() {
                    var J;
                    (V = U(g)) && Y && (J = Bt.bind(null, null), V.then(J, J));
                  }), V && typeof V.then == "function" ? Z.resolve(V) : I.then(function() {
                    return V;
                  });
                }
              }), E.push(function(R) {
                var P, I, U = C._cfg.dbschema;
                P = U, I = R, [].slice.call(I.db.objectStoreNames).forEach(function(X) {
                  return P[X] == null && I.db.deleteObjectStore(X);
                }), Xr(y, [y.Transaction.prototype]), ar(y, [y.Transaction.prototype], y._storeNames, y._dbSchema), g.schema = y._dbSchema;
              }), E.push(function(R) {
                y.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(y.idbdb.version / 10) === C._cfg.version ? (y.idbdb.deleteObjectStore("$meta"), delete y._dbSchema.$meta, y._storeNames = y._storeNames.filter(function(P) {
                  return P !== "$meta";
                })) : R.objectStore("$meta").put(C._cfg.version, "version"));
              });
            }), function C() {
              return E.length ? Z.resolve(E.shift()(g.idbtrans)).then(C) : Z.resolve();
            }().then(function() {
              ri(T, w);
            })) : Z.resolve();
            var y, N, g, w, E, T;
          }).catch(p)) : (f(a).forEach(function(O) {
            Jr(o, O, a[O].primKey, a[O].indexes);
          }), sr(e, o), void Z.follow(function() {
            return e.on.populate.fire(l);
          }).catch(p));
          var v, b;
        });
      }
      function js(e, n) {
        ri(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
        var o = lr(0, e.idbdb, n);
        cr(e, e._dbSchema, n);
        for (var i = 0, a = zr(o, e._dbSchema).change; i < a.length; i++) {
          var l = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var m = n.objectStore(p.name);
            p.add.forEach(function(v) {
              ae && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(v.src)), ur(m, v);
            });
          }(a[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function zr(e, n) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) n[o] || i.del.push(o);
        for (o in n) {
          var a = e[o], l = n[o];
          if (a) {
            var p = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (a.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || a.primKey.auto !== l.primKey.auto) p.recreate = !0, i.change.push(p);
            else {
              var m = a.idxByName, v = l.idxByName, b = void 0;
              for (b in m) v[b] || p.del.push(b);
              for (b in v) {
                var O = m[b], y = v[b];
                O ? O.src !== y.src && p.change.push(y) : p.add.push(y);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && i.change.push(p);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Jr(e, n, o, i) {
        var a = e.db.createObjectStore(n, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return ur(a, l);
        }), a;
      }
      function ri(e, n) {
        f(e).forEach(function(o) {
          n.db.objectStoreNames.contains(o) || (ae && console.debug("Dexie: Creating missing table", o), Jr(n, o, e[o].primKey, e[o].indexes));
        });
      }
      function ur(e, n) {
        e.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi });
      }
      function lr(e, n, o) {
        var i = {};
        return $(n.objectStoreNames, 0).forEach(function(a) {
          for (var l = o.objectStore(a), p = Gr(ti(b = l.keyPath), b || "", !0, !1, !!l.autoIncrement, b && typeof b != "string", !0), m = [], v = 0; v < l.indexNames.length; ++v) {
            var O = l.index(l.indexNames[v]), b = O.keyPath, O = Gr(O.name, b, !!O.unique, !!O.multiEntry, !1, b && typeof b != "string", !1);
            m.push(O);
          }
          i[a] = Yr(a, p, m);
        }), i;
      }
      function cr(e, n, o) {
        for (var i = o.db.objectStoreNames, a = 0; a < i.length; ++a) {
          var l = i[a], p = o.objectStore(l);
          e._hasGetAll = "getAll" in p;
          for (var m = 0; m < p.indexNames.length; ++m) {
            var v = p.indexNames[m], b = p.index(v).keyPath, O = typeof b == "string" ? b : "[" + $(b).join("+") + "]";
            !n[l] || (b = n[l].idxByName[O]) && (b.name = v, delete n[l].idxByName[O], n[l].idxByName[v] = b);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && d.WorkerGlobalScope && d instanceof d.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function oi(e) {
        return e.split(",").map(function(n, o) {
          var l = n.split(":"), i = (a = l[1]) === null || a === void 0 ? void 0 : a.trim(), a = (n = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(a) ? a.match(/^\[(.*)\]$/)[1].split("+") : a;
          return Gr(a, l || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), h(l), o === 0, i);
        });
      }
      var Ls = (wn.prototype._createTableSchema = Yr, wn.prototype._parseIndexSyntax = oi, wn.prototype._parseStoresSpec = function(e, n) {
        var o = this;
        f(e).forEach(function(i) {
          if (e[i] !== null) {
            var a = o._parseIndexSyntax(e[i]), l = a.shift();
            if (!l) throw new K.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new K.Schema("Primary key cannot be multiEntry*");
            a.forEach(function(p) {
              if (p.auto) throw new K.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new K.Schema("Index must have a name and cannot be an empty string");
            }), a = o._createTableSchema(i, l, a), n[i] = a;
          }
        });
      }, wn.prototype.stores = function(o) {
        var n = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? _(this._cfg.storesSource, o) : o;
        var o = n._versions, i = {}, a = {};
        return o.forEach(function(l) {
          _(i, l._cfg.storesSource), a = l._cfg.dbschema = {}, l._parseStoresSpec(i, a);
        }), n._dbSchema = a, Xr(n, [n._allTables, n, n.Transaction.prototype]), ar(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], f(a), a), n._storeNames = f(a), this;
      }, wn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = pe(this._cfg.contentUpgrade || S, e), this;
      }, wn);
      function wn() {
      }
      function Zr(e, n) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Pt(er, { addons: [], indexedDB: e, IDBKeyRange: n })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function eo(e) {
        return e && typeof e.databases == "function";
      }
      function to(e) {
        return Mt(function() {
          return oe.letThrough = !0, e();
        });
      }
      function no(e) {
        return !("from" in e);
      }
      var ze = function(e, n) {
        if (!this) {
          var o = new ze();
          return e && "d" in e && _(o, e), o;
        }
        _(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? n : e } : { d: 0 });
      };
      function Ln(e, n, o) {
        var i = xe(n, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (no(e)) return _(e, { from: n, to: o, d: 1 });
          var a = e.l, i = e.r;
          if (xe(o, e.from) < 0) return a ? Ln(a, n, o) : e.l = { from: n, to: o, d: 1, l: null, r: null }, si(e);
          if (0 < xe(n, e.to)) return i ? Ln(i, n, o) : e.r = { from: n, to: o, d: 1, l: null, r: null }, si(e);
          xe(n, e.from) < 0 && (e.from = n, e.l = null, e.d = i ? i.d + 1 : 1), 0 < xe(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, a && !e.l && Fn(e, a), i && o && Fn(e, i);
        }
      }
      function Fn(e, n) {
        no(n) || function o(i, v) {
          var l = v.from, p = v.to, m = v.l, v = v.r;
          Ln(i, l, p), m && o(i, m), v && o(i, v);
        }(e, n);
      }
      function ii(e, n) {
        var o = fr(n), i = o.next();
        if (i.done) return !1;
        for (var a = i.value, l = fr(e), p = l.next(a.from), m = p.value; !i.done && !p.done; ) {
          if (xe(m.from, a.to) <= 0 && 0 <= xe(m.to, a.from)) return !0;
          xe(a.from, m.from) < 0 ? a = (i = o.next(m.from)).value : m = (p = l.next(a.from)).value;
        }
        return !1;
      }
      function fr(e) {
        var n = no(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; n; ) switch (n.s) {
            case 0:
              if (n.s = 1, i) for (; n.n.l && xe(o, n.n.from) < 0; ) n = { up: n, n: n.n.l, s: 1 };
              else for (; n.n.l; ) n = { up: n, n: n.n.l, s: 1 };
            case 1:
              if (n.s = 2, !i || xe(o, n.n.to) <= 0) return { value: n.n, done: !1 };
            case 2:
              if (n.n.r) {
                n.s = 3, n = { up: n, n: n.n.r, s: 0 };
                continue;
              }
            case 3:
              n = n.up;
          }
          return { done: !0 };
        } };
      }
      function si(e) {
        var n, o, i = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), a = 1 < i ? "r" : i < -1 ? "l" : "";
        a && (n = a == "r" ? "l" : "r", o = u({}, e), i = e[a], e.from = i.from, e.to = i.to, e[a] = i[a], o[a] = i[n], (e[n] = o).d = ai(o)), e.d = ai(e);
      }
      function ai(o) {
        var n = o.r, o = o.l;
        return (n ? o ? Math.max(n.d, o.d) : n.d : o ? o.d : 0) + 1;
      }
      function dr(e, n) {
        return f(n).forEach(function(o) {
          e[o] ? Fn(e[o], n[o]) : e[o] = function i(a) {
            var l, p, m = {};
            for (l in a) j(a, l) && (p = a[l], m[l] = !p || typeof p != "object" || dt.has(p.constructor) ? p : i(p));
            return m;
          }(n[o]);
        }), e;
      }
      function ro(e, n) {
        return e.all || n.all || Object.keys(e).some(function(o) {
          return n[o] && ii(n[o], e[o]);
        });
      }
      B(ze.prototype, ((wt = { add: function(e) {
        return Fn(this, e), this;
      }, addKey: function(e) {
        return Ln(this, e, e), this;
      }, addKeys: function(e) {
        var n = this;
        return e.forEach(function(o) {
          return Ln(n, o, o);
        }), this;
      }, hasKey: function(e) {
        var n = fr(this).next(e).value;
        return n && xe(n.from, e) <= 0 && 0 <= xe(n.to, e);
      } })[rt] = function() {
        return fr(this);
      }, wt));
      var nn = {}, oo = {}, io = !1;
      function pr(e) {
        dr(oo, e), io || (io = !0, setTimeout(function() {
          io = !1, so(oo, !(oo = {}));
        }, 0));
      }
      function so(e, n) {
        n === void 0 && (n = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, a = Object.values(nn); i < a.length; i++) ui(p = a[i], e, o, n);
        else for (var l in e) {
          var p, m = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          m && (l = m[1], m = m[2], (p = nn["idb://".concat(l, "/").concat(m)]) && ui(p, e, o, n));
        }
        o.forEach(function(v) {
          return v();
        });
      }
      function ui(e, n, o, i) {
        for (var a = [], l = 0, p = Object.entries(e.queries.query); l < p.length; l++) {
          for (var m = p[l], v = m[0], b = [], O = 0, y = m[1]; O < y.length; O++) {
            var N = y[O];
            ro(n, N.obsSet) ? N.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && b.push(N);
          }
          i && a.push([v, b]);
        }
        if (i) for (var g = 0, w = a; g < w.length; g++) {
          var E = w[g], v = E[0], b = E[1];
          e.queries.query[v] = b;
        }
      }
      function Fs(e) {
        var n = e._state, o = e._deps.indexedDB;
        if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
          return n.dbOpenError ? $e(n.dbOpenError) : e;
        });
        n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
        var i = n.openCanceller, a = Math.round(10 * e.verno), l = !1;
        function p() {
          if (n.openCanceller !== i) throw new K.DatabaseClosed("db.open() was cancelled");
        }
        function m() {
          return new Z(function(N, g) {
            if (p(), !o) throw new K.MissingAPI();
            var w = e.name, E = n.autoSchema || !a ? o.open(w) : o.open(w, a);
            if (!E) throw new K.MissingAPI();
            E.onerror = Ct(g), E.onblocked = Le(e._fireOnBlocked), E.onupgradeneeded = Le(function(T) {
              var C;
              O = E.transaction, n.autoSchema && !e._options.allowEmptyDB ? (E.onerror = Pn, O.abort(), E.result.close(), (C = o.deleteDatabase(w)).onsuccess = C.onerror = Le(function() {
                g(new K.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (O.onerror = Ct(g), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, y = T < 1, e.idbdb = E.result, l && js(e, O), ks(e, T / 10, O, g));
            }, g), E.onsuccess = Le(function() {
              O = null;
              var T, C, R, P, I, U = e.idbdb = E.result, X = $(U.objectStoreNames);
              if (0 < X.length) try {
                var V = U.transaction((P = X).length === 1 ? P[0] : P, "readonly");
                if (n.autoSchema) C = U, R = V, (T = e).verno = C.version / 10, R = T._dbSchema = lr(0, C, R), T._storeNames = $(C.objectStoreNames, 0), ar(T, [T._allTables], f(R), R);
                else if (cr(e, e._dbSchema, V), ((I = zr(lr(0, (I = e).idbdb, V), I._dbSchema)).add.length || I.change.some(function(Y) {
                  return Y.add.length || Y.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), U.close(), a = U.version + 1, l = !0, N(m());
                sr(e, V);
              } catch {
              }
              vn.push(e), U.onversionchange = Le(function(Y) {
                n.vcFired = !0, e.on("versionchange").fire(Y);
              }), U.onclose = Le(function(Y) {
                e.on("close").fire(Y);
              }), y && (I = e._deps, V = w, U = I.indexedDB, I = I.IDBKeyRange, eo(U) || V === er || Zr(U, I).put({ name: V }).catch(S)), N();
            }, g);
          }).catch(function(N) {
            switch (N?.name) {
              case "UnknownError":
                if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), m();
                break;
              case "VersionError":
                if (0 < a) return a = 0, m();
            }
            return Z.reject(N);
          });
        }
        var v, b = n.dbReadyResolve, O = null, y = !1;
        return Z.race([i, (typeof navigator > "u" ? Z.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(N) {
          function g() {
            return indexedDB.databases().finally(N);
          }
          v = setInterval(g, 100), g();
        }).finally(function() {
          return clearInterval(v);
        }) : Promise.resolve()).then(m)]).then(function() {
          return p(), n.onReadyBeingFired = [], Z.resolve(to(function() {
            return e.on.ready.fire(e.vip);
          })).then(function N() {
            if (0 < n.onReadyBeingFired.length) {
              var g = n.onReadyBeingFired.reduce(pe, S);
              return n.onReadyBeingFired = [], Z.resolve(to(function() {
                return g(e.vip);
              })).then(N);
            }
          });
        }).finally(function() {
          n.openCanceller === i && (n.onReadyBeingFired = null, n.isBeingOpened = !1);
        }).catch(function(N) {
          n.dbOpenError = N;
          try {
            O && O.abort();
          } catch {
          }
          return i === n.openCanceller && e._close(), $e(N);
        }).finally(function() {
          n.openComplete = !0, b();
        }).then(function() {
          var N;
          return y && (N = {}, e.tables.forEach(function(g) {
            g.schema.indexes.forEach(function(w) {
              w.name && (N["idb://".concat(e.name, "/").concat(g.name, "/").concat(w.name)] = new ze(-1 / 0, [[[]]]));
            }), N["idb://".concat(e.name, "/").concat(g.name, "/")] = N["idb://".concat(e.name, "/").concat(g.name, "/:dels")] = new ze(-1 / 0, [[[]]]);
          }), Ut(In).fire(N), so(N, !0)), e;
        });
      }
      function ao(e) {
        function n(l) {
          return e.next(l);
        }
        var o = a(n), i = a(function(l) {
          return e.throw(l);
        });
        function a(l) {
          return function(v) {
            var m = l(v), v = m.value;
            return m.done ? v : v && typeof v.then == "function" ? v.then(o, i) : h(v) ? Promise.all(v).then(o, i) : o(v);
          };
        }
        return a(n)();
      }
      function hr(e, n, o) {
        for (var i = h(e) ? e.slice() : [e], a = 0; a < o; ++a) i.push(n);
        return i;
      }
      var Ks = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(n) {
          var o = e.table(n), i = o.schema, a = {}, l = [];
          function p(y, N, g) {
            var w = jn(y), E = a[w] = a[w] || [], T = y == null ? 0 : typeof y == "string" ? 1 : y.length, C = 0 < N, C = u(u({}, g), { name: C ? "".concat(w, "(virtual-from:").concat(g.name, ")") : g.name, lowLevelIndex: g, isVirtual: C, keyTail: N, keyLength: T, extractKey: Qr(y), unique: !C && g.unique });
            return E.push(C), C.isPrimaryKey || l.push(C), 1 < T && p(T === 2 ? y[0] : y.slice(0, T - 1), N + 1, g), E.sort(function(R, P) {
              return R.keyTail - P.keyTail;
            }), C;
          }
          n = p(i.primaryKey.keyPath, 0, i.primaryKey), a[":id"] = [n];
          for (var m = 0, v = i.indexes; m < v.length; m++) {
            var b = v[m];
            p(b.keyPath, 0, b);
          }
          function O(y) {
            var N, g = y.query.index;
            return g.isVirtual ? u(u({}, y), { query: { index: g.lowLevelIndex, range: (N = y.query.range, g = g.keyTail, { type: N.type === 1 ? 2 : N.type, lower: hr(N.lower, N.lowerOpen ? e.MAX_KEY : e.MIN_KEY, g), lowerOpen: !0, upper: hr(N.upper, N.upperOpen ? e.MIN_KEY : e.MAX_KEY, g), upperOpen: !0 }) } }) : y;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: n, indexes: l, getIndexByKeyPath: function(y) {
            return (y = a[jn(y)]) && y[0];
          } }), count: function(y) {
            return o.count(O(y));
          }, query: function(y) {
            return o.query(O(y));
          }, openCursor: function(y) {
            var N = y.query.index, g = N.keyTail, w = N.isVirtual, E = N.keyLength;
            return w ? o.openCursor(O(y)).then(function(C) {
              return C && T(C);
            }) : o.openCursor(y);
            function T(C) {
              return Object.create(C, { continue: { value: function(R) {
                R != null ? C.continue(hr(R, y.reverse ? e.MAX_KEY : e.MIN_KEY, g)) : y.unique ? C.continue(C.key.slice(0, E).concat(y.reverse ? e.MIN_KEY : e.MAX_KEY, g)) : C.continue();
              } }, continuePrimaryKey: { value: function(R, P) {
                C.continuePrimaryKey(hr(R, e.MAX_KEY, g), P);
              } }, primaryKey: { get: function() {
                return C.primaryKey;
              } }, key: { get: function() {
                var R = C.key;
                return E === 1 ? R[0] : R.slice(0, E);
              } }, value: { get: function() {
                return C.value;
              } } });
            }
          } });
        } });
      } };
      function uo(e, n, o, i) {
        return o = o || {}, i = i || "", f(e).forEach(function(a) {
          var l, p, m;
          j(n, a) ? (l = e[a], p = n[a], typeof l == "object" && typeof p == "object" && l && p ? (m = jt(l)) !== jt(p) ? o[i + a] = n[a] : m === "Object" ? uo(l, p, o, i + a + ".") : l !== p && (o[i + a] = n[a]) : l !== p && (o[i + a] = n[a])) : o[i + a] = void 0;
        }), f(n).forEach(function(a) {
          j(e, a) || (o[i + a] = n[a]);
        }), o;
      }
      function lo(e, n) {
        return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey);
      }
      var Ms = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(n) {
          var o = e.table(n), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(a) {
            var l = oe.trans, p = l.table(n).hook, m = p.deleting, v = p.creating, b = p.updating;
            switch (a.type) {
              case "add":
                if (v.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "put":
                if (v.fire === S && b.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "delete":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "deleteRange":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return function y(N, g, w) {
                    return o.query({ trans: N, values: !1, query: { index: i, range: g }, limit: w }).then(function(E) {
                      var T = E.result;
                      return O({ type: "delete", keys: T, trans: N }).then(function(C) {
                        return 0 < C.numFailures ? Promise.reject(C.failures[0]) : T.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : y(N, u(u({}, g), { lower: T[T.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(a.trans, a.range, 1e4);
                }, !0);
            }
            return o.mutate(a);
            function O(y) {
              var N, g, w, E = oe.trans, T = y.keys || lo(i, y);
              if (!T) throw new Error("Keys missing");
              return (y = y.type === "add" || y.type === "put" ? u(u({}, y), { keys: T }) : u({}, y)).type !== "delete" && (y.values = c([], y.values)), y.keys && (y.keys = c([], y.keys)), N = o, w = T, ((g = y).type === "add" ? Promise.resolve([]) : N.getMany({ trans: g.trans, keys: w, cache: "immutable" })).then(function(C) {
                var R = T.map(function(P, I) {
                  var U, X, V, Y = C[I], J = { onerror: null, onsuccess: null };
                  return y.type === "delete" ? m.fire.call(J, P, Y, E) : y.type === "add" || Y === void 0 ? (U = v.fire.call(J, P, y.values[I], E), P == null && U != null && (y.keys[I] = P = U, i.outbound || ue(y.values[I], i.keyPath, P))) : (U = uo(Y, y.values[I]), (X = b.fire.call(J, U, P, Y, E)) && (V = y.values[I], Object.keys(X).forEach(function(z) {
                    j(V, z) ? V[z] = X[z] : ue(V, z, X[z]);
                  }))), J;
                });
                return o.mutate(y).then(function(P) {
                  for (var I = P.failures, U = P.results, X = P.numFailures, P = P.lastResult, V = 0; V < T.length; ++V) {
                    var Y = (U || T)[V], J = R[V];
                    Y == null ? J.onerror && J.onerror(I[V]) : J.onsuccess && J.onsuccess(y.type === "put" && C[V] ? y.values[V] : Y);
                  }
                  return { failures: I, results: U, numFailures: X, lastResult: P };
                }).catch(function(P) {
                  return R.forEach(function(I) {
                    return I.onerror && I.onerror(P);
                  }), Promise.reject(P);
                });
              });
            }
          } });
        } });
      } };
      function li(e, n, o) {
        try {
          if (!n || n.keys.length < e.length) return null;
          for (var i = [], a = 0, l = 0; a < n.keys.length && l < e.length; ++a) xe(n.keys[a], e[l]) === 0 && (i.push(o ? at(n.values[a]) : n.values[a]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Bs = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(n) {
          var o = e.table(n);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var a = li(i.keys, i.trans._cache, i.cache === "clone");
            return a ? Z.resolve(a) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? at(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function ci(e, n) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound;
      }
      function fi(e, n) {
        switch (e) {
          case "query":
            return n.values && !n.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var $s = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var n = e.schema.name, o = new ze(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, a, l) {
          if (oe.subscr && a !== "readonly") throw new K.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(oe.querier));
          return e.transaction(i, a, l);
        }, table: function(i) {
          var a = e.table(i), l = a.schema, p = l.primaryKey, y = l.indexes, m = p.extractKey, v = p.outbound, b = p.autoIncrement && y.filter(function(g) {
            return g.compound && g.keyPath.includes(p.keyPath);
          }), O = u(u({}, a), { mutate: function(g) {
            function w(z) {
              return z = "idb://".concat(n, "/").concat(i, "/").concat(z), P[z] || (P[z] = new ze());
            }
            var E, T, C, R = g.trans, P = g.mutatedParts || (g.mutatedParts = {}), I = w(""), U = w(":dels"), X = g.type, J = g.type === "deleteRange" ? [g.range] : g.type === "delete" ? [g.keys] : g.values.length < 50 ? [lo(p, g).filter(function(z) {
              return z;
            }), g.values] : [], V = J[0], Y = J[1], J = g.trans._cache;
            return h(V) ? (I.addKeys(V), (J = X === "delete" || V.length === Y.length ? li(V, J) : null) || U.addKeys(V), (J || Y) && (E = w, T = J, C = Y, l.indexes.forEach(function(z) {
              var te = E(z.name || "");
              function ge(me) {
                return me != null ? z.extractKey(me) : null;
              }
              function Oe(me) {
                return z.multiEntry && h(me) ? me.forEach(function(Fe) {
                  return te.addKey(Fe);
                }) : te.addKey(me);
              }
              (T || C).forEach(function(me, Je) {
                var he = T && ge(T[Je]), Je = C && ge(C[Je]);
                xe(he, Je) !== 0 && (he != null && Oe(he), Je != null && Oe(Je));
              });
            }))) : V ? (Y = { from: (Y = V.lower) !== null && Y !== void 0 ? Y : e.MIN_KEY, to: (Y = V.upper) !== null && Y !== void 0 ? Y : e.MAX_KEY }, U.add(Y), I.add(Y)) : (I.add(o), U.add(o), l.indexes.forEach(function(z) {
              return w(z.name).add(o);
            })), a.mutate(g).then(function(z) {
              return !V || g.type !== "add" && g.type !== "put" || (I.addKeys(z.results), b && b.forEach(function(te) {
                for (var ge = g.values.map(function(he) {
                  return te.extractKey(he);
                }), Oe = te.keyPath.findIndex(function(he) {
                  return he === p.keyPath;
                }), me = 0, Fe = z.results.length; me < Fe; ++me) ge[me][Oe] = z.results[me];
                w(te.name).addKeys(ge);
              })), R.mutatedParts = dr(R.mutatedParts || {}, P), z;
            });
          } }), y = function(w) {
            var E = w.query, w = E.index, E = E.range;
            return [w, new ze((w = E.lower) !== null && w !== void 0 ? w : e.MIN_KEY, (E = E.upper) !== null && E !== void 0 ? E : e.MAX_KEY)];
          }, N = { get: function(g) {
            return [p, new ze(g.key)];
          }, getMany: function(g) {
            return [p, new ze().addKeys(g.keys)];
          }, count: y, query: y, openCursor: y };
          return f(N).forEach(function(g) {
            O[g] = function(w) {
              var E = oe.subscr, T = !!E, C = ci(oe, a) && fi(g, w) ? w.obsSet = {} : E;
              if (T) {
                var R = function(Y) {
                  return Y = "idb://".concat(n, "/").concat(i, "/").concat(Y), C[Y] || (C[Y] = new ze());
                }, P = R(""), I = R(":dels"), E = N[g](w), T = E[0], E = E[1];
                if ((g === "query" && T.isPrimaryKey && !w.values ? I : R(T.name || "")).add(E), !T.isPrimaryKey) {
                  if (g !== "count") {
                    var U = g === "query" && v && w.values && a.query(u(u({}, w), { values: !1 }));
                    return a[g].apply(this, arguments).then(function(Y) {
                      if (g === "query") {
                        if (v && w.values) return U.then(function(ge) {
                          return ge = ge.result, P.addKeys(ge), Y;
                        });
                        var J = w.values ? Y.result.map(m) : Y.result;
                        (w.values ? P : I).addKeys(J);
                      } else if (g === "openCursor") {
                        var z = Y, te = w.values;
                        return z && Object.create(z, { key: { get: function() {
                          return I.addKey(z.primaryKey), z.key;
                        } }, primaryKey: { get: function() {
                          var ge = z.primaryKey;
                          return I.addKey(ge), ge;
                        } }, value: { get: function() {
                          return te && P.addKey(z.primaryKey), z.value;
                        } } });
                      }
                      return Y;
                    });
                  }
                  I.add(o);
                }
              }
              return a[g].apply(this, arguments);
            };
          }), O;
        } });
      } };
      function di(e, n, o) {
        if (o.numFailures === 0) return n;
        if (n.type === "deleteRange") return null;
        var i = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
        return o.numFailures === i ? null : (n = u({}, n), h(n.keys) && (n.keys = n.keys.filter(function(a, l) {
          return !(l in o.failures);
        })), "values" in n && h(n.values) && (n.values = n.values.filter(function(a, l) {
          return !(l in o.failures);
        })), n);
      }
      function co(e, n) {
        return o = e, ((i = n).lower === void 0 || (i.lowerOpen ? 0 < xe(o, i.lower) : 0 <= xe(o, i.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? xe(e, n.upper) < 0 : xe(e, n.upper) <= 0));
        var o, i;
      }
      function pi(e, n, N, i, a, l) {
        if (!N || N.length === 0) return e;
        var p = n.query.index, m = p.multiEntry, v = n.query.range, b = i.schema.primaryKey.extractKey, O = p.extractKey, y = (p.lowLevelIndex || p).extractKey, N = N.reduce(function(g, w) {
          var E = g, T = [];
          if (w.type === "add" || w.type === "put") for (var C = new ze(), R = w.values.length - 1; 0 <= R; --R) {
            var P, I = w.values[R], U = b(I);
            C.hasKey(U) || (P = O(I), (m && h(P) ? P.some(function(z) {
              return co(z, v);
            }) : co(P, v)) && (C.addKey(U), T.push(I)));
          }
          switch (w.type) {
            case "add":
              var X = new ze().addKeys(n.values ? g.map(function(te) {
                return b(te);
              }) : g), E = g.concat(n.values ? T.filter(function(te) {
                return te = b(te), !X.hasKey(te) && (X.addKey(te), !0);
              }) : T.map(function(te) {
                return b(te);
              }).filter(function(te) {
                return !X.hasKey(te) && (X.addKey(te), !0);
              }));
              break;
            case "put":
              var V = new ze().addKeys(w.values.map(function(te) {
                return b(te);
              }));
              E = g.filter(function(te) {
                return !V.hasKey(n.values ? b(te) : te);
              }).concat(n.values ? T : T.map(function(te) {
                return b(te);
              }));
              break;
            case "delete":
              var Y = new ze().addKeys(w.keys);
              E = g.filter(function(te) {
                return !Y.hasKey(n.values ? b(te) : te);
              });
              break;
            case "deleteRange":
              var J = w.range;
              E = g.filter(function(te) {
                return !co(b(te), J);
              });
          }
          return E;
        }, e);
        return N === e ? e : (N.sort(function(g, w) {
          return xe(y(g), y(w)) || xe(b(g), b(w));
        }), n.limit && n.limit < 1 / 0 && (N.length > n.limit ? N.length = n.limit : e.length === n.limit && N.length < n.limit && (a.dirty = !0)), l ? Object.freeze(N) : N);
      }
      function hi(e, n) {
        return xe(e.lower, n.lower) === 0 && xe(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen;
      }
      function qs(e, n) {
        return function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = xe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = xe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, n.upper, e.upperOpen, n.upperOpen);
      }
      function Us(e, n, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var a, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (a = e, l = n, setTimeout(function() {
            a.subscribers.size === 0 && Ke(l, a);
          }, 3e3));
        });
      }
      var Vs = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var n = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, a) {
          var l, p, m = e.transaction(o, i, a);
          return i === "readwrite" && (p = (l = new AbortController()).signal, a = function(v) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var b = /* @__PURE__ */ new Set(), O = 0, y = o; O < y.length; O++) {
                  var N = y[O], g = nn["idb://".concat(n, "/").concat(N)];
                  if (g) {
                    var w = e.table(N), E = g.optimisticOps.filter(function(te) {
                      return te.trans === m;
                    });
                    if (m._explicit && v && m.mutatedParts) for (var T = 0, C = Object.values(g.queries.query); T < C.length; T++) for (var R = 0, P = (X = C[T]).slice(); R < P.length; R++) ro((V = P[R]).obsSet, m.mutatedParts) && (Ke(X, V), V.subscribers.forEach(function(te) {
                      return b.add(te);
                    }));
                    else if (0 < E.length) {
                      g.optimisticOps = g.optimisticOps.filter(function(te) {
                        return te.trans !== m;
                      });
                      for (var I = 0, U = Object.values(g.queries.query); I < U.length; I++) for (var X, V, Y, J = 0, z = (X = U[I]).slice(); J < z.length; J++) (V = z[J]).res != null && m.mutatedParts && (v && !V.dirty ? (Y = Object.isFrozen(V.res), Y = pi(V.res, V.req, E, w, V, Y), V.dirty ? (Ke(X, V), V.subscribers.forEach(function(te) {
                        return b.add(te);
                      })) : Y !== V.res && (V.res = Y, V.promise = Z.resolve({ result: Y }))) : (V.dirty && Ke(X, V), V.subscribers.forEach(function(te) {
                        return b.add(te);
                      })));
                    }
                  }
                }
                b.forEach(function(te) {
                  return te();
                });
              }
            };
          }, m.addEventListener("abort", a(!1), { signal: p }), m.addEventListener("error", a(!1), { signal: p }), m.addEventListener("complete", a(!0), { signal: p })), m;
        }, table: function(o) {
          var i = e.table(o), a = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var p = oe.trans;
            if (a.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return i.mutate(l);
            var m = nn["idb://".concat(n, "/").concat(o)];
            return m ? (p = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || lo(a, l).some(function(v) {
              return v == null;
            })) ? (m.optimisticOps.push(l), l.mutatedParts && pr(l.mutatedParts), p.then(function(v) {
              0 < v.numFailures && (Ke(m.optimisticOps, l), (v = di(0, l, v)) && m.optimisticOps.push(v), l.mutatedParts && pr(l.mutatedParts));
            }), p.catch(function() {
              Ke(m.optimisticOps, l), l.mutatedParts && pr(l.mutatedParts);
            })) : p.then(function(v) {
              var b = di(0, u(u({}, l), { values: l.values.map(function(O, y) {
                var N;
                return v.failures[y] ? O : (O = (N = a.keyPath) !== null && N !== void 0 && N.includes(".") ? at(O) : u({}, O), ue(O, a.keyPath, v.results[y]), O);
              }) }), v);
              m.optimisticOps.push(b), queueMicrotask(function() {
                return l.mutatedParts && pr(l.mutatedParts);
              });
            }), p) : i.mutate(l);
          }, query: function(l) {
            if (!ci(oe, i) || !fi("query", l)) return i.query(l);
            var p = ((b = oe.trans) === null || b === void 0 ? void 0 : b.db._options.cache) === "immutable", y = oe, m = y.requery, v = y.signal, b = function(w, E, T, C) {
              var R = nn["idb://".concat(w, "/").concat(E)];
              if (!R) return [];
              if (!(E = R.queries[T])) return [null, !1, R, null];
              var P = E[(C.query ? C.query.index.name : null) || ""];
              if (!P) return [null, !1, R, null];
              switch (T) {
                case "query":
                  var I = P.find(function(U) {
                    return U.req.limit === C.limit && U.req.values === C.values && hi(U.req.query.range, C.query.range);
                  });
                  return I ? [I, !0, R, P] : [P.find(function(U) {
                    return ("limit" in U.req ? U.req.limit : 1 / 0) >= C.limit && (!C.values || U.req.values) && qs(U.req.query.range, C.query.range);
                  }), !1, R, P];
                case "count":
                  return I = P.find(function(U) {
                    return hi(U.req.query.range, C.query.range);
                  }), [I, !!I, R, P];
              }
            }(n, o, "query", l), O = b[0], y = b[1], N = b[2], g = b[3];
            return O && y ? O.obsSet = l.obsSet : (y = i.query(l).then(function(w) {
              var E = w.result;
              if (O && (O.res = E), p) {
                for (var T = 0, C = E.length; T < C; ++T) Object.freeze(E[T]);
                Object.freeze(E);
              } else w.result = at(E);
              return w;
            }).catch(function(w) {
              return g && O && Ke(g, O), Promise.reject(w);
            }), O = { obsSet: l.obsSet, promise: y, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, g ? g.push(O) : (g = [O], (N = N || (nn["idb://".concat(n, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = g)), Us(O, g, m, v), O.promise.then(function(w) {
              return { result: pi(w.result, l, N?.optimisticOps, i, O, p) };
            });
          } });
        } });
      } };
      function mr(e, n) {
        return new Proxy(e, { get: function(o, i, a) {
          return i === "db" ? n : Reflect.get(o, i, a);
        } });
      }
      var Pt = (qe.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new K.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new K.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var n = this._versions, o = n.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), n.push(o), n.sort(Is), o.stores({}), this._state.autoSchema = !1, o);
      }, qe.prototype._whenReady = function(e) {
        var n = this;
        return this.idbdb && (this._state.openComplete || oe.letThrough || this._vip) ? e() : new Z(function(o, i) {
          if (n._state.openComplete) return i(new K.DatabaseClosed(n._state.dbOpenError));
          if (!n._state.isBeingOpened) {
            if (!n._state.autoOpen) return void i(new K.DatabaseClosed());
            n.open().catch(S);
          }
          n._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, qe.prototype.use = function(e) {
        var n = e.stack, o = e.create, i = e.level, a = e.name;
        return a && this.unuse({ stack: n, name: a }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({ stack: n, create: o, level: i ?? 10, name: a }), e.sort(function(l, p) {
          return l.level - p.level;
        }), this;
      }, qe.prototype.unuse = function(e) {
        var n = e.stack, o = e.name, i = e.create;
        return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(a) {
          return i ? a.create !== i : !!o && a.name !== o;
        })), this;
      }, qe.prototype.open = function() {
        var e = this;
        return Zt(ot, function() {
          return Fs(e);
        });
      }, qe.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, n = vn.indexOf(this);
        if (0 <= n && vn.splice(n, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new Z(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new Z(function(o, i) {
          e.cancelOpen = i;
        }));
      }, qe.prototype.close = function(o) {
        var n = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        n ? (o.isBeingOpened && o.cancelOpen(new K.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new K.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, qe.prototype.delete = function(e) {
        var n = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new Z(function(a, l) {
          function p() {
            n.close(e);
            var m = n._deps.indexedDB.deleteDatabase(n.name);
            m.onsuccess = Le(function() {
              var v, b, O;
              v = n._deps, b = n.name, O = v.indexedDB, v = v.IDBKeyRange, eo(O) || b === er || Zr(O, v).delete(b).catch(S), a();
            }), m.onerror = Ct(l), m.onblocked = n._fireOnBlocked;
          }
          if (o) throw new K.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(p) : p();
        });
      }, qe.prototype.backendDB = function() {
        return this.idbdb;
      }, qe.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, qe.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, qe.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, qe.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(qe.prototype, "tables", { get: function() {
        var e = this;
        return f(this._allTables).map(function(n) {
          return e._allTables[n];
        });
      }, enumerable: !1, configurable: !0 }), qe.prototype.transaction = function() {
        var e = (function(n, o, i) {
          var a = arguments.length;
          if (a < 2) throw new K.InvalidArgument("Too few arguments");
          for (var l = new Array(a - 1); --a; ) l[a - 1] = arguments[a];
          return i = l.pop(), [n, Xe(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, qe.prototype._transaction = function(e, n, o) {
        var i = this, a = oe.trans;
        a && a.db === this && e.indexOf("!") === -1 || (a = null);
        var l, p, m = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (p = n.map(function(b) {
            if (b = b instanceof i.Table ? b.name : b, typeof b != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return b;
          }), e == "r" || e === qr) l = qr;
          else {
            if (e != "rw" && e != Ur) throw new K.InvalidArgument("Invalid transaction mode: " + e);
            l = Ur;
          }
          if (a) {
            if (a.mode === qr && l === Ur) {
              if (!m) throw new K.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              a = null;
            }
            a && p.forEach(function(b) {
              if (a && a.storeNames.indexOf(b) === -1) {
                if (!m) throw new K.SubTransaction("Table " + b + " not included in parent transaction.");
                a = null;
              }
            }), m && a && !a.active && (a = null);
          }
        } catch (b) {
          return a ? a._promise(null, function(O, y) {
            y(b);
          }) : $e(b);
        }
        var v = (function b(O, y, N, g, w) {
          return Z.resolve().then(function() {
            var E = oe.transless || oe, T = O._createTransaction(y, N, O._dbSchema, g);
            if (T.explicit = !0, E = { trans: T, transless: E }, g) T.idbtrans = g.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, O._state.PR1398_maxLoop = 3;
            } catch (P) {
              return P.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                return b(O, y, N, null, w);
              })) : $e(P);
            }
            var C, R = xt(w);
            return R && yn(), E = Z.follow(function() {
              var P;
              (C = w.call(T, T)) && (R ? (P = Bt.bind(null, null), C.then(P, P)) : typeof C.next == "function" && typeof C.throw == "function" && (C = ao(C)));
            }, E), (C && typeof C.then == "function" ? Z.resolve(C).then(function(P) {
              return T.active ? P : $e(new K.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : E.then(function() {
              return C;
            })).then(function(P) {
              return g && T._resolve(), T._completion.then(function() {
                return P;
              });
            }).catch(function(P) {
              return T._reject(P), $e(P);
            });
          });
        }).bind(null, this, l, p, a, o);
        return a ? a._promise(l, v, "lock") : oe.trans ? Zt(oe.transless, function() {
          return i._whenReady(v);
        }) : this._whenReady(v);
      }, qe.prototype.table = function(e) {
        if (!j(this._allTables, e)) throw new K.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, qe);
      function qe(e, n) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = qe.dependencies;
        this._options = n = u({ addons: qe.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, n), this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange }, i = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var a, l, p, m, v, b = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: S, dbReadyPromise: null, cancelOpen: S, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: n.autoOpen };
        b.dbReadyPromise = new Z(function(y) {
          b.dbReadyResolve = y;
        }), b.openCanceller = new Z(function(y, N) {
          b.cancelOpen = N;
        }), this._state = b, this.name = e, this.on = An(this, "populate", "blocked", "versionchange", "close", { ready: [pe, S] }), this.once = function(y, N) {
          var g = function() {
            for (var w = [], E = 0; E < arguments.length; E++) w[E] = arguments[E];
            o.on(y).unsubscribe(g), N.apply(o, w);
          };
          return o.on(y, g);
        }, this.on.ready.subscribe = q(this.on.ready.subscribe, function(y) {
          return function(N, g) {
            qe.vip(function() {
              var w, E = o._state;
              E.openComplete ? (E.dbOpenError || Z.resolve().then(N), g && y(N)) : E.onReadyBeingFired ? (E.onReadyBeingFired.push(N), g && y(N)) : (y(N), w = o, g || y(function T() {
                w.on.ready.unsubscribe(N), w.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (a = this, Rn(Ns.prototype, function(C, T) {
          this.db = a;
          var g = Vo, w = null;
          if (T) try {
            g = T();
          } catch (R) {
            w = R;
          }
          var E = C._ctx, T = E.table, C = T.hook.reading.fire;
          this._ctx = { table: T, index: E.index, isPrimKey: !E.index || T.schema.primKey.keyPath && E.index === T.schema.primKey.name, range: g, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: E.or, valueMapper: C !== M ? C : null };
        })), this.Table = (l = this, Rn(Yo.prototype, function(y, N, g) {
          this.db = l, this._tx = g, this.name = y, this.schema = N, this.hook = l._allTables[y] ? l._allTables[y].hook : An(null, { creating: [le, S], reading: [ne, M], updating: [ve, S], deleting: [se, S] });
        })), this.Transaction = (p = this, Rn(As.prototype, function(y, N, g, w, E) {
          var T = this;
          y !== "readonly" && N.forEach(function(C) {
            C = (C = g[C]) === null || C === void 0 ? void 0 : C.yProps, C && (N = N.concat(C.map(function(R) {
              return R.updatesTable;
            })));
          }), this.db = p, this.mode = y, this.storeNames = N, this.schema = g, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = An(this, "complete", "error", "abort"), this.parent = E || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Z(function(C, R) {
            T._resolve = C, T._reject = R;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(C) {
            var R = T.active;
            return T.active = !1, T.on.error.fire(C), T.parent ? T.parent._reject(C) : R && T.idbtrans && T.idbtrans.abort(), $e(C);
          });
        })), this.Version = (m = this, Rn(Ls.prototype, function(y) {
          this.db = m, this._cfg = { version: y, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (v = this, Rn(ei.prototype, function(y, N, g) {
          if (this.db = v, this._ctx = { table: y, index: N === ":id" ? null : N, or: g }, this._cmp = this._ascending = xe, this._descending = function(w, E) {
            return xe(E, w);
          }, this._max = function(w, E) {
            return 0 < xe(w, E) ? w : E;
          }, this._min = function(w, E) {
            return xe(w, E) < 0 ? w : E;
          }, this._IDBKeyRange = v._deps.IDBKeyRange, !this._IDBKeyRange) throw new K.MissingAPI();
        })), this.on("versionchange", function(y) {
          0 < y.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(y) {
          !y.newVersion || y.newVersion < y.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(y.oldVersion / 10));
        }), this._maxKey = kn(n.IDBKeyRange), this._createTransaction = function(y, N, g, w) {
          return new o.Transaction(y, N, g, o._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(y) {
          o.on("blocked").fire(y), vn.filter(function(N) {
            return N.name === o.name && N !== o && !N._state.vcFired;
          }).map(function(N) {
            return N.on("versionchange").fire(y);
          });
        }, this.use(Bs), this.use(Vs), this.use($s), this.use(Ks), this.use(Ms);
        var O = new Proxy(this, { get: function(y, N, g) {
          if (N === "_vip") return !0;
          if (N === "table") return function(E) {
            return mr(o.table(E), O);
          };
          var w = Reflect.get(y, N, g);
          return w instanceof Yo ? mr(w, O) : N === "tables" ? w.map(function(E) {
            return mr(E, O);
          }) : N === "_createTransaction" ? function() {
            return mr(w.apply(this, arguments), O);
          } : w;
        } });
        this.vip = O, i.forEach(function(y) {
          return y(o);
        });
      }
      var yr, wt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ws = (fo.prototype.subscribe = function(e, n, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: o });
      }, fo.prototype[wt] = function() {
        return this;
      }, fo);
      function fo(e) {
        this._subscribe = e;
      }
      try {
        yr = { indexedDB: d.indexedDB || d.mozIndexedDB || d.webkitIndexedDB || d.msIndexedDB, IDBKeyRange: d.IDBKeyRange || d.webkitIDBKeyRange };
      } catch {
        yr = { indexedDB: null, IDBKeyRange: null };
      }
      function mi(e) {
        var n, o = !1, i = new Ws(function(a) {
          var l = xt(e), p, m = !1, v = {}, b = {}, O = { get closed() {
            return m;
          }, unsubscribe: function() {
            m || (m = !0, p && p.abort(), y && Ut.storagemutated.unsubscribe(g));
          } };
          a.start && a.start(O);
          var y = !1, N = function() {
            return $r(w);
          }, g = function(E) {
            dr(v, E), ro(b, v) && N();
          }, w = function() {
            var E, T, C;
            !m && yr.indexedDB && (v = {}, E = {}, p && p.abort(), p = new AbortController(), C = function(R) {
              var P = hn();
              try {
                l && yn();
                var I = Mt(e, R);
                return I = l ? I.finally(Bt) : I;
              } finally {
                P && mn();
              }
            }(T = { subscr: E, signal: p.signal, requery: N, querier: e, trans: null }), Promise.resolve(C).then(function(R) {
              o = !0, n = R, m || T.signal.aborted || (v = {}, function(P) {
                for (var I in P) if (j(P, I)) return;
                return 1;
              }(b = E) || y || (Ut(In, g), y = !0), $r(function() {
                return !m && a.next && a.next(R);
              }));
            }, function(R) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(R?.name) || m || $r(function() {
                m || a.error && a.error(R);
              });
            }));
          };
          return setTimeout(N, 0), O;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return n;
        }, i;
      }
      var rn = Pt;
      function po(e) {
        var n = Vt;
        try {
          Vt = !0, Ut.storagemutated.fire(e), so(e, !0);
        } finally {
          Vt = n;
        }
      }
      B(rn, u(u({}, Ve), { delete: function(e) {
        return new rn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new rn(e, { addons: [] }).open().then(function(n) {
          return n.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return n = rn.dependencies, o = n.indexedDB, n = n.IDBKeyRange, (eo(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(a) {
              return a.name;
            }).filter(function(a) {
              return a !== er;
            });
          }) : Zr(o, n).toCollection().primaryKeys()).then(e);
        } catch {
          return $e(new K.MissingAPI());
        }
        var n, o;
      }, defineClass: function() {
        return function(e) {
          _(this, e);
        };
      }, ignoreTransaction: function(e) {
        return oe.trans ? Zt(oe.transless, e) : e();
      }, vip: to, async: function(e) {
        return function() {
          try {
            var n = ao(e.apply(this, arguments));
            return n && typeof n.then == "function" ? n : Z.resolve(n);
          } catch (o) {
            return $e(o);
          }
        };
      }, spawn: function(e, n, o) {
        try {
          var i = ao(e.apply(o, n || []));
          return i && typeof i.then == "function" ? i : Z.resolve(i);
        } catch (a) {
          return $e(a);
        }
      }, currentTransaction: { get: function() {
        return oe.trans || null;
      } }, waitFor: function(e, n) {
        return n = Z.resolve(typeof e == "function" ? rn.ignoreTransaction(e) : e).timeout(n || 6e4), oe.trans ? oe.trans.waitFor(n) : n;
      }, Promise: Z, debug: { get: function() {
        return ae;
      }, set: function(e) {
        Ce(e);
      } }, derive: Q, extend: _, props: B, override: q, Events: An, on: Ut, liveQuery: mi, extendObservabilitySet: dr, getByKeyPath: Pe, setByKeyPath: ue, delByKeyPath: function(e, n) {
        typeof n == "string" ? ue(e, n, void 0) : "length" in n && [].map.call(n, function(o) {
          ue(e, o, void 0);
        });
      }, shallowClone: de, deepClone: at, getObjectDiff: uo, cmp: xe, asap: _e, minKey: -1 / 0, addons: [], connections: vn, errnames: A, dependencies: yr, cache: nn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, n, o) {
        return e + n / Math.pow(10, 2 * o);
      }) })), rn.maxKey = kn(rn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ut(In, function(e) {
        Vt || (e = new CustomEvent(Hr, { detail: e }), Vt = !0, dispatchEvent(e), Vt = !1);
      }), addEventListener(Hr, function(e) {
        e = e.detail, Vt || po(e);
      }));
      var En, Vt = !1, yi = function() {
      };
      return typeof BroadcastChannel < "u" && ((yi = function() {
        (En = new BroadcastChannel(Hr)).onmessage = function(e) {
          return e.data && po(e.data);
        };
      })(), typeof En.unref == "function" && En.unref(), Ut(In, function(e) {
        Vt || En.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Pt.disableBfCache && e.persisted) {
          ae && console.debug("Dexie: handling persisted pagehide"), En?.close();
          for (var n = 0, o = vn; n < o.length; n++) o[n].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Pt.disableBfCache && e.persisted && (ae && console.debug("Dexie: handling persisted pageshow"), yi(), po({ all: new ze(-1 / 0, [[]]) }));
      })), Z.rejectionMapper = function(e, n) {
        return !e || e instanceof Ft || e instanceof TypeError || e instanceof SyntaxError || !e.name || !H[e.name] ? e : (n = new H[e.name](n || e.message, e), "stack" in e && re(n, "stack", { get: function() {
          return this.inner.stack;
        } }), n);
      }, Ce(ae), u(Pt, Object.freeze({ __proto__: null, Dexie: Pt, liveQuery: mi, Entity: Wo, cmp: xe, PropModification: Dn, replacePrefix: function(e, n) {
        return new Dn({ replacePrefix: [e, n] });
      }, add: function(e) {
        return new Dn({ add: e });
      }, remove: function(e) {
        return new Dn({ remove: e });
      }, default: Pt, RangeSet: ze, mergeRanges: Fn, rangesOverlap: ii }), { default: Pt }), Pt;
    });
  }(Xi)), Xi.exports;
}
var Vd = Ud();
const wa = /* @__PURE__ */ $d(Vd), Lu = Symbol.for("Dexie"), ss = globalThis[Lu] || (globalThis[Lu] = wa);
if (wa.semVer !== ss.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${wa.semVer} and ${ss.semVer}`);
const {
  liveQuery: my,
  mergeRanges: yy,
  rangesOverlap: vy,
  RangeSet: gy,
  cmp: by,
  Entity: wy,
  PropModification: _y,
  replacePrefix: xy,
  add: Oy,
  remove: Ty,
  DexieYProvider: Ey
} = ss;
var Wd = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Hd(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
function Gd(t) {
  if (Object.prototype.hasOwnProperty.call(t, "__esModule")) return t;
  var r = t.default;
  if (typeof r == "function") {
    var s = function u() {
      var c = !1;
      try {
        c = this instanceof u;
      } catch {
      }
      return c ? Reflect.construct(r, arguments, this.constructor) : r.apply(this, arguments);
    };
    s.prototype = r.prototype;
  } else s = {};
  return Object.defineProperty(s, "__esModule", { value: !0 }), Object.keys(t).forEach(function(u) {
    var c = Object.getOwnPropertyDescriptor(t, u);
    Object.defineProperty(s, u, c.get ? c : {
      enumerable: !0,
      get: function() {
        return t[u];
      }
    });
  }), s;
}
var Fu = {};
const Yd = {}, Qd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Yd
}, Symbol.toStringTag, { value: "Module" })), Ku = /* @__PURE__ */ Gd(Qd);
var Mu;
function Xd() {
  return Mu || (Mu = 1, function(t) {
    (function(r) {
      r.parser = function(A, x) {
        return new u(A, x);
      }, r.SAXParser = u, r.SAXStream = D, r.createStream = k, r.MAX_BUFFER_LENGTH = 64 * 1024;
      var s = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      r.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function u(A, x) {
        if (!(this instanceof u))
          return new u(A, x);
        var K = this;
        d(K), K.q = K.c = "", K.bufferCheckPosition = r.MAX_BUFFER_LENGTH, K.opt = x || {}, K.opt.lowercase = K.opt.lowercase || K.opt.lowercasetags, K.looseCase = K.opt.lowercase ? "toLowerCase" : "toUpperCase", K.tags = [], K.closed = K.closedRoot = K.sawRoot = !1, K.tag = K.error = null, K.strict = !!A, K.noscript = !!(A || K.opt.noscript), K.state = F.BEGIN, K.strictEntities = K.opt.strictEntities, K.ENTITIES = K.strictEntities ? Object.create(r.XML_ENTITIES) : Object.create(r.ENTITIES), K.attribList = [], K.opt.xmlns && (K.ns = Object.create(Q)), K.opt.unquotedAttributeValues === void 0 && (K.opt.unquotedAttributeValues = !A), K.trackPosition = K.opt.position !== !1, K.trackPosition && (K.position = K.line = K.column = 0), dt(K, "onready");
      }
      Object.create || (Object.create = function(A) {
        function x() {
        }
        x.prototype = A;
        var K = new x();
        return K;
      }), Object.keys || (Object.keys = function(A) {
        var x = [];
        for (var K in A) A.hasOwnProperty(K) && x.push(K);
        return x;
      });
      function c(A) {
        for (var x = Math.max(r.MAX_BUFFER_LENGTH, 10), K = 0, H = 0, Ve = s.length; H < Ve; H++) {
          var S = A[s[H]].length;
          if (S > x)
            switch (s[H]) {
              case "textNode":
                at(A);
                break;
              case "cdata":
                Be(A, "oncdata", A.cdata), A.cdata = "";
                break;
              case "script":
                Be(A, "onscript", A.script), A.script = "";
                break;
              default:
                jt(A, "Max buffer length exceeded: " + s[H]);
            }
          K = Math.max(K, S);
        }
        var M = r.MAX_BUFFER_LENGTH - K;
        A.bufferCheckPosition = M + A.position;
      }
      function d(A) {
        for (var x = 0, K = s.length; x < K; x++)
          A[s[x]] = "";
      }
      function f(A) {
        at(A), A.cdata !== "" && (Be(A, "oncdata", A.cdata), A.cdata = ""), A.script !== "" && (Be(A, "onscript", A.script), A.script = "");
      }
      u.prototype = {
        end: function() {
          rt(this);
        },
        write: Nt,
        resume: function() {
          return this.error = null, this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          f(this);
        }
      };
      var h;
      try {
        h = Ku.Stream;
      } catch {
        h = function() {
        };
      }
      h || (h = function() {
      });
      var _ = r.EVENTS.filter(function(A) {
        return A !== "error" && A !== "end";
      });
      function k(A, x) {
        return new D(A, x);
      }
      function D(A, x) {
        if (!(this instanceof D))
          return new D(A, x);
        h.apply(this), this._parser = new u(A, x), this.writable = !0, this.readable = !0;
        var K = this;
        this._parser.onend = function() {
          K.emit("end");
        }, this._parser.onerror = function(H) {
          K.emit("error", H), K._parser.error = null;
        }, this._decoder = null, _.forEach(function(H) {
          Object.defineProperty(K, "on" + H, {
            get: function() {
              return K._parser["on" + H];
            },
            set: function(Ve) {
              if (!Ve)
                return K.removeAllListeners(H), K._parser["on" + H] = Ve, Ve;
              K.on(H, Ve);
            },
            enumerable: !0,
            configurable: !1
          });
        });
      }
      D.prototype = Object.create(h.prototype, {
        constructor: {
          value: D
        }
      }), D.prototype.write = function(A) {
        if (typeof Buffer == "function" && typeof Buffer.isBuffer == "function" && Buffer.isBuffer(A)) {
          if (!this._decoder) {
            var x = Ku.StringDecoder;
            this._decoder = new x("utf8");
          }
          A = this._decoder.write(A);
        }
        return this._parser.write(A.toString()), this.emit("data", A), !0;
      }, D.prototype.end = function(A) {
        return A && A.length && this.write(A), this._parser.end(), !0;
      }, D.prototype.on = function(A, x) {
        var K = this;
        return !K._parser["on" + A] && _.indexOf(A) !== -1 && (K._parser["on" + A] = function() {
          var H = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
          H.splice(0, 0, A), K.emit.apply(K, H);
        }), h.prototype.on.call(K, A, x);
      };
      var j = "[CDATA[", B = "DOCTYPE", ee = "http://www.w3.org/XML/1998/namespace", re = "http://www.w3.org/2000/xmlns/", Q = { xml: ee, xmlns: re }, W = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, G = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/, $ = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/, q = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function fe(A) {
        return A === " " || A === `
` || A === "\r" || A === "	";
      }
      function _e(A) {
        return A === '"' || A === "'";
      }
      function Pe(A) {
        return A === ">" || fe(A);
      }
      function ue(A, x) {
        return A.test(x);
      }
      function de(A, x) {
        return !ue(A, x);
      }
      var F = 0;
      r.STATE = {
        BEGIN: F++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: F++,
        // leading whitespace
        TEXT: F++,
        // general stuff
        TEXT_ENTITY: F++,
        // &amp and such.
        OPEN_WAKA: F++,
        // <
        SGML_DECL: F++,
        // <!BLARG
        SGML_DECL_QUOTED: F++,
        // <!BLARG foo "bar
        DOCTYPE: F++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: F++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: F++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: F++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: F++,
        // <!-
        COMMENT: F++,
        // <!--
        COMMENT_ENDING: F++,
        // <!-- blah -
        COMMENT_ENDED: F++,
        // <!-- blah --
        CDATA: F++,
        // <![CDATA[ something
        CDATA_ENDING: F++,
        // ]
        CDATA_ENDING_2: F++,
        // ]]
        PROC_INST: F++,
        // <?hi
        PROC_INST_BODY: F++,
        // <?hi there
        PROC_INST_ENDING: F++,
        // <?hi "there" ?
        OPEN_TAG: F++,
        // <strong
        OPEN_TAG_SLASH: F++,
        // <strong /
        ATTRIB: F++,
        // <a
        ATTRIB_NAME: F++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: F++,
        // <a foo _
        ATTRIB_VALUE: F++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: F++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: F++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: F++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: F++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: F++,
        // <foo bar=&quot
        CLOSE_TAG: F++,
        // </a
        CLOSE_TAG_SAW_WHITE: F++,
        // </a   >
        SCRIPT: F++,
        // <script> ...
        SCRIPT_ENDING: F++
        // <script> ... <
      }, r.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, r.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(r.ENTITIES).forEach(function(A) {
        var x = r.ENTITIES[A], K = typeof x == "number" ? String.fromCharCode(x) : x;
        r.ENTITIES[A] = K;
      });
      for (var Xe in r.STATE)
        r.STATE[r.STATE[Xe]] = Xe;
      F = r.STATE;
      function dt(A, x, K) {
        A[x] && A[x](K);
      }
      function Be(A, x, K) {
        A.textNode && at(A), dt(A, x, K);
      }
      function at(A) {
        A.textNode = Tn(A.opt, A.textNode), A.textNode && dt(A, "ontext", A.textNode), A.textNode = "";
      }
      function Tn(A, x) {
        return A.trim && (x = x.trim()), A.normalize && (x = x.replace(/\s+/g, " ")), x;
      }
      function jt(A, x) {
        return at(A), A.trackPosition && (x += `
Line: ` + A.line + `
Column: ` + A.column + `
Char: ` + A.c), x = new Error(x), A.error = x, dt(A, "onerror", x), A;
      }
      function rt(A) {
        return A.sawRoot && !A.closedRoot && Ee(A, "Unclosed root tag"), A.state !== F.BEGIN && A.state !== F.BEGIN_WHITESPACE && A.state !== F.TEXT && jt(A, "Unexpected end"), at(A), A.c = "", A.closed = !0, dt(A, "onend"), u.call(A, A.strict, A.opt), A;
      }
      function Ee(A, x) {
        if (typeof A != "object" || !(A instanceof u))
          throw new Error("bad call to strictFail");
        A.strict && jt(A, x);
      }
      function Ke(A) {
        A.strict || (A.tagName = A.tagName[A.looseCase]());
        var x = A.tags[A.tags.length - 1] || A, K = A.tag = { name: A.tagName, attributes: {} };
        A.opt.xmlns && (K.ns = x.ns), A.attribList.length = 0, Be(A, "onopentagstart", K);
      }
      function bt(A, x) {
        var K = A.indexOf(":"), H = K < 0 ? ["", A] : A.split(":"), Ve = H[0], S = H[1];
        return x && A === "xmlns" && (Ve = "xmlns", S = ""), { prefix: Ve, local: S };
      }
      function ct(A) {
        if (A.strict || (A.attribName = A.attribName[A.looseCase]()), A.attribList.indexOf(A.attribName) !== -1 || A.tag.attributes.hasOwnProperty(A.attribName)) {
          A.attribName = A.attribValue = "";
          return;
        }
        if (A.opt.xmlns) {
          var x = bt(A.attribName, !0), K = x.prefix, H = x.local;
          if (K === "xmlns")
            if (H === "xml" && A.attribValue !== ee)
              Ee(
                A,
                "xml: prefix must be bound to " + ee + `
Actual: ` + A.attribValue
              );
            else if (H === "xmlns" && A.attribValue !== re)
              Ee(
                A,
                "xmlns: prefix must be bound to " + re + `
Actual: ` + A.attribValue
              );
            else {
              var Ve = A.tag, S = A.tags[A.tags.length - 1] || A;
              Ve.ns === S.ns && (Ve.ns = Object.create(S.ns)), Ve.ns[H] = A.attribValue;
            }
          A.attribList.push([A.attribName, A.attribValue]);
        } else
          A.tag.attributes[A.attribName] = A.attribValue, Be(A, "onattribute", {
            name: A.attribName,
            value: A.attribValue
          });
        A.attribName = A.attribValue = "";
      }
      function xt(A, x) {
        if (A.opt.xmlns) {
          var K = A.tag, H = bt(A.tagName);
          K.prefix = H.prefix, K.local = H.local, K.uri = K.ns[H.prefix] || "", K.prefix && !K.uri && (Ee(A, "Unbound namespace prefix: " + JSON.stringify(A.tagName)), K.uri = H.prefix);
          var Ve = A.tags[A.tags.length - 1] || A;
          K.ns && Ve.ns !== K.ns && Object.keys(K.ns).forEach(function(Ce) {
            Be(A, "onopennamespace", {
              prefix: Ce,
              uri: K.ns[Ce]
            });
          });
          for (var S = 0, M = A.attribList.length; S < M; S++) {
            var ne = A.attribList[S], ie = ne[0], le = ne[1], se = bt(ie, !0), ve = se.prefix, be = se.local, pe = ve === "" ? "" : K.ns[ve] || "", ae = {
              name: ie,
              value: le,
              prefix: ve,
              local: be,
              uri: pe
            };
            ve && ve !== "xmlns" && !pe && (Ee(A, "Unbound namespace prefix: " + JSON.stringify(ve)), ae.uri = ve), A.tag.attributes[ie] = ae, Be(A, "onattribute", ae);
          }
          A.attribList.length = 0;
        }
        A.tag.isSelfClosing = !!x, A.sawRoot = !0, A.tags.push(A.tag), Be(A, "onopentag", A.tag), x || (!A.noscript && A.tagName.toLowerCase() === "script" ? A.state = F.SCRIPT : A.state = F.TEXT, A.tag = null, A.tagName = ""), A.attribName = A.attribValue = "", A.attribList.length = 0;
      }
      function Lt(A) {
        if (!A.tagName) {
          Ee(A, "Weird empty close tag."), A.textNode += "</>", A.state = F.TEXT;
          return;
        }
        if (A.script) {
          if (A.tagName !== "script") {
            A.script += "</" + A.tagName + ">", A.tagName = "", A.state = F.SCRIPT;
            return;
          }
          Be(A, "onscript", A.script), A.script = "";
        }
        var x = A.tags.length, K = A.tagName;
        A.strict || (K = K[A.looseCase]());
        for (var H = K; x--; ) {
          var Ve = A.tags[x];
          if (Ve.name !== H)
            Ee(A, "Unexpected close tag");
          else
            break;
        }
        if (x < 0) {
          Ee(A, "Unmatched closing tag: " + A.tagName), A.textNode += "</" + A.tagName + ">", A.state = F.TEXT;
          return;
        }
        A.tagName = K;
        for (var S = A.tags.length; S-- > x; ) {
          var M = A.tag = A.tags.pop();
          A.tagName = A.tag.name, Be(A, "onclosetag", A.tagName);
          var ne = {};
          for (var ie in M.ns)
            ne[ie] = M.ns[ie];
          var le = A.tags[A.tags.length - 1] || A;
          A.opt.xmlns && M.ns !== le.ns && Object.keys(M.ns).forEach(function(se) {
            var ve = M.ns[se];
            Be(A, "onclosenamespace", { prefix: se, uri: ve });
          });
        }
        x === 0 && (A.closedRoot = !0), A.tagName = A.attribValue = A.attribName = "", A.attribList.length = 0, A.state = F.TEXT;
      }
      function Ft(A) {
        var x = A.entity, K = x.toLowerCase(), H, Ve = "";
        return A.ENTITIES[x] ? A.ENTITIES[x] : A.ENTITIES[K] ? A.ENTITIES[K] : (x = K, x.charAt(0) === "#" && (x.charAt(1) === "x" ? (x = x.slice(2), H = parseInt(x, 16), Ve = H.toString(16)) : (x = x.slice(1), H = parseInt(x, 10), Ve = H.toString(10))), x = x.replace(/^0+/, ""), isNaN(H) || Ve.toLowerCase() !== x ? (Ee(A, "Invalid character entity"), "&" + A.entity + ";") : String.fromCodePoint(H));
      }
      function Bn(A, x) {
        x === "<" ? (A.state = F.OPEN_WAKA, A.startTagPosition = A.position) : fe(x) || (Ee(A, "Non-whitespace before first tag."), A.textNode = x, A.state = F.TEXT);
      }
      function fn(A, x) {
        var K = "";
        return x < A.length && (K = A.charAt(x)), K;
      }
      function Nt(A) {
        var x = this;
        if (this.error)
          throw this.error;
        if (x.closed)
          return jt(
            x,
            "Cannot write after close. Assign an onready handler."
          );
        if (A === null)
          return rt(x);
        typeof A == "object" && (A = A.toString());
        for (var K = 0, H = ""; H = fn(A, K++), x.c = H, !!H; )
          switch (x.trackPosition && (x.position++, H === `
` ? (x.line++, x.column = 0) : x.column++), x.state) {
            case F.BEGIN:
              if (x.state = F.BEGIN_WHITESPACE, H === "\uFEFF")
                continue;
              Bn(x, H);
              continue;
            case F.BEGIN_WHITESPACE:
              Bn(x, H);
              continue;
            case F.TEXT:
              if (x.sawRoot && !x.closedRoot) {
                for (var Ve = K - 1; H && H !== "<" && H !== "&"; )
                  H = fn(A, K++), H && x.trackPosition && (x.position++, H === `
` ? (x.line++, x.column = 0) : x.column++);
                x.textNode += A.substring(Ve, K - 1);
              }
              H === "<" && !(x.sawRoot && x.closedRoot && !x.strict) ? (x.state = F.OPEN_WAKA, x.startTagPosition = x.position) : (!fe(H) && (!x.sawRoot || x.closedRoot) && Ee(x, "Text data outside of root node."), H === "&" ? x.state = F.TEXT_ENTITY : x.textNode += H);
              continue;
            case F.SCRIPT:
              H === "<" ? x.state = F.SCRIPT_ENDING : x.script += H;
              continue;
            case F.SCRIPT_ENDING:
              H === "/" ? x.state = F.CLOSE_TAG : (x.script += "<" + H, x.state = F.SCRIPT);
              continue;
            case F.OPEN_WAKA:
              if (H === "!")
                x.state = F.SGML_DECL, x.sgmlDecl = "";
              else if (!fe(H)) if (ue(W, H))
                x.state = F.OPEN_TAG, x.tagName = H;
              else if (H === "/")
                x.state = F.CLOSE_TAG, x.tagName = "";
              else if (H === "?")
                x.state = F.PROC_INST, x.procInstName = x.procInstBody = "";
              else {
                if (Ee(x, "Unencoded <"), x.startTagPosition + 1 < x.position) {
                  var S = x.position - x.startTagPosition;
                  H = new Array(S).join(" ") + H;
                }
                x.textNode += "<" + H, x.state = F.TEXT;
              }
              continue;
            case F.SGML_DECL:
              if (x.sgmlDecl + H === "--") {
                x.state = F.COMMENT, x.comment = "", x.sgmlDecl = "";
                continue;
              }
              x.doctype && x.doctype !== !0 && x.sgmlDecl ? (x.state = F.DOCTYPE_DTD, x.doctype += "<!" + x.sgmlDecl + H, x.sgmlDecl = "") : (x.sgmlDecl + H).toUpperCase() === j ? (Be(x, "onopencdata"), x.state = F.CDATA, x.sgmlDecl = "", x.cdata = "") : (x.sgmlDecl + H).toUpperCase() === B ? (x.state = F.DOCTYPE, (x.doctype || x.sawRoot) && Ee(
                x,
                "Inappropriately located doctype declaration"
              ), x.doctype = "", x.sgmlDecl = "") : H === ">" ? (Be(x, "onsgmldeclaration", x.sgmlDecl), x.sgmlDecl = "", x.state = F.TEXT) : (_e(H) && (x.state = F.SGML_DECL_QUOTED), x.sgmlDecl += H);
              continue;
            case F.SGML_DECL_QUOTED:
              H === x.q && (x.state = F.SGML_DECL, x.q = ""), x.sgmlDecl += H;
              continue;
            case F.DOCTYPE:
              H === ">" ? (x.state = F.TEXT, Be(x, "ondoctype", x.doctype), x.doctype = !0) : (x.doctype += H, H === "[" ? x.state = F.DOCTYPE_DTD : _e(H) && (x.state = F.DOCTYPE_QUOTED, x.q = H));
              continue;
            case F.DOCTYPE_QUOTED:
              x.doctype += H, H === x.q && (x.q = "", x.state = F.DOCTYPE);
              continue;
            case F.DOCTYPE_DTD:
              H === "]" ? (x.doctype += H, x.state = F.DOCTYPE) : H === "<" ? (x.state = F.OPEN_WAKA, x.startTagPosition = x.position) : _e(H) ? (x.doctype += H, x.state = F.DOCTYPE_DTD_QUOTED, x.q = H) : x.doctype += H;
              continue;
            case F.DOCTYPE_DTD_QUOTED:
              x.doctype += H, H === x.q && (x.state = F.DOCTYPE_DTD, x.q = "");
              continue;
            case F.COMMENT:
              H === "-" ? x.state = F.COMMENT_ENDING : x.comment += H;
              continue;
            case F.COMMENT_ENDING:
              H === "-" ? (x.state = F.COMMENT_ENDED, x.comment = Tn(x.opt, x.comment), x.comment && Be(x, "oncomment", x.comment), x.comment = "") : (x.comment += "-" + H, x.state = F.COMMENT);
              continue;
            case F.COMMENT_ENDED:
              H !== ">" ? (Ee(x, "Malformed comment"), x.comment += "--" + H, x.state = F.COMMENT) : x.doctype && x.doctype !== !0 ? x.state = F.DOCTYPE_DTD : x.state = F.TEXT;
              continue;
            case F.CDATA:
              H === "]" ? x.state = F.CDATA_ENDING : x.cdata += H;
              continue;
            case F.CDATA_ENDING:
              H === "]" ? x.state = F.CDATA_ENDING_2 : (x.cdata += "]" + H, x.state = F.CDATA);
              continue;
            case F.CDATA_ENDING_2:
              H === ">" ? (x.cdata && Be(x, "oncdata", x.cdata), Be(x, "onclosecdata"), x.cdata = "", x.state = F.TEXT) : H === "]" ? x.cdata += "]" : (x.cdata += "]]" + H, x.state = F.CDATA);
              continue;
            case F.PROC_INST:
              H === "?" ? x.state = F.PROC_INST_ENDING : fe(H) ? x.state = F.PROC_INST_BODY : x.procInstName += H;
              continue;
            case F.PROC_INST_BODY:
              if (!x.procInstBody && fe(H))
                continue;
              H === "?" ? x.state = F.PROC_INST_ENDING : x.procInstBody += H;
              continue;
            case F.PROC_INST_ENDING:
              H === ">" ? (Be(x, "onprocessinginstruction", {
                name: x.procInstName,
                body: x.procInstBody
              }), x.procInstName = x.procInstBody = "", x.state = F.TEXT) : (x.procInstBody += "?" + H, x.state = F.PROC_INST_BODY);
              continue;
            case F.OPEN_TAG:
              ue(G, H) ? x.tagName += H : (Ke(x), H === ">" ? xt(x) : H === "/" ? x.state = F.OPEN_TAG_SLASH : (fe(H) || Ee(x, "Invalid character in tag name"), x.state = F.ATTRIB));
              continue;
            case F.OPEN_TAG_SLASH:
              H === ">" ? (xt(x, !0), Lt(x)) : (Ee(x, "Forward-slash in opening tag not followed by >"), x.state = F.ATTRIB);
              continue;
            case F.ATTRIB:
              if (fe(H))
                continue;
              H === ">" ? xt(x) : H === "/" ? x.state = F.OPEN_TAG_SLASH : ue(W, H) ? (x.attribName = H, x.attribValue = "", x.state = F.ATTRIB_NAME) : Ee(x, "Invalid attribute name");
              continue;
            case F.ATTRIB_NAME:
              H === "=" ? x.state = F.ATTRIB_VALUE : H === ">" ? (Ee(x, "Attribute without value"), x.attribValue = x.attribName, ct(x), xt(x)) : fe(H) ? x.state = F.ATTRIB_NAME_SAW_WHITE : ue(G, H) ? x.attribName += H : Ee(x, "Invalid attribute name");
              continue;
            case F.ATTRIB_NAME_SAW_WHITE:
              if (H === "=")
                x.state = F.ATTRIB_VALUE;
              else {
                if (fe(H))
                  continue;
                Ee(x, "Attribute without value"), x.tag.attributes[x.attribName] = "", x.attribValue = "", Be(x, "onattribute", {
                  name: x.attribName,
                  value: ""
                }), x.attribName = "", H === ">" ? xt(x) : ue(W, H) ? (x.attribName = H, x.state = F.ATTRIB_NAME) : (Ee(x, "Invalid attribute name"), x.state = F.ATTRIB);
              }
              continue;
            case F.ATTRIB_VALUE:
              if (fe(H))
                continue;
              _e(H) ? (x.q = H, x.state = F.ATTRIB_VALUE_QUOTED) : (x.opt.unquotedAttributeValues || jt(x, "Unquoted attribute value"), x.state = F.ATTRIB_VALUE_UNQUOTED, x.attribValue = H);
              continue;
            case F.ATTRIB_VALUE_QUOTED:
              if (H !== x.q) {
                H === "&" ? x.state = F.ATTRIB_VALUE_ENTITY_Q : x.attribValue += H;
                continue;
              }
              ct(x), x.q = "", x.state = F.ATTRIB_VALUE_CLOSED;
              continue;
            case F.ATTRIB_VALUE_CLOSED:
              fe(H) ? x.state = F.ATTRIB : H === ">" ? xt(x) : H === "/" ? x.state = F.OPEN_TAG_SLASH : ue(W, H) ? (Ee(x, "No whitespace between attributes"), x.attribName = H, x.attribValue = "", x.state = F.ATTRIB_NAME) : Ee(x, "Invalid attribute name");
              continue;
            case F.ATTRIB_VALUE_UNQUOTED:
              if (!Pe(H)) {
                H === "&" ? x.state = F.ATTRIB_VALUE_ENTITY_U : x.attribValue += H;
                continue;
              }
              ct(x), H === ">" ? xt(x) : x.state = F.ATTRIB;
              continue;
            case F.CLOSE_TAG:
              if (x.tagName)
                H === ">" ? Lt(x) : ue(G, H) ? x.tagName += H : x.script ? (x.script += "</" + x.tagName, x.tagName = "", x.state = F.SCRIPT) : (fe(H) || Ee(x, "Invalid tagname in closing tag"), x.state = F.CLOSE_TAG_SAW_WHITE);
              else {
                if (fe(H))
                  continue;
                de(W, H) ? x.script ? (x.script += "</" + H, x.state = F.SCRIPT) : Ee(x, "Invalid tagname in closing tag.") : x.tagName = H;
              }
              continue;
            case F.CLOSE_TAG_SAW_WHITE:
              if (fe(H))
                continue;
              H === ">" ? Lt(x) : Ee(x, "Invalid characters in closing tag");
              continue;
            case F.TEXT_ENTITY:
            case F.ATTRIB_VALUE_ENTITY_Q:
            case F.ATTRIB_VALUE_ENTITY_U:
              var M, ne;
              switch (x.state) {
                case F.TEXT_ENTITY:
                  M = F.TEXT, ne = "textNode";
                  break;
                case F.ATTRIB_VALUE_ENTITY_Q:
                  M = F.ATTRIB_VALUE_QUOTED, ne = "attribValue";
                  break;
                case F.ATTRIB_VALUE_ENTITY_U:
                  M = F.ATTRIB_VALUE_UNQUOTED, ne = "attribValue";
                  break;
              }
              if (H === ";") {
                var ie = Ft(x);
                x.opt.unparsedEntities && !Object.values(r.XML_ENTITIES).includes(ie) ? (x.entity = "", x.state = M, x.write(ie)) : (x[ne] += ie, x.entity = "", x.state = M);
              } else ue(x.entity.length ? q : $, H) ? x.entity += H : (Ee(x, "Invalid character in entity name"), x[ne] += "&" + x.entity + H, x.entity = "", x.state = M);
              continue;
            default:
              throw new Error(x, "Unknown state: " + x.state);
          }
        return x.position >= x.bufferCheckPosition && c(x), x;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      String.fromCodePoint || function() {
        var A = String.fromCharCode, x = Math.floor, K = function() {
          var H = 16384, Ve = [], S, M, ne = -1, ie = arguments.length;
          if (!ie)
            return "";
          for (var le = ""; ++ne < ie; ) {
            var se = Number(arguments[ne]);
            if (!isFinite(se) || // `NaN`, `+Infinity`, or `-Infinity`
            se < 0 || // not a valid Unicode code point
            se > 1114111 || // not a valid Unicode code point
            x(se) !== se)
              throw RangeError("Invalid code point: " + se);
            se <= 65535 ? Ve.push(se) : (se -= 65536, S = (se >> 10) + 55296, M = se % 1024 + 56320, Ve.push(S, M)), (ne + 1 === ie || Ve.length > H) && (le += A.apply(null, Ve), Ve.length = 0);
          }
          return le;
        };
        Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
          value: K,
          configurable: !0,
          writable: !0
        }) : String.fromCodePoint = K;
      }();
    })(t);
  }(Fu)), Fu;
}
Xd();
const st = "sclElements", zd = {
  default: {
    prefix: "",
    uri: "http://www.iec.ch/61850/2003/SCL"
  }
};
var _a = { exports: {} }, Jd = _a.exports, Bu;
function Zd() {
  return Bu || (Bu = 1, function(t, r) {
    (function(s, u) {
      t.exports = u();
    })(Jd, function() {
      var s = function(e, n) {
        return (s = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(o, i) {
          o.__proto__ = i;
        } || function(o, i) {
          for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (o[a] = i[a]);
        })(e, n);
      }, u = function() {
        return (u = Object.assign || function(e) {
          for (var n, o = 1, i = arguments.length; o < i; o++) for (var a in n = arguments[o]) Object.prototype.hasOwnProperty.call(n, a) && (e[a] = n[a]);
          return e;
        }).apply(this, arguments);
      };
      function c(e, n, o) {
        for (var i, a = 0, l = n.length; a < l; a++) !i && a in n || ((i = i || Array.prototype.slice.call(n, 0, a))[a] = n[a]);
        return e.concat(i || Array.prototype.slice.call(n));
      }
      var d = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : Wd, f = Object.keys, h = Array.isArray;
      function _(e, n) {
        return typeof n != "object" || f(n).forEach(function(o) {
          e[o] = n[o];
        }), e;
      }
      typeof Promise > "u" || d.Promise || (d.Promise = Promise);
      var k = Object.getPrototypeOf, D = {}.hasOwnProperty;
      function j(e, n) {
        return D.call(e, n);
      }
      function B(e, n) {
        typeof n == "function" && (n = n(k(e))), (typeof Reflect > "u" ? f : Reflect.ownKeys)(n).forEach(function(o) {
          re(e, o, n[o]);
        });
      }
      var ee = Object.defineProperty;
      function re(e, n, o, i) {
        ee(e, n, _(o && j(o, "get") && typeof o.get == "function" ? { get: o.get, set: o.set, configurable: !0 } : { value: o, configurable: !0, writable: !0 }, i));
      }
      function Q(e) {
        return { from: function(n) {
          return e.prototype = Object.create(n.prototype), re(e.prototype, "constructor", e), { extend: B.bind(null, e.prototype) };
        } };
      }
      var W = Object.getOwnPropertyDescriptor, G = [].slice;
      function $(e, n, o) {
        return G.call(e, n, o);
      }
      function q(e, n) {
        return n(e);
      }
      function fe(e) {
        if (!e) throw new Error("Assertion Failed");
      }
      function _e(e) {
        d.setImmediate ? setImmediate(e) : setTimeout(e, 0);
      }
      function Pe(e, n) {
        if (typeof n == "string" && j(e, n)) return e[n];
        if (!n) return e;
        if (typeof n != "string") {
          for (var o = [], i = 0, a = n.length; i < a; ++i) {
            var l = Pe(e, n[i]);
            o.push(l);
          }
          return o;
        }
        var p = n.indexOf(".");
        if (p !== -1) {
          var m = e[n.substr(0, p)];
          return m == null ? void 0 : Pe(m, n.substr(p + 1));
        }
      }
      function ue(e, n, o) {
        if (e && n !== void 0 && !("isFrozen" in Object && Object.isFrozen(e))) if (typeof n != "string" && "length" in n) {
          fe(typeof o != "string" && "length" in o);
          for (var i = 0, a = n.length; i < a; ++i) ue(e, n[i], o[i]);
        } else {
          var l, p, m = n.indexOf(".");
          m !== -1 ? (l = n.substr(0, m), (p = n.substr(m + 1)) === "" ? o === void 0 ? h(e) && !isNaN(parseInt(l)) ? e.splice(l, 1) : delete e[l] : e[l] = o : ue(m = !(m = e[l]) || !j(e, l) ? e[l] = {} : m, p, o)) : o === void 0 ? h(e) && !isNaN(parseInt(n)) ? e.splice(n, 1) : delete e[n] : e[n] = o;
        }
      }
      function de(e) {
        var n, o = {};
        for (n in e) j(e, n) && (o[n] = e[n]);
        return o;
      }
      var F = [].concat;
      function Xe(e) {
        return F.apply([], e);
      }
      var je = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(Xe([8, 16, 32, 64].map(function(e) {
        return ["Int", "Uint", "Float"].map(function(n) {
          return n + e + "Array";
        });
      }))).filter(function(e) {
        return d[e];
      }), dt = new Set(je.map(function(e) {
        return d[e];
      })), Be = null;
      function at(e) {
        return Be = /* @__PURE__ */ new WeakMap(), e = function n(o) {
          if (!o || typeof o != "object") return o;
          var i = Be.get(o);
          if (i) return i;
          if (h(o)) {
            i = [], Be.set(o, i);
            for (var a = 0, l = o.length; a < l; ++a) i.push(n(o[a]));
          } else if (dt.has(o.constructor)) i = o;
          else {
            var p, m = k(o);
            for (p in i = m === Object.prototype ? {} : Object.create(m), Be.set(o, i), o) j(o, p) && (i[p] = n(o[p]));
          }
          return i;
        }(e), Be = null, e;
      }
      var Tn = {}.toString;
      function jt(e) {
        return Tn.call(e).slice(8, -1);
      }
      var rt = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", Ee = typeof rt == "symbol" ? function(e) {
        var n;
        return e != null && (n = e[rt]) && n.apply(e);
      } : function() {
        return null;
      };
      function Ke(e, n) {
        return n = e.indexOf(n), 0 <= n && e.splice(n, 1), 0 <= n;
      }
      var bt = {};
      function ct(e) {
        var n, o, i, a;
        if (arguments.length === 1) {
          if (h(e)) return e.slice();
          if (this === bt && typeof e == "string") return [e];
          if (a = Ee(e)) {
            for (o = []; !(i = a.next()).done; ) o.push(i.value);
            return o;
          }
          if (e == null) return [e];
          if (typeof (n = e.length) != "number") return [e];
          for (o = new Array(n); n--; ) o[n] = e[n];
          return o;
        }
        for (n = arguments.length, o = new Array(n); n--; ) o[n] = arguments[n];
        return o;
      }
      var xt = typeof Symbol < "u" ? function(e) {
        return e[Symbol.toStringTag] === "AsyncFunction";
      } : function() {
        return !1;
      }, Re = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], wt = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(Re), Lt = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
      function Ft(e, n) {
        this.name = e, this.message = n;
      }
      function Bn(e, n) {
        return e + ". Errors: " + Object.keys(n).map(function(o) {
          return n[o].toString();
        }).filter(function(o, i, a) {
          return a.indexOf(o) === i;
        }).join(`
`);
      }
      function fn(e, n, o, i) {
        this.failures = n, this.failedKeys = i, this.successCount = o, this.message = Bn(e, n);
      }
      function Nt(e, n) {
        this.name = "BulkError", this.failures = Object.keys(n).map(function(o) {
          return n[o];
        }), this.failuresByPos = n, this.message = Bn(e, this.failures);
      }
      Q(Ft).from(Error).extend({ toString: function() {
        return this.name + ": " + this.message;
      } }), Q(fn).from(Ft), Q(Nt).from(Ft);
      var A = wt.reduce(function(e, n) {
        return e[n] = n + "Error", e;
      }, {}), x = Ft, K = wt.reduce(function(e, n) {
        var o = n + "Error";
        function i(a, l) {
          this.name = o, a ? typeof a == "string" ? (this.message = "".concat(a).concat(l ? `
 ` + l : ""), this.inner = l || null) : typeof a == "object" && (this.message = "".concat(a.name, " ").concat(a.message), this.inner = a) : (this.message = Lt[n] || o, this.inner = null);
        }
        return Q(i).from(x), e[n] = i, e;
      }, {});
      K.Syntax = SyntaxError, K.Type = TypeError, K.Range = RangeError;
      var H = Re.reduce(function(e, n) {
        return e[n + "Error"] = K[n], e;
      }, {}), Ve = wt.reduce(function(e, n) {
        return ["Syntax", "Type", "Range"].indexOf(n) === -1 && (e[n + "Error"] = K[n]), e;
      }, {});
      function S() {
      }
      function M(e) {
        return e;
      }
      function ne(e, n) {
        return e == null || e === M ? n : function(o) {
          return n(e(o));
        };
      }
      function ie(e, n) {
        return function() {
          e.apply(this, arguments), n.apply(this, arguments);
        };
      }
      function le(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          o !== void 0 && (arguments[0] = o);
          var i = this.onsuccess, a = this.onerror;
          this.onsuccess = null, this.onerror = null;
          var l = n.apply(this, arguments);
          return i && (this.onsuccess = this.onsuccess ? ie(i, this.onsuccess) : i), a && (this.onerror = this.onerror ? ie(a, this.onerror) : a), l !== void 0 ? l : o;
        };
      }
      function se(e, n) {
        return e === S ? n : function() {
          e.apply(this, arguments);
          var o = this.onsuccess, i = this.onerror;
          this.onsuccess = this.onerror = null, n.apply(this, arguments), o && (this.onsuccess = this.onsuccess ? ie(o, this.onsuccess) : o), i && (this.onerror = this.onerror ? ie(i, this.onerror) : i);
        };
      }
      function ve(e, n) {
        return e === S ? n : function(o) {
          var i = e.apply(this, arguments);
          _(o, i);
          var a = this.onsuccess, l = this.onerror;
          return this.onsuccess = null, this.onerror = null, o = n.apply(this, arguments), a && (this.onsuccess = this.onsuccess ? ie(a, this.onsuccess) : a), l && (this.onerror = this.onerror ? ie(l, this.onerror) : l), i === void 0 ? o === void 0 ? void 0 : o : _(i, o);
        };
      }
      function be(e, n) {
        return e === S ? n : function() {
          return n.apply(this, arguments) !== !1 && e.apply(this, arguments);
        };
      }
      function pe(e, n) {
        return e === S ? n : function() {
          var o = e.apply(this, arguments);
          if (o && typeof o.then == "function") {
            for (var i = this, a = arguments.length, l = new Array(a); a--; ) l[a] = arguments[a];
            return o.then(function() {
              return n.apply(i, l);
            });
          }
          return n.apply(this, arguments);
        };
      }
      Ve.ModifyError = fn, Ve.DexieError = Ft, Ve.BulkError = Nt;
      var ae = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
      function Ce(e) {
        ae = e;
      }
      var we = {}, Se = 100, je = typeof Promise > "u" ? [] : function() {
        var e = Promise.resolve();
        if (typeof crypto > "u" || !crypto.subtle) return [e, k(e), e];
        var n = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
        return [n, k(n), e];
      }(), Re = je[0], wt = je[1], je = je[2], wt = wt && wt.then, Ue = Re && Re.constructor, He = !!je, ht = function(e, n) {
        dn.push([e, n]), Rt && (queueMicrotask(xs), Rt = !1);
      }, Et = !0, Rt = !0, mt = [], zt = [], $n = M, ot = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: S, pgp: !1, env: {}, finalize: S }, oe = ot, dn = [], Jt = 0, Yn = [];
      function Z(e) {
        if (typeof this != "object") throw new TypeError("Promises must be constructed via new");
        this._listeners = [], this._lib = !1;
        var n = this._PSD = oe;
        if (typeof e != "function") {
          if (e !== we) throw new TypeError("Not a function");
          return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Kr(this, this._value));
        }
        this._state = null, this._value = null, ++n.ref, function o(i, a) {
          try {
            a(function(l) {
              if (i._state === null) {
                if (l === i) throw new TypeError("A promise cannot be resolved with itself.");
                var p = i._lib && hn();
                l && typeof l.then == "function" ? o(i, function(m, v) {
                  l instanceof Z ? l._then(m, v) : l.then(m, v);
                }) : (i._state = !0, i._value = l, Bo(i)), p && mn();
              }
            }, Kr.bind(null, i));
          } catch (l) {
            Kr(i, l);
          }
        }(this, e);
      }
      var Fr = { get: function() {
        var e = oe, n = Jn;
        function o(i, a) {
          var l = this, p = !e.global && (e !== oe || n !== Jn), m = p && !Bt(), v = new Z(function(b, O) {
            Mr(l, new Mo(qo(i, e, p, m), qo(a, e, p, m), b, O, e));
          });
          return this._consoleTask && (v._consoleTask = this._consoleTask), v;
        }
        return o.prototype = we, o;
      }, set: function(e) {
        re(this, "then", e && e.prototype === we ? Fr : { get: function() {
          return e;
        }, set: Fr.set });
      } };
      function Mo(e, n, o, i, a) {
        this.onFulfilled = typeof e == "function" ? e : null, this.onRejected = typeof n == "function" ? n : null, this.resolve = o, this.reject = i, this.psd = a;
      }
      function Kr(e, n) {
        var o, i;
        zt.push(n), e._state === null && (o = e._lib && hn(), n = $n(n), e._state = !1, e._value = n, i = e, mt.some(function(a) {
          return a._value === i._value;
        }) || mt.push(i), Bo(e), o && mn());
      }
      function Bo(e) {
        var n = e._listeners;
        e._listeners = [];
        for (var o = 0, i = n.length; o < i; ++o) Mr(e, n[o]);
        var a = e._PSD;
        --a.ref || a.finalize(), Jt === 0 && (++Jt, ht(function() {
          --Jt == 0 && Br();
        }, []));
      }
      function Mr(e, n) {
        if (e._state !== null) {
          var o = e._state ? n.onFulfilled : n.onRejected;
          if (o === null) return (e._state ? n.resolve : n.reject)(e._value);
          ++n.psd.ref, ++Jt, ht(_s, [o, e, n]);
        } else e._listeners.push(n);
      }
      function _s(e, n, o) {
        try {
          var i, a = n._value;
          !n._state && zt.length && (zt = []), i = ae && n._consoleTask ? n._consoleTask.run(function() {
            return e(a);
          }) : e(a), n._state || zt.indexOf(a) !== -1 || function(l) {
            for (var p = mt.length; p; ) if (mt[--p]._value === l._value) return mt.splice(p, 1);
          }(n), o.resolve(i);
        } catch (l) {
          o.reject(l);
        } finally {
          --Jt == 0 && Br(), --o.psd.ref || o.psd.finalize();
        }
      }
      function xs() {
        Zt(ot, function() {
          hn() && mn();
        });
      }
      function hn() {
        var e = Et;
        return Rt = Et = !1, e;
      }
      function mn() {
        var e, n, o;
        do
          for (; 0 < dn.length; ) for (e = dn, dn = [], o = e.length, n = 0; n < o; ++n) {
            var i = e[n];
            i[0].apply(null, i[1]);
          }
        while (0 < dn.length);
        Rt = Et = !0;
      }
      function Br() {
        var e = mt;
        mt = [], e.forEach(function(i) {
          i._PSD.onunhandled.call(null, i._value, i);
        });
        for (var n = Yn.slice(0), o = n.length; o; ) n[--o]();
      }
      function Qn(e) {
        return new Z(we, !1, e);
      }
      function Le(e, n) {
        var o = oe;
        return function() {
          var i = hn(), a = oe;
          try {
            return $t(o, !0), e.apply(this, arguments);
          } catch (l) {
            n && n(l);
          } finally {
            $t(a, !1), i && mn();
          }
        };
      }
      B(Z.prototype, { then: Fr, _then: function(e, n) {
        Mr(this, new Mo(null, null, e, n, oe));
      }, catch: function(e) {
        if (arguments.length === 1) return this.then(null, e);
        var n = e, o = arguments[1];
        return typeof n == "function" ? this.then(null, function(i) {
          return (i instanceof n ? o : Qn)(i);
        }) : this.then(null, function(i) {
          return (i && i.name === n ? o : Qn)(i);
        });
      }, finally: function(e) {
        return this.then(function(n) {
          return Z.resolve(e()).then(function() {
            return n;
          });
        }, function(n) {
          return Z.resolve(e()).then(function() {
            return Qn(n);
          });
        });
      }, timeout: function(e, n) {
        var o = this;
        return e < 1 / 0 ? new Z(function(i, a) {
          var l = setTimeout(function() {
            return a(new K.Timeout(n));
          }, e);
          o.then(i, a).finally(clearTimeout.bind(null, l));
        }) : this;
      } }), typeof Symbol < "u" && Symbol.toStringTag && re(Z.prototype, Symbol.toStringTag, "Dexie.Promise"), ot.env = $o(), B(Z, { all: function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n, o) {
          e.length === 0 && n([]);
          var i = e.length;
          e.forEach(function(a, l) {
            return Z.resolve(a).then(function(p) {
              e[l] = p, --i || n(e);
            }, o);
          });
        });
      }, resolve: function(e) {
        return e instanceof Z ? e : e && typeof e.then == "function" ? new Z(function(n, o) {
          e.then(n, o);
        }) : new Z(we, !0, e);
      }, reject: Qn, race: function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n, o) {
          e.map(function(i) {
            return Z.resolve(i).then(n, o);
          });
        });
      }, PSD: { get: function() {
        return oe;
      }, set: function(e) {
        return oe = e;
      } }, totalEchoes: { get: function() {
        return Jn;
      } }, newPSD: Mt, usePSD: Zt, scheduler: { get: function() {
        return ht;
      }, set: function(e) {
        ht = e;
      } }, rejectionMapper: { get: function() {
        return $n;
      }, set: function(e) {
        $n = e;
      } }, follow: function(e, n) {
        return new Z(function(o, i) {
          return Mt(function(a, l) {
            var p = oe;
            p.unhandleds = [], p.onunhandled = l, p.finalize = ie(function() {
              var m, v = this;
              m = function() {
                v.unhandleds.length === 0 ? a() : l(v.unhandleds[0]);
              }, Yn.push(function b() {
                m(), Yn.splice(Yn.indexOf(b), 1);
              }), ++Jt, ht(function() {
                --Jt == 0 && Br();
              }, []);
            }, p.finalize), e();
          }, n, o, i);
        });
      } }), Ue && (Ue.allSettled && re(Z, "allSettled", function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n) {
          e.length === 0 && n([]);
          var o = e.length, i = new Array(o);
          e.forEach(function(a, l) {
            return Z.resolve(a).then(function(p) {
              return i[l] = { status: "fulfilled", value: p };
            }, function(p) {
              return i[l] = { status: "rejected", reason: p };
            }).then(function() {
              return --o || n(i);
            });
          });
        });
      }), Ue.any && typeof AggregateError < "u" && re(Z, "any", function() {
        var e = ct.apply(null, arguments).map(Zn);
        return new Z(function(n, o) {
          e.length === 0 && o(new AggregateError([]));
          var i = e.length, a = new Array(i);
          e.forEach(function(l, p) {
            return Z.resolve(l).then(function(m) {
              return n(m);
            }, function(m) {
              a[p] = m, --i || o(new AggregateError(a));
            });
          });
        });
      }), Ue.withResolvers && (Z.withResolvers = Ue.withResolvers));
      var Ge = { awaits: 0, echoes: 0, id: 0 }, Os = 0, Xn = [], zn = 0, Jn = 0, Ts = 0;
      function Mt(e, n, o, i) {
        var a = oe, l = Object.create(a);
        return l.parent = a, l.ref = 0, l.global = !1, l.id = ++Ts, ot.env, l.env = He ? { Promise: Z, PromiseProp: { value: Z, configurable: !0, writable: !0 }, all: Z.all, race: Z.race, allSettled: Z.allSettled, any: Z.any, resolve: Z.resolve, reject: Z.reject } : {}, n && _(l, n), ++a.ref, l.finalize = function() {
          --this.parent.ref || this.parent.finalize();
        }, i = Zt(l, e, o, i), l.ref === 0 && l.finalize(), i;
      }
      function yn() {
        return Ge.id || (Ge.id = ++Os), ++Ge.awaits, Ge.echoes += Se, Ge.id;
      }
      function Bt() {
        return !!Ge.awaits && (--Ge.awaits == 0 && (Ge.id = 0), Ge.echoes = Ge.awaits * Se, !0);
      }
      function Zn(e) {
        return Ge.echoes && e && e.constructor === Ue ? (yn(), e.then(function(n) {
          return Bt(), n;
        }, function(n) {
          return Bt(), $e(n);
        })) : e;
      }
      function Es() {
        var e = Xn[Xn.length - 1];
        Xn.pop(), $t(e, !1);
      }
      function $t(e, n) {
        var o, i = oe;
        (n ? !Ge.echoes || zn++ && e === oe : !zn || --zn && e === oe) || queueMicrotask(n ? (function(a) {
          ++Jn, Ge.echoes && --Ge.echoes != 0 || (Ge.echoes = Ge.awaits = Ge.id = 0), Xn.push(oe), $t(a, !0);
        }).bind(null, e) : Es), e !== oe && (oe = e, i === ot && (ot.env = $o()), He && (o = ot.env.Promise, n = e.env, (i.global || e.global) && (Object.defineProperty(d, "Promise", n.PromiseProp), o.all = n.all, o.race = n.race, o.resolve = n.resolve, o.reject = n.reject, n.allSettled && (o.allSettled = n.allSettled), n.any && (o.any = n.any))));
      }
      function $o() {
        var e = d.Promise;
        return He ? { Promise: e, PromiseProp: Object.getOwnPropertyDescriptor(d, "Promise"), all: e.all, race: e.race, allSettled: e.allSettled, any: e.any, resolve: e.resolve, reject: e.reject } : {};
      }
      function Zt(e, n, o, i, a) {
        var l = oe;
        try {
          return $t(e, !0), n(o, i, a);
        } finally {
          $t(l, !1);
        }
      }
      function qo(e, n, o, i) {
        return typeof e != "function" ? e : function() {
          var a = oe;
          o && yn(), $t(n, !0);
          try {
            return e.apply(this, arguments);
          } finally {
            $t(a, !1), i && queueMicrotask(Bt);
          }
        };
      }
      function $r(e) {
        Promise === Ue && Ge.echoes === 0 ? zn === 0 ? e() : enqueueNativeMicroTask(e) : setTimeout(e, 0);
      }
      ("" + wt).indexOf("[native code]") === -1 && (yn = Bt = S);
      var $e = Z.reject, en = "￿", Dt = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", Uo = "String expected.", vn = [], er = "__dbnames", qr = "readonly", Ur = "readwrite";
      function tn(e, n) {
        return e ? n ? function() {
          return e.apply(this, arguments) && n.apply(this, arguments);
        } : e : n;
      }
      var Vo = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
      function tr(e) {
        return typeof e != "string" || /\./.test(e) ? function(n) {
          return n;
        } : function(n) {
          return n[e] === void 0 && e in n && delete (n = at(n))[e], n;
        };
      }
      function Wo() {
        throw K.Type("Entity instances must never be new:ed. Instances are generated by the framework bypassing the constructor.");
      }
      function xe(e, n) {
        try {
          var o = Ho(e), i = Ho(n);
          if (o !== i) return o === "Array" ? 1 : i === "Array" ? -1 : o === "binary" ? 1 : i === "binary" ? -1 : o === "string" ? 1 : i === "string" ? -1 : o === "Date" ? 1 : i !== "Date" ? NaN : -1;
          switch (o) {
            case "number":
            case "Date":
            case "string":
              return n < e ? 1 : e < n ? -1 : 0;
            case "binary":
              return function(a, l) {
                for (var p = a.length, m = l.length, v = p < m ? p : m, b = 0; b < v; ++b) if (a[b] !== l[b]) return a[b] < l[b] ? -1 : 1;
                return p === m ? 0 : p < m ? -1 : 1;
              }(Go(e), Go(n));
            case "Array":
              return function(a, l) {
                for (var p = a.length, m = l.length, v = p < m ? p : m, b = 0; b < v; ++b) {
                  var O = xe(a[b], l[b]);
                  if (O !== 0) return O;
                }
                return p === m ? 0 : p < m ? -1 : 1;
              }(e, n);
          }
        } catch {
        }
        return NaN;
      }
      function Ho(e) {
        var n = typeof e;
        return n != "object" ? n : ArrayBuffer.isView(e) ? "binary" : (e = jt(e), e === "ArrayBuffer" ? "binary" : e);
      }
      function Go(e) {
        return e instanceof Uint8Array ? e : ArrayBuffer.isView(e) ? new Uint8Array(e.buffer, e.byteOffset, e.byteLength) : new Uint8Array(e);
      }
      function nr(e, n, o) {
        var i = e.schema.yProps;
        return i ? (n && 0 < o.numFailures && (n = n.filter(function(a, l) {
          return !o.failures[l];
        })), Promise.all(i.map(function(a) {
          return a = a.updatesTable, n ? e.db.table(a).where("k").anyOf(n).delete() : e.db.table(a).clear();
        })).then(function() {
          return o;
        })) : o;
      }
      var Yo = (Ie.prototype._trans = function(e, n, o) {
        var i = this._tx || oe.trans, a = this.name, l = ae && typeof console < "u" && console.createTask && console.createTask("Dexie: ".concat(e === "readonly" ? "read" : "write", " ").concat(this.name));
        function p(b, O, y) {
          if (!y.schema[a]) throw new K.NotFound("Table " + a + " not part of transaction");
          return n(y.idbtrans, y);
        }
        var m = hn();
        try {
          var v = i && i.db._novip === this.db._novip ? i === oe.trans ? i._promise(e, p, o) : Mt(function() {
            return i._promise(e, p, o);
          }, { trans: i, transless: oe.transless || oe }) : function b(O, y, N, g) {
            if (O.idbdb && (O._state.openComplete || oe.letThrough || O._vip)) {
              var w = O._createTransaction(y, N, O._dbSchema);
              try {
                w.create(), O._state.PR1398_maxLoop = 3;
              } catch (E) {
                return E.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                  return b(O, y, N, g);
                })) : $e(E);
              }
              return w._promise(y, function(E, T) {
                return Mt(function() {
                  return oe.trans = w, g(E, T, w);
                });
              }).then(function(E) {
                if (y === "readwrite") try {
                  w.idbtrans.commit();
                } catch {
                }
                return y === "readonly" ? E : w._completion.then(function() {
                  return E;
                });
              });
            }
            if (O._state.openComplete) return $e(new K.DatabaseClosed(O._state.dbOpenError));
            if (!O._state.isBeingOpened) {
              if (!O._state.autoOpen) return $e(new K.DatabaseClosed());
              O.open().catch(S);
            }
            return O._state.dbReadyPromise.then(function() {
              return b(O, y, N, g);
            });
          }(this.db, e, [this.name], p);
          return l && (v._consoleTask = l, v = v.catch(function(b) {
            return console.trace(b), $e(b);
          })), v;
        } finally {
          m && mn();
        }
      }, Ie.prototype.get = function(e, n) {
        var o = this;
        return e && e.constructor === Object ? this.where(e).first(n) : e == null ? $e(new K.Type("Invalid argument to Table.get()")) : this._trans("readonly", function(i) {
          return o.core.get({ trans: i, key: e }).then(function(a) {
            return o.hook.reading.fire(a);
          });
        }).then(n);
      }, Ie.prototype.where = function(e) {
        if (typeof e == "string") return new this.db.WhereClause(this, e);
        if (h(e)) return new this.db.WhereClause(this, "[".concat(e.join("+"), "]"));
        var n = f(e);
        if (n.length === 1) return this.where(n[0]).equals(e[n[0]]);
        var o = this.schema.indexes.concat(this.schema.primKey).filter(function(m) {
          if (m.compound && n.every(function(b) {
            return 0 <= m.keyPath.indexOf(b);
          })) {
            for (var v = 0; v < n.length; ++v) if (n.indexOf(m.keyPath[v]) === -1) return !1;
            return !0;
          }
          return !1;
        }).sort(function(m, v) {
          return m.keyPath.length - v.keyPath.length;
        })[0];
        if (o && this.db._maxKey !== en) {
          var l = o.keyPath.slice(0, n.length);
          return this.where(l).equals(l.map(function(v) {
            return e[v];
          }));
        }
        !o && ae && console.warn("The query ".concat(JSON.stringify(e), " on ").concat(this.name, " would benefit from a ") + "compound index [".concat(n.join("+"), "]"));
        var i = this.schema.idxByName;
        function a(m, v) {
          return xe(m, v) === 0;
        }
        var p = n.reduce(function(y, v) {
          var b = y[0], O = y[1], y = i[v], N = e[v];
          return [b || y, b || !y ? tn(O, y && y.multi ? function(g) {
            return g = Pe(g, v), h(g) && g.some(function(w) {
              return a(N, w);
            });
          } : function(g) {
            return a(N, Pe(g, v));
          }) : O];
        }, [null, null]), l = p[0], p = p[1];
        return l ? this.where(l.name).equals(e[l.keyPath]).filter(p) : o ? this.filter(p) : this.where(n).equals("");
      }, Ie.prototype.filter = function(e) {
        return this.toCollection().and(e);
      }, Ie.prototype.count = function(e) {
        return this.toCollection().count(e);
      }, Ie.prototype.offset = function(e) {
        return this.toCollection().offset(e);
      }, Ie.prototype.limit = function(e) {
        return this.toCollection().limit(e);
      }, Ie.prototype.each = function(e) {
        return this.toCollection().each(e);
      }, Ie.prototype.toArray = function(e) {
        return this.toCollection().toArray(e);
      }, Ie.prototype.toCollection = function() {
        return new this.db.Collection(new this.db.WhereClause(this));
      }, Ie.prototype.orderBy = function(e) {
        return new this.db.Collection(new this.db.WhereClause(this, h(e) ? "[".concat(e.join("+"), "]") : e));
      }, Ie.prototype.reverse = function() {
        return this.toCollection().reverse();
      }, Ie.prototype.mapToClass = function(e) {
        var n, o = this.db, i = this.name;
        function a() {
          return n !== null && n.apply(this, arguments) || this;
        }
        (this.schema.mappedClass = e).prototype instanceof Wo && (function(v, b) {
          if (typeof b != "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          function O() {
            this.constructor = v;
          }
          s(v, b), v.prototype = b === null ? Object.create(b) : (O.prototype = b.prototype, new O());
        }(a, n = e), Object.defineProperty(a.prototype, "db", { get: function() {
          return o;
        }, enumerable: !1, configurable: !0 }), a.prototype.table = function() {
          return i;
        }, e = a);
        for (var l = /* @__PURE__ */ new Set(), p = e.prototype; p; p = k(p)) Object.getOwnPropertyNames(p).forEach(function(v) {
          return l.add(v);
        });
        function m(v) {
          if (!v) return v;
          var b, O = Object.create(e.prototype);
          for (b in v) if (!l.has(b)) try {
            O[b] = v[b];
          } catch {
          }
          return O;
        }
        return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = m, this.hook("reading", m), e;
      }, Ie.prototype.defineClass = function() {
        return this.mapToClass(function(e) {
          _(this, e);
        });
      }, Ie.prototype.add = function(e, n) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, p = e;
        return l && a && (p = tr(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "add", keys: n != null ? [n] : null, values: [p] });
        }).then(function(m) {
          return m.numFailures ? Z.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            ue(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.update = function(e, n) {
        return typeof e != "object" || h(e) ? this.where(":id").equals(e).modify(n) : (e = Pe(e, this.schema.primKey.keyPath), e === void 0 ? $e(new K.InvalidArgument("Given object does not contain its primary key")) : this.where(":id").equals(e).modify(n));
      }, Ie.prototype.put = function(e, n) {
        var o = this, i = this.schema.primKey, a = i.auto, l = i.keyPath, p = e;
        return l && a && (p = tr(l)(e)), this._trans("readwrite", function(m) {
          return o.core.mutate({ trans: m, type: "put", values: [p], keys: n != null ? [n] : null });
        }).then(function(m) {
          return m.numFailures ? Z.reject(m.failures[0]) : m.lastResult;
        }).then(function(m) {
          if (l) try {
            ue(e, l, m);
          } catch {
          }
          return m;
        });
      }, Ie.prototype.delete = function(e) {
        var n = this;
        return this._trans("readwrite", function(o) {
          return n.core.mutate({ trans: o, type: "delete", keys: [e] }).then(function(i) {
            return nr(n, [e], i);
          }).then(function(i) {
            return i.numFailures ? Z.reject(i.failures[0]) : void 0;
          });
        });
      }, Ie.prototype.clear = function() {
        var e = this;
        return this._trans("readwrite", function(n) {
          return e.core.mutate({ trans: n, type: "deleteRange", range: Vo }).then(function(o) {
            return nr(e, null, o);
          });
        }).then(function(n) {
          return n.numFailures ? Z.reject(n.failures[0]) : void 0;
        });
      }, Ie.prototype.bulkGet = function(e) {
        var n = this;
        return this._trans("readonly", function(o) {
          return n.core.getMany({ keys: e, trans: o }).then(function(i) {
            return i.map(function(a) {
              return n.hook.reading.fire(a);
            });
          });
        });
      }, Ie.prototype.bulkAdd = function(e, n, o) {
        var i = this, a = Array.isArray(n) ? n : void 0, l = (o = o || (a ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var b = i.schema.primKey, m = b.auto, b = b.keyPath;
          if (b && a) throw new K.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && m ? e.map(tr(b)) : e;
          return i.core.mutate({ trans: p, type: "add", keys: a, values: b, wantResults: l }).then(function(w) {
            var y = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (y === 0) return l ? N : g;
            throw new Nt("".concat(i.name, ".bulkAdd(): ").concat(y, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Ie.prototype.bulkPut = function(e, n, o) {
        var i = this, a = Array.isArray(n) ? n : void 0, l = (o = o || (a ? void 0 : n)) ? o.allKeys : void 0;
        return this._trans("readwrite", function(p) {
          var b = i.schema.primKey, m = b.auto, b = b.keyPath;
          if (b && a) throw new K.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
          if (a && a.length !== e.length) throw new K.InvalidArgument("Arguments objects and keys must have the same length");
          var v = e.length, b = b && m ? e.map(tr(b)) : e;
          return i.core.mutate({ trans: p, type: "put", keys: a, values: b, wantResults: l }).then(function(w) {
            var y = w.numFailures, N = w.results, g = w.lastResult, w = w.failures;
            if (y === 0) return l ? N : g;
            throw new Nt("".concat(i.name, ".bulkPut(): ").concat(y, " of ").concat(v, " operations failed"), w);
          });
        });
      }, Ie.prototype.bulkUpdate = function(e) {
        var n = this, o = this.core, i = e.map(function(p) {
          return p.key;
        }), a = e.map(function(p) {
          return p.changes;
        }), l = [];
        return this._trans("readwrite", function(p) {
          return o.getMany({ trans: p, keys: i, cache: "clone" }).then(function(m) {
            var v = [], b = [];
            e.forEach(function(y, N) {
              var g = y.key, w = y.changes, E = m[N];
              if (E) {
                for (var T = 0, C = Object.keys(w); T < C.length; T++) {
                  var R = C[T], P = w[R];
                  if (R === n.schema.primKey.keyPath) {
                    if (xe(P, g) !== 0) throw new K.Constraint("Cannot update primary key in bulkUpdate()");
                  } else ue(E, R, P);
                }
                l.push(N), v.push(g), b.push(E);
              }
            });
            var O = v.length;
            return o.mutate({ trans: p, type: "put", keys: v, values: b, updates: { keys: i, changeSpecs: a } }).then(function(y) {
              var N = y.numFailures, g = y.failures;
              if (N === 0) return O;
              for (var w = 0, E = Object.keys(g); w < E.length; w++) {
                var T, C = E[w], R = l[Number(C)];
                R != null && (T = g[C], delete g[C], g[R] = T);
              }
              throw new Nt("".concat(n.name, ".bulkUpdate(): ").concat(N, " of ").concat(O, " operations failed"), g);
            });
          });
        });
      }, Ie.prototype.bulkDelete = function(e) {
        var n = this, o = e.length;
        return this._trans("readwrite", function(i) {
          return n.core.mutate({ trans: i, type: "delete", keys: e }).then(function(a) {
            return nr(n, e, a);
          });
        }).then(function(p) {
          var a = p.numFailures, l = p.lastResult, p = p.failures;
          if (a === 0) return l;
          throw new Nt("".concat(n.name, ".bulkDelete(): ").concat(a, " of ").concat(o, " operations failed"), p);
        });
      }, Ie);
      function Ie() {
      }
      function An(e) {
        function n(p, m) {
          if (m) {
            for (var v = arguments.length, b = new Array(v - 1); --v; ) b[v - 1] = arguments[v];
            return o[p].subscribe.apply(null, b), e;
          }
          if (typeof p == "string") return o[p];
        }
        var o = {};
        n.addEventType = l;
        for (var i = 1, a = arguments.length; i < a; ++i) l(arguments[i]);
        return n;
        function l(p, m, v) {
          if (typeof p != "object") {
            var b;
            m = m || be;
            var O = { subscribers: [], fire: v = v || S, subscribe: function(y) {
              O.subscribers.indexOf(y) === -1 && (O.subscribers.push(y), O.fire = m(O.fire, y));
            }, unsubscribe: function(y) {
              O.subscribers = O.subscribers.filter(function(N) {
                return N !== y;
              }), O.fire = O.subscribers.reduce(m, v);
            } };
            return o[p] = n[p] = O;
          }
          f(b = p).forEach(function(y) {
            var N = b[y];
            if (h(N)) l(y, b[y][0], b[y][1]);
            else {
              if (N !== "asap") throw new K.InvalidArgument("Invalid event config");
              var g = l(y, M, function() {
                for (var w = arguments.length, E = new Array(w); w--; ) E[w] = arguments[w];
                g.subscribers.forEach(function(T) {
                  _e(function() {
                    T.apply(null, E);
                  });
                });
              });
            }
          });
        }
      }
      function Rn(e, n) {
        return Q(n).from({ prototype: e }), n;
      }
      function gn(e, n) {
        return !(e.filter || e.algorithm || e.or) && (n ? e.justLimit : !e.replayFilter);
      }
      function Vr(e, n) {
        e.filter = tn(e.filter, n);
      }
      function Wr(e, n, o) {
        var i = e.replayFilter;
        e.replayFilter = i ? function() {
          return tn(i(), n());
        } : n, e.justLimit = o && !i;
      }
      function rr(e, n) {
        if (e.isPrimKey) return n.primaryKey;
        var o = n.getIndexByKeyPath(e.index);
        if (!o) throw new K.Schema("KeyPath " + e.index + " on object store " + n.name + " is not indexed");
        return o;
      }
      function Qo(e, n, o) {
        var i = rr(e, n.schema);
        return n.openCursor({ trans: o, values: !e.keysOnly, reverse: e.dir === "prev", unique: !!e.unique, query: { index: i, range: e.range } });
      }
      function or(e, n, o, i) {
        var a = e.replayFilter ? tn(e.filter, e.replayFilter()) : e.filter;
        if (e.or) {
          var l = {}, p = function(m, v, b) {
            var O, y;
            a && !a(v, b, function(N) {
              return v.stop(N);
            }, function(N) {
              return v.fail(N);
            }) || ((y = "" + (O = v.primaryKey)) == "[object ArrayBuffer]" && (y = "" + new Uint8Array(O)), j(l, y) || (l[y] = !0, n(m, v, b)));
          };
          return Promise.all([e.or._iterate(p, o), Xo(Qo(e, i, o), e.algorithm, p, !e.keysOnly && e.valueMapper)]);
        }
        return Xo(Qo(e, i, o), tn(e.algorithm, a), n, !e.keysOnly && e.valueMapper);
      }
      function Xo(e, n, o, i) {
        var a = Le(i ? function(l, p, m) {
          return o(i(l), p, m);
        } : o);
        return e.then(function(l) {
          if (l) return l.start(function() {
            var p = function() {
              return l.continue();
            };
            n && !n(l, function(m) {
              return p = m;
            }, function(m) {
              l.stop(m), p = S;
            }, function(m) {
              l.fail(m), p = S;
            }) || a(l.value, l, function(m) {
              return p = m;
            }), p();
          });
        });
      }
      var Dn = (zo.prototype.execute = function(e) {
        var n = this["@@propmod"];
        if (n.add !== void 0) {
          var o = n.add;
          if (h(o)) return c(c([], h(e) ? e : [], !0), o).sort();
          if (typeof o == "number") return (Number(e) || 0) + o;
          if (typeof o == "bigint") try {
            return BigInt(e) + o;
          } catch {
            return BigInt(0) + o;
          }
          throw new TypeError("Invalid term ".concat(o));
        }
        if (n.remove !== void 0) {
          var i = n.remove;
          if (h(i)) return h(e) ? e.filter(function(a) {
            return !i.includes(a);
          }).sort() : [];
          if (typeof i == "number") return Number(e) - i;
          if (typeof i == "bigint") try {
            return BigInt(e) - i;
          } catch {
            return BigInt(0) - i;
          }
          throw new TypeError("Invalid subtrahend ".concat(i));
        }
        return o = (o = n.replacePrefix) === null || o === void 0 ? void 0 : o[0], o && typeof e == "string" && e.startsWith(o) ? n.replacePrefix[1] + e.substring(o.length) : e;
      }, zo);
      function zo(e) {
        this["@@propmod"] = e;
      }
      var Ns = (Ne.prototype._read = function(e, n) {
        var o = this._ctx;
        return o.error ? o.table._trans(null, $e.bind(null, o.error)) : o.table._trans("readonly", e).then(n);
      }, Ne.prototype._write = function(e) {
        var n = this._ctx;
        return n.error ? n.table._trans(null, $e.bind(null, n.error)) : n.table._trans("readwrite", e, "locked");
      }, Ne.prototype._addAlgorithm = function(e) {
        var n = this._ctx;
        n.algorithm = tn(n.algorithm, e);
      }, Ne.prototype._iterate = function(e, n) {
        return or(this._ctx, e, n, this._ctx.table.core);
      }, Ne.prototype.clone = function(e) {
        var n = Object.create(this.constructor.prototype), o = Object.create(this._ctx);
        return e && _(o, e), n._ctx = o, n;
      }, Ne.prototype.raw = function() {
        return this._ctx.valueMapper = null, this;
      }, Ne.prototype.each = function(e) {
        var n = this._ctx;
        return this._read(function(o) {
          return or(n, e, o, n.table.core);
        });
      }, Ne.prototype.count = function(e) {
        var n = this;
        return this._read(function(o) {
          var i = n._ctx, a = i.table.core;
          if (gn(i, !0)) return a.count({ trans: o, query: { index: rr(i, a.schema), range: i.range } }).then(function(p) {
            return Math.min(p, i.limit);
          });
          var l = 0;
          return or(i, function() {
            return ++l, !1;
          }, o, a).then(function() {
            return l;
          });
        }).then(e);
      }, Ne.prototype.sortBy = function(e, n) {
        var o = e.split(".").reverse(), i = o[0], a = o.length - 1;
        function l(v, b) {
          return b ? l(v[o[b]], b - 1) : v[i];
        }
        var p = this._ctx.dir === "next" ? 1 : -1;
        function m(v, b) {
          return xe(l(v, a), l(b, a)) * p;
        }
        return this.toArray(function(v) {
          return v.sort(m);
        }).then(n);
      }, Ne.prototype.toArray = function(e) {
        var n = this;
        return this._read(function(o) {
          var i = n._ctx;
          if (i.dir === "next" && gn(i, !0) && 0 < i.limit) {
            var a = i.valueMapper, l = rr(i, i.table.core.schema);
            return i.table.core.query({ trans: o, limit: i.limit, values: !0, query: { index: l, range: i.range } }).then(function(m) {
              return m = m.result, a ? m.map(a) : m;
            });
          }
          var p = [];
          return or(i, function(m) {
            return p.push(m);
          }, o, i.table.core).then(function() {
            return p;
          });
        }, e);
      }, Ne.prototype.offset = function(e) {
        var n = this._ctx;
        return e <= 0 || (n.offset += e, gn(n) ? Wr(n, function() {
          var o = e;
          return function(i, a) {
            return o === 0 || (o === 1 ? --o : a(function() {
              i.advance(o), o = 0;
            }), !1);
          };
        }) : Wr(n, function() {
          var o = e;
          return function() {
            return --o < 0;
          };
        })), this;
      }, Ne.prototype.limit = function(e) {
        return this._ctx.limit = Math.min(this._ctx.limit, e), Wr(this._ctx, function() {
          var n = e;
          return function(o, i, a) {
            return --n <= 0 && i(a), 0 <= n;
          };
        }, !0), this;
      }, Ne.prototype.until = function(e, n) {
        return Vr(this._ctx, function(o, i, a) {
          return !e(o.value) || (i(a), n);
        }), this;
      }, Ne.prototype.first = function(e) {
        return this.limit(1).toArray(function(n) {
          return n[0];
        }).then(e);
      }, Ne.prototype.last = function(e) {
        return this.reverse().first(e);
      }, Ne.prototype.filter = function(e) {
        var n;
        return Vr(this._ctx, function(o) {
          return e(o.value);
        }), (n = this._ctx).isMatch = tn(n.isMatch, e), this;
      }, Ne.prototype.and = function(e) {
        return this.filter(e);
      }, Ne.prototype.or = function(e) {
        return new this.db.WhereClause(this._ctx.table, e, this);
      }, Ne.prototype.reverse = function() {
        return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
      }, Ne.prototype.desc = function() {
        return this.reverse();
      }, Ne.prototype.eachKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, i) {
          e(i.key, i);
        });
      }, Ne.prototype.eachUniqueKey = function(e) {
        return this._ctx.unique = "unique", this.eachKey(e);
      }, Ne.prototype.eachPrimaryKey = function(e) {
        var n = this._ctx;
        return n.keysOnly = !n.isMatch, this.each(function(o, i) {
          e(i.primaryKey, i);
        });
      }, Ne.prototype.keys = function(e) {
        var n = this._ctx;
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.key);
        }).then(function() {
          return o;
        }).then(e);
      }, Ne.prototype.primaryKeys = function(e) {
        var n = this._ctx;
        if (n.dir === "next" && gn(n, !0) && 0 < n.limit) return this._read(function(i) {
          var a = rr(n, n.table.core.schema);
          return n.table.core.query({ trans: i, values: !1, limit: n.limit, query: { index: a, range: n.range } });
        }).then(function(i) {
          return i.result;
        }).then(e);
        n.keysOnly = !n.isMatch;
        var o = [];
        return this.each(function(i, a) {
          o.push(a.primaryKey);
        }).then(function() {
          return o;
        }).then(e);
      }, Ne.prototype.uniqueKeys = function(e) {
        return this._ctx.unique = "unique", this.keys(e);
      }, Ne.prototype.firstKey = function(e) {
        return this.limit(1).keys(function(n) {
          return n[0];
        }).then(e);
      }, Ne.prototype.lastKey = function(e) {
        return this.reverse().firstKey(e);
      }, Ne.prototype.distinct = function() {
        var e = this._ctx, e = e.index && e.table.schema.idxByName[e.index];
        if (!e || !e.multi) return this;
        var n = {};
        return Vr(this._ctx, function(a) {
          var i = a.primaryKey.toString(), a = j(n, i);
          return n[i] = !0, !a;
        }), this;
      }, Ne.prototype.modify = function(e) {
        var n = this, o = this._ctx;
        return this._write(function(i) {
          var a, l, p;
          p = typeof e == "function" ? e : (a = f(e), l = a.length, function(C) {
            for (var R = !1, P = 0; P < l; ++P) {
              var I = a[P], U = e[I], X = Pe(C, I);
              U instanceof Dn ? (ue(C, I, U.execute(X)), R = !0) : X !== U && (ue(C, I, U), R = !0);
            }
            return R;
          });
          var m = o.table.core, y = m.schema.primaryKey, v = y.outbound, b = y.extractKey, O = 200, y = n.db._options.modifyChunkSize;
          y && (O = typeof y == "object" ? y[m.name] || y["*"] || 200 : y);
          function N(C, I) {
            var P = I.failures, I = I.numFailures;
            w += C - I;
            for (var U = 0, X = f(P); U < X.length; U++) {
              var V = X[U];
              g.push(P[V]);
            }
          }
          var g = [], w = 0, E = [], T = e === Jo;
          return n.clone().primaryKeys().then(function(C) {
            function R(I) {
              var U = Math.min(O, C.length - I), X = C.slice(I, I + U);
              return (T ? Promise.resolve([]) : m.getMany({ trans: i, keys: X, cache: "immutable" })).then(function(V) {
                var Y = [], J = [], z = v ? [] : null, te = T ? X : [];
                if (!T) for (var ge = 0; ge < U; ++ge) {
                  var Oe = V[ge], me = { value: at(Oe), primKey: C[I + ge] };
                  p.call(me, me.value, me) !== !1 && (me.value == null ? te.push(C[I + ge]) : v || xe(b(Oe), b(me.value)) === 0 ? (J.push(me.value), v && z.push(C[I + ge])) : (te.push(C[I + ge]), Y.push(me.value)));
                }
                return Promise.resolve(0 < Y.length && m.mutate({ trans: i, type: "add", values: Y }).then(function(Fe) {
                  for (var he in Fe.failures) te.splice(parseInt(he), 1);
                  N(Y.length, Fe);
                })).then(function() {
                  return (0 < J.length || P && typeof e == "object") && m.mutate({ trans: i, type: "put", keys: z, values: J, criteria: P, changeSpec: typeof e != "function" && e, isAdditionalChunk: 0 < I }).then(function(Fe) {
                    return N(J.length, Fe);
                  });
                }).then(function() {
                  return (0 < te.length || P && T) && m.mutate({ trans: i, type: "delete", keys: te, criteria: P, isAdditionalChunk: 0 < I }).then(function(Fe) {
                    return nr(o.table, te, Fe);
                  }).then(function(Fe) {
                    return N(te.length, Fe);
                  });
                }).then(function() {
                  return C.length > I + U && R(I + O);
                });
              });
            }
            var P = gn(o) && o.limit === 1 / 0 && (typeof e != "function" || T) && { index: o.index, range: o.range };
            return R(0).then(function() {
              if (0 < g.length) throw new fn("Error modifying one or more objects", g, w, E);
              return C.length;
            });
          });
        });
      }, Ne.prototype.delete = function() {
        var e = this._ctx, n = e.range;
        return !gn(e) || e.table.schema.yProps || !e.isPrimKey && n.type !== 3 ? this.modify(Jo) : this._write(function(o) {
          var i = e.table.core.schema.primaryKey, a = n;
          return e.table.core.count({ trans: o, query: { index: i, range: a } }).then(function(l) {
            return e.table.core.mutate({ trans: o, type: "deleteRange", range: a }).then(function(v) {
              var m = v.failures, v = v.numFailures;
              if (v) throw new fn("Could not delete some values", Object.keys(m).map(function(b) {
                return m[b];
              }), l - v);
              return l - v;
            });
          });
        });
      }, Ne);
      function Ne() {
      }
      var Jo = function(e, n) {
        return n.value = null;
      };
      function Cs(e, n) {
        return e < n ? -1 : e === n ? 0 : 1;
      }
      function Ss(e, n) {
        return n < e ? -1 : e === n ? 0 : 1;
      }
      function pt(e, n, o) {
        return e = e instanceof ei ? new e.Collection(e) : e, e._ctx.error = new (o || TypeError)(n), e;
      }
      function bn(e) {
        return new e.Collection(e, function() {
          return Zo("");
        }).limit(0);
      }
      function ir(e, n, o, i) {
        var a, l, p, m, v, b, O, y = o.length;
        if (!o.every(function(w) {
          return typeof w == "string";
        })) return pt(e, Uo);
        function N(w) {
          a = w === "next" ? function(T) {
            return T.toUpperCase();
          } : function(T) {
            return T.toLowerCase();
          }, l = w === "next" ? function(T) {
            return T.toLowerCase();
          } : function(T) {
            return T.toUpperCase();
          }, p = w === "next" ? Cs : Ss;
          var E = o.map(function(T) {
            return { lower: l(T), upper: a(T) };
          }).sort(function(T, C) {
            return p(T.lower, C.lower);
          });
          m = E.map(function(T) {
            return T.upper;
          }), v = E.map(function(T) {
            return T.lower;
          }), O = (b = w) === "next" ? "" : i;
        }
        N("next"), e = new e.Collection(e, function() {
          return qt(m[0], v[y - 1] + i);
        }), e._ondirectionchange = function(w) {
          N(w);
        };
        var g = 0;
        return e._addAlgorithm(function(w, E, T) {
          var C = w.key;
          if (typeof C != "string") return !1;
          var R = l(C);
          if (n(R, v, g)) return !0;
          for (var P = null, I = g; I < y; ++I) {
            var U = function(X, V, Y, J, z, te) {
              for (var ge = Math.min(X.length, J.length), Oe = -1, me = 0; me < ge; ++me) {
                var Fe = V[me];
                if (Fe !== J[me]) return z(X[me], Y[me]) < 0 ? X.substr(0, me) + Y[me] + Y.substr(me + 1) : z(X[me], J[me]) < 0 ? X.substr(0, me) + J[me] + Y.substr(me + 1) : 0 <= Oe ? X.substr(0, Oe) + V[Oe] + Y.substr(Oe + 1) : null;
                z(X[me], Fe) < 0 && (Oe = me);
              }
              return ge < J.length && te === "next" ? X + Y.substr(X.length) : ge < X.length && te === "prev" ? X.substr(0, Y.length) : Oe < 0 ? null : X.substr(0, Oe) + J[Oe] + Y.substr(Oe + 1);
            }(C, R, m[I], v[I], p, b);
            U === null && P === null ? g = I + 1 : (P === null || 0 < p(P, U)) && (P = U);
          }
          return E(P !== null ? function() {
            w.continue(P + O);
          } : T), !1;
        }), e;
      }
      function qt(e, n, o, i) {
        return { type: 2, lower: e, upper: n, lowerOpen: o, upperOpen: i };
      }
      function Zo(e) {
        return { type: 1, lower: e, upper: e };
      }
      var ei = (Object.defineProperty(Ye.prototype, "Collection", { get: function() {
        return this._ctx.table.db.Collection;
      }, enumerable: !1, configurable: !0 }), Ye.prototype.between = function(e, n, o, i) {
        o = o !== !1, i = i === !0;
        try {
          return 0 < this._cmp(e, n) || this._cmp(e, n) === 0 && (o || i) && (!o || !i) ? bn(this) : new this.Collection(this, function() {
            return qt(e, n, !o, !i);
          });
        } catch {
          return pt(this, Dt);
        }
      }, Ye.prototype.equals = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return Zo(e);
        });
      }, Ye.prototype.above = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(e, void 0, !0);
        });
      }, Ye.prototype.aboveOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(e, void 0, !1);
        });
      }, Ye.prototype.below = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(void 0, e, !1, !0);
        });
      }, Ye.prototype.belowOrEqual = function(e) {
        return e == null ? pt(this, Dt) : new this.Collection(this, function() {
          return qt(void 0, e);
        });
      }, Ye.prototype.startsWith = function(e) {
        return typeof e != "string" ? pt(this, Uo) : this.between(e, e + en, !0, !0);
      }, Ye.prototype.startsWithIgnoreCase = function(e) {
        return e === "" ? this.startsWith(e) : ir(this, function(n, o) {
          return n.indexOf(o[0]) === 0;
        }, [e], en);
      }, Ye.prototype.equalsIgnoreCase = function(e) {
        return ir(this, function(n, o) {
          return n === o[0];
        }, [e], "");
      }, Ye.prototype.anyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? bn(this) : ir(this, function(n, o) {
          return o.indexOf(n) !== -1;
        }, e, "");
      }, Ye.prototype.startsWithAnyOfIgnoreCase = function() {
        var e = ct.apply(bt, arguments);
        return e.length === 0 ? bn(this) : ir(this, function(n, o) {
          return o.some(function(i) {
            return n.indexOf(i) === 0;
          });
        }, e, en);
      }, Ye.prototype.anyOf = function() {
        var e = this, n = ct.apply(bt, arguments), o = this._cmp;
        try {
          n.sort(o);
        } catch {
          return pt(this, Dt);
        }
        if (n.length === 0) return bn(this);
        var i = new this.Collection(this, function() {
          return qt(n[0], n[n.length - 1]);
        });
        i._ondirectionchange = function(l) {
          o = l === "next" ? e._ascending : e._descending, n.sort(o);
        };
        var a = 0;
        return i._addAlgorithm(function(l, p, m) {
          for (var v = l.key; 0 < o(v, n[a]); ) if (++a === n.length) return p(m), !1;
          return o(v, n[a]) === 0 || (p(function() {
            l.continue(n[a]);
          }), !1);
        }), i;
      }, Ye.prototype.notEqual = function(e) {
        return this.inAnyRange([[-1 / 0, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.noneOf = function() {
        var e = ct.apply(bt, arguments);
        if (e.length === 0) return new this.Collection(this);
        try {
          e.sort(this._ascending);
        } catch {
          return pt(this, Dt);
        }
        var n = e.reduce(function(o, i) {
          return o ? o.concat([[o[o.length - 1][1], i]]) : [[-1 / 0, i]];
        }, null);
        return n.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(n, { includeLowers: !1, includeUppers: !1 });
      }, Ye.prototype.inAnyRange = function(C, n) {
        var o = this, i = this._cmp, a = this._ascending, l = this._descending, p = this._min, m = this._max;
        if (C.length === 0) return bn(this);
        if (!C.every(function(R) {
          return R[0] !== void 0 && R[1] !== void 0 && a(R[0], R[1]) <= 0;
        })) return pt(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", K.InvalidArgument);
        var v = !n || n.includeLowers !== !1, b = n && n.includeUppers === !0, O, y = a;
        function N(R, P) {
          return y(R[0], P[0]);
        }
        try {
          (O = C.reduce(function(R, P) {
            for (var I = 0, U = R.length; I < U; ++I) {
              var X = R[I];
              if (i(P[0], X[1]) < 0 && 0 < i(P[1], X[0])) {
                X[0] = p(X[0], P[0]), X[1] = m(X[1], P[1]);
                break;
              }
            }
            return I === U && R.push(P), R;
          }, [])).sort(N);
        } catch {
          return pt(this, Dt);
        }
        var g = 0, w = b ? function(R) {
          return 0 < a(R, O[g][1]);
        } : function(R) {
          return 0 <= a(R, O[g][1]);
        }, E = v ? function(R) {
          return 0 < l(R, O[g][0]);
        } : function(R) {
          return 0 <= l(R, O[g][0]);
        }, T = w, C = new this.Collection(this, function() {
          return qt(O[0][0], O[O.length - 1][1], !v, !b);
        });
        return C._ondirectionchange = function(R) {
          y = R === "next" ? (T = w, a) : (T = E, l), O.sort(N);
        }, C._addAlgorithm(function(R, P, I) {
          for (var U, X = R.key; T(X); ) if (++g === O.length) return P(I), !1;
          return !w(U = X) && !E(U) || (o._cmp(X, O[g][1]) === 0 || o._cmp(X, O[g][0]) === 0 || P(function() {
            y === a ? R.continue(O[g][0]) : R.continue(O[g][1]);
          }), !1);
        }), C;
      }, Ye.prototype.startsWithAnyOf = function() {
        var e = ct.apply(bt, arguments);
        return e.every(function(n) {
          return typeof n == "string";
        }) ? e.length === 0 ? bn(this) : this.inAnyRange(e.map(function(n) {
          return [n, n + en];
        })) : pt(this, "startsWithAnyOf() only works with strings");
      }, Ye);
      function Ye() {
      }
      function Ct(e) {
        return Le(function(n) {
          return Pn(n), e(n.target.error), !1;
        });
      }
      function Pn(e) {
        e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
      }
      var In = "storagemutated", Hr = "x-storagemutated-1", Ut = An(null, In), As = (St.prototype._lock = function() {
        return fe(!oe.global), ++this._reculock, this._reculock !== 1 || oe.global || (oe.lockOwnerFor = this), this;
      }, St.prototype._unlock = function() {
        if (fe(!oe.global), --this._reculock == 0) for (oe.global || (oe.lockOwnerFor = null); 0 < this._blockedFuncs.length && !this._locked(); ) {
          var e = this._blockedFuncs.shift();
          try {
            Zt(e[1], e[0]);
          } catch {
          }
        }
        return this;
      }, St.prototype._locked = function() {
        return this._reculock && oe.lockOwnerFor !== this;
      }, St.prototype.create = function(e) {
        var n = this;
        if (!this.mode) return this;
        var o = this.db.idbdb, i = this.db._state.dbOpenError;
        if (fe(!this.idbtrans), !e && !o) switch (i && i.name) {
          case "DatabaseClosedError":
            throw new K.DatabaseClosed(i);
          case "MissingAPIError":
            throw new K.MissingAPI(i.message, i);
          default:
            throw new K.OpenFailed(i);
        }
        if (!this.active) throw new K.TransactionInactive();
        return fe(this._completion._state === null), (e = this.idbtrans = e || (this.db.core || o).transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })).onerror = Le(function(a) {
          Pn(a), n._reject(e.error);
        }), e.onabort = Le(function(a) {
          Pn(a), n.active && n._reject(new K.Abort(e.error)), n.active = !1, n.on("abort").fire(a);
        }), e.oncomplete = Le(function() {
          n.active = !1, n._resolve(), "mutatedParts" in e && Ut.storagemutated.fire(e.mutatedParts);
        }), this;
      }, St.prototype._promise = function(e, n, o) {
        var i = this;
        if (e === "readwrite" && this.mode !== "readwrite") return $e(new K.ReadOnly("Transaction is readonly"));
        if (!this.active) return $e(new K.TransactionInactive());
        if (this._locked()) return new Z(function(l, p) {
          i._blockedFuncs.push([function() {
            i._promise(e, n, o).then(l, p);
          }, oe]);
        });
        if (o) return Mt(function() {
          var l = new Z(function(p, m) {
            i._lock();
            var v = n(p, m, i);
            v && v.then && v.then(p, m);
          });
          return l.finally(function() {
            return i._unlock();
          }), l._lib = !0, l;
        });
        var a = new Z(function(l, p) {
          var m = n(l, p, i);
          m && m.then && m.then(l, p);
        });
        return a._lib = !0, a;
      }, St.prototype._root = function() {
        return this.parent ? this.parent._root() : this;
      }, St.prototype.waitFor = function(e) {
        var n, o = this._root(), i = Z.resolve(e);
        o._waitingFor ? o._waitingFor = o._waitingFor.then(function() {
          return i;
        }) : (o._waitingFor = i, o._waitingQueue = [], n = o.idbtrans.objectStore(o.storeNames[0]), function l() {
          for (++o._spinCount; o._waitingQueue.length; ) o._waitingQueue.shift()();
          o._waitingFor && (n.get(-1 / 0).onsuccess = l);
        }());
        var a = o._waitingFor;
        return new Z(function(l, p) {
          i.then(function(m) {
            return o._waitingQueue.push(Le(l.bind(null, m)));
          }, function(m) {
            return o._waitingQueue.push(Le(p.bind(null, m)));
          }).finally(function() {
            o._waitingFor === a && (o._waitingFor = null);
          });
        });
      }, St.prototype.abort = function() {
        this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new K.Abort()));
      }, St.prototype.table = function(e) {
        var n = this._memoizedTables || (this._memoizedTables = {});
        if (j(n, e)) return n[e];
        var o = this.schema[e];
        if (!o) throw new K.NotFound("Table " + e + " not part of transaction");
        return o = new this.db.Table(e, o, this), o.core = this.db.core.table(e), n[e] = o;
      }, St);
      function St() {
      }
      function Gr(e, n, o, i, a, l, p, m) {
        return { name: e, keyPath: n, unique: o, multi: i, auto: a, compound: l, src: (o && !p ? "&" : "") + (i ? "*" : "") + (a ? "++" : "") + ti(n), type: m };
      }
      function ti(e) {
        return typeof e == "string" ? e : e ? "[" + [].join.call(e, "+") + "]" : "";
      }
      function Yr(e, n, o) {
        return { name: e, primKey: n, indexes: o, mappedClass: null, idxByName: (i = function(a) {
          return [a.name, a];
        }, o.reduce(function(a, l, p) {
          return p = i(l, p), p && (a[p[0]] = p[1]), a;
        }, {})) };
        var i;
      }
      var kn = function(e) {
        try {
          return e.only([[]]), kn = function() {
            return [[]];
          }, [[]];
        } catch {
          return kn = function() {
            return en;
          }, en;
        }
      };
      function Qr(e) {
        return e == null ? function() {
        } : typeof e == "string" ? (n = e).split(".").length === 1 ? function(o) {
          return o[n];
        } : function(o) {
          return Pe(o, n);
        } : function(o) {
          return Pe(o, e);
        };
        var n;
      }
      function ni(e) {
        return [].slice.call(e);
      }
      var Rs = 0;
      function jn(e) {
        return e == null ? ":id" : typeof e == "string" ? e : "[".concat(e.join("+"), "]");
      }
      function Ds(e, n, v) {
        function i(T) {
          if (T.type === 3) return null;
          if (T.type === 4) throw new Error("Cannot convert never type to IDBKeyRange");
          var g = T.lower, w = T.upper, E = T.lowerOpen, T = T.upperOpen;
          return g === void 0 ? w === void 0 ? null : n.upperBound(w, !!T) : w === void 0 ? n.lowerBound(g, !!E) : n.bound(g, w, !!E, !!T);
        }
        function a(N) {
          var g, w = N.name;
          return { name: w, schema: N, mutate: function(E) {
            var T = E.trans, C = E.type, R = E.keys, P = E.values, I = E.range;
            return new Promise(function(U, X) {
              U = Le(U);
              var V = T.objectStore(w), Y = V.keyPath == null, J = C === "put" || C === "add";
              if (!J && C !== "delete" && C !== "deleteRange") throw new Error("Invalid operation type: " + C);
              var z, te = (R || P || { length: 1 }).length;
              if (R && P && R.length !== P.length) throw new Error("Given keys array must have same length as given values array.");
              if (te === 0) return U({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
              function ge(it) {
                ++Fe, Pn(it);
              }
              var Oe = [], me = [], Fe = 0;
              if (C === "deleteRange") {
                if (I.type === 4) return U({ numFailures: Fe, failures: me, results: [], lastResult: void 0 });
                I.type === 3 ? Oe.push(z = V.clear()) : Oe.push(z = V.delete(i(I)));
              } else {
                var Y = J ? Y ? [P, R] : [P, null] : [R, null], he = Y[0], Je = Y[1];
                if (J) for (var Ze = 0; Ze < te; ++Ze) Oe.push(z = Je && Je[Ze] !== void 0 ? V[C](he[Ze], Je[Ze]) : V[C](he[Ze])), z.onerror = ge;
                else for (Ze = 0; Ze < te; ++Ze) Oe.push(z = V[C](he[Ze])), z.onerror = ge;
              }
              function vr(it) {
                it = it.target.result, Oe.forEach(function(on, ho) {
                  return on.error != null && (me[ho] = on.error);
                }), U({ numFailures: Fe, failures: me, results: C === "delete" ? R : Oe.map(function(on) {
                  return on.result;
                }), lastResult: it });
              }
              z.onerror = function(it) {
                ge(it), vr(it);
              }, z.onsuccess = vr;
            });
          }, getMany: function(E) {
            var T = E.trans, C = E.keys;
            return new Promise(function(R, P) {
              R = Le(R);
              for (var I, U = T.objectStore(w), X = C.length, V = new Array(X), Y = 0, J = 0, z = function(Oe) {
                Oe = Oe.target, V[Oe._pos] = Oe.result, ++J === Y && R(V);
              }, te = Ct(P), ge = 0; ge < X; ++ge) C[ge] != null && ((I = U.get(C[ge]))._pos = ge, I.onsuccess = z, I.onerror = te, ++Y);
              Y === 0 && R(V);
            });
          }, get: function(E) {
            var T = E.trans, C = E.key;
            return new Promise(function(R, P) {
              R = Le(R);
              var I = T.objectStore(w).get(C);
              I.onsuccess = function(U) {
                return R(U.target.result);
              }, I.onerror = Ct(P);
            });
          }, query: (g = b, function(E) {
            return new Promise(function(T, C) {
              T = Le(T);
              var R, P, I, Y = E.trans, U = E.values, X = E.limit, z = E.query, V = X === 1 / 0 ? void 0 : X, J = z.index, z = z.range, Y = Y.objectStore(w), J = J.isPrimaryKey ? Y : Y.index(J.name), z = i(z);
              if (X === 0) return T({ result: [] });
              g ? ((V = U ? J.getAll(z, V) : J.getAllKeys(z, V)).onsuccess = function(te) {
                return T({ result: te.target.result });
              }, V.onerror = Ct(C)) : (R = 0, P = !U && "openKeyCursor" in J ? J.openKeyCursor(z) : J.openCursor(z), I = [], P.onsuccess = function(te) {
                var ge = P.result;
                return ge ? (I.push(U ? ge.value : ge.primaryKey), ++R === X ? T({ result: I }) : void ge.continue()) : T({ result: I });
              }, P.onerror = Ct(C));
            });
          }), openCursor: function(E) {
            var T = E.trans, C = E.values, R = E.query, P = E.reverse, I = E.unique;
            return new Promise(function(U, X) {
              U = Le(U);
              var J = R.index, V = R.range, Y = T.objectStore(w), Y = J.isPrimaryKey ? Y : Y.index(J.name), J = P ? I ? "prevunique" : "prev" : I ? "nextunique" : "next", z = !C && "openKeyCursor" in Y ? Y.openKeyCursor(i(V), J) : Y.openCursor(i(V), J);
              z.onerror = Ct(X), z.onsuccess = Le(function(te) {
                var ge, Oe, me, Fe, he = z.result;
                he ? (he.___id = ++Rs, he.done = !1, ge = he.continue.bind(he), Oe = (Oe = he.continuePrimaryKey) && Oe.bind(he), me = he.advance.bind(he), Fe = function() {
                  throw new Error("Cursor not stopped");
                }, he.trans = T, he.stop = he.continue = he.continuePrimaryKey = he.advance = function() {
                  throw new Error("Cursor not started");
                }, he.fail = Le(X), he.next = function() {
                  var Je = this, Ze = 1;
                  return this.start(function() {
                    return Ze-- ? Je.continue() : Je.stop();
                  }).then(function() {
                    return Je;
                  });
                }, he.start = function(Je) {
                  function Ze() {
                    if (z.result) try {
                      Je();
                    } catch (it) {
                      he.fail(it);
                    }
                    else he.done = !0, he.start = function() {
                      throw new Error("Cursor behind last entry");
                    }, he.stop();
                  }
                  var vr = new Promise(function(it, on) {
                    it = Le(it), z.onerror = Ct(on), he.fail = on, he.stop = function(ho) {
                      he.stop = he.continue = he.continuePrimaryKey = he.advance = Fe, it(ho);
                    };
                  });
                  return z.onsuccess = Le(function(it) {
                    z.onsuccess = Ze, Ze();
                  }), he.continue = ge, he.continuePrimaryKey = Oe, he.advance = me, Ze(), vr;
                }, U(he)) : U(null);
              }, X);
            });
          }, count: function(E) {
            var T = E.query, C = E.trans, R = T.index, P = T.range;
            return new Promise(function(I, U) {
              var X = C.objectStore(w), V = R.isPrimaryKey ? X : X.index(R.name), X = i(P), V = X ? V.count(X) : V.count();
              V.onsuccess = Le(function(Y) {
                return I(Y.target.result);
              }), V.onerror = Ct(U);
            });
          } };
        }
        var l, p, m, O = (p = v, m = ni((l = e).objectStoreNames), { schema: { name: l.name, tables: m.map(function(N) {
          return p.objectStore(N);
        }).map(function(N) {
          var g = N.keyPath, T = N.autoIncrement, w = h(g), E = {}, T = { name: N.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: g == null, compound: w, keyPath: g, autoIncrement: T, unique: !0, extractKey: Qr(g) }, indexes: ni(N.indexNames).map(function(C) {
            return N.index(C);
          }).map(function(I) {
            var R = I.name, P = I.unique, U = I.multiEntry, I = I.keyPath, U = { name: R, compound: h(I), keyPath: I, unique: P, multiEntry: U, extractKey: Qr(I) };
            return E[jn(I)] = U;
          }), getIndexByKeyPath: function(C) {
            return E[jn(C)];
          } };
          return E[":id"] = T.primaryKey, g != null && (E[jn(g)] = T.primaryKey), T;
        }) }, hasGetAll: 0 < m.length && "getAll" in p.objectStore(m[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) }), v = O.schema, b = O.hasGetAll, O = v.tables.map(a), y = {};
        return O.forEach(function(N) {
          return y[N.name] = N;
        }), { stack: "dbcore", transaction: e.transaction.bind(e), table: function(N) {
          if (!y[N]) throw new Error("Table '".concat(N, "' not found"));
          return y[N];
        }, MIN_KEY: -1 / 0, MAX_KEY: kn(n), schema: v };
      }
      function Ps(e, n, o, i) {
        var a = o.IDBKeyRange;
        return o.indexedDB, { dbcore: (i = Ds(n, a, i), e.dbcore.reduce(function(l, p) {
          return p = p.create, u(u({}, l), p(l));
        }, i)) };
      }
      function sr(e, i) {
        var o = i.db, i = Ps(e._middlewares, o, e._deps, i);
        e.core = i.dbcore, e.tables.forEach(function(a) {
          var l = a.name;
          e.core.schema.tables.some(function(p) {
            return p.name === l;
          }) && (a.core = e.core.table(l), e[l] instanceof e.Table && (e[l].core = a.core));
        });
      }
      function ar(e, n, o, i) {
        o.forEach(function(a) {
          var l = i[a];
          n.forEach(function(p) {
            var m = function v(b, O) {
              return W(b, O) || (b = k(b)) && v(b, O);
            }(p, a);
            (!m || "value" in m && m.value === void 0) && (p === e.Transaction.prototype || p instanceof e.Transaction ? re(p, a, { get: function() {
              return this.table(a);
            }, set: function(v) {
              ee(this, a, { value: v, writable: !0, configurable: !0, enumerable: !0 });
            } }) : p[a] = new e.Table(a, l));
          });
        });
      }
      function Xr(e, n) {
        n.forEach(function(o) {
          for (var i in o) o[i] instanceof e.Table && delete o[i];
        });
      }
      function Is(e, n) {
        return e._cfg.version - n._cfg.version;
      }
      function ks(e, n, o, i) {
        var a = e._dbSchema;
        o.objectStoreNames.contains("$meta") && !a.$meta && (a.$meta = Yr("$meta", oi("")[0], []), e._storeNames.push("$meta"));
        var l = e._createTransaction("readwrite", e._storeNames, a);
        l.create(o), l._completion.catch(i);
        var p = l._reject.bind(l), m = oe.transless || oe;
        Mt(function() {
          return oe.trans = l, oe.transless = m, n !== 0 ? (sr(e, o), b = n, ((v = l).storeNames.includes("$meta") ? v.table("$meta").get("version").then(function(O) {
            return O ?? b;
          }) : Z.resolve(b)).then(function(O) {
            return N = O, g = l, w = o, E = [], O = (y = e)._versions, T = y._dbSchema = lr(0, y.idbdb, w), (O = O.filter(function(C) {
              return C._cfg.version >= N;
            })).length !== 0 ? (O.forEach(function(C) {
              E.push(function() {
                var R = T, P = C._cfg.dbschema;
                cr(y, R, w), cr(y, P, w), T = y._dbSchema = P;
                var I = zr(R, P);
                I.add.forEach(function(J) {
                  Jr(w, J[0], J[1].primKey, J[1].indexes);
                }), I.change.forEach(function(J) {
                  if (J.recreate) throw new K.Upgrade("Not yet support for changing primary key");
                  var z = w.objectStore(J.name);
                  J.add.forEach(function(te) {
                    return ur(z, te);
                  }), J.change.forEach(function(te) {
                    z.deleteIndex(te.name), ur(z, te);
                  }), J.del.forEach(function(te) {
                    return z.deleteIndex(te);
                  });
                });
                var U = C._cfg.contentUpgrade;
                if (U && C._cfg.version > N) {
                  sr(y, w), g._memoizedTables = {};
                  var X = de(P);
                  I.del.forEach(function(J) {
                    X[J] = R[J];
                  }), Xr(y, [y.Transaction.prototype]), ar(y, [y.Transaction.prototype], f(X), X), g.schema = X;
                  var V, Y = xt(U);
                  return Y && yn(), I = Z.follow(function() {
                    var J;
                    (V = U(g)) && Y && (J = Bt.bind(null, null), V.then(J, J));
                  }), V && typeof V.then == "function" ? Z.resolve(V) : I.then(function() {
                    return V;
                  });
                }
              }), E.push(function(R) {
                var P, I, U = C._cfg.dbschema;
                P = U, I = R, [].slice.call(I.db.objectStoreNames).forEach(function(X) {
                  return P[X] == null && I.db.deleteObjectStore(X);
                }), Xr(y, [y.Transaction.prototype]), ar(y, [y.Transaction.prototype], y._storeNames, y._dbSchema), g.schema = y._dbSchema;
              }), E.push(function(R) {
                y.idbdb.objectStoreNames.contains("$meta") && (Math.ceil(y.idbdb.version / 10) === C._cfg.version ? (y.idbdb.deleteObjectStore("$meta"), delete y._dbSchema.$meta, y._storeNames = y._storeNames.filter(function(P) {
                  return P !== "$meta";
                })) : R.objectStore("$meta").put(C._cfg.version, "version"));
              });
            }), function C() {
              return E.length ? Z.resolve(E.shift()(g.idbtrans)).then(C) : Z.resolve();
            }().then(function() {
              ri(T, w);
            })) : Z.resolve();
            var y, N, g, w, E, T;
          }).catch(p)) : (f(a).forEach(function(O) {
            Jr(o, O, a[O].primKey, a[O].indexes);
          }), sr(e, o), void Z.follow(function() {
            return e.on.populate.fire(l);
          }).catch(p));
          var v, b;
        });
      }
      function js(e, n) {
        ri(e._dbSchema, n), n.db.version % 10 != 0 || n.objectStoreNames.contains("$meta") || n.db.createObjectStore("$meta").add(Math.ceil(n.db.version / 10 - 1), "version");
        var o = lr(0, e.idbdb, n);
        cr(e, e._dbSchema, n);
        for (var i = 0, a = zr(o, e._dbSchema).change; i < a.length; i++) {
          var l = function(p) {
            if (p.change.length || p.recreate) return console.warn("Unable to patch indexes of table ".concat(p.name, " because it has changes on the type of index or primary key.")), { value: void 0 };
            var m = n.objectStore(p.name);
            p.add.forEach(function(v) {
              ae && console.debug("Dexie upgrade patch: Creating missing index ".concat(p.name, ".").concat(v.src)), ur(m, v);
            });
          }(a[i]);
          if (typeof l == "object") return l.value;
        }
      }
      function zr(e, n) {
        var o, i = { del: [], add: [], change: [] };
        for (o in e) n[o] || i.del.push(o);
        for (o in n) {
          var a = e[o], l = n[o];
          if (a) {
            var p = { name: o, def: l, recreate: !1, del: [], add: [], change: [] };
            if ("" + (a.primKey.keyPath || "") != "" + (l.primKey.keyPath || "") || a.primKey.auto !== l.primKey.auto) p.recreate = !0, i.change.push(p);
            else {
              var m = a.idxByName, v = l.idxByName, b = void 0;
              for (b in m) v[b] || p.del.push(b);
              for (b in v) {
                var O = m[b], y = v[b];
                O ? O.src !== y.src && p.change.push(y) : p.add.push(y);
              }
              (0 < p.del.length || 0 < p.add.length || 0 < p.change.length) && i.change.push(p);
            }
          } else i.add.push([o, l]);
        }
        return i;
      }
      function Jr(e, n, o, i) {
        var a = e.db.createObjectStore(n, o.keyPath ? { keyPath: o.keyPath, autoIncrement: o.auto } : { autoIncrement: o.auto });
        return i.forEach(function(l) {
          return ur(a, l);
        }), a;
      }
      function ri(e, n) {
        f(e).forEach(function(o) {
          n.db.objectStoreNames.contains(o) || (ae && console.debug("Dexie: Creating missing table", o), Jr(n, o, e[o].primKey, e[o].indexes));
        });
      }
      function ur(e, n) {
        e.createIndex(n.name, n.keyPath, { unique: n.unique, multiEntry: n.multi });
      }
      function lr(e, n, o) {
        var i = {};
        return $(n.objectStoreNames, 0).forEach(function(a) {
          for (var l = o.objectStore(a), p = Gr(ti(b = l.keyPath), b || "", !0, !1, !!l.autoIncrement, b && typeof b != "string", !0), m = [], v = 0; v < l.indexNames.length; ++v) {
            var O = l.index(l.indexNames[v]), b = O.keyPath, O = Gr(O.name, b, !!O.unique, !!O.multiEntry, !1, b && typeof b != "string", !1);
            m.push(O);
          }
          i[a] = Yr(a, p, m);
        }), i;
      }
      function cr(e, n, o) {
        for (var i = o.db.objectStoreNames, a = 0; a < i.length; ++a) {
          var l = i[a], p = o.objectStore(l);
          e._hasGetAll = "getAll" in p;
          for (var m = 0; m < p.indexNames.length; ++m) {
            var v = p.indexNames[m], b = p.index(v).keyPath, O = typeof b == "string" ? b : "[" + $(b).join("+") + "]";
            !n[l] || (b = n[l].idxByName[O]) && (b.name = v, delete n[l].idxByName[O], n[l].idxByName[v] = b);
          }
        }
        typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && d.WorkerGlobalScope && d instanceof d.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (e._hasGetAll = !1);
      }
      function oi(e) {
        return e.split(",").map(function(n, o) {
          var l = n.split(":"), i = (a = l[1]) === null || a === void 0 ? void 0 : a.trim(), a = (n = l[0].trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(a) ? a.match(/^\[(.*)\]$/)[1].split("+") : a;
          return Gr(a, l || null, /\&/.test(n), /\*/.test(n), /\+\+/.test(n), h(l), o === 0, i);
        });
      }
      var Ls = (wn.prototype._createTableSchema = Yr, wn.prototype._parseIndexSyntax = oi, wn.prototype._parseStoresSpec = function(e, n) {
        var o = this;
        f(e).forEach(function(i) {
          if (e[i] !== null) {
            var a = o._parseIndexSyntax(e[i]), l = a.shift();
            if (!l) throw new K.Schema("Invalid schema for table " + i + ": " + e[i]);
            if (l.unique = !0, l.multi) throw new K.Schema("Primary key cannot be multiEntry*");
            a.forEach(function(p) {
              if (p.auto) throw new K.Schema("Only primary key can be marked as autoIncrement (++)");
              if (!p.keyPath) throw new K.Schema("Index must have a name and cannot be an empty string");
            }), a = o._createTableSchema(i, l, a), n[i] = a;
          }
        });
      }, wn.prototype.stores = function(o) {
        var n = this.db;
        this._cfg.storesSource = this._cfg.storesSource ? _(this._cfg.storesSource, o) : o;
        var o = n._versions, i = {}, a = {};
        return o.forEach(function(l) {
          _(i, l._cfg.storesSource), a = l._cfg.dbschema = {}, l._parseStoresSpec(i, a);
        }), n._dbSchema = a, Xr(n, [n._allTables, n, n.Transaction.prototype]), ar(n, [n._allTables, n, n.Transaction.prototype, this._cfg.tables], f(a), a), n._storeNames = f(a), this;
      }, wn.prototype.upgrade = function(e) {
        return this._cfg.contentUpgrade = pe(this._cfg.contentUpgrade || S, e), this;
      }, wn);
      function wn() {
      }
      function Zr(e, n) {
        var o = e._dbNamesDB;
        return o || (o = e._dbNamesDB = new Pt(er, { addons: [], indexedDB: e, IDBKeyRange: n })).version(1).stores({ dbnames: "name" }), o.table("dbnames");
      }
      function eo(e) {
        return e && typeof e.databases == "function";
      }
      function to(e) {
        return Mt(function() {
          return oe.letThrough = !0, e();
        });
      }
      function no(e) {
        return !("from" in e);
      }
      var ze = function(e, n) {
        if (!this) {
          var o = new ze();
          return e && "d" in e && _(o, e), o;
        }
        _(this, arguments.length ? { d: 1, from: e, to: 1 < arguments.length ? n : e } : { d: 0 });
      };
      function Ln(e, n, o) {
        var i = xe(n, o);
        if (!isNaN(i)) {
          if (0 < i) throw RangeError();
          if (no(e)) return _(e, { from: n, to: o, d: 1 });
          var a = e.l, i = e.r;
          if (xe(o, e.from) < 0) return a ? Ln(a, n, o) : e.l = { from: n, to: o, d: 1, l: null, r: null }, si(e);
          if (0 < xe(n, e.to)) return i ? Ln(i, n, o) : e.r = { from: n, to: o, d: 1, l: null, r: null }, si(e);
          xe(n, e.from) < 0 && (e.from = n, e.l = null, e.d = i ? i.d + 1 : 1), 0 < xe(o, e.to) && (e.to = o, e.r = null, e.d = e.l ? e.l.d + 1 : 1), o = !e.r, a && !e.l && Fn(e, a), i && o && Fn(e, i);
        }
      }
      function Fn(e, n) {
        no(n) || function o(i, v) {
          var l = v.from, p = v.to, m = v.l, v = v.r;
          Ln(i, l, p), m && o(i, m), v && o(i, v);
        }(e, n);
      }
      function ii(e, n) {
        var o = fr(n), i = o.next();
        if (i.done) return !1;
        for (var a = i.value, l = fr(e), p = l.next(a.from), m = p.value; !i.done && !p.done; ) {
          if (xe(m.from, a.to) <= 0 && 0 <= xe(m.to, a.from)) return !0;
          xe(a.from, m.from) < 0 ? a = (i = o.next(m.from)).value : m = (p = l.next(a.from)).value;
        }
        return !1;
      }
      function fr(e) {
        var n = no(e) ? null : { s: 0, n: e };
        return { next: function(o) {
          for (var i = 0 < arguments.length; n; ) switch (n.s) {
            case 0:
              if (n.s = 1, i) for (; n.n.l && xe(o, n.n.from) < 0; ) n = { up: n, n: n.n.l, s: 1 };
              else for (; n.n.l; ) n = { up: n, n: n.n.l, s: 1 };
            case 1:
              if (n.s = 2, !i || xe(o, n.n.to) <= 0) return { value: n.n, done: !1 };
            case 2:
              if (n.n.r) {
                n.s = 3, n = { up: n, n: n.n.r, s: 0 };
                continue;
              }
            case 3:
              n = n.up;
          }
          return { done: !0 };
        } };
      }
      function si(e) {
        var n, o, i = (((n = e.r) === null || n === void 0 ? void 0 : n.d) || 0) - (((o = e.l) === null || o === void 0 ? void 0 : o.d) || 0), a = 1 < i ? "r" : i < -1 ? "l" : "";
        a && (n = a == "r" ? "l" : "r", o = u({}, e), i = e[a], e.from = i.from, e.to = i.to, e[a] = i[a], o[a] = i[n], (e[n] = o).d = ai(o)), e.d = ai(e);
      }
      function ai(o) {
        var n = o.r, o = o.l;
        return (n ? o ? Math.max(n.d, o.d) : n.d : o ? o.d : 0) + 1;
      }
      function dr(e, n) {
        return f(n).forEach(function(o) {
          e[o] ? Fn(e[o], n[o]) : e[o] = function i(a) {
            var l, p, m = {};
            for (l in a) j(a, l) && (p = a[l], m[l] = !p || typeof p != "object" || dt.has(p.constructor) ? p : i(p));
            return m;
          }(n[o]);
        }), e;
      }
      function ro(e, n) {
        return e.all || n.all || Object.keys(e).some(function(o) {
          return n[o] && ii(n[o], e[o]);
        });
      }
      B(ze.prototype, ((wt = { add: function(e) {
        return Fn(this, e), this;
      }, addKey: function(e) {
        return Ln(this, e, e), this;
      }, addKeys: function(e) {
        var n = this;
        return e.forEach(function(o) {
          return Ln(n, o, o);
        }), this;
      }, hasKey: function(e) {
        var n = fr(this).next(e).value;
        return n && xe(n.from, e) <= 0 && 0 <= xe(n.to, e);
      } })[rt] = function() {
        return fr(this);
      }, wt));
      var nn = {}, oo = {}, io = !1;
      function pr(e) {
        dr(oo, e), io || (io = !0, setTimeout(function() {
          io = !1, so(oo, !(oo = {}));
        }, 0));
      }
      function so(e, n) {
        n === void 0 && (n = !1);
        var o = /* @__PURE__ */ new Set();
        if (e.all) for (var i = 0, a = Object.values(nn); i < a.length; i++) ui(p = a[i], e, o, n);
        else for (var l in e) {
          var p, m = /^idb\:\/\/(.*)\/(.*)\//.exec(l);
          m && (l = m[1], m = m[2], (p = nn["idb://".concat(l, "/").concat(m)]) && ui(p, e, o, n));
        }
        o.forEach(function(v) {
          return v();
        });
      }
      function ui(e, n, o, i) {
        for (var a = [], l = 0, p = Object.entries(e.queries.query); l < p.length; l++) {
          for (var m = p[l], v = m[0], b = [], O = 0, y = m[1]; O < y.length; O++) {
            var N = y[O];
            ro(n, N.obsSet) ? N.subscribers.forEach(function(T) {
              return o.add(T);
            }) : i && b.push(N);
          }
          i && a.push([v, b]);
        }
        if (i) for (var g = 0, w = a; g < w.length; g++) {
          var E = w[g], v = E[0], b = E[1];
          e.queries.query[v] = b;
        }
      }
      function Fs(e) {
        var n = e._state, o = e._deps.indexedDB;
        if (n.isBeingOpened || e.idbdb) return n.dbReadyPromise.then(function() {
          return n.dbOpenError ? $e(n.dbOpenError) : e;
        });
        n.isBeingOpened = !0, n.dbOpenError = null, n.openComplete = !1;
        var i = n.openCanceller, a = Math.round(10 * e.verno), l = !1;
        function p() {
          if (n.openCanceller !== i) throw new K.DatabaseClosed("db.open() was cancelled");
        }
        function m() {
          return new Z(function(N, g) {
            if (p(), !o) throw new K.MissingAPI();
            var w = e.name, E = n.autoSchema || !a ? o.open(w) : o.open(w, a);
            if (!E) throw new K.MissingAPI();
            E.onerror = Ct(g), E.onblocked = Le(e._fireOnBlocked), E.onupgradeneeded = Le(function(T) {
              var C;
              O = E.transaction, n.autoSchema && !e._options.allowEmptyDB ? (E.onerror = Pn, O.abort(), E.result.close(), (C = o.deleteDatabase(w)).onsuccess = C.onerror = Le(function() {
                g(new K.NoSuchDatabase("Database ".concat(w, " doesnt exist")));
              })) : (O.onerror = Ct(g), T = T.oldVersion > Math.pow(2, 62) ? 0 : T.oldVersion, y = T < 1, e.idbdb = E.result, l && js(e, O), ks(e, T / 10, O, g));
            }, g), E.onsuccess = Le(function() {
              O = null;
              var T, C, R, P, I, U = e.idbdb = E.result, X = $(U.objectStoreNames);
              if (0 < X.length) try {
                var V = U.transaction((P = X).length === 1 ? P[0] : P, "readonly");
                if (n.autoSchema) C = U, R = V, (T = e).verno = C.version / 10, R = T._dbSchema = lr(0, C, R), T._storeNames = $(C.objectStoreNames, 0), ar(T, [T._allTables], f(R), R);
                else if (cr(e, e._dbSchema, V), ((I = zr(lr(0, (I = e).idbdb, V), I._dbSchema)).add.length || I.change.some(function(Y) {
                  return Y.add.length || Y.change.length;
                })) && !l) return console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Dexie will add missing parts and increment native version number to workaround this."), U.close(), a = U.version + 1, l = !0, N(m());
                sr(e, V);
              } catch {
              }
              vn.push(e), U.onversionchange = Le(function(Y) {
                n.vcFired = !0, e.on("versionchange").fire(Y);
              }), U.onclose = Le(function(Y) {
                e.on("close").fire(Y);
              }), y && (I = e._deps, V = w, U = I.indexedDB, I = I.IDBKeyRange, eo(U) || V === er || Zr(U, I).put({ name: V }).catch(S)), N();
            }, g);
          }).catch(function(N) {
            switch (N?.name) {
              case "UnknownError":
                if (0 < n.PR1398_maxLoop) return n.PR1398_maxLoop--, console.warn("Dexie: Workaround for Chrome UnknownError on open()"), m();
                break;
              case "VersionError":
                if (0 < a) return a = 0, m();
            }
            return Z.reject(N);
          });
        }
        var v, b = n.dbReadyResolve, O = null, y = !1;
        return Z.race([i, (typeof navigator > "u" ? Z.resolve() : !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(N) {
          function g() {
            return indexedDB.databases().finally(N);
          }
          v = setInterval(g, 100), g();
        }).finally(function() {
          return clearInterval(v);
        }) : Promise.resolve()).then(m)]).then(function() {
          return p(), n.onReadyBeingFired = [], Z.resolve(to(function() {
            return e.on.ready.fire(e.vip);
          })).then(function N() {
            if (0 < n.onReadyBeingFired.length) {
              var g = n.onReadyBeingFired.reduce(pe, S);
              return n.onReadyBeingFired = [], Z.resolve(to(function() {
                return g(e.vip);
              })).then(N);
            }
          });
        }).finally(function() {
          n.openCanceller === i && (n.onReadyBeingFired = null, n.isBeingOpened = !1);
        }).catch(function(N) {
          n.dbOpenError = N;
          try {
            O && O.abort();
          } catch {
          }
          return i === n.openCanceller && e._close(), $e(N);
        }).finally(function() {
          n.openComplete = !0, b();
        }).then(function() {
          var N;
          return y && (N = {}, e.tables.forEach(function(g) {
            g.schema.indexes.forEach(function(w) {
              w.name && (N["idb://".concat(e.name, "/").concat(g.name, "/").concat(w.name)] = new ze(-1 / 0, [[[]]]));
            }), N["idb://".concat(e.name, "/").concat(g.name, "/")] = N["idb://".concat(e.name, "/").concat(g.name, "/:dels")] = new ze(-1 / 0, [[[]]]);
          }), Ut(In).fire(N), so(N, !0)), e;
        });
      }
      function ao(e) {
        function n(l) {
          return e.next(l);
        }
        var o = a(n), i = a(function(l) {
          return e.throw(l);
        });
        function a(l) {
          return function(v) {
            var m = l(v), v = m.value;
            return m.done ? v : v && typeof v.then == "function" ? v.then(o, i) : h(v) ? Promise.all(v).then(o, i) : o(v);
          };
        }
        return a(n)();
      }
      function hr(e, n, o) {
        for (var i = h(e) ? e.slice() : [e], a = 0; a < o; ++a) i.push(n);
        return i;
      }
      var Ks = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(e) {
        return u(u({}, e), { table: function(n) {
          var o = e.table(n), i = o.schema, a = {}, l = [];
          function p(y, N, g) {
            var w = jn(y), E = a[w] = a[w] || [], T = y == null ? 0 : typeof y == "string" ? 1 : y.length, C = 0 < N, C = u(u({}, g), { name: C ? "".concat(w, "(virtual-from:").concat(g.name, ")") : g.name, lowLevelIndex: g, isVirtual: C, keyTail: N, keyLength: T, extractKey: Qr(y), unique: !C && g.unique });
            return E.push(C), C.isPrimaryKey || l.push(C), 1 < T && p(T === 2 ? y[0] : y.slice(0, T - 1), N + 1, g), E.sort(function(R, P) {
              return R.keyTail - P.keyTail;
            }), C;
          }
          n = p(i.primaryKey.keyPath, 0, i.primaryKey), a[":id"] = [n];
          for (var m = 0, v = i.indexes; m < v.length; m++) {
            var b = v[m];
            p(b.keyPath, 0, b);
          }
          function O(y) {
            var N, g = y.query.index;
            return g.isVirtual ? u(u({}, y), { query: { index: g.lowLevelIndex, range: (N = y.query.range, g = g.keyTail, { type: N.type === 1 ? 2 : N.type, lower: hr(N.lower, N.lowerOpen ? e.MAX_KEY : e.MIN_KEY, g), lowerOpen: !0, upper: hr(N.upper, N.upperOpen ? e.MIN_KEY : e.MAX_KEY, g), upperOpen: !0 }) } }) : y;
          }
          return u(u({}, o), { schema: u(u({}, i), { primaryKey: n, indexes: l, getIndexByKeyPath: function(y) {
            return (y = a[jn(y)]) && y[0];
          } }), count: function(y) {
            return o.count(O(y));
          }, query: function(y) {
            return o.query(O(y));
          }, openCursor: function(y) {
            var N = y.query.index, g = N.keyTail, w = N.isVirtual, E = N.keyLength;
            return w ? o.openCursor(O(y)).then(function(C) {
              return C && T(C);
            }) : o.openCursor(y);
            function T(C) {
              return Object.create(C, { continue: { value: function(R) {
                R != null ? C.continue(hr(R, y.reverse ? e.MAX_KEY : e.MIN_KEY, g)) : y.unique ? C.continue(C.key.slice(0, E).concat(y.reverse ? e.MIN_KEY : e.MAX_KEY, g)) : C.continue();
              } }, continuePrimaryKey: { value: function(R, P) {
                C.continuePrimaryKey(hr(R, e.MAX_KEY, g), P);
              } }, primaryKey: { get: function() {
                return C.primaryKey;
              } }, key: { get: function() {
                var R = C.key;
                return E === 1 ? R[0] : R.slice(0, E);
              } }, value: { get: function() {
                return C.value;
              } } });
            }
          } });
        } });
      } };
      function uo(e, n, o, i) {
        return o = o || {}, i = i || "", f(e).forEach(function(a) {
          var l, p, m;
          j(n, a) ? (l = e[a], p = n[a], typeof l == "object" && typeof p == "object" && l && p ? (m = jt(l)) !== jt(p) ? o[i + a] = n[a] : m === "Object" ? uo(l, p, o, i + a + ".") : l !== p && (o[i + a] = n[a]) : l !== p && (o[i + a] = n[a])) : o[i + a] = void 0;
        }), f(n).forEach(function(a) {
          j(e, a) || (o[i + a] = n[a]);
        }), o;
      }
      function lo(e, n) {
        return n.type === "delete" ? n.keys : n.keys || n.values.map(e.extractKey);
      }
      var Ms = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: function(e) {
        return u(u({}, e), { table: function(n) {
          var o = e.table(n), i = o.schema.primaryKey;
          return u(u({}, o), { mutate: function(a) {
            var l = oe.trans, p = l.table(n).hook, m = p.deleting, v = p.creating, b = p.updating;
            switch (a.type) {
              case "add":
                if (v.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "put":
                if (v.fire === S && b.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "delete":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return O(a);
                }, !0);
              case "deleteRange":
                if (m.fire === S) break;
                return l._promise("readwrite", function() {
                  return function y(N, g, w) {
                    return o.query({ trans: N, values: !1, query: { index: i, range: g }, limit: w }).then(function(E) {
                      var T = E.result;
                      return O({ type: "delete", keys: T, trans: N }).then(function(C) {
                        return 0 < C.numFailures ? Promise.reject(C.failures[0]) : T.length < w ? { failures: [], numFailures: 0, lastResult: void 0 } : y(N, u(u({}, g), { lower: T[T.length - 1], lowerOpen: !0 }), w);
                      });
                    });
                  }(a.trans, a.range, 1e4);
                }, !0);
            }
            return o.mutate(a);
            function O(y) {
              var N, g, w, E = oe.trans, T = y.keys || lo(i, y);
              if (!T) throw new Error("Keys missing");
              return (y = y.type === "add" || y.type === "put" ? u(u({}, y), { keys: T }) : u({}, y)).type !== "delete" && (y.values = c([], y.values)), y.keys && (y.keys = c([], y.keys)), N = o, w = T, ((g = y).type === "add" ? Promise.resolve([]) : N.getMany({ trans: g.trans, keys: w, cache: "immutable" })).then(function(C) {
                var R = T.map(function(P, I) {
                  var U, X, V, Y = C[I], J = { onerror: null, onsuccess: null };
                  return y.type === "delete" ? m.fire.call(J, P, Y, E) : y.type === "add" || Y === void 0 ? (U = v.fire.call(J, P, y.values[I], E), P == null && U != null && (y.keys[I] = P = U, i.outbound || ue(y.values[I], i.keyPath, P))) : (U = uo(Y, y.values[I]), (X = b.fire.call(J, U, P, Y, E)) && (V = y.values[I], Object.keys(X).forEach(function(z) {
                    j(V, z) ? V[z] = X[z] : ue(V, z, X[z]);
                  }))), J;
                });
                return o.mutate(y).then(function(P) {
                  for (var I = P.failures, U = P.results, X = P.numFailures, P = P.lastResult, V = 0; V < T.length; ++V) {
                    var Y = (U || T)[V], J = R[V];
                    Y == null ? J.onerror && J.onerror(I[V]) : J.onsuccess && J.onsuccess(y.type === "put" && C[V] ? y.values[V] : Y);
                  }
                  return { failures: I, results: U, numFailures: X, lastResult: P };
                }).catch(function(P) {
                  return R.forEach(function(I) {
                    return I.onerror && I.onerror(P);
                  }), Promise.reject(P);
                });
              });
            }
          } });
        } });
      } };
      function li(e, n, o) {
        try {
          if (!n || n.keys.length < e.length) return null;
          for (var i = [], a = 0, l = 0; a < n.keys.length && l < e.length; ++a) xe(n.keys[a], e[l]) === 0 && (i.push(o ? at(n.values[a]) : n.values[a]), ++l);
          return i.length === e.length ? i : null;
        } catch {
          return null;
        }
      }
      var Bs = { stack: "dbcore", level: -1, create: function(e) {
        return { table: function(n) {
          var o = e.table(n);
          return u(u({}, o), { getMany: function(i) {
            if (!i.cache) return o.getMany(i);
            var a = li(i.keys, i.trans._cache, i.cache === "clone");
            return a ? Z.resolve(a) : o.getMany(i).then(function(l) {
              return i.trans._cache = { keys: i.keys, values: i.cache === "clone" ? at(l) : l }, l;
            });
          }, mutate: function(i) {
            return i.type !== "add" && (i.trans._cache = null), o.mutate(i);
          } });
        } };
      } };
      function ci(e, n) {
        return e.trans.mode === "readonly" && !!e.subscr && !e.trans.explicit && e.trans.db._options.cache !== "disabled" && !n.schema.primaryKey.outbound;
      }
      function fi(e, n) {
        switch (e) {
          case "query":
            return n.values && !n.unique;
          case "get":
          case "getMany":
          case "count":
          case "openCursor":
            return !1;
        }
      }
      var $s = { stack: "dbcore", level: 0, name: "Observability", create: function(e) {
        var n = e.schema.name, o = new ze(e.MIN_KEY, e.MAX_KEY);
        return u(u({}, e), { transaction: function(i, a, l) {
          if (oe.subscr && a !== "readonly") throw new K.ReadOnly("Readwrite transaction in liveQuery context. Querier source: ".concat(oe.querier));
          return e.transaction(i, a, l);
        }, table: function(i) {
          var a = e.table(i), l = a.schema, p = l.primaryKey, y = l.indexes, m = p.extractKey, v = p.outbound, b = p.autoIncrement && y.filter(function(g) {
            return g.compound && g.keyPath.includes(p.keyPath);
          }), O = u(u({}, a), { mutate: function(g) {
            function w(z) {
              return z = "idb://".concat(n, "/").concat(i, "/").concat(z), P[z] || (P[z] = new ze());
            }
            var E, T, C, R = g.trans, P = g.mutatedParts || (g.mutatedParts = {}), I = w(""), U = w(":dels"), X = g.type, J = g.type === "deleteRange" ? [g.range] : g.type === "delete" ? [g.keys] : g.values.length < 50 ? [lo(p, g).filter(function(z) {
              return z;
            }), g.values] : [], V = J[0], Y = J[1], J = g.trans._cache;
            return h(V) ? (I.addKeys(V), (J = X === "delete" || V.length === Y.length ? li(V, J) : null) || U.addKeys(V), (J || Y) && (E = w, T = J, C = Y, l.indexes.forEach(function(z) {
              var te = E(z.name || "");
              function ge(me) {
                return me != null ? z.extractKey(me) : null;
              }
              function Oe(me) {
                return z.multiEntry && h(me) ? me.forEach(function(Fe) {
                  return te.addKey(Fe);
                }) : te.addKey(me);
              }
              (T || C).forEach(function(me, Je) {
                var he = T && ge(T[Je]), Je = C && ge(C[Je]);
                xe(he, Je) !== 0 && (he != null && Oe(he), Je != null && Oe(Je));
              });
            }))) : V ? (Y = { from: (Y = V.lower) !== null && Y !== void 0 ? Y : e.MIN_KEY, to: (Y = V.upper) !== null && Y !== void 0 ? Y : e.MAX_KEY }, U.add(Y), I.add(Y)) : (I.add(o), U.add(o), l.indexes.forEach(function(z) {
              return w(z.name).add(o);
            })), a.mutate(g).then(function(z) {
              return !V || g.type !== "add" && g.type !== "put" || (I.addKeys(z.results), b && b.forEach(function(te) {
                for (var ge = g.values.map(function(he) {
                  return te.extractKey(he);
                }), Oe = te.keyPath.findIndex(function(he) {
                  return he === p.keyPath;
                }), me = 0, Fe = z.results.length; me < Fe; ++me) ge[me][Oe] = z.results[me];
                w(te.name).addKeys(ge);
              })), R.mutatedParts = dr(R.mutatedParts || {}, P), z;
            });
          } }), y = function(w) {
            var E = w.query, w = E.index, E = E.range;
            return [w, new ze((w = E.lower) !== null && w !== void 0 ? w : e.MIN_KEY, (E = E.upper) !== null && E !== void 0 ? E : e.MAX_KEY)];
          }, N = { get: function(g) {
            return [p, new ze(g.key)];
          }, getMany: function(g) {
            return [p, new ze().addKeys(g.keys)];
          }, count: y, query: y, openCursor: y };
          return f(N).forEach(function(g) {
            O[g] = function(w) {
              var E = oe.subscr, T = !!E, C = ci(oe, a) && fi(g, w) ? w.obsSet = {} : E;
              if (T) {
                var R = function(Y) {
                  return Y = "idb://".concat(n, "/").concat(i, "/").concat(Y), C[Y] || (C[Y] = new ze());
                }, P = R(""), I = R(":dels"), E = N[g](w), T = E[0], E = E[1];
                if ((g === "query" && T.isPrimaryKey && !w.values ? I : R(T.name || "")).add(E), !T.isPrimaryKey) {
                  if (g !== "count") {
                    var U = g === "query" && v && w.values && a.query(u(u({}, w), { values: !1 }));
                    return a[g].apply(this, arguments).then(function(Y) {
                      if (g === "query") {
                        if (v && w.values) return U.then(function(ge) {
                          return ge = ge.result, P.addKeys(ge), Y;
                        });
                        var J = w.values ? Y.result.map(m) : Y.result;
                        (w.values ? P : I).addKeys(J);
                      } else if (g === "openCursor") {
                        var z = Y, te = w.values;
                        return z && Object.create(z, { key: { get: function() {
                          return I.addKey(z.primaryKey), z.key;
                        } }, primaryKey: { get: function() {
                          var ge = z.primaryKey;
                          return I.addKey(ge), ge;
                        } }, value: { get: function() {
                          return te && P.addKey(z.primaryKey), z.value;
                        } } });
                      }
                      return Y;
                    });
                  }
                  I.add(o);
                }
              }
              return a[g].apply(this, arguments);
            };
          }), O;
        } });
      } };
      function di(e, n, o) {
        if (o.numFailures === 0) return n;
        if (n.type === "deleteRange") return null;
        var i = n.keys ? n.keys.length : "values" in n && n.values ? n.values.length : 1;
        return o.numFailures === i ? null : (n = u({}, n), h(n.keys) && (n.keys = n.keys.filter(function(a, l) {
          return !(l in o.failures);
        })), "values" in n && h(n.values) && (n.values = n.values.filter(function(a, l) {
          return !(l in o.failures);
        })), n);
      }
      function co(e, n) {
        return o = e, ((i = n).lower === void 0 || (i.lowerOpen ? 0 < xe(o, i.lower) : 0 <= xe(o, i.lower))) && (e = e, (n = n).upper === void 0 || (n.upperOpen ? xe(e, n.upper) < 0 : xe(e, n.upper) <= 0));
        var o, i;
      }
      function pi(e, n, N, i, a, l) {
        if (!N || N.length === 0) return e;
        var p = n.query.index, m = p.multiEntry, v = n.query.range, b = i.schema.primaryKey.extractKey, O = p.extractKey, y = (p.lowLevelIndex || p).extractKey, N = N.reduce(function(g, w) {
          var E = g, T = [];
          if (w.type === "add" || w.type === "put") for (var C = new ze(), R = w.values.length - 1; 0 <= R; --R) {
            var P, I = w.values[R], U = b(I);
            C.hasKey(U) || (P = O(I), (m && h(P) ? P.some(function(z) {
              return co(z, v);
            }) : co(P, v)) && (C.addKey(U), T.push(I)));
          }
          switch (w.type) {
            case "add":
              var X = new ze().addKeys(n.values ? g.map(function(te) {
                return b(te);
              }) : g), E = g.concat(n.values ? T.filter(function(te) {
                return te = b(te), !X.hasKey(te) && (X.addKey(te), !0);
              }) : T.map(function(te) {
                return b(te);
              }).filter(function(te) {
                return !X.hasKey(te) && (X.addKey(te), !0);
              }));
              break;
            case "put":
              var V = new ze().addKeys(w.values.map(function(te) {
                return b(te);
              }));
              E = g.filter(function(te) {
                return !V.hasKey(n.values ? b(te) : te);
              }).concat(n.values ? T : T.map(function(te) {
                return b(te);
              }));
              break;
            case "delete":
              var Y = new ze().addKeys(w.keys);
              E = g.filter(function(te) {
                return !Y.hasKey(n.values ? b(te) : te);
              });
              break;
            case "deleteRange":
              var J = w.range;
              E = g.filter(function(te) {
                return !co(b(te), J);
              });
          }
          return E;
        }, e);
        return N === e ? e : (N.sort(function(g, w) {
          return xe(y(g), y(w)) || xe(b(g), b(w));
        }), n.limit && n.limit < 1 / 0 && (N.length > n.limit ? N.length = n.limit : e.length === n.limit && N.length < n.limit && (a.dirty = !0)), l ? Object.freeze(N) : N);
      }
      function hi(e, n) {
        return xe(e.lower, n.lower) === 0 && xe(e.upper, n.upper) === 0 && !!e.lowerOpen == !!n.lowerOpen && !!e.upperOpen == !!n.upperOpen;
      }
      function qs(e, n) {
        return function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? -1 : 0;
          if (i === void 0) return 1;
          if ((i = xe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return 1;
            if (l) return -1;
          }
          return i;
        }(e.lower, n.lower, e.lowerOpen, n.lowerOpen) <= 0 && 0 <= function(o, i, a, l) {
          if (o === void 0) return i !== void 0 ? 1 : 0;
          if (i === void 0) return -1;
          if ((i = xe(o, i)) === 0) {
            if (a && l) return 0;
            if (a) return -1;
            if (l) return 1;
          }
          return i;
        }(e.upper, n.upper, e.upperOpen, n.upperOpen);
      }
      function Us(e, n, o, i) {
        e.subscribers.add(o), i.addEventListener("abort", function() {
          var a, l;
          e.subscribers.delete(o), e.subscribers.size === 0 && (a = e, l = n, setTimeout(function() {
            a.subscribers.size === 0 && Ke(l, a);
          }, 3e3));
        });
      }
      var Vs = { stack: "dbcore", level: 0, name: "Cache", create: function(e) {
        var n = e.schema.name;
        return u(u({}, e), { transaction: function(o, i, a) {
          var l, p, m = e.transaction(o, i, a);
          return i === "readwrite" && (p = (l = new AbortController()).signal, a = function(v) {
            return function() {
              if (l.abort(), i === "readwrite") {
                for (var b = /* @__PURE__ */ new Set(), O = 0, y = o; O < y.length; O++) {
                  var N = y[O], g = nn["idb://".concat(n, "/").concat(N)];
                  if (g) {
                    var w = e.table(N), E = g.optimisticOps.filter(function(te) {
                      return te.trans === m;
                    });
                    if (m._explicit && v && m.mutatedParts) for (var T = 0, C = Object.values(g.queries.query); T < C.length; T++) for (var R = 0, P = (X = C[T]).slice(); R < P.length; R++) ro((V = P[R]).obsSet, m.mutatedParts) && (Ke(X, V), V.subscribers.forEach(function(te) {
                      return b.add(te);
                    }));
                    else if (0 < E.length) {
                      g.optimisticOps = g.optimisticOps.filter(function(te) {
                        return te.trans !== m;
                      });
                      for (var I = 0, U = Object.values(g.queries.query); I < U.length; I++) for (var X, V, Y, J = 0, z = (X = U[I]).slice(); J < z.length; J++) (V = z[J]).res != null && m.mutatedParts && (v && !V.dirty ? (Y = Object.isFrozen(V.res), Y = pi(V.res, V.req, E, w, V, Y), V.dirty ? (Ke(X, V), V.subscribers.forEach(function(te) {
                        return b.add(te);
                      })) : Y !== V.res && (V.res = Y, V.promise = Z.resolve({ result: Y }))) : (V.dirty && Ke(X, V), V.subscribers.forEach(function(te) {
                        return b.add(te);
                      })));
                    }
                  }
                }
                b.forEach(function(te) {
                  return te();
                });
              }
            };
          }, m.addEventListener("abort", a(!1), { signal: p }), m.addEventListener("error", a(!1), { signal: p }), m.addEventListener("complete", a(!0), { signal: p })), m;
        }, table: function(o) {
          var i = e.table(o), a = i.schema.primaryKey;
          return u(u({}, i), { mutate: function(l) {
            var p = oe.trans;
            if (a.outbound || p.db._options.cache === "disabled" || p.explicit || p.idbtrans.mode !== "readwrite") return i.mutate(l);
            var m = nn["idb://".concat(n, "/").concat(o)];
            return m ? (p = i.mutate(l), l.type !== "add" && l.type !== "put" || !(50 <= l.values.length || lo(a, l).some(function(v) {
              return v == null;
            })) ? (m.optimisticOps.push(l), l.mutatedParts && pr(l.mutatedParts), p.then(function(v) {
              0 < v.numFailures && (Ke(m.optimisticOps, l), (v = di(0, l, v)) && m.optimisticOps.push(v), l.mutatedParts && pr(l.mutatedParts));
            }), p.catch(function() {
              Ke(m.optimisticOps, l), l.mutatedParts && pr(l.mutatedParts);
            })) : p.then(function(v) {
              var b = di(0, u(u({}, l), { values: l.values.map(function(O, y) {
                var N;
                return v.failures[y] || (O = (N = a.keyPath) !== null && N !== void 0 && N.includes(".") ? at(O) : u({}, O), ue(O, a.keyPath, v.results[y])), O;
              }) }), v);
              m.optimisticOps.push(b), queueMicrotask(function() {
                return l.mutatedParts && pr(l.mutatedParts);
              });
            }), p) : i.mutate(l);
          }, query: function(l) {
            if (!ci(oe, i) || !fi("query", l)) return i.query(l);
            var p = ((b = oe.trans) === null || b === void 0 ? void 0 : b.db._options.cache) === "immutable", y = oe, m = y.requery, v = y.signal, b = function(w, E, T, C) {
              var R = nn["idb://".concat(w, "/").concat(E)];
              if (!R) return [];
              if (!(E = R.queries[T])) return [null, !1, R, null];
              var P = E[(C.query ? C.query.index.name : null) || ""];
              if (!P) return [null, !1, R, null];
              switch (T) {
                case "query":
                  var I = P.find(function(U) {
                    return U.req.limit === C.limit && U.req.values === C.values && hi(U.req.query.range, C.query.range);
                  });
                  return I ? [I, !0, R, P] : [P.find(function(U) {
                    return ("limit" in U.req ? U.req.limit : 1 / 0) >= C.limit && (!C.values || U.req.values) && qs(U.req.query.range, C.query.range);
                  }), !1, R, P];
                case "count":
                  return I = P.find(function(U) {
                    return hi(U.req.query.range, C.query.range);
                  }), [I, !!I, R, P];
              }
            }(n, o, "query", l), O = b[0], y = b[1], N = b[2], g = b[3];
            return O && y ? O.obsSet = l.obsSet : (y = i.query(l).then(function(w) {
              var E = w.result;
              if (O && (O.res = E), p) {
                for (var T = 0, C = E.length; T < C; ++T) Object.freeze(E[T]);
                Object.freeze(E);
              } else w.result = at(E);
              return w;
            }).catch(function(w) {
              return g && O && Ke(g, O), Promise.reject(w);
            }), O = { obsSet: l.obsSet, promise: y, subscribers: /* @__PURE__ */ new Set(), type: "query", req: l, dirty: !1 }, g ? g.push(O) : (g = [O], (N = N || (nn["idb://".concat(n, "/").concat(o)] = { queries: { query: {}, count: {} }, objs: /* @__PURE__ */ new Map(), optimisticOps: [], unsignaledParts: {} })).queries.query[l.query.index.name || ""] = g)), Us(O, g, m, v), O.promise.then(function(w) {
              return { result: pi(w.result, l, N?.optimisticOps, i, O, p) };
            });
          } });
        } });
      } };
      function mr(e, n) {
        return new Proxy(e, { get: function(o, i, a) {
          return i === "db" ? n : Reflect.get(o, i, a);
        } });
      }
      var Pt = (qe.prototype.version = function(e) {
        if (isNaN(e) || e < 0.1) throw new K.Type("Given version is not a positive number");
        if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened) throw new K.Schema("Cannot add version when database is open");
        this.verno = Math.max(this.verno, e);
        var n = this._versions, o = n.filter(function(i) {
          return i._cfg.version === e;
        })[0];
        return o || (o = new this.Version(e), n.push(o), n.sort(Is), o.stores({}), this._state.autoSchema = !1, o);
      }, qe.prototype._whenReady = function(e) {
        var n = this;
        return this.idbdb && (this._state.openComplete || oe.letThrough || this._vip) ? e() : new Z(function(o, i) {
          if (n._state.openComplete) return i(new K.DatabaseClosed(n._state.dbOpenError));
          if (!n._state.isBeingOpened) {
            if (!n._state.autoOpen) return void i(new K.DatabaseClosed());
            n.open().catch(S);
          }
          n._state.dbReadyPromise.then(o, i);
        }).then(e);
      }, qe.prototype.use = function(e) {
        var n = e.stack, o = e.create, i = e.level, a = e.name;
        return a && this.unuse({ stack: n, name: a }), e = this._middlewares[n] || (this._middlewares[n] = []), e.push({ stack: n, create: o, level: i ?? 10, name: a }), e.sort(function(l, p) {
          return l.level - p.level;
        }), this;
      }, qe.prototype.unuse = function(e) {
        var n = e.stack, o = e.name, i = e.create;
        return n && this._middlewares[n] && (this._middlewares[n] = this._middlewares[n].filter(function(a) {
          return i ? a.create !== i : !!o && a.name !== o;
        })), this;
      }, qe.prototype.open = function() {
        var e = this;
        return Zt(ot, function() {
          return Fs(e);
        });
      }, qe.prototype._close = function() {
        this.on.close.fire(new CustomEvent("close"));
        var e = this._state, n = vn.indexOf(this);
        if (0 <= n && vn.splice(n, 1), this.idbdb) {
          try {
            this.idbdb.close();
          } catch {
          }
          this.idbdb = null;
        }
        e.isBeingOpened || (e.dbReadyPromise = new Z(function(o) {
          e.dbReadyResolve = o;
        }), e.openCanceller = new Z(function(o, i) {
          e.cancelOpen = i;
        }));
      }, qe.prototype.close = function(o) {
        var n = (o === void 0 ? { disableAutoOpen: !0 } : o).disableAutoOpen, o = this._state;
        n ? (o.isBeingOpened && o.cancelOpen(new K.DatabaseClosed()), this._close(), o.autoOpen = !1, o.dbOpenError = new K.DatabaseClosed()) : (this._close(), o.autoOpen = this._options.autoOpen || o.isBeingOpened, o.openComplete = !1, o.dbOpenError = null);
      }, qe.prototype.delete = function(e) {
        var n = this;
        e === void 0 && (e = { disableAutoOpen: !0 });
        var o = 0 < arguments.length && typeof arguments[0] != "object", i = this._state;
        return new Z(function(a, l) {
          function p() {
            n.close(e);
            var m = n._deps.indexedDB.deleteDatabase(n.name);
            m.onsuccess = Le(function() {
              var v, b, O;
              v = n._deps, b = n.name, O = v.indexedDB, v = v.IDBKeyRange, eo(O) || b === er || Zr(O, v).delete(b).catch(S), a();
            }), m.onerror = Ct(l), m.onblocked = n._fireOnBlocked;
          }
          if (o) throw new K.InvalidArgument("Invalid closeOptions argument to db.delete()");
          i.isBeingOpened ? i.dbReadyPromise.then(p) : p();
        });
      }, qe.prototype.backendDB = function() {
        return this.idbdb;
      }, qe.prototype.isOpen = function() {
        return this.idbdb !== null;
      }, qe.prototype.hasBeenClosed = function() {
        var e = this._state.dbOpenError;
        return e && e.name === "DatabaseClosed";
      }, qe.prototype.hasFailed = function() {
        return this._state.dbOpenError !== null;
      }, qe.prototype.dynamicallyOpened = function() {
        return this._state.autoSchema;
      }, Object.defineProperty(qe.prototype, "tables", { get: function() {
        var e = this;
        return f(this._allTables).map(function(n) {
          return e._allTables[n];
        });
      }, enumerable: !1, configurable: !0 }), qe.prototype.transaction = function() {
        var e = (function(n, o, i) {
          var a = arguments.length;
          if (a < 2) throw new K.InvalidArgument("Too few arguments");
          for (var l = new Array(a - 1); --a; ) l[a - 1] = arguments[a];
          return i = l.pop(), [n, Xe(l), i];
        }).apply(this, arguments);
        return this._transaction.apply(this, e);
      }, qe.prototype._transaction = function(e, n, o) {
        var i = this, a = oe.trans;
        a && a.db === this && e.indexOf("!") === -1 || (a = null);
        var l, p, m = e.indexOf("?") !== -1;
        e = e.replace("!", "").replace("?", "");
        try {
          if (p = n.map(function(b) {
            if (b = b instanceof i.Table ? b.name : b, typeof b != "string") throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
            return b;
          }), e == "r" || e === qr) l = qr;
          else {
            if (e != "rw" && e != Ur) throw new K.InvalidArgument("Invalid transaction mode: " + e);
            l = Ur;
          }
          if (a) {
            if (a.mode === qr && l === Ur) {
              if (!m) throw new K.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
              a = null;
            }
            a && p.forEach(function(b) {
              if (a && a.storeNames.indexOf(b) === -1) {
                if (!m) throw new K.SubTransaction("Table " + b + " not included in parent transaction.");
                a = null;
              }
            }), m && a && !a.active && (a = null);
          }
        } catch (b) {
          return a ? a._promise(null, function(O, y) {
            y(b);
          }) : $e(b);
        }
        var v = (function b(O, y, N, g, w) {
          return Z.resolve().then(function() {
            var E = oe.transless || oe, T = O._createTransaction(y, N, O._dbSchema, g);
            if (T.explicit = !0, E = { trans: T, transless: E }, g) T.idbtrans = g.idbtrans;
            else try {
              T.create(), T.idbtrans._explicit = !0, O._state.PR1398_maxLoop = 3;
            } catch (P) {
              return P.name === A.InvalidState && O.isOpen() && 0 < --O._state.PR1398_maxLoop ? (console.warn("Dexie: Need to reopen db"), O.close({ disableAutoOpen: !1 }), O.open().then(function() {
                return b(O, y, N, null, w);
              })) : $e(P);
            }
            var C, R = xt(w);
            return R && yn(), E = Z.follow(function() {
              var P;
              (C = w.call(T, T)) && (R ? (P = Bt.bind(null, null), C.then(P, P)) : typeof C.next == "function" && typeof C.throw == "function" && (C = ao(C)));
            }, E), (C && typeof C.then == "function" ? Z.resolve(C).then(function(P) {
              return T.active ? P : $e(new K.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"));
            }) : E.then(function() {
              return C;
            })).then(function(P) {
              return g && T._resolve(), T._completion.then(function() {
                return P;
              });
            }).catch(function(P) {
              return T._reject(P), $e(P);
            });
          });
        }).bind(null, this, l, p, a, o);
        return a ? a._promise(l, v, "lock") : oe.trans ? Zt(oe.transless, function() {
          return i._whenReady(v);
        }) : this._whenReady(v);
      }, qe.prototype.table = function(e) {
        if (!j(this._allTables, e)) throw new K.InvalidTable("Table ".concat(e, " does not exist"));
        return this._allTables[e];
      }, qe);
      function qe(e, n) {
        var o = this;
        this._middlewares = {}, this.verno = 0;
        var i = qe.dependencies;
        this._options = n = u({ addons: qe.addons, autoOpen: !0, indexedDB: i.indexedDB, IDBKeyRange: i.IDBKeyRange, cache: "cloned" }, n), this._deps = { indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange }, i = n.addons, this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
        var a, l, p, m, v, b = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: S, dbReadyPromise: null, cancelOpen: S, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3, autoOpen: n.autoOpen };
        b.dbReadyPromise = new Z(function(y) {
          b.dbReadyResolve = y;
        }), b.openCanceller = new Z(function(y, N) {
          b.cancelOpen = N;
        }), this._state = b, this.name = e, this.on = An(this, "populate", "blocked", "versionchange", "close", { ready: [pe, S] }), this.once = function(y, N) {
          var g = function() {
            for (var w = [], E = 0; E < arguments.length; E++) w[E] = arguments[E];
            o.on(y).unsubscribe(g), N.apply(o, w);
          };
          return o.on(y, g);
        }, this.on.ready.subscribe = q(this.on.ready.subscribe, function(y) {
          return function(N, g) {
            qe.vip(function() {
              var w, E = o._state;
              E.openComplete ? (E.dbOpenError || Z.resolve().then(N), g && y(N)) : E.onReadyBeingFired ? (E.onReadyBeingFired.push(N), g && y(N)) : (y(N), w = o, g || y(function T() {
                w.on.ready.unsubscribe(N), w.on.ready.unsubscribe(T);
              }));
            });
          };
        }), this.Collection = (a = this, Rn(Ns.prototype, function(C, T) {
          this.db = a;
          var g = Vo, w = null;
          if (T) try {
            g = T();
          } catch (R) {
            w = R;
          }
          var E = C._ctx, T = E.table, C = T.hook.reading.fire;
          this._ctx = { table: T, index: E.index, isPrimKey: !E.index || T.schema.primKey.keyPath && E.index === T.schema.primKey.name, range: g, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: w, or: E.or, valueMapper: C !== M ? C : null };
        })), this.Table = (l = this, Rn(Yo.prototype, function(y, N, g) {
          this.db = l, this._tx = g, this.name = y, this.schema = N, this.hook = l._allTables[y] ? l._allTables[y].hook : An(null, { creating: [le, S], reading: [ne, M], updating: [ve, S], deleting: [se, S] });
        })), this.Transaction = (p = this, Rn(As.prototype, function(y, N, g, w, E) {
          var T = this;
          y !== "readonly" && N.forEach(function(C) {
            C = (C = g[C]) === null || C === void 0 ? void 0 : C.yProps, C && (N = N.concat(C.map(function(R) {
              return R.updatesTable;
            })));
          }), this.db = p, this.mode = y, this.storeNames = N, this.schema = g, this.chromeTransactionDurability = w, this.idbtrans = null, this.on = An(this, "complete", "error", "abort"), this.parent = E || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new Z(function(C, R) {
            T._resolve = C, T._reject = R;
          }), this._completion.then(function() {
            T.active = !1, T.on.complete.fire();
          }, function(C) {
            var R = T.active;
            return T.active = !1, T.on.error.fire(C), T.parent ? T.parent._reject(C) : R && T.idbtrans && T.idbtrans.abort(), $e(C);
          });
        })), this.Version = (m = this, Rn(Ls.prototype, function(y) {
          this.db = m, this._cfg = { version: y, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
        })), this.WhereClause = (v = this, Rn(ei.prototype, function(y, N, g) {
          if (this.db = v, this._ctx = { table: y, index: N === ":id" ? null : N, or: g }, this._cmp = this._ascending = xe, this._descending = function(w, E) {
            return xe(E, w);
          }, this._max = function(w, E) {
            return 0 < xe(w, E) ? w : E;
          }, this._min = function(w, E) {
            return xe(w, E) < 0 ? w : E;
          }, this._IDBKeyRange = v._deps.IDBKeyRange, !this._IDBKeyRange) throw new K.MissingAPI();
        })), this.on("versionchange", function(y) {
          0 < y.newVersion ? console.warn("Another connection wants to upgrade database '".concat(o.name, "'. Closing db now to resume the upgrade.")) : console.warn("Another connection wants to delete database '".concat(o.name, "'. Closing db now to resume the delete request.")), o.close({ disableAutoOpen: !1 });
        }), this.on("blocked", function(y) {
          !y.newVersion || y.newVersion < y.oldVersion ? console.warn("Dexie.delete('".concat(o.name, "') was blocked")) : console.warn("Upgrade '".concat(o.name, "' blocked by other connection holding version ").concat(y.oldVersion / 10));
        }), this._maxKey = kn(n.IDBKeyRange), this._createTransaction = function(y, N, g, w) {
          return new o.Transaction(y, N, g, o._options.chromeTransactionDurability, w);
        }, this._fireOnBlocked = function(y) {
          o.on("blocked").fire(y), vn.filter(function(N) {
            return N.name === o.name && N !== o && !N._state.vcFired;
          }).map(function(N) {
            return N.on("versionchange").fire(y);
          });
        }, this.use(Bs), this.use(Vs), this.use($s), this.use(Ks), this.use(Ms);
        var O = new Proxy(this, { get: function(y, N, g) {
          if (N === "_vip") return !0;
          if (N === "table") return function(E) {
            return mr(o.table(E), O);
          };
          var w = Reflect.get(y, N, g);
          return w instanceof Yo ? mr(w, O) : N === "tables" ? w.map(function(E) {
            return mr(E, O);
          }) : N === "_createTransaction" ? function() {
            return mr(w.apply(this, arguments), O);
          } : w;
        } });
        this.vip = O, i.forEach(function(y) {
          return y(o);
        });
      }
      var yr, wt = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable", Ws = (fo.prototype.subscribe = function(e, n, o) {
        return this._subscribe(e && typeof e != "function" ? e : { next: e, error: n, complete: o });
      }, fo.prototype[wt] = function() {
        return this;
      }, fo);
      function fo(e) {
        this._subscribe = e;
      }
      try {
        yr = { indexedDB: d.indexedDB || d.mozIndexedDB || d.webkitIndexedDB || d.msIndexedDB, IDBKeyRange: d.IDBKeyRange || d.webkitIDBKeyRange };
      } catch {
        yr = { indexedDB: null, IDBKeyRange: null };
      }
      function mi(e) {
        var n, o = !1, i = new Ws(function(a) {
          var l = xt(e), p, m = !1, v = {}, b = {}, O = { get closed() {
            return m;
          }, unsubscribe: function() {
            m || (m = !0, p && p.abort(), y && Ut.storagemutated.unsubscribe(g));
          } };
          a.start && a.start(O);
          var y = !1, N = function() {
            return $r(w);
          }, g = function(E) {
            dr(v, E), ro(b, v) && N();
          }, w = function() {
            var E, T, C;
            !m && yr.indexedDB && (v = {}, E = {}, p && p.abort(), p = new AbortController(), C = function(R) {
              var P = hn();
              try {
                l && yn();
                var I = Mt(e, R);
                return I = l ? I.finally(Bt) : I;
              } finally {
                P && mn();
              }
            }(T = { subscr: E, signal: p.signal, requery: N, querier: e, trans: null }), Promise.resolve(C).then(function(R) {
              o = !0, n = R, m || T.signal.aborted || (v = {}, function(P) {
                for (var I in P) if (j(P, I)) return;
                return 1;
              }(b = E) || y || (Ut(In, g), y = !0), $r(function() {
                return !m && a.next && a.next(R);
              }));
            }, function(R) {
              o = !1, ["DatabaseClosedError", "AbortError"].includes(R?.name) || m || $r(function() {
                m || a.error && a.error(R);
              });
            }));
          };
          return setTimeout(N, 0), O;
        });
        return i.hasValue = function() {
          return o;
        }, i.getValue = function() {
          return n;
        }, i;
      }
      var rn = Pt;
      function po(e) {
        var n = Vt;
        try {
          Vt = !0, Ut.storagemutated.fire(e), so(e, !0);
        } finally {
          Vt = n;
        }
      }
      B(rn, u(u({}, Ve), { delete: function(e) {
        return new rn(e, { addons: [] }).delete();
      }, exists: function(e) {
        return new rn(e, { addons: [] }).open().then(function(n) {
          return n.close(), !0;
        }).catch("NoSuchDatabaseError", function() {
          return !1;
        });
      }, getDatabaseNames: function(e) {
        try {
          return n = rn.dependencies, o = n.indexedDB, n = n.IDBKeyRange, (eo(o) ? Promise.resolve(o.databases()).then(function(i) {
            return i.map(function(a) {
              return a.name;
            }).filter(function(a) {
              return a !== er;
            });
          }) : Zr(o, n).toCollection().primaryKeys()).then(e);
        } catch {
          return $e(new K.MissingAPI());
        }
        var n, o;
      }, defineClass: function() {
        return function(e) {
          _(this, e);
        };
      }, ignoreTransaction: function(e) {
        return oe.trans ? Zt(oe.transless, e) : e();
      }, vip: to, async: function(e) {
        return function() {
          try {
            var n = ao(e.apply(this, arguments));
            return n && typeof n.then == "function" ? n : Z.resolve(n);
          } catch (o) {
            return $e(o);
          }
        };
      }, spawn: function(e, n, o) {
        try {
          var i = ao(e.apply(o, n || []));
          return i && typeof i.then == "function" ? i : Z.resolve(i);
        } catch (a) {
          return $e(a);
        }
      }, currentTransaction: { get: function() {
        return oe.trans || null;
      } }, waitFor: function(e, n) {
        return n = Z.resolve(typeof e == "function" ? rn.ignoreTransaction(e) : e).timeout(n || 6e4), oe.trans ? oe.trans.waitFor(n) : n;
      }, Promise: Z, debug: { get: function() {
        return ae;
      }, set: function(e) {
        Ce(e);
      } }, derive: Q, extend: _, props: B, override: q, Events: An, on: Ut, liveQuery: mi, extendObservabilitySet: dr, getByKeyPath: Pe, setByKeyPath: ue, delByKeyPath: function(e, n) {
        typeof n == "string" ? ue(e, n, void 0) : "length" in n && [].map.call(n, function(o) {
          ue(e, o, void 0);
        });
      }, shallowClone: de, deepClone: at, getObjectDiff: uo, cmp: xe, asap: _e, minKey: -1 / 0, addons: [], connections: vn, errnames: A, dependencies: yr, cache: nn, semVer: "4.2.0", version: "4.2.0".split(".").map(function(e) {
        return parseInt(e);
      }).reduce(function(e, n, o) {
        return e + n / Math.pow(10, 2 * o);
      }) })), rn.maxKey = kn(rn.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (Ut(In, function(e) {
        Vt || (e = new CustomEvent(Hr, { detail: e }), Vt = !0, dispatchEvent(e), Vt = !1);
      }), addEventListener(Hr, function(e) {
        e = e.detail, Vt || po(e);
      }));
      var En, Vt = !1, yi = function() {
      };
      return typeof BroadcastChannel < "u" && ((yi = function() {
        (En = new BroadcastChannel(Hr)).onmessage = function(e) {
          return e.data && po(e.data);
        };
      })(), typeof En.unref == "function" && En.unref(), Ut(In, function(e) {
        Vt || En.postMessage(e);
      })), typeof addEventListener < "u" && (addEventListener("pagehide", function(e) {
        if (!Pt.disableBfCache && e.persisted) {
          ae && console.debug("Dexie: handling persisted pagehide"), En?.close();
          for (var n = 0, o = vn; n < o.length; n++) o[n].close({ disableAutoOpen: !1 });
        }
      }), addEventListener("pageshow", function(e) {
        !Pt.disableBfCache && e.persisted && (ae && console.debug("Dexie: handling persisted pageshow"), yi(), po({ all: new ze(-1 / 0, [[]]) }));
      })), Z.rejectionMapper = function(e, n) {
        return !e || e instanceof Ft || e instanceof TypeError || e instanceof SyntaxError || !e.name || !H[e.name] ? e : (n = new H[e.name](n || e.message, e), "stack" in e && re(n, "stack", { get: function() {
          return this.inner.stack;
        } }), n);
      }, Ce(ae), u(Pt, Object.freeze({ __proto__: null, Dexie: Pt, liveQuery: mi, Entity: Wo, cmp: xe, PropModification: Dn, replacePrefix: function(e, n) {
        return new Dn({ replacePrefix: [e, n] });
      }, add: function(e) {
        return new Dn({ add: e });
      }, remove: function(e) {
        return new Dn({ remove: e });
      }, default: Pt, RangeSet: ze, mergeRanges: Fn, rangesOverlap: ii }), { default: Pt }), Pt;
    });
  }(_a)), _a.exports;
}
var ep = Zd();
const xa = /* @__PURE__ */ Hd(ep), $u = Symbol.for("Dexie"), Oa = globalThis[$u] || (globalThis[$u] = xa);
if (xa.semVer !== Oa.semVer)
  throw new Error(`Two different versions of Dexie loaded in the same app: ${xa.semVer} and ${Oa.semVer}`);
const {
  liveQuery: Ny,
  mergeRanges: Cy,
  rangesOverlap: Sy,
  RangeSet: Ay,
  cmp: Ry,
  Entity: Dy,
  PropModification: Py,
  replacePrefix: Iy,
  add: ky,
  remove: jy,
  DexieYProvider: Ly
} = Oa;
function oc(t) {
  return {
    addRecord: r,
    findChildRecords: d,
    findChildRecordsByTagName: f,
    ensureRelationship: u,
    removeRelationship: c,
    findParentRecordsWithinDepthAndGivenTagName: h,
    db: t
  };
  async function r(_) {
    const k = { ..._, id: crypto.randomUUID() };
    try {
      return await t.table(st).add(k), k;
    } catch (D) {
      const j = {
        msg: "could not add record",
        db: t.name,
        newRecord: k,
        err: D
      };
      throw console.error(j), new Error(JSON.stringify(j));
    }
  }
  async function s(_) {
    try {
      if (await t.table(st).update(_.id, _) < 1) {
        const D = { msg: "nothing has been updated", record: _ };
        throw console.error(D), new Error(JSON.stringify(D));
      }
    } catch (k) {
      console.error(k);
    }
  }
  async function u(_, k) {
    const D = _.children?.some((B) => B.id === k.id), j = k.parent?.id === _.id;
    if (D || await t.table(st).where({ id: _.id }).modify((B) => {
      B.children.push({ id: k.id, tagName: k.tagName });
    }), !j) {
      const B = {
        id: _.id,
        tagName: _.tagName
      };
      await t.table(st).update(k.id, { parent: B });
    }
  }
  async function c(_, k) {
    k.parent = null, await s(k), _.children && (_.children = _.children.filter((D) => D.id !== k.id), await s(_));
  }
  async function d(_, k) {
    if (!_.children?.length)
      return [];
    let D = (await t.table(st).bulkGet(_.children.map((j) => j.id))).filter(Boolean);
    return k?.tagNames && k.tagNames.length > 0 && (D = D.filter((j) => k?.tagNames?.includes(j.tagName))), k?.attrs && k.attrs.length > 0 && (D = D.filter(
      (j) => k.attrs.every(
        (B) => j.attributes.some(
          (ee) => ee.name === B.name && ee.value === B.value
        )
      )
    )), D;
  }
  async function f(_, k) {
    return (await d(_)).filter((j) => k.includes(j.tagName));
  }
  async function h(_, k, D = []) {
    const j = [];
    let B = _;
    for (let ee = 0; ee < k; ee++) {
      if (!B.parent)
        return j;
      const re = await t.table(st).get(B.parent.id);
      if (!re)
        break;
      (D.length == 0 || D.length > 0 && D.includes(re.tagName)) && j.push(re), B = re;
    }
    return j;
  }
}
function De(t, r) {
  return t?.attributes?.find((s) => s.name === r)?.value;
}
var vt = /* @__PURE__ */ ((t) => (t.GOOSE = "GOOSE", t.SMV = "SMV", t.REPORT = "Report", t.INTERNAL = "Internal", t.WIRED = "Wired", t.CONTROL = "Control", t))(vt || {});
const jo = {
  GOOSE: ["ST", "MX", "SP", "OR"],
  SMV: ["ST", "MX"],
  Report: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Wired: ["ST", "MX", "SP", "SV", "CF", "DC", "SG", "SE", "SR", "OR", "BL", "EX"],
  Control: [],
  Internal: []
}, Ht = {
  prefix: "eIEC61850-6-100",
  uri: "http://www.iec.ch/61850/2019/SCL/6-100"
};
function tp(t) {
  const r = oc(t), s = Qt();
  return {
    createControlledConnection: c,
    createConnection: u,
    createSourcePlaceholder: f,
    createDestinationPlaceholder: d,
    calculateNextInputInstance: h,
    calculateNextOutputInstance: _,
    findExistingInputs: k,
    findExistingOutputs: D
  };
  async function u(j, B, ee, re) {
    const Q = await Wi(r, ee), W = await np(
      r,
      B,
      Q,
      j
    );
    await rp(r, B, j), re && (await Uu(
      r,
      ee,
      W
    ), await Vu(
      r,
      B,
      ee,
      j.type,
      j.signal,
      j.attribute
    )), await s.refreshConnections(), await s.refreshLNode(B.id);
  }
  async function c(j, B, ee, re) {
    const Q = await ra(r, B), W = fp(
      j,
      ee
    ), G = await op(r, W);
    if (await r.ensureRelationship(Q, G), !ee.dataObjectSpecifications?.find(
      (q) => q.name === j.controlledSignal
    )) {
      const _e = Qt().lnodeTypes.find(
        (F) => F.lnClass === ee.lnClass
      )?.dataObjects.find(
        (F) => F.name === j.controlledSignal
      );
      let Pe = await ji(
        r,
        ee,
        Ht.prefix
      );
      const ue = {
        name: j.controlledSignal,
        desc: _e?.desc || ""
      }, de = await Ta(r, ue);
      await r.ensureRelationship(Pe, de);
    }
    re && (await ap(r, B, G), await Vu(
      r,
      B,
      ee,
      j.type,
      j.controlledSignal
    )), await s.refreshConnections(), await s.refreshLNode(ee.id);
  }
  async function d(j, B, ee) {
    const re = await Wi(r, B), Q = await zi(
      r,
      dp(j)
    );
    await r.ensureRelationship(re, Q), ee && await Uu(r, B, [
      Q
    ]), await s.refreshConnections();
  }
  async function f(j, B, ee) {
    let re = [{ name: "inputName", value: B.inputName }];
    B.preferredLNode && re.push({ name: "pLN", value: B.preferredLNode }), B.dataflowType && re.push({ name: "service", value: B.dataflowType }), B.processResource && re.push({ name: "resourceName", value: B.processResource });
    const Q = j.dataObjectSpecifications?.find(
      (de) => de.name === B.dataObject
    ), W = Q?.dataAttributeSpecifications.find(
      (de) => de.name === B.dataAttribute
    ), G = Qt(), q = G.lnodeTypes.find((de) => de.lnClass === j.lnClass)?.dataObjects.find((de) => de.name === B.dataObject), fe = q?.dataAttributes.find((de) => de.name === B.dataAttribute);
    let _e, Pe;
    if (Q)
      _e = await r.db.table(st).get(Q.id);
    else {
      const de = await ji(
        r,
        j,
        Ht.prefix
      ), F = {
        name: B.dataObject,
        desc: q?.desc || ""
      };
      _e = await Ta(r, F), await r.ensureRelationship(de, _e);
    }
    if (!_e) {
      const de = "DOS element could not be found or created for source placeholder";
      throw new Error(JSON.stringify(de));
    }
    if (W)
      Pe = await r.db.table(st).get(W.id);
    else {
      const de = {
        name: B.dataAttribute,
        desc: fe?.desc || ""
      };
      Pe = await ic(
        r,
        de
      ), await r.ensureRelationship(_e, Pe);
    }
    if (!Pe) {
      const de = "DAS element could not be found or created for source placeholder";
      throw new Error(JSON.stringify(de));
    }
    const ue = await r.addRecord({
      tagName: "SubscriberLNode",
      attributes: re,
      parent: null,
      namespace: { prefix: "eIEC61850-6-100", uri: "http://www.iec.ch/61850/2019/SCL/6-100" },
      value: "",
      children: []
    });
    await r.ensureRelationship(Pe, ue), ee && await up(
      r,
      j,
      B.dataObject,
      B.dataAttribute,
      B.dataflowType || void 0
    ), await G.refreshLNode(j.id);
  }
  async function h(j, B, ee) {
    const re = await Wi(r, ee), G = (await r.findChildRecordsByTagName(re, [
      "SourceRef"
    ])).map(($) => ({
      input: De($, "input"),
      pDA: De($, "pDA")
    })).filter(
      ($) => $.input === j && $.pDA === B
    );
    return G.length === 0 ? 1 : G.length + 1;
  }
  async function _(j, B) {
    const ee = await ra(r, B), W = (await r.findChildRecordsByTagName(ee, [
      "ControlRef"
    ])).map((G) => De(G, "output")).filter((G) => !!G).filter(
      (G) => G === j
    );
    return W.length === 0 ? 1 : W.length + 1;
  }
  async function k(j) {
    const B = await Wi(r, j), re = (await r.findChildRecordsByTagName(B, [
      "SourceRef"
    ])).map((W) => De(W, "input")).filter((W) => !!W);
    return Array.from(new Set(re));
  }
  async function D(j) {
    const B = await ra(r, j), re = (await r.findChildRecordsByTagName(B, [
      "ControlRef"
    ])).map((W) => De(W, "output")).filter((W) => !!W);
    return Array.from(new Set(re));
  }
}
async function Wi(t, r) {
  const s = await ji(
    t,
    r,
    Ht.prefix
  ), u = await t.findChildRecordsByTagName(s, [
    "LNodeInputs"
  ]);
  if (u.length == 1)
    return u[0];
  if (u.length == 0) {
    const d = await t.addRecord({
      tagName: "LNodeInputs",
      attributes: [],
      parent: null,
      namespace: Ht,
      value: "",
      children: []
    });
    return await t.ensureRelationship(s, d), d;
  }
  const c = {
    msg: `More than one LNodeInputs element found in LNode with uuid ${r.uuid}`
  };
  throw new Error(JSON.stringify(c));
}
async function ra(t, r) {
  const s = await ji(
    t,
    r,
    Ht.prefix
  ), u = await t.findChildRecordsByTagName(s, [
    "LNodeOutputs"
  ]);
  if (u.length == 1)
    return u[0];
  if (u.length == 0) {
    const d = await t.addRecord({
      tagName: "LNodeOutputs",
      attributes: [],
      parent: null,
      namespace: Ht,
      value: "",
      children: []
    });
    return await t.ensureRelationship(s, d), d;
  }
  const c = {
    msg: `More than one LNodeOutputs element found in LNode with uuid ${r.uuid}`
  };
  throw new Error(JSON.stringify(c));
}
async function np(t, r, s, u) {
  const c = [], d = await zi(
    t,
    ia(u, r)
  );
  if (c.push(d), await t.ensureRelationship(s, d), u.includeQuality) {
    const f = {
      ...u,
      attribute: "q"
      // Set to 'q' for Quality
    }, h = await zi(
      t,
      ia(f, r)
    );
    c.push(h), await t.ensureRelationship(s, h);
  }
  if (u.includeTimestamp) {
    const f = {
      ...u,
      attribute: "t"
      // Set to 't' for Timestamp
    }, h = await zi(
      t,
      ia(f, r)
    );
    c.push(h), await t.ensureRelationship(s, h);
  }
  return c;
}
async function ji(t, r, s) {
  const u = await t.db.table(st).where({ "parent.id": r.id, tagName: "Private" }).and((f) => De(f, "type") === s).first();
  if (u)
    return u;
  const c = await t.db.table(st).get(r.id);
  if (!c) {
    const f = {
      msg: `LNode element with uuid ${r.uuid} not found`
    };
    throw new Error(JSON.stringify(f));
  }
  const d = await t.addRecord({
    tagName: "Private",
    attributes: [{ name: "type", value: s }],
    parent: null,
    namespace: zd.default,
    value: "",
    children: []
  });
  return await t.ensureRelationship(c, d), d;
}
async function zi(t, r) {
  const s = {
    tagName: "SourceRef",
    namespace: Ht,
    attributes: [
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pDA",
        value: r.pDA
      },
      {
        name: "input",
        value: r.inputName
      },
      {
        name: "inputInst",
        value: r.inputInstance
      },
      {
        name: "service",
        value: r.dataflowType || ""
      },
      {
        name: "sourceLNodeUuid",
        value: r.sourceLNodeUuid
      },
      {
        name: "sourceDoName",
        value: r.sourceDoName
      },
      {
        name: "sourceDaName",
        value: r.sourceDaName
        // TODO: in the example SSD this was a combination fo SDS and DA name
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      },
      {
        name: "resourceName",
        value: r.resourceName
      },
      {
        name: "source",
        value: await xo(
          t.db,
          r.sourceLNodeUuid,
          r.sourceDoName,
          r.sourceDaName
        )
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(s);
}
async function rp(t, r, s) {
  const u = r.dataObjectSpecifications?.find(
    (D) => D.name === s.signal
  ), c = u?.dataAttributeSpecifications.find(
    (D) => D.name === s.attribute
  ), f = Qt().lnodeTypes.find((D) => D.lnClass === r.lnClass), h = f?.dataObjects.find((D) => D.name === s.signal), _ = h?.dataAttributes.find((D) => D.name === s.attribute);
  if (!f || !h || !_) {
    const D = `LNodeType, DO type or DA type not found for LNode class ${r.lnClass}, DO ${s.signal}, DA ${s.attribute}`;
    throw console.error(D), new Error(D);
  }
  let k;
  if (!u) {
    const D = await ji(
      t,
      r,
      Ht.prefix
    ), j = {
      name: s.signal,
      desc: h.desc
    };
    k = await Ta(t, j), await t.ensureRelationship(D, k);
  }
  if (!k && (k = await t.db.table(st).get(u.id), !k))
    throw new Error(`DOS element with id ${u.id} not found`);
  if (c || await oa(t, k, s.attribute, _.desc), s.includeQuality) {
    const D = h?.dataAttributes.find((B) => B.name === "q");
    if (!D)
      throw new Error(`DA type 'q' not allowed for DO ${s.signal}`);
    u?.dataAttributeSpecifications.find(
      (B) => B.name === D.name
    ) || await oa(t, k, D.name, D.desc);
  }
  if (s.includeTimestamp) {
    const D = h?.dataAttributes.find((B) => B.name === "t");
    if (!D)
      throw new Error(`DA type 't' not allowed for DO ${s.signal}`);
    u?.dataAttributeSpecifications.find(
      (B) => B.name === D.name
    ) || await oa(t, k, D.name, D.desc);
  }
}
async function oa(t, r, s, u) {
  const d = await ic(
    t,
    {
      name: s,
      desc: u
    }
  );
  await t.ensureRelationship(r, d);
}
async function op(t, r) {
  const s = {
    tagName: "ControlRef",
    namespace: Ht,
    attributes: [
      {
        name: "pDO",
        value: r.pDO
      },
      {
        name: "pLN",
        value: r.pLN
      },
      {
        name: "controlled",
        value: await xo(
          t.db,
          r.controlledLNodeUuid,
          r.controlledDoName
        )
      },
      {
        name: "output",
        value: r.output
      },
      {
        name: "outputInst",
        value: r.outputInst
      },
      {
        name: "controlledLNodeUuid",
        value: r.controlledLNodeUuid
      },
      {
        name: "controlledDoName",
        value: r.controlledDoName
      },
      {
        name: "uuid",
        value: crypto.randomUUID()
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(s);
}
async function xo(t, r, s, u) {
  if (!r) return "";
  const c = await t.table(st).where({ tagName: "LNode" }).and((D) => De(D, "uuid") === r).first();
  if (!c) return "";
  const d = [];
  let f = c;
  const h = ["LNode", "SubFunction", "Function", "Bay", "VoltageLevel", "Substation"];
  for (; f && f.parent; ) {
    if (h.includes(f.tagName)) {
      const D = De(f, "name");
      D && d.unshift(D);
    }
    f = await t.table(st).get(f.parent.id);
  }
  const _ = (() => {
    const D = c.attributes?.find((ee) => ee.name === "prefix")?.value || "", j = c.attributes?.find((ee) => ee.name === "lnClass")?.value || "", B = c.attributes?.find((ee) => ee.name === "lnInst")?.value || "";
    return `${D}${j}${B}`;
  })();
  d.push(_);
  let k = d.join("/");
  return s && (k += `.${s}`, u && (k += "." + u)), k;
}
async function ip(t, r, s) {
  const u = await xo(t, r), c = De(s, "input"), d = De(s, "inputInst"), f = De(s, "pDA");
  let h = `${u}.${c}`;
  return d && (h += `(${d})`), f && (h += `.${f}`), h;
}
async function sp(t, r, s) {
  const u = await xo(t, r), c = De(s, "output"), d = De(s, "outputInst");
  let f = `${u}.${c}`;
  return d && (f += `(${d})`), f;
}
async function Li(t, r) {
  const s = await t.db.table(st).get(r);
  if (!s || !s?.parent)
    return [];
  const u = await t.db.table(st).get(s.parent.id);
  return u?.tagName === "Function" || u?.tagName === "SubFunction" ? await t.db.table(st).where({ tagName: "FunctionRef" }).and(
    (f) => De(f, "functionUuid") === De(u, "uuid")
  ).toArray() : [];
}
async function Qa(t, r) {
  const s = [];
  for (const u of r)
    (await t.findParentRecordsWithinDepthAndGivenTagName(
      u,
      3,
      ["Application"]
    )).length === 1 && s.push(u);
  return s;
}
async function qu(t, r) {
  const s = /* @__PURE__ */ new Map();
  for (const u of r) {
    const c = await t.findParentRecordsWithinDepthAndGivenTagName(
      u,
      3,
      ["Application"]
    );
    c.length === 1 && s.set(u.id, c[0].id);
  }
  return s;
}
async function Uu(t, r, s) {
  const u = await Li(t, r.id);
  if (u.length === 0)
    return;
  const c = await Qa(
    t,
    u
  );
  for (const d of c) {
    let f = (await t.findChildRecords(d, {
      tagNames: ["SignalRole"],
      attrs: [{ name: "name", value: "Input" }]
    }))[0];
    f || (f = await t.addRecord({
      tagName: "SignalRole",
      attributes: [
        { name: "name", value: "Input" },
        { name: "uuid", value: crypto.randomUUID() }
      ],
      parent: null,
      namespace: Ht,
      value: "",
      children: []
    }), await t.ensureRelationship(d, f));
    for (const h of s) {
      const _ = await t.addRecord({
        tagName: "LNodeInputRef",
        attributes: [
          {
            name: "sourceRef",
            value: await ip(t.db, r.uuid, h)
          },
          { name: "sourceRefUuid", value: De(h, "uuid") || "" }
        ],
        parent: null,
        namespace: Ht,
        value: "",
        children: []
      });
      await t.ensureRelationship(f, _);
    }
  }
}
async function ap(t, r, s) {
  const u = await Li(t, r.id);
  if (u.length === 0)
    return;
  const c = await Qa(
    t,
    u
  );
  for (const d of c) {
    let f = (await t.findChildRecords(d, {
      tagNames: ["SignalRole"],
      attrs: [{ name: "name", value: "Output" }]
    }))[0];
    f || (f = await t.addRecord({
      tagName: "SignalRole",
      attributes: [
        { name: "name", value: "Output" },
        { name: "uuid", value: crypto.randomUUID() }
      ],
      parent: null,
      namespace: Ht,
      value: "",
      children: []
    }), await t.ensureRelationship(d, f));
    const h = await t.addRecord({
      tagName: "LNodeOutputRef",
      attributes: [
        {
          name: "controlRef",
          value: await sp(
            t.db,
            r.uuid,
            s
          )
        },
        { name: "controlRefUuid", value: De(s, "uuid") || "" }
      ],
      parent: null,
      namespace: Ht,
      value: "",
      children: []
    });
    await t.ensureRelationship(f, h);
  }
}
async function up(t, r, s, u, c) {
  const d = await Li(t, r.id);
  if (d.length === 0)
    return;
  const f = await Qa(
    t,
    d
  ), h = await xo(t.db, r.uuid, s, u);
  for (const _ of f)
    await Pr(
      t,
      _,
      "Process",
      h,
      r.uuid,
      s,
      u
    ), c === vt.REPORT && await Pr(
      t,
      _,
      "Signalisation",
      h,
      r.uuid,
      s,
      u
    );
}
async function Vu(t, r, s, u, c, d) {
  const f = await Li(
    t,
    r.id
  ), h = await qu(
    t,
    f
  ), _ = await Li(
    t,
    s.id
  ), k = await qu(
    t,
    _
  );
  let D = "", j, B;
  if (u === vt.CONTROL ? (D = await xo(t.db, s.uuid, c), j = s, B = _.filter(
    (q) => Array.from(k.keys()).includes(q.id)
  )) : (D = await xo(t.db, r.uuid, c, d), j = r, B = f.filter(
    (q) => Array.from(h.keys()).includes(q.id)
  )), B.length === 0)
    return;
  for (const q of B)
    u === vt.REPORT && await Pr(
      t,
      q,
      "Signalisation",
      D,
      j.uuid,
      c,
      d
    ), u === vt.CONTROL && await Pr(
      t,
      q,
      "Control",
      D,
      j.uuid,
      c
    );
  const Q = Qt().lnodeTypes.find((q) => q.lnClass === j.lnClass)?.dataObjects.find((q) => q.name === c);
  if (Q) {
    const q = await t.db.table(st).where({ tagName: "DOType" }).and((_e) => De(_e, "id") === Q.type).first(), fe = De(q, "cdc");
    if (fe === "DPL" || fe === "LPL" || fe === "VSD")
      for (const _e of B)
        await Pr(
          t,
          _e,
          "Information",
          D,
          j.uuid,
          c,
          d
        );
    else {
      const _e = j.dataObjectSpecifications?.find((ue) => ue.name === c)?.dataAttributeSpecifications.find((ue) => ue.name === d);
      if (await t.db.table(st).where({ tagName: "Val", "parent.id": _e?.id }).first())
        for (const ue of B)
          await Pr(
            t,
            ue,
            "Setting",
            D,
            j.uuid,
            c,
            d
          );
    }
  }
  let W = /* @__PURE__ */ new Set(), G = /* @__PURE__ */ new Set();
  function $(q, fe) {
    const _e = q.find((Pe) => Pe.id === fe);
    if (!_e)
      throw new Error(`FunctionRef with id ${fe} not found`);
    return _e;
  }
  if (h.size === 0)
    G = new Set(
      _.filter(
        (q) => Array.from(k.keys()).includes(q.id)
      )
    );
  else if (k.size === 0)
    G = new Set(
      f.filter(
        (q) => Array.from(h.keys()).includes(q.id)
      )
    );
  else
    for (const [
      q,
      fe
    ] of h)
      for (const [
        _e,
        Pe
      ] of k) {
        const ue = $(
          f,
          q
        ), de = $(
          _,
          _e
        );
        fe === Pe ? (W.add(ue), W.add(de)) : (G.add(ue), G.add(de));
      }
  for (const q of B)
    G.has(q) && await Pr(
      t,
      q,
      "Process",
      D,
      j.uuid,
      c,
      d
    ), W.has(q) && await Pr(
      t,
      q,
      "Internal",
      D,
      j.uuid,
      c,
      d
    );
}
async function Pr(t, r, s, u, c, d, f) {
  const h = await lp(
    t,
    r,
    s
  );
  await cp(
    t,
    h,
    u,
    c,
    d,
    f
  );
}
async function lp(t, r, s) {
  let u = (await t.findChildRecords(r, {
    tagNames: ["SignalRole"],
    attrs: [{ name: "name", value: s }]
  }))[0];
  return u || (u = await t.addRecord({
    tagName: "SignalRole",
    attributes: [
      { name: "name", value: s },
      { name: "uuid", value: crypto.randomUUID() }
    ],
    parent: null,
    namespace: Ht,
    value: "",
    children: []
  }), await t.ensureRelationship(r, u), u);
}
async function cp(t, r, s, u, c, d) {
  const f = [
    { name: "data", value: s },
    { name: "lnodeUuid", value: u },
    { name: "doName", value: c }
  ];
  if (d && f.push({ name: "daName", value: d }), !(await t.findChildRecords(r, {
    tagNames: ["LNodeDataRef"],
    attrs: f
  }))[0]) {
    const _ = await t.addRecord({
      tagName: "LNodeDataRef",
      attributes: f,
      parent: null,
      namespace: Ht,
      value: "",
      children: []
    });
    await t.ensureRelationship(r, _);
  }
}
function ia(t, r) {
  return {
    dataflowType: t.type,
    inputName: t.inputName,
    inputInstance: t.inputInstance,
    sourceLNodeUuid: r.uuid,
    resourceName: "",
    // TODO: https://github.com/SeptKit/set/issues/163
    sourceDoName: t.signal,
    sourceDaName: t.attribute,
    pLN: r.lnClass,
    // SETRULE: set lnClass of source LNode also as preferred LN
    pDO: t.signal,
    // SETRULE: set signal/data object also as preferred DO
    pDA: t.attribute
    // SETRULE: set data attribute also as preferred DA
  };
}
function fp(t, r) {
  return {
    pDO: "",
    // TODO
    pLN: "",
    // TODO
    output: t.outputName,
    outputInst: t.outputInstance,
    controlledLNodeUuid: r.uuid,
    controlledDoName: t.controlledSignal
  };
}
function dp(t) {
  return {
    dataflowType: t.dataflowType,
    inputName: t.inputName,
    inputInstance: t.inputInstance,
    sourceLNodeUuid: "",
    resourceName: t.processResource,
    sourceDoName: "",
    sourceDaName: "",
    pLN: t.preferredLNode,
    pDO: t.preferredDataObject,
    pDA: t.preferredDataAttribute
  };
}
async function Ta(t, r) {
  const s = {
    tagName: "DOS",
    namespace: Ht,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(s);
}
async function ic(t, r) {
  const s = {
    tagName: "DAS",
    namespace: Ht,
    attributes: [
      {
        name: "name",
        value: r.name
      },
      {
        name: "desc",
        value: r.desc
      }
    ],
    parent: null,
    value: "",
    children: []
  };
  return await t.addRecord(s);
}
function pp(t) {
  return {
    findAllEnrichedLNodes: r,
    findAllLNodeTypes: s,
    enrichWithDataObjectSpecifications: d
  };
  async function r() {
    const h = await f();
    return h.length ? await d(h) : [];
  }
  async function s() {
    const h = await t.table(st).where({ tagName: "LNodeType" }).toArray(), _ = [];
    for (const k of h)
      _.push({
        id: k.id,
        typeId: De(k, "id") ?? "",
        lnClass: De(k, "lnClass") ?? "",
        dataObjects: await u(k)
      });
    return _;
  }
  async function u(h) {
    if (!h.children) return [];
    const _ = [];
    for (const k of h.children) {
      if (k.tagName !== "DO") continue;
      const D = await t.table(st).get(k.id);
      D && _.push({
        id: D.id,
        name: De(D, "name") ?? "",
        type: De(D, "type") ?? "",
        desc: De(D, "desc") ?? "",
        dataAttributes: await c(D)
      });
    }
    return _;
  }
  async function c(h) {
    const _ = De(h, "type");
    if (!_) return [];
    const k = (await t.table(st).where({ tagName: "DOType" }).toArray()).find((j) => j.attributes?.find((B) => B.name === "id" && B.value === _));
    if (!k || !k.children) return [];
    const D = [];
    for (const j of k.children) {
      if (j.tagName !== "DA") continue;
      const B = await t.table(st).get(j.id);
      B && D.push({
        id: B.id,
        name: De(B, "name") ?? "",
        type: De(B, "type") ?? "",
        desc: De(B, "desc") ?? "",
        bType: De(B, "bType") ?? "",
        fc: De(B, "fc") ?? ""
      });
    }
    return D;
  }
  async function d(h) {
    const _ = await t.table(st).where({ tagName: "Private" }).toArray(), k = await t.table(st).where({ tagName: "DOS" }).toArray(), D = await t.table(st).where({ tagName: "DAS" }).toArray(), j = await t.table(st).where({ tagName: "SubscriberLNode" }).toArray();
    return Promise.all(
      h.map(async (B) => {
        const ee = _.find(
          (Q) => Q.parent?.id === B.id && Q.parent?.tagName === "LNode" && De(Q, "type") === "eIEC61850-6-100"
        );
        if (!ee || !ee.children)
          return { ...B, dataObjectSpecifications: [] };
        const re = [];
        for (const Q of ee.children) {
          if (Q.tagName !== "DOS") continue;
          const W = k.find(($) => $.id === Q.id);
          if (!W) continue;
          const G = [];
          if (W.children)
            for (const $ of W.children) {
              if ($.tagName !== "DAS") continue;
              const q = D.find((_e) => _e.id === $.id);
              if (!q) continue;
              let fe = [];
              if (q.children) {
                const _e = q.children.filter((ue) => ue.tagName === "SubscriberLNode"), Pe = j.filter(
                  (ue) => _e.some((de) => de.id === ue.id)
                );
                for (const ue of Pe)
                  fe.push({
                    id: ue.id,
                    inputName: De(ue, "inputName") ?? "",
                    service: sc(ue, "service"),
                    pLN: De(ue, "pLN") ?? "",
                    resourceName: De(ue, "resourceName") ?? ""
                  });
              }
              G.push({
                id: q.id,
                name: De(q, "name") ?? "",
                desc: De(q, "desc") ?? "",
                subscriberLNodes: fe
              });
            }
          re.push({
            id: W.id,
            name: De(W, "name") ?? "",
            desc: De(W, "desc") ?? "",
            dataAttributeSpecifications: G
          });
        }
        return { ...B, dataObjectSpecifications: re };
      })
    );
  }
  async function f() {
    return (await t.table(st).where({ tagName: "LNode" }).toArray()).map((_) => ({
      id: _.id,
      uuid: De(_, "uuid") ?? "",
      iedName: De(_, "iedName") ?? "",
      prefix: De(_, "prefix") ?? "",
      lnClass: De(_, "lnClass") ?? "",
      lnInst: De(_, "lnInst") ?? "",
      lnType: De(_, "lnType") ?? "",
      dataObjects: []
    }));
  }
}
function sc(t, r) {
  const s = t?.attributes?.find((c) => c.name === r)?.value;
  if (!s) return;
  switch (s.toUpperCase()) {
    case "GOOSE":
      return vt.GOOSE;
    case "SMV":
      return vt.SMV;
    case "REPORT":
      return vt.REPORT;
    case "WIRED":
      return vt.WIRED;
    case "CONTROL":
      return vt.CONTROL;
    case "INTERNAL":
      return vt.INTERNAL;
    default:
      return;
  }
}
function hp(t) {
  const r = oc(t);
  return {
    findAllExistingConnections: s,
    findAllExistingControlledConnections: u
  };
  async function s() {
    const c = await t.table(st).where({ tagName: "SourceRef" }).toArray();
    if (!c.length) return [];
    const d = [];
    for (const f of c) {
      if (!f.attributes) continue;
      const h = De(f, "sourceLNodeUuid"), _ = await t.table(st).where({ tagName: "LNode" }).toArray().then(
        (j) => j.find(
          (B) => B.attributes?.some(
            (ee) => ee.name === "uuid" && ee.value === h
          )
        )?.id
      ) || null, k = await r.findParentRecordsWithinDepthAndGivenTagName(
        f,
        3,
        ["LNode"]
      );
      if (k.length != 1) {
        const j = {
          msg: "LNode record not found for SourceRef id",
          id: f.id
        };
        throw console.error(j), new Error(JSON.stringify(j));
      }
      const D = {
        id: f.id,
        sourceLNodeId: _,
        destinationLNodeId: k[0].id,
        sourceDataObject: De(f, "sourceDoName") || "",
        sourceDataAttribute: De(f, "sourceDaName") || "",
        dataflowType: sc(f, "service"),
        inputInstance: De(f, "inputInst") || "",
        input: De(f, "input") || "",
        preferredLNode: De(f, "pLN") || "",
        preferredDataObject: De(f, "pDO") || "",
        preferredDataAttribute: De(f, "pDA") || "",
        processResource: De(f, "resourceName") || ""
      };
      d.push(D);
    }
    return d;
  }
  async function u() {
    const c = await t.table(st).where({ tagName: "ControlRef" }).toArray();
    if (!c.length) return [];
    const d = [];
    for (const f of c) {
      if (!f.attributes) continue;
      const h = De(f, "controlledLNodeUuid"), _ = De(f, "controlledDoName"), k = await t.table(st).where({ tagName: "LNode" }).toArray().then(
        (B) => B.find(
          (ee) => ee.attributes?.some(
            (re) => re.name === "uuid" && re.value === h
          )
        )?.id
      ) || null, D = await r.findParentRecordsWithinDepthAndGivenTagName(
        f,
        3,
        // ControlRef ->  LNodeOutputs -> Private -> LNode
        ["LNode"]
      );
      if (D.length != 1) {
        const B = {
          msg: "LNode record not found for ControlRef id",
          id: f.id
        };
        throw console.error(B), new Error(JSON.stringify(B));
      }
      const j = {
        controllerLNodeId: D[0].id,
        controlledLNodeId: k,
        controlledDataObject: _ || "",
        dataflowType: vt.CONTROL,
        outputInstance: De(f, "outputInst") || "",
        outputName: De(f, "output") || "",
        id: f.id
      };
      d.push(j);
    }
    return d;
  }
}
const Qt = /* @__PURE__ */ Ya("dataflow/app", () => {
  let t = null;
  const r = nt(""), s = nt([]), u = nt([]), c = nt([]), d = nt([]), f = bo(), h = bo(), _ = bo();
  async function k(ee) {
    D(), t = new ss(ee), await t.open(), _.value = pp(t), h.value = hp(t), r.value = ee, f.value = tp(t), s.value = await _.value.findAllEnrichedLNodes(), u.value = await _.value.findAllLNodeTypes(), c.value = await h.value.findAllExistingConnections(), d.value = await h.value.findAllExistingControlledConnections();
  }
  function D() {
    t && (t.close(), t = null);
  }
  async function j() {
    c.value = await h.value.findAllExistingConnections(), d.value = await h.value.findAllExistingControlledConnections();
  }
  async function B(ee) {
    const Q = (await _.value.findAllEnrichedLNodes()).find((W) => W.id === ee);
    if (Q) {
      const W = s.value.findIndex((G) => G.id === ee);
      W !== -1 && (s.value[W] = Q);
    }
  }
  return {
    // states
    activeFilename: r,
    lnodes: s,
    lnodeTypes: u,
    connections: c,
    controlledConnections: d,
    // getters
    dataflowSdk: f,
    // actions
    initApp: k,
    closeDatabase: D,
    refreshConnections: j,
    refreshLNode: B
  };
}), mp = { key: 0 }, yp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, vp = { key: 1 }, gp = { key: 2 }, bp = /* @__PURE__ */ kt({
  __name: "connection-details",
  props: {
    connection: {}
  },
  setup(t) {
    const r = t, s = Qt(), { lnodes: u } = cn(s), c = tt(() => u.value.find((h) => h.id === r.connection.sourceLNodeId)?.dataObjectSpecifications?.find(
      (h) => h.name === r.connection.sourceDataObject
    )), d = tt(() => c?.value?.dataAttributeSpecifications?.find(
      (f) => f.name === r.connection.sourceDataAttribute
    ));
    return (f, h) => (ce(), ye("div", null, [
      (ce(), ye("div", mp, [
        h[0] || (h[0] = L("h2", { class: "text-lg font-bold mb-2" }, "Connection Details", -1)),
        f.connection.dataflowType ? (ce(), ye("span", yp, Te(f.connection.dataflowType), 1)) : lt("", !0),
        L("p", null, "Input: " + Te(f.connection.input), 1),
        L("p", null, "Input Instance: " + Te(f.connection.inputInstance || "-"), 1),
        h[1] || (h[1] = L("br", null, null, -1)),
        L("p", null, "Data Object: " + Te(f.connection.sourceDataObject || "-"), 1),
        c.value?.desc ? (ce(), ye("p", vp, "Data Object Desc: " + Te(c.value?.desc), 1)) : lt("", !0),
        L("p", null, "Data Attribute: " + Te(f.connection.sourceDataAttribute || "-"), 1),
        d.value?.desc ? (ce(), ye("p", gp, "Data Attribute Desc: " + Te(d.value?.desc), 1)) : lt("", !0),
        h[2] || (h[2] = L("br", null, null, -1)),
        L("p", null, "Preferred LNode: " + Te(f.connection.preferredLNode || "-"), 1),
        L("p", null, "Preferred Data Object: " + Te(f.connection.preferredDataObject || "-"), 1),
        L("p", null, "Preferred Data Attribute: " + Te(f.connection.preferredDataAttribute || "-"), 1),
        L("p", null, "Process Resource: " + Te(f.connection.processResource || "-"), 1)
      ]))
    ]));
  }
}), wp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, _p = ["onClick"], xp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Op = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Tp = ["onClick"], Ep = ["onClick", "data-testid"], Np = ["onClick"], Cp = ["onClick"], Sp = ["onClick"], Ap = ["onClick"], Rp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Dp = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, Pp = /* @__PURE__ */ kt({
  __name: "dataflow-connections",
  props: {
    connections: {}
  },
  setup(t) {
    const r = t, s = ws(), { activeElement: u } = cn(s), c = tt(() => [...r.connections].sort((d, f) => d.dataflowType < f.dataflowType ? -1 : d.dataflowType > f.dataflowType ? 1 : 0));
    return (d, f) => (ce(!0), ye(Qe, null, At(c.value, (h, _) => (ce(), ye("div", wp, [
      L("div", {
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer",
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id)
      }, [
        L("span", xp, Te(h.sourceDataObject), 1),
        L("span", Op, Te(h.sourceDataAttribute), 1)
      ], 8, _p),
      L("div", {
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id),
        class: pn(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(u) === h.id,
          "bg-(--color-ocean-gray-100)": Ae(u) !== h.id
        }])
      }, null, 10, Tp),
      L("div", {
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id),
        class: pn(["col-start-3 col-span-1 h-[2px] self-center row-start-1 hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(u) === h.id,
          "bg-(--color-ocean-gray-100)": Ae(u) !== h.id
        }]),
        "data-testid": `dataflow-line-${_}`
      }, null, 10, Ep),
      (ce(), ye("svg", {
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id),
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        L("polygon", {
          points: "0,0 8,6 0,12",
          style: Fo({
            fill: Ae(u) === h.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ], 8, Np)),
      L("div", {
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id),
        class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
      }, Te(h.dataflowType), 9, Cp),
      L("div", {
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id),
        class: pn(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(u) === h.id,
          "bg-(--color-ocean-gray-100)": Ae(u) !== h.id
        }])
      }, null, 10, Sp),
      L("div", {
        onClick: (k) => Ae(s).setOrResetActiveElement(h.id),
        class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
      }, [
        L("span", Rp, Te(h.input), 1),
        L("span", Dp, Te(h.inputInstance), 1)
      ], 8, Ap),
      Ae(u) == h.id ? (ce(), On(hs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        _t(bp, { connection: h }, null, 8, ["connection"])
      ])) : lt("", !0)
    ]))), 256));
  }
}), Ip = { key: 0 }, kp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, jp = { key: 1 }, Lp = { key: 2 }, Fp = /* @__PURE__ */ kt({
  __name: "destination-placeholder-details",
  props: {
    placeholder: {}
  },
  setup(t) {
    const r = t, s = Qt(), { lnodeTypes: u } = cn(s), c = tt(() => u.value.find((h) => h.lnClass === r.placeholder.preferredLNode)?.dataObjects.find(
      (h) => h.name === r.placeholder.preferredDataObject
    )), d = tt(() => c?.value?.dataAttributes?.find(
      (f) => f.name === r.placeholder.preferredDataAttribute
    ));
    return (f, h) => (ce(), ye("div", null, [
      (ce(), ye("div", Ip, [
        h[0] || (h[0] = L("h2", { class: "text-lg font-bold mb-2" }, "Destination Placeholder Details", -1)),
        f.placeholder.dataflowType ? (ce(), ye("span", kp, Te(f.placeholder.dataflowType), 1)) : lt("", !0),
        L("p", null, "Input: " + Te(f.placeholder.input), 1),
        L("p", null, "Input Instance: " + Te(f.placeholder.inputInstance || "-"), 1),
        h[1] || (h[1] = L("br", null, null, -1)),
        L("p", null, "Preferred LNode: " + Te(f.placeholder.preferredLNode || "-"), 1),
        L("p", null, "Preferred DO: " + Te(f.placeholder.preferredDataObject || "-"), 1),
        c.value?.desc ? (ce(), ye("p", jp, "Preferred DO Desc: " + Te(c.value?.desc), 1)) : lt("", !0),
        L("p", null, "Preferred DA: " + Te(f.placeholder.preferredDataAttribute || "-"), 1),
        d.value?.desc ? (ce(), ye("p", Lp, "Preferred DA Desc: " + Te(d.value?.desc), 1)) : lt("", !0),
        L("p", null, "Process Resource: " + Te(f.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Kp = ["y1", "x2", "y2"], Mp = ["points"], Bp = /* @__PURE__ */ kt({
  __name: "arrow",
  props: {
    height: {},
    length: {}
  },
  setup(t) {
    return (r, s) => (ce(), ye(Qe, null, [
      L("line", {
        x1: 0,
        y1: r.height / 2,
        x2: r.length - r.height / 2,
        y2: r.height / 2,
        stroke: "currentColor",
        "stroke-width": "2"
      }, null, 8, Kp),
      L("polygon", {
        points: `${r.length - r.height * 0.7}, 0 ${r.length}, ${r.height / 2} ${r.length - r.height * 0.7}, ${r.height}`,
        fill: "currentColor"
      }, null, 8, Mp)
    ], 64));
  }
}), $p = ["onClick"], qp = ["data-testid"], Up = ["onClick"], Vp = { class: "col-start-5 col-span-1 self-center justify-self-start" }, Wp = ["onClick"], Hp = ["onClick"], Gp = /* @__PURE__ */ kt({
  __name: "destination-placeholder-ports",
  props: {
    destinationPlaceHolderPorts: {}
  },
  setup(t) {
    const r = ws(), { activeElement: s } = cn(r);
    return (u, c) => (ce(!0), ye(Qe, null, At(u.destinationPlaceHolderPorts, (d, f) => (ce(), ye("div", {
      class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]",
      key: `destination-placeholder-port-${f}`
    }, [
      (ce(), ye("svg", {
        height: "12",
        width: "35",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 text-(--color-ocean-gray-100) hover:cursor-pointer",
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id)
      }, [
        L("g", {
          "data-testid": `placeholder-line-${f}`,
          class: pn({
            "text-(--color-primary)": Ae(s) === d.id
          })
        }, [
          _t(Bp, {
            height: 12,
            length: 35
          })
        ], 10, qp)
      ], 8, $p)),
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: pn(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(s) === d.id
        }])
      }, null, 10, Up),
      L("div", Vp, [
        L("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm hover:cursor-pointer",
          onClick: (h) => Ae(r).setOrResetActiveElement(d.id)
        }, Te(d.input), 9, Wp),
        L("span", {
          class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm hover:cursor-pointer",
          onClick: (h) => Ae(r).setOrResetActiveElement(d.id)
        }, Te(d.inputInstance), 9, Hp)
      ]),
      Ae(s) == d.id ? (ce(), On(hs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        _t(Fp, { placeholder: d }, null, 8, ["placeholder"])
      ])) : lt("", !0)
    ]))), 128));
  }
}), Yp = { key: 0 }, Qp = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, Xp = { key: 1 }, zp = { key: 2 }, Jp = /* @__PURE__ */ kt({
  __name: "source-placeholder-details",
  props: {
    placeholder: {},
    sourceLNodeId: {}
  },
  setup(t) {
    const r = t, s = Qt(), { lnodes: u } = cn(s), c = tt(() => u.value.find((h) => h.id === r.sourceLNodeId)?.dataObjectSpecifications?.find(
      (h) => h.name === r.placeholder.dataObject
    )), d = tt(() => c?.value?.dataAttributeSpecifications?.find(
      (f) => f.name === r.placeholder.dataAttribute
    ));
    return (f, h) => (ce(), ye("div", null, [
      (ce(), ye("div", Yp, [
        h[0] || (h[0] = L("h2", { class: "text-lg font-bold mb-2" }, "Source Placeholder Details", -1)),
        f.placeholder.dataflowType ? (ce(), ye("span", Qp, Te(f.placeholder.dataflowType), 1)) : lt("", !0),
        L("p", null, "Input: " + Te(f.placeholder.input), 1),
        h[1] || (h[1] = L("br", null, null, -1)),
        L("p", null, "Data Object: " + Te(f.placeholder.dataObject || "-"), 1),
        c.value?.desc ? (ce(), ye("p", Xp, "Data Object Desc: " + Te(c.value?.desc), 1)) : lt("", !0),
        L("p", null, "Data Attribute: " + Te(f.placeholder.dataAttribute || "-"), 1),
        d.value?.desc ? (ce(), ye("p", zp, "Data Attribute Desc: " + Te(d.value?.desc), 1)) : lt("", !0),
        h[2] || (h[2] = L("br", null, null, -1)),
        L("p", null, "Preferred LNode: " + Te(f.placeholder.preferredLNode || "-"), 1),
        L("p", null, "Process Resource: " + Te(f.placeholder.processResource || "-"), 1)
      ]))
    ]));
  }
}), Zp = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-12 *:pointer-events-auto" }, eh = ["onClick"], th = { class: "border-2 border-dashed border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, nh = ["onClick"], rh = { class: "col-start-3 col-span-1 row-start-1 !pointer-events-none *:pointer-events-auto" }, oh = ["onClick"], ih = {
  height: "12",
  width: "24"
}, sh = { class: "ml-2" }, ah = /* @__PURE__ */ kt({
  __name: "source-placeholder-ports",
  props: {
    sourceLNodeId: {},
    dataObjectSpecifications: {}
  },
  setup(t) {
    const r = t, s = tt(
      () => r.dataObjectSpecifications.flatMap(
        (d) => d.dataAttributeSpecifications.flatMap(
          (f) => f.subscriberLNodes?.map(
            (h) => ({
              id: h.id,
              dataObject: d.name,
              dataAttribute: f.name,
              dataflowType: h.service,
              preferredLNode: h.pLN,
              input: h.inputName,
              processResource: h.resourceName
            })
          ) ?? []
        )
      )
    ), u = ws(), { activeElement: c } = cn(u);
    return (d, f) => (ce(!0), ye(Qe, null, At(s.value, (h) => (ce(), ye("div", Zp, [
      L("div", {
        onClick: (_) => Ae(u).setOrResetActiveElement(h.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        L("span", th, Te(h.dataObject) + "." + Te(h.dataAttribute), 1)
      ], 8, eh),
      L("div", {
        onClick: (_) => Ae(u).setOrResetActiveElement(h.id),
        class: pn([{
          "bg-(--color-primary)": Ae(c) === h.id
        }, "rounded-full size-5 col-start-2 col-span-1 bg-(--color-ocean-gray-100) self-center justify-self-end -mr-[8.5px] hover:cursor-pointer"])
      }, null, 10, nh),
      L("div", rh, [
        L("div", {
          class: "inline-flex items-center h-full max-w-max hover:cursor-pointer",
          onClick: (_) => Ae(u).setOrResetActiveElement(h.id)
        }, [
          (ce(), ye("svg", ih, [
            L("line", {
              x1: "0",
              y1: "6",
              x2: "24",
              y2: "6",
              stroke: "currentColor",
              "stroke-width": "2",
              class: pn({
                "text-(--color-primary)": Ae(c) === h.id,
                "text-(--color-ocean-gray-100)": Ae(c) !== h.id
              })
            }, null, 2)
          ])),
          L("span", sh, Te(h.input), 1)
        ], 8, oh)
      ]),
      Ae(c) == h.id ? (ce(), On(hs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        _t(Jp, {
          placeholder: h,
          sourceLNodeId: r.sourceLNodeId
        }, null, 8, ["placeholder", "sourceLNodeId"])
      ])) : lt("", !0)
    ]))), 256));
  }
}), uh = { key: 0 }, lh = {
  key: 0,
  class: "bg-(--color-primary) text-white z-1 relative p-1 rounded-sm text-sm mb-4 inline-block"
}, ch = { key: 1 }, fh = /* @__PURE__ */ kt({
  __name: "controlled-connection-details",
  props: {
    controlledConnection: {}
  },
  setup(t) {
    const r = t, s = Qt(), { lnodes: u } = cn(s), c = tt(() => u.value.find(
      (f) => f.id === r.controlledConnection.controlledLNodeId
    )?.dataObjectSpecifications?.find(
      (f) => f.name === r.controlledConnection.controlledDataObject
    ));
    return (d, f) => (ce(), ye("div", null, [
      (ce(), ye("div", uh, [
        f[0] || (f[0] = L("h2", { class: "text-lg font-bold mb-2" }, "Controlled Connection Details", -1)),
        d.controlledConnection.dataflowType ? (ce(), ye("span", lh, Te(d.controlledConnection.dataflowType), 1)) : lt("", !0),
        L("p", null, "Output: " + Te(d.controlledConnection.outputName), 1),
        L("p", null, "Output Instance: " + Te(d.controlledConnection.outputInstance || "-"), 1),
        f[1] || (f[1] = L("br", null, null, -1)),
        L("p", null, "Controlled Data Object: " + Te(d.controlledConnection.controlledDataObject || "-"), 1),
        c.value?.desc ? (ce(), ye("p", ch, "Controlled Data Object Desc: " + Te(c.value?.desc), 1)) : lt("", !0)
      ]))
    ]));
  }
}), dh = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] h-[50px]" }, ph = ["onClick"], hh = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, mh = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 rounded-sm" }, yh = ["onClick"], vh = ["onClick", "data-testid"], gh = ["onClick"], bh = ["onClick"], wh = ["onClick"], _h = ["onClick"], xh = { class: "border-2 border-(--color-ocean-gray-100) px-2 py-1 mr-2 rounded-sm" }, Oh = /* @__PURE__ */ kt({
  __name: "dataflow-controlled-connections",
  props: {
    controlledConnections: {}
  },
  setup(t) {
    const r = ws(), { activeElement: s } = cn(r);
    return (u, c) => (ce(!0), ye(Qe, null, At(u.controlledConnections, (d, f) => (ce(), ye("div", dh, [
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: "col-start-1 col-span-1 self-center justify-self-end hover:cursor-pointer"
      }, [
        L("span", hh, Te(d.outputName), 1),
        L("span", mh, Te(d.outputInstance), 1)
      ], 8, ph),
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: pn(["rounded-full w-[20px] h-[20px] col-start-2 col-span-1 self-center justify-self-end -mr-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(s) === d.id,
          "bg-(--color-ocean-gray-100)": Ae(s) !== d.id
        }])
      }, null, 10, yh),
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: pn(["col-start-3 col-span-1 h-[2px] self-center row-start-1 hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(s) === d.id,
          "bg-(--color-ocean-gray-100)": Ae(s) !== d.id
        }]),
        "data-testid": `dataflow-controlled-connection-line-${f}`
      }, null, 10, vh),
      (ce(), ye("svg", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        height: "12",
        width: "8",
        class: "col-start-3 col-span-1 self-center justify-self-end mr-[9px] row-start-1 hover:cursor-pointer",
        xmlns: "http://www.w3.org/2000/svg"
      }, [
        L("polygon", {
          points: "0,0 8,6 0,12",
          style: Fo({
            fill: Ae(s) === d.id ? "var(--color-primary)" : "var(--color-ocean-gray-100)"
          })
        }, null, 4)
      ], 8, gh)),
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: "bg-(--color-primary) text-white col-start-3 self-center justify-self-center z-1 relative p-1 rounded-sm text-sm row-start-1 hover:cursor-pointer"
      }, Te(d.dataflowType), 9, bh),
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: pn(["rounded-full w-[20px] h-[20px] col-start-4 col-span-1 self-center justify-self-start -ml-[9px] hover:cursor-pointer", {
          "bg-(--color-primary)": Ae(s) === d.id,
          "bg-(--color-ocean-gray-100)": Ae(s) !== d.id
        }])
      }, null, 10, wh),
      L("div", {
        onClick: (h) => Ae(r).setOrResetActiveElement(d.id),
        class: "col-start-5 col-span-1 self-center justify-self-start hover:cursor-pointer"
      }, [
        L("span", xh, Te(d.controlledDataObject), 1)
      ], 8, _h),
      Ae(s) == d.id ? (ce(), On(hs, {
        key: 0,
        to: "#sidebar-details"
      }, [
        _t(fh, { "controlled-connection": d }, null, 8, ["controlled-connection"])
      ])) : lt("", !0)
    ]))), 256));
  }
}), Xa = (t, r) => {
  const s = t.__vccOpts || t;
  for (const [u, c] of r)
    s[u] = c;
  return s;
}, Th = {}, Eh = {
  width: "16",
  height: "16",
  viewBox: "0 0 20 20",
  fill: "currentColor"
};
function Nh(t, r) {
  return ce(), ye("svg", Eh, r[0] || (r[0] = [
    L("path", { d: "M5 11C4.44772 11 4 10.5523 4 10C4 9.44772 4.44772 9 5 9H15C15.5523 9 16 9.44772 16 10C16 10.5523 15.5523 11 15 11H5Z" }, null, -1),
    L("path", { d: "M9 5C9 4.44772 9.44772 4 10 4C10.5523 4 11 4.44772 11 5V15C11 15.5523 10.5523 16 10 16C9.44772 16 9 15.5523 9 15V5Z" }, null, -1)
  ]));
}
const Ea = /* @__PURE__ */ Xa(Th, [["render", Nh]]), Ch = { class: "grid grid-cols-2 gap-4 mt-4" }, Sh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Ah = ["value"], Rh = { class: "grid grid-cols-2 gap-4 mt-4" }, Dh = ["value", "title"], Ph = { class: "grid grid-cols-2 gap-4 mt-4" }, Ih = ["value", "title"], kh = { class: "grid grid-cols-2 gap-4 mt-4" }, jh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Lh = ["value"], Fh = { class: "grid grid-cols-2 gap-4 mt-4" }, Kh = { class: "flex items-center" }, Mh = { class: "flex items-center" }, Bh = ["value"], $h = { class: "grid grid-cols-2 gap-4 mt-4" }, qh = { class: "mt-4" }, Uh = { class: "mt-4" }, Vh = { class: "mt-4 flex items-center" }, Wh = /* @__PURE__ */ kt({
  __name: "dataflow-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {}
  },
  setup(t) {
    const r = t, s = To(), u = Qt(), { lnodeTypes: c, dataflowSdk: d } = cn(u), f = nt(B()), h = nt(!1), _ = nt([]), k = nt(!0);
    Ko(async () => {
      _.value = await d.value.findExistingInputs(r.destinationLNode);
    }), xn(h, (G) => {
      G ? f.value.inputName = "" : f.value.inputName = f.value.signal;
    }), xn(
      [
        () => f.value.inputName,
        () => f.value.attribute
      ],
      async ([G, $]) => {
        const q = await d.value.calculateNextInputInstance(
          G,
          $,
          r.destinationLNode
        );
        f.value.inputInstance = q.toString();
      }
    ), xn(
      () => f.value.signal,
      (G, $) => {
        const q = f.value.inputName !== $ && f.value.inputName !== "";
        !h.value && !q && (f.value.inputName = G);
      }
    ), Bf(() => {
      switch (W(), f.value.type = r.dataflowType, r.dataflowType) {
        case vt.GOOSE:
        case vt.SMV:
          f.value.includeQuality = !0, f.value.includeTimestamp = !1;
          break;
        case vt.REPORT:
          f.value.includeQuality = !0, f.value.includeTimestamp = !0;
          break;
        default:
          f.value.includeQuality = !1, f.value.includeTimestamp = !1;
      }
    });
    const D = tt(() => !r.dataflowType || !r.sourceLNode ? [] : c.value.find((G) => G.typeId === r.sourceLNode.lnType)?.dataObjects.filter(
      (G) => G.dataAttributes.some(
        ($) => jo[r.dataflowType]?.includes($.fc)
      )
    ).sort((G, $) => G.name.localeCompare($.name)) ?? []), j = tt(() => !r.dataflowType || !r.sourceLNode ? [] : c.value.find((G) => G.typeId === r.sourceLNode.lnType)?.dataObjects.find((G) => G.name === f.value.signal)?.dataAttributes.filter(
      (G) => jo[r.dataflowType].includes(G.fc)
    ).filter((G) => !ki.includes(G.name)).sort((G, $) => G.name.localeCompare($.name)) ?? []);
    function B() {
      return {
        type: null,
        signal: "",
        attribute: "",
        inputName: "",
        inputInstance: "",
        includeQuality: !1,
        includeTimestamp: !1
      };
    }
    function ee(G) {
      for (const $ of G)
        f.value[$] = "";
    }
    async function re() {
      try {
        if (!Q(f.value))
          return;
        await d.value.createConnection(
          f.value,
          r.sourceLNode,
          r.destinationLNode,
          k.value
        ), s.handleClose();
      } catch (G) {
        console.error("Error creating dataflow:", G), alert(`Error creating dataflow: ${G instanceof Error ? G.message : "Unknown error"}`);
      }
    }
    function Q(G) {
      return G.type ? G.signal ? G.attribute ? G.inputName ? !0 : (alert("Please enter an input name."), !1) : (alert("Please select an attribute (DA)."), !1) : (alert("Please select a signal (DO)."), !1) : (alert("Please select a dataflow type."), !1);
    }
    function W() {
      f.value = B(), h.value = !1, k.value = !0;
    }
    return (G, $) => (ce(), ye(Qe, null, [
      $[27] || ($[27] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("form", {
        method: "dialog",
        onSubmit: re
      }, [
        L("div", Ch, [
          $[11] || ($[11] = L("label", {
            for: "source-select",
            class: "col-start-1 self-center"
          }, "Source", -1)),
          L("select", Sh, [
            L("option", {
              value: r.sourceLNode.id
            }, Te(Ae(Wn)(G.sourceLNode)), 9, Ah)
          ])
        ]),
        L("div", Rh, [
          $[13] || ($[13] = L("label", {
            for: "data-object-select",
            class: "col-start-1 self-center"
          }, "Signal (DO)", -1)),
          We(L("select", {
            id: "data-object-select",
            required: "",
            class: "select col-start-2",
            "onUpdate:modelValue": $[0] || ($[0] = (q) => f.value.signal = q),
            onChange: $[1] || ($[1] = (q) => ee(["attribute"]))
          }, [
            $[12] || ($[12] = L("option", {
              key: "empty",
              value: ""
            }, "-", -1)),
            (ce(!0), ye(Qe, null, At(D.value, (q) => (ce(), ye("option", {
              key: q.name,
              value: q.name,
              title: q.desc ? `Desc: ${q.desc}` : ""
            }, Te(q.desc ? q.name + " ⓘ" : q.name), 9, Dh))), 128))
          ], 544), [
            [ln, f.value.signal]
          ])
        ]),
        L("div", Ph, [
          $[15] || ($[15] = L("label", {
            for: "data-attribute-select",
            class: "col-start-1 self-center"
          }, "Attribute (DA)", -1)),
          We(L("select", {
            id: "data-attribute-select",
            required: "",
            class: "select col-start-2",
            "onUpdate:modelValue": $[2] || ($[2] = (q) => f.value.attribute = q)
          }, [
            $[14] || ($[14] = L("option", {
              key: "empty",
              value: ""
            }, "-", -1)),
            (ce(!0), ye(Qe, null, At(j.value, (q) => (ce(), ye("option", {
              key: q.name,
              value: q.name,
              title: q.desc ? `Desc: ${q.desc}` : ""
            }, Te(q.desc ? q.name + " ⓘ" : q.name), 9, Ih))), 128))
          ], 512), [
            [ln, f.value.attribute]
          ])
        ]),
        $[24] || ($[24] = L("hr", { class: "solid mt-4" }, null, -1)),
        L("div", kh, [
          $[16] || ($[16] = L("label", {
            for: "destination-select",
            class: "col-start-1 self-center"
          }, "Destination", -1)),
          L("select", jh, [
            L("option", {
              value: r.destinationLNode.id
            }, Te(Ae(Wn)(G.destinationLNode)), 9, Lh)
          ])
        ]),
        L("div", Fh, [
          L("fieldset", null, [
            $[19] || ($[19] = L("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
            L("div", Kh, [
              We(L("input", {
                type: "radio",
                id: "dataflow-new-input",
                name: "input",
                "onUpdate:modelValue": $[3] || ($[3] = (q) => h.value = q),
                value: !1,
                class: "radio radio-sm mr-2"
              }, null, 512), [
                [Lr, h.value]
              ]),
              $[17] || ($[17] = L("label", { for: "dataflow-new-input" }, "New Input", -1))
            ]),
            L("div", Mh, [
              We(L("input", {
                type: "radio",
                id: "dataflow-existing-input",
                name: "input",
                "onUpdate:modelValue": $[4] || ($[4] = (q) => h.value = q),
                value: !0,
                class: "radio radio-sm mr-2"
              }, null, 512), [
                [Lr, h.value]
              ]),
              $[18] || ($[18] = L("label", { for: "dataflow-existing-input" }, "Existing Input", -1))
            ])
          ]),
          h.value ? lt("", !0) : We((ce(), ye("input", {
            key: 0,
            "aria-label": "New Input Name",
            required: "",
            type: "text",
            placeholder: "Input Name",
            class: "input col-start-2",
            "onUpdate:modelValue": $[5] || ($[5] = (q) => f.value.inputName = q)
          }, null, 512)), [
            [Tr, f.value.inputName]
          ]),
          h.value ? We((ce(), ye("select", {
            key: 1,
            "aria-label": "Existing Input Name Select",
            required: "",
            class: "select col-start-2",
            "onUpdate:modelValue": $[6] || ($[6] = (q) => f.value.inputName = q)
          }, [
            (ce(!0), ye(Qe, null, At(_.value, (q) => (ce(), ye("option", {
              key: q,
              value: q
            }, Te(q), 9, Bh))), 128))
          ], 512)), [
            [ln, f.value.inputName]
          ]) : lt("", !0)
        ]),
        L("div", $h, [
          $[20] || ($[20] = L("label", {
            for: "input-instance-input",
            class: "col-start-1 self-center"
          }, "Input Instance", -1)),
          We(L("input", {
            id: "input-instance-input",
            required: "",
            disabled: "",
            type: "text",
            class: "input col-start-2",
            "onUpdate:modelValue": $[7] || ($[7] = (q) => f.value.inputInstance = q)
          }, null, 512), [
            [Tr, f.value.inputInstance]
          ])
        ]),
        $[25] || ($[25] = L("hr", { class: "solid mt-4" }, null, -1)),
        L("div", qh, [
          We(L("input", {
            type: "checkbox",
            "onUpdate:modelValue": $[8] || ($[8] = (q) => f.value.includeQuality = q),
            class: "checkbox mr-2",
            id: "checkbox-include-quality"
          }, null, 512), [
            [Po, f.value.includeQuality]
          ]),
          $[21] || ($[21] = L("label", { for: "checkbox-include-quality" }, "Include Quality", -1))
        ]),
        L("div", Uh, [
          We(L("input", {
            type: "checkbox",
            "onUpdate:modelValue": $[9] || ($[9] = (q) => f.value.includeTimestamp = q),
            class: "checkbox mr-2",
            id: "checkbox-include-timestamp"
          }, null, 512), [
            [Po, f.value.includeTimestamp]
          ]),
          $[22] || ($[22] = L("label", { for: "checkbox-include-timestamp" }, "Include Timestamp", -1))
        ]),
        L("div", Vh, [
          We(L("input", {
            type: "checkbox",
            "onUpdate:modelValue": $[10] || ($[10] = (q) => k.value = q),
            class: "checkbox mr-2",
            id: "dataflow-checkbox-add-references"
          }, null, 512), [
            [Po, k.value]
          ]),
          $[23] || ($[23] = L("label", { for: "dataflow-checkbox-add-references" }, "Add References to Application", -1))
        ]),
        $[26] || ($[26] = L("div", { class: "modal-action" }, [
          L("button", {
            class: "btn bg-(--color-primary) border-none text-white",
            type: "submit",
            "data-testId": "save-dataflow-connection"
          }, " Save ")
        ], -1))
      ], 32)
    ], 64));
  }
}), Hh = { class: "grid grid-cols-2 gap-4 mt-4" }, Gh = {
  id: "destination-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Yh = ["value"], Qh = { class: "grid grid-cols-2 gap-4 mt-4" }, Xh = ["value", "title"], zh = { class: "grid grid-cols-2 gap-4 mt-4" }, Jh = {
  id: "source-select",
  required: "",
  disabled: "",
  class: "select col-start-2"
}, Zh = ["value"], em = { class: "grid grid-cols-2 gap-4 mt-4" }, tm = { class: "flex items-center" }, nm = { class: "flex items-center" }, rm = ["value"], om = { class: "grid grid-cols-2 gap-4 mt-4" }, im = { class: "mt-4 flex items-center" }, sm = /* @__PURE__ */ kt({
  __name: "dataflow-controlled-connection-form-fields",
  props: {
    sourceLNode: {},
    destinationLNode: {},
    dataflowType: {}
  },
  setup(t) {
    const r = t, s = To(), u = Qt(), { lnodeTypes: c, dataflowSdk: d } = cn(u), f = nt(
      j()
    ), h = nt(!1), _ = nt([]), k = nt(!0);
    Ko(async () => {
      _.value = await d.value.findExistingOutputs(r.sourceLNode);
    }), xn(h, (re) => {
      re ? f.value.outputName = "" : f.value.outputName = f.value.controlledSignal;
    }), xn(
      () => f.value.outputName,
      async (re) => {
        const Q = await d.value.calculateNextOutputInstance(
          re,
          r.sourceLNode
        );
        f.value.outputInstance = Q.toString();
      }
    ), xn(
      () => f.value.controlledSignal,
      (re, Q) => {
        const W = f.value.outputName !== Q && f.value.outputName !== "";
        !h.value && !W && (f.value.outputName = re);
      }
    );
    const D = tt(() => r.destinationLNode ? c.value.find((Q) => Q.typeId === r.destinationLNode.lnType)?.dataObjects.map((Q) => ({
      name: Q.name,
      desc: Q.desc
    })).sort((Q, W) => Q.name.localeCompare(W.name)) ?? [] : []);
    function j() {
      return {
        type: vt.CONTROL,
        controlledSignal: "",
        outputName: "",
        outputInstance: ""
      };
    }
    async function B() {
      try {
        if (!ee(f.value))
          return;
        await d.value.createControlledConnection(
          f.value,
          r.sourceLNode,
          r.destinationLNode,
          k.value
        ), s.handleClose();
      } catch (re) {
        console.error("Error creating controlled dataflow:", re), alert(`Error creating controlled dataflow: ${re instanceof Error ? re.message : "Unknown error"}`);
      }
    }
    function ee(re) {
      return re.type ? re.outputName ? re.controlledSignal ? !0 : (alert("Please select a controlled signal (DO)."), !1) : (alert("Please select an controller output name."), !1) : (alert("Please select a dataflow type."), !1);
    }
    return (re, Q) => (ce(), ye(Qe, null, [
      Q[16] || (Q[16] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", Hh, [
        Q[7] || (Q[7] = L("label", {
          for: "destination-select",
          class: "col-start-1 self-center"
        }, "Controlled", -1)),
        L("select", Gh, [
          L("option", {
            value: r.destinationLNode.id
          }, Te(Ae(Wn)(re.destinationLNode)), 9, Yh)
        ])
      ]),
      L("div", Qh, [
        Q[9] || (Q[9] = L("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Controlled Signal (DO)", -1)),
        We(L("select", {
          id: "data-object-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": Q[0] || (Q[0] = (W) => f.value.controlledSignal = W)
        }, [
          Q[8] || (Q[8] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(D.value, (W) => (ce(), ye("option", {
            key: W.name,
            value: W.name,
            title: W.desc ? `Desc: ${W.desc}` : ""
          }, Te(W.desc ? W.name + " ⓘ" : W.name), 9, Xh))), 128))
        ], 512), [
          [ln, f.value.controlledSignal]
        ])
      ]),
      Q[17] || (Q[17] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", zh, [
        Q[10] || (Q[10] = L("label", {
          for: "source-select",
          class: "col-start-1 self-center"
        }, "Controller", -1)),
        L("select", Jh, [
          L("option", {
            value: r.sourceLNode.id
          }, Te(Ae(Wn)(re.sourceLNode)), 9, Zh)
        ])
      ]),
      L("div", em, [
        L("fieldset", null, [
          Q[13] || (Q[13] = L("legend", { class: "col-start-1 self-start" }, "Controller Output Name", -1)),
          L("div", tm, [
            We(L("input", {
              type: "radio",
              id: "dataflow-control-new-output",
              name: "output",
              "onUpdate:modelValue": Q[1] || (Q[1] = (W) => h.value = W),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Lr, h.value]
            ]),
            Q[11] || (Q[11] = L("label", { for: "dataflow-control-new-output" }, "New Output", -1))
          ]),
          L("div", nm, [
            We(L("input", {
              type: "radio",
              id: "dataflow-control-existing-output",
              name: "output",
              "onUpdate:modelValue": Q[2] || (Q[2] = (W) => h.value = W),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Lr, h.value]
            ]),
            Q[12] || (Q[12] = L("label", { for: "dataflow-control-existing-output" }, "Existing Output", -1))
          ])
        ]),
        h.value ? lt("", !0) : We((ce(), ye("input", {
          key: 0,
          "aria-label": "New Output Name",
          required: "",
          type: "text",
          placeholder: "Output Name",
          class: "input col-start-2",
          "onUpdate:modelValue": Q[3] || (Q[3] = (W) => f.value.outputName = W)
        }, null, 512)), [
          [Tr, f.value.outputName]
        ]),
        h.value ? We((ce(), ye("select", {
          key: 1,
          "aria-label": "Existing Output Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": Q[4] || (Q[4] = (W) => f.value.outputName = W)
        }, [
          (ce(!0), ye(Qe, null, At(_.value, (W) => (ce(), ye("option", {
            key: W,
            value: W
          }, Te(W), 9, rm))), 128))
        ], 512)), [
          [ln, f.value.outputName]
        ]) : lt("", !0)
      ]),
      L("div", om, [
        Q[14] || (Q[14] = L("label", {
          for: "output-instance-input",
          class: "col-start-1 self-center"
        }, "Output Instance", -1)),
        We(L("input", {
          id: "output-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": Q[5] || (Q[5] = (W) => f.value.outputInstance = W)
        }, null, 512), [
          [Tr, f.value.outputInstance]
        ])
      ]),
      L("div", im, [
        We(L("input", {
          type: "checkbox",
          "onUpdate:modelValue": Q[6] || (Q[6] = (W) => k.value = W),
          class: "checkbox mr-2",
          id: "dataflow-control-checkbox-add-references"
        }, null, 512), [
          [Po, k.value]
        ]),
        Q[15] || (Q[15] = L("label", { for: "dataflow-control-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      Q[18] || (Q[18] = L("hr", { class: "solid mt-4" }, null, -1)),
      L("div", { class: "modal-action" }, [
        L("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          onClick: B,
          "data-testId": "save-dataflow-connection"
        }, " Save ")
      ])
    ], 64));
  }
}), am = { class: "grid grid-cols-2 gap-4 mt-4" }, um = ["value", "disabled"], lm = /* @__PURE__ */ kt({
  __name: "dataflow-creation",
  props: {
    sourceLNode: {},
    destinationLNode: {}
  },
  setup(t) {
    const r = t, s = nt(null), u = tt(
      () => Object.values(vt).filter((f) => f !== vt.INTERNAL)
    ), c = tt(
      () => r.sourceLNode?.lnClass === "IHMI" || r.sourceLNode?.lnClass === "ITCI"
    );
    function d(f) {
      const h = f.target.value;
      s.value = h;
    }
    return (f, h) => (ce(), ye(Qe, null, [
      h[3] || (h[3] = L("h3", { class: "font-bold text-lg" }, "Create Connection", -1)),
      L("div", am, [
        h[2] || (h[2] = L("label", {
          for: "dataflow-type-select",
          class: "col-start-1 self-center"
        }, "Dataflow Type", -1)),
        We(L("select", {
          id: "dataflow-type-select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": h[0] || (h[0] = (_) => s.value = _),
          onChange: d
        }, [
          h[1] || (h[1] = L("option", {
            key: "empty",
            value: null
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(u.value, (_) => (ce(), ye("option", {
            key: _,
            value: _,
            disabled: _ === Ae(vt).CONTROL && !c.value
          }, Te(_), 9, um))), 128))
        ], 544), [
          [ln, s.value]
        ])
      ]),
      s.value !== Ae(vt).CONTROL ? (ce(), On(Wh, {
        key: 0,
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        dataflowType: s.value
      }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType"])) : (ce(), On(sm, {
        key: 1,
        sourceLNode: r.sourceLNode,
        destinationLNode: r.destinationLNode,
        dataflowType: s.value
      }, null, 8, ["sourceLNode", "destinationLNode", "dataflowType"]))
    ], 64));
  }
}), cm = { class: "grid grid-cols-2 gap-4 items-center" }, fm = { class: "grid grid-cols-2 gap-4 items-center" }, dm = ["value", "disabled"], pm = { class: "grid grid-cols-2 gap-4 items-center" }, hm = ["value", "title"], mm = { class: "grid grid-cols-2 gap-4 items-center" }, ym = ["value", "title"], vm = { class: "grid grid-cols-2 gap-4 items-center" }, gm = { class: "grid grid-cols-2 gap-4 items-center" }, bm = ["value"], wm = { class: "flex items-center" }, _m = /* @__PURE__ */ kt({
  __name: "source-placeholder-port-creation",
  props: {
    sourceLNode: {}
  },
  setup(t) {
    const r = t, s = To(), u = Qt(), { lnodeTypes: c, dataflowSdk: d } = cn(u), f = nt(
      ee()
    ), h = nt(!0);
    async function _(Q) {
      try {
        await d.value.createSourcePlaceholder(
          r.sourceLNode,
          f.value,
          h.value
        ), s.handleClose();
      } catch (W) {
        console.error("Error creating source placeholder port:", W), alert(`Error creating placeholder: ${W instanceof Error ? W.message : "Unknown error"}`);
      }
    }
    const k = tt(
      () => [...c.value].sort((Q, W) => Q.lnClass.localeCompare(W.lnClass))
    ), D = tt(
      () => Object.values(vt).filter((Q) => Q !== vt.INTERNAL)
    ), j = tt(() => {
      const Q = c.value.find((W) => W.typeId === r.sourceLNode.lnType);
      return Q ? f.value.dataflowType ? Q.dataObjects.filter(
        (W) => W.dataAttributes.some(
          (G) => jo[f.value.dataflowType].includes(
            G.fc
          )
        )
      ).sort((W, G) => W.name.localeCompare(G.name)) : Q.dataObjects.sort((W, G) => W.name.localeCompare(G.name)) : [];
    }), B = tt(() => {
      const Q = c.value.find((W) => W.typeId === r.sourceLNode.lnType)?.dataObjects.find((W) => W.name === f.value.dataObject);
      return Q ? f.value.dataflowType ? Q.dataAttributes.filter(
        (W) => jo[f.value.dataflowType].includes(
          W.fc
        )
      ).filter((W) => !ki.includes(W.name)).sort((W, G) => W.name.localeCompare(G.name)) : Q.dataAttributes.filter((W) => !ki.includes(W.name)).sort((W, G) => W.name.localeCompare(G.name)) : [];
    });
    function ee() {
      return {
        dataObject: "",
        dataAttribute: "",
        inputName: "",
        dataflowType: "",
        processResource: "",
        preferredLNode: ""
      };
    }
    function re(Q) {
      for (const W of Q)
        f.value[W] = "";
    }
    return (Q, W) => (ce(), ye("form", {
      onSubmit: _,
      method: "dialog",
      class: "flex flex-col gap-4 mt-4"
    }, [
      W[20] || (W[20] = L("h3", { class: "font-bold text-lg" }, "Create Placeholder - Provide data", -1)),
      L("div", cm, [
        W[9] || (W[9] = L("label", { for: "input-name" }, "Input Name", -1)),
        We(L("input", {
          required: "",
          id: "input-name",
          name: "inputName",
          "onUpdate:modelValue": W[0] || (W[0] = (G) => f.value.inputName = G),
          placeholder: "Input Name",
          class: "input col-start-2"
        }, null, 512), [
          [Tr, f.value.inputName]
        ])
      ]),
      L("div", fm, [
        W[11] || (W[11] = L("label", { for: "dataflow-type-select" }, "Dataflow Type", -1)),
        We(L("select", {
          id: "dataflow-type-select",
          name: "dataflowType",
          class: "select col-start-2",
          "onUpdate:modelValue": W[1] || (W[1] = (G) => f.value.dataflowType = G),
          onChange: W[2] || (W[2] = (G) => re(["dataObject", "dataAttribute"]))
        }, [
          W[10] || (W[10] = L("option", { value: "" }, "-", -1)),
          (ce(!0), ye(Qe, null, At(D.value, (G) => (ce(), ye("option", {
            key: G,
            value: G,
            disabled: G === Ae(vt).CONTROL
          }, Te(G), 9, dm))), 128))
        ], 544), [
          [ln, f.value.dataflowType]
        ])
      ]),
      L("div", pm, [
        W[13] || (W[13] = L("label", { for: "data-object-select" }, "Data Object", -1)),
        We(L("select", {
          required: "",
          id: "data-object-select",
          name: "data object",
          class: "select col-start-2",
          "onUpdate:modelValue": W[3] || (W[3] = (G) => f.value.dataObject = G),
          onChange: W[4] || (W[4] = (G) => re(["dataAttribute"]))
        }, [
          W[12] || (W[12] = L("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(j.value, (G) => (ce(), ye("option", {
            key: G.id,
            value: G.name,
            title: G.desc ? `Desc: ${G.desc}` : ""
          }, Te(G.desc ? G.name + " ⓘ" : G.name), 9, hm))), 128))
        ], 544), [
          [ln, f.value.dataObject]
        ])
      ]),
      L("div", mm, [
        W[15] || (W[15] = L("label", { for: "data-attribute-select" }, "Data Attribute", -1)),
        We(L("select", {
          required: "",
          id: "data-attribute-select",
          name: "data attribute",
          "onUpdate:modelValue": W[5] || (W[5] = (G) => f.value.dataAttribute = G),
          class: "select col-start-2"
        }, [
          W[14] || (W[14] = L("option", {
            key: "empty",
            value: "",
            disabled: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(B.value, (G) => (ce(), ye("option", {
            key: G.id,
            value: G.name,
            title: G.desc ? `Desc: ${G.desc}` : ""
          }, Te(G.desc ? G.name + " ⓘ" : G.name), 9, ym))), 128))
        ], 512), [
          [ln, f.value.dataAttribute]
        ])
      ]),
      L("div", vm, [
        W[16] || (W[16] = L("label", { for: "process-resource-input" }, "Process Resource", -1)),
        We(L("input", {
          id: "process-resource-input",
          name: "processResource",
          placeholder: "Process Resource",
          class: "input col-start-2",
          "onUpdate:modelValue": W[6] || (W[6] = (G) => f.value.processResource = G)
        }, null, 512), [
          [Tr, f.value.processResource]
        ])
      ]),
      L("div", gm, [
        W[18] || (W[18] = L("label", { for: "preferred-lnode-select" }, "Preferred LNode", -1)),
        We(L("select", {
          id: "preferred-lnode-select",
          name: "preferredLNode",
          class: "select col-start-2",
          "onUpdate:modelValue": W[7] || (W[7] = (G) => f.value.preferredLNode = G)
        }, [
          W[17] || (W[17] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(k.value, (G) => (ce(), ye("option", {
            key: G.lnClass,
            value: G.lnClass
          }, Te(G.lnClass), 9, bm))), 128))
        ], 512), [
          [ln, f.value.preferredLNode]
        ])
      ]),
      L("div", wm, [
        We(L("input", {
          type: "checkbox",
          "onUpdate:modelValue": W[8] || (W[8] = (G) => h.value = G),
          class: "checkbox mr-2",
          id: "source-placeholder-checkbox-add-references"
        }, null, 512), [
          [Po, h.value]
        ]),
        W[19] || (W[19] = L("label", { for: "source-placeholder-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      W[21] || (W[21] = L("div", { class: "modal-action" }, [
        L("button", { class: "btn bg-(--color-primary) border-none text-white" }, "Save")
      ], -1))
    ], 32));
  }
}), xm = { class: "grid grid-cols-2 gap-4 mt-4" }, Om = { class: "flex items-center" }, Tm = { class: "flex items-center" }, Em = ["value"], Nm = { class: "grid grid-cols-2 gap-4 mt-4" }, Cm = { class: "grid grid-cols-2 gap-4 mt-4" }, Sm = ["value", "disabled"], Am = { class: "grid grid-cols-2 gap-4 mt-4" }, Rm = ["value"], Dm = { class: "grid grid-cols-2 gap-4 mt-4" }, Pm = ["value", "title"], Im = { class: "grid grid-cols-2 gap-4 mt-4" }, km = ["value", "title"], jm = { class: "grid grid-cols-2 gap-4 mt-4" }, Lm = { class: "mt-4 flex items-center" }, Fm = /* @__PURE__ */ kt({
  __name: "destination-placeholder-port-creation",
  props: {
    destinationLNode: {}
  },
  setup(t) {
    const r = t, s = To(), u = Qt(), { lnodeTypes: c, dataflowSdk: d } = cn(u), f = nt(
      re()
    ), h = nt(!0), _ = nt(!1), k = nt([]);
    Ko(async () => {
      k.value = await d.value.findExistingInputs(r.destinationLNode);
    }), xn(_, () => {
      f.value.inputName = "";
    }), xn(
      [
        () => f.value.inputName,
        () => f.value.preferredDataAttribute
      ],
      async ([G, $]) => {
        if (!G) {
          f.value.inputInstance = "";
          return;
        }
        const q = await d.value.calculateNextInputInstance(
          G,
          $,
          r.destinationLNode
        );
        f.value.inputInstance = q.toString();
      }
    );
    const D = tt(
      () => Object.values(vt).filter((G) => G !== vt.INTERNAL)
    ), j = tt(
      () => [...c.value].sort((G, $) => G.lnClass.localeCompare($.lnClass))
    ), B = tt(() => {
      const G = c.value.find(
        ($) => $.lnClass === f.value.preferredLNode
      );
      return G ? f.value.dataflowType ? G.dataObjects.filter(
        ($) => $.dataAttributes.some(
          (q) => jo[f.value.dataflowType].includes(q.fc)
        )
      ).map(($) => ({
        name: $.name,
        desc: $.desc
      })).sort(($, q) => $.name.localeCompare(q.name)) : G.dataObjects.map(($) => ({
        name: $.name,
        desc: $.desc
      })).sort(($, q) => $.name.localeCompare(q.name)) : [];
    }), ee = tt(() => {
      const G = c.value.find(
        (q) => q.lnClass === f.value.preferredLNode
      );
      if (!G) return [];
      const $ = G.dataObjects.find(
        (q) => q.name === f.value.preferredDataObject
      );
      return $ ? f.value.dataflowType ? $.dataAttributes.filter(
        (q) => jo[f.value.dataflowType].includes(q.fc)
      ).filter((q) => !ki.includes(q.name)).sort((q, fe) => q.name.localeCompare(fe.name)) : $.dataAttributes.filter((q) => !ki.includes(q.name)).sort((q, fe) => q.name.localeCompare(fe.name)) : [];
    });
    function re() {
      return {
        dataflowType: null,
        inputName: "",
        inputInstance: "",
        preferredLNode: "",
        preferredDataObject: "",
        preferredDataAttribute: "",
        processResource: ""
      };
    }
    async function Q() {
      try {
        await d.value.createDestinationPlaceholder(
          f.value,
          r.destinationLNode,
          h.value
        ), s.handleClose();
      } catch (G) {
        console.error("Error creating destination placeholder port:", G), alert(`Error creating placeholder: ${G instanceof Error ? G.message : "Unknown error"}`);
      }
    }
    function W(G) {
      for (const $ of G)
        f.value[$] = "";
    }
    return (G, $) => (ce(), ye("form", {
      method: "dialog",
      onSubmit: Q
    }, [
      $[28] || ($[28] = L("h3", { class: "font-bold text-lg" }, "Create Placeholder - Receive data from", -1)),
      L("div", xm, [
        L("fieldset", null, [
          $[16] || ($[16] = L("legend", { class: "col-start-1 self-start" }, "Input Name", -1)),
          L("div", Om, [
            We(L("input", {
              type: "radio",
              id: "destination-placeholder-new-input",
              name: "input",
              "onUpdate:modelValue": $[0] || ($[0] = (q) => _.value = q),
              value: !1,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Lr, _.value]
            ]),
            $[14] || ($[14] = L("label", { for: "destination-placeholder-new-input" }, "New Input", -1))
          ]),
          L("div", Tm, [
            We(L("input", {
              type: "radio",
              id: "destination-placeholder-existing-input",
              name: "input",
              "onUpdate:modelValue": $[1] || ($[1] = (q) => _.value = q),
              value: !0,
              class: "radio radio-sm mr-2"
            }, null, 512), [
              [Lr, _.value]
            ]),
            $[15] || ($[15] = L("label", { for: "destination-placeholder-existing-input" }, "Existing Input", -1))
          ])
        ]),
        _.value ? lt("", !0) : We((ce(), ye("input", {
          key: 0,
          "aria-label": "New Input Name",
          required: "",
          type: "text",
          placeholder: "Input Name",
          class: "input col-start-2",
          "onUpdate:modelValue": $[2] || ($[2] = (q) => f.value.inputName = q)
        }, null, 512)), [
          [Tr, f.value.inputName]
        ]),
        _.value ? We((ce(), ye("select", {
          key: 1,
          "aria-label": "Existing Input Name Select",
          required: "",
          class: "select col-start-2",
          "onUpdate:modelValue": $[3] || ($[3] = (q) => f.value.inputName = q)
        }, [
          (ce(!0), ye(Qe, null, At(k.value, (q) => (ce(), ye("option", {
            key: q,
            value: q
          }, Te(q), 9, Em))), 128))
        ], 512)), [
          [ln, f.value.inputName]
        ]) : lt("", !0)
      ]),
      L("div", Nm, [
        $[17] || ($[17] = L("label", {
          for: "input-instance-input",
          class: "col-start-1 self-center"
        }, "Input Instance", -1)),
        We(L("input", {
          id: "input-instance-input",
          required: "",
          disabled: "",
          type: "text",
          class: "input col-start-2",
          "onUpdate:modelValue": $[4] || ($[4] = (q) => f.value.inputInstance = q)
        }, null, 512), [
          [Tr, f.value.inputInstance]
        ])
      ]),
      L("div", Cm, [
        $[19] || ($[19] = L("label", {
          for: "dataflow-type-select",
          class: "col-start-1 self-center"
        }, "Dataflow Type", -1)),
        We(L("select", {
          id: "dataflow-type-select",
          class: "select col-start-2",
          "onUpdate:modelValue": $[5] || ($[5] = (q) => f.value.dataflowType = q),
          onChange: $[6] || ($[6] = (q) => W(["preferredDataObject"]))
        }, [
          $[18] || ($[18] = L("option", {
            key: "empty",
            value: null
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(D.value, (q) => (ce(), ye("option", {
            key: q,
            value: q,
            disabled: q === Ae(vt).CONTROL
          }, Te(q), 9, Sm))), 128))
        ], 544), [
          [ln, f.value.dataflowType]
        ])
      ]),
      L("div", Am, [
        $[21] || ($[21] = L("label", {
          for: "preferred-lnode-select",
          class: "col-start-1 self-center"
        }, "Preferred LNode", -1)),
        We(L("select", {
          id: "preferred-lnode-select",
          class: "select col-start-2",
          "onUpdate:modelValue": $[7] || ($[7] = (q) => f.value.preferredLNode = q),
          onChange: $[8] || ($[8] = (q) => W(["preferredDataObject"]))
        }, [
          $[20] || ($[20] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(j.value, (q) => (ce(), ye("option", {
            key: q.id,
            value: q.lnClass
          }, Te(q.lnClass), 9, Rm))), 128))
        ], 544), [
          [ln, f.value.preferredLNode]
        ])
      ]),
      L("div", Dm, [
        $[23] || ($[23] = L("label", {
          for: "data-object-select",
          class: "col-start-1 self-center"
        }, "Preferred Data Object", -1)),
        We(L("select", {
          id: "data-object-select",
          class: "select col-start-2",
          "onUpdate:modelValue": $[9] || ($[9] = (q) => f.value.preferredDataObject = q),
          onChange: $[10] || ($[10] = (q) => W(["preferredDataAttribute"]))
        }, [
          $[22] || ($[22] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(B.value, (q) => (ce(), ye("option", {
            key: q.name,
            value: q.name,
            title: q.desc ? `Desc: ${q.desc}` : ""
          }, Te(q.desc ? q.name + " ⓘ" : q.name), 9, Pm))), 128))
        ], 544), [
          [ln, f.value.preferredDataObject]
        ])
      ]),
      L("div", Im, [
        $[25] || ($[25] = L("label", {
          for: "data-attribute-select",
          class: "col-start-1 self-center"
        }, "Preferred Data Attribute", -1)),
        We(L("select", {
          id: "data-attribute-select",
          class: "select col-start-2",
          "onUpdate:modelValue": $[11] || ($[11] = (q) => f.value.preferredDataAttribute = q)
        }, [
          $[24] || ($[24] = L("option", {
            key: "empty",
            value: ""
          }, "-", -1)),
          (ce(!0), ye(Qe, null, At(ee.value, (q) => (ce(), ye("option", {
            key: q.name,
            value: q.name,
            title: q.desc ? `Desc: ${q.desc}` : ""
          }, Te(q.desc ? q.name + " ⓘ" : q.name), 9, km))), 128))
        ], 512), [
          [ln, f.value.preferredDataAttribute]
        ])
      ]),
      L("div", jm, [
        $[26] || ($[26] = L("label", {
          for: "process-resource-input",
          class: "col-start-1 self-center"
        }, "Process Resource", -1)),
        We(L("input", {
          id: "process-resource-input",
          type: "text",
          placeholder: "Process Resource",
          class: "input col-start-2",
          "onUpdate:modelValue": $[12] || ($[12] = (q) => f.value.processResource = q)
        }, null, 512), [
          [Tr, f.value.processResource]
        ])
      ]),
      L("div", Lm, [
        We(L("input", {
          type: "checkbox",
          "onUpdate:modelValue": $[13] || ($[13] = (q) => h.value = q),
          class: "checkbox mr-2",
          id: "destination-placeholder-checkbox-add-references"
        }, null, 512), [
          [Po, h.value]
        ]),
        $[27] || ($[27] = L("label", { for: "destination-placeholder-checkbox-add-references" }, "Add References to Application", -1))
      ]),
      $[29] || ($[29] = L("div", { class: "modal-action" }, [
        L("button", {
          class: "btn bg-(--color-primary) border-none text-white",
          type: "submit"
        }, "Save")
      ], -1))
    ], 32));
  }
}), To = /* @__PURE__ */ Ya("dataflow/dialog-store", () => {
  const t = {
    component: void 0,
    props: void 0
  }, r = nt(), s = nt(t), u = Ki({
    DataflowCreation: bo(lm),
    SourcePlaceholderCreation: bo(_m),
    DestinationPlaceholderCreation: bo(Fm)
  });
  function c() {
    s.value = {
      component: void 0,
      props: void 0
    };
  }
  function d() {
    r.value?.close(), c();
  }
  function f(h, _) {
    s.value.component = ds(u[h]), s.value.props = _, r.value?.showModal();
  }
  return {
    // states
    dialogRef: r,
    currentDialogContent: s,
    availableDialogContent: u,
    // getters
    // actions
    hardReset: c,
    handleClose: d,
    setCurrentDialogContent: f
  };
}), Km = { class: "grid grid-cols-[1fr_20px_1fr_20px_1fr] w-full mb-8 grid-rows-[100px_1fr_80px]" }, Mm = ["value"], Bm = ["value"], $m = ["value"], qm = ["value"], Um = { class: "col-span-full row-start-2" }, Vm = { class: "grid" }, Wm = { class: "col-start-1 row-start-1 pointer-events-none" }, Hm = { class: "col-start-1 row-start-1 -order-1" }, Gm = /* @__PURE__ */ kt({
  __name: "dataflow-visualisation",
  emits: ["sourceLNodeChange", "destinationLNodeChange"],
  setup(t, { emit: r }) {
    const s = r, u = To(), c = Qt(), { lnodes: d, connections: f, controlledConnections: h } = cn(c), _ = nt(), k = nt(), D = nt(), j = nt();
    xn(
      () => d.value,
      () => {
        _.value = void 0, k.value = void 0;
      }
    );
    const B = tt(
      () => d.value.filter((ue) => ue.id !== k.value).sort((ue, de) => Wn(ue).localeCompare(Wn(de)))
    ), ee = tt(() => d.value.find((de) => de.id === _.value)?.dataObjectSpecifications ?? []), re = tt(
      () => d.value.filter((ue) => ue.id !== _.value).sort((ue, de) => Wn(ue).localeCompare(Wn(de)))
    ), Q = tt(() => !_.value || !k.value ? [] : f.value.filter(
      (ue) => ue.sourceLNodeId === _.value && ue.destinationLNodeId === k.value
    )), W = tt(() => !_.value || !k.value ? [] : h.value.filter(
      (ue) => ue.controllerLNodeId === _.value && ue.controlledLNodeId === k.value
    )), G = tt(() => k.value ? f.value.filter(
      (ue) => ue.destinationLNodeId === k.value && !ue.sourceLNodeId
    ) : []);
    function $(ue) {
      return d.value.find((de) => de.id === ue) ?? void 0;
    }
    function q(ue) {
      _.value = ue, D.value = $(ue), s("sourceLNodeChange", ue);
    }
    function fe(ue) {
      k.value = ue, j.value = $(ue), s("destinationLNodeChange", ue);
    }
    function _e() {
      u.setCurrentDialogContent("SourcePlaceholderCreation", {
        sourceLNode: D.value
      });
    }
    function Pe() {
      u.setCurrentDialogContent("DestinationPlaceholderCreation", {
        destinationLNode: j.value
      });
    }
    return (ue, de) => (ce(), ye("div", Km, [
      de[5] || (de[5] = L("div", { class: "col-start-1 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      L("select", {
        value: _.value ?? "",
        onChange: de[0] || (de[0] = (F) => q(F.target.value)),
        "data-testid": "select-source-lnode",
        class: "col-start-1 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        de[2] || (de[2] = Yl(" > ")),
        de[3] || (de[3] = L("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ce(!0), ye(Qe, null, At(B.value, (F) => (ce(), ye("option", {
          key: F.id,
          value: F.id
        }, Te(Ae(Wn)(F)), 9, Bm))), 128))
      ], 40, Mm),
      de[6] || (de[6] = L("div", { class: "col-start-4 col-span-2 row-span-full bg-(--color-ocean-gray-50) relative rounded-xl -z-1 border-(--color-ocean-gray-100) border-3 min-h-[450px]" }, null, -1)),
      L("select", {
        value: k.value ?? "",
        onChange: de[1] || (de[1] = (F) => fe(F.target.value)),
        "data-testid": "select-destination-lnode",
        class: "col-start-4 col-span-2 self-center justify-self-center row-start-1 text-2xl text-center"
      }, [
        de[4] || (de[4] = L("option", {
          key: "null",
          value: ""
        }, "Select LNode", -1)),
        (ce(!0), ye(Qe, null, At(re.value, (F) => (ce(), ye("option", {
          key: F.id,
          value: F.id
        }, Te(Ae(Wn)(F)), 9, qm))), 128))
      ], 40, $m),
      L("div", Um, [
        Q.value.length > 0 ? (ce(), On(Pp, {
          key: 0,
          connections: Q.value
        }, null, 8, ["connections"])) : lt("", !0),
        W.value.length > 0 ? (ce(), On(Oh, {
          key: 1,
          controlledConnections: W.value
        }, null, 8, ["controlledConnections"])) : lt("", !0),
        L("div", Vm, [
          L("div", Wm, [
            _.value ? (ce(), On(ah, {
              key: 0,
              dataObjectSpecifications: ee.value,
              sourceLNodeId: _.value
            }, null, 8, ["dataObjectSpecifications", "sourceLNodeId"])) : lt("", !0)
          ]),
          L("div", Hm, [
            _t(Gp, { destinationPlaceHolderPorts: G.value }, null, 8, ["destinationPlaceHolderPorts"])
          ])
        ])
      ]),
      D.value ? (ce(), ye("button", {
        key: 0,
        "aria-label": "Add source placeholder",
        class: "btn btn-primary btn-circle size-5 col-start-3 col-span-1 -ml-[12px] self-center relative z-10 row-start-3",
        onClick: _e
      }, [
        _t(Ea)
      ])) : lt("", !0),
      j.value ? (ce(), ye("button", {
        key: 1,
        class: "btn btn-primary btn-circle size-5 col-start-4 col-span-1 -ml-[9px] self-center row-start-3",
        "aria-label": "Add destination placeholder",
        onClick: Pe
      }, [
        _t(Ea)
      ])) : lt("", !0)
    ]));
  }
}), Ym = { class: "flex flex-col items-center justify-center w-full" }, Qm = ["disabled"], Xm = /* @__PURE__ */ kt({
  __name: "dataflow-view",
  setup(t) {
    const r = nt(), s = nt(), u = To(), c = Qt(), { lnodes: d } = cn(c), f = tt(() => D(r.value)), h = tt(() => D(s.value));
    function _(B) {
      r.value = B;
    }
    function k(B) {
      s.value = B;
    }
    function D(B) {
      return d.value.find((ee) => ee.id === B) ?? void 0;
    }
    function j() {
      u.setCurrentDialogContent("DataflowCreation", {
        sourceLNode: f.value,
        destinationLNode: h.value
      });
    }
    return (B, ee) => (ce(), ye("div", Ym, [
      _t(Gm, {
        onSourceLNodeChange: _,
        onDestinationLNodeChange: k
      }),
      L("button", {
        class: "btn bg-(--color-primary) border-none text-white disabled:text-(--color-ocean-gray-300)",
        onClick: j,
        disabled: !r.value || !s.value,
        "aria-label": "Add connection"
      }, [
        _t(Ea)
      ], 8, Qm)
    ]));
  }
}), zm = {}, Jm = { class: "layout" }, Zm = { class: "main" }, ey = { class: "sidebar" };
function ty(t, r) {
  return ce(), ye("div", Jm, [
    L("div", Zm, [
      su(t.$slots, "main", {}, void 0)
    ]),
    L("div", ey, [
      su(t.$slots, "sidebar", {}, void 0)
    ])
  ]);
}
const ny = /* @__PURE__ */ Xa(zm, [["render", ty], ["__scopeId", "data-v-5f95d421"]]), ry = {
  name: "sidebar",
  class: "root"
}, oy = { class: "tabs tabs-box" }, iy = { key: 0 }, sy = { key: 1 }, ay = /* @__PURE__ */ kt({
  __name: "sidebar",
  setup(t) {
    const r = nt("details");
    return (s, u) => (ce(), ye("div", ry, [
      L("div", oy, [
        We(L("input", {
          type: "radio",
          value: "details",
          name: "tabs",
          "onUpdate:modelValue": u[0] || (u[0] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Details"
        }, null, 512), [
          [Lr, r.value]
        ]),
        We(L("input", {
          type: "radio",
          value: "advanced",
          name: "tabs",
          "onUpdate:modelValue": u[1] || (u[1] = (c) => r.value = c),
          class: "tab",
          "aria-label": "Advanced"
        }, null, 512), [
          [Lr, r.value]
        ])
      ]),
      L("div", null, [
        r.value === "details" ? (ce(), ye("div", iy, u[2] || (u[2] = [
          L("div", { id: "sidebar-details" }, null, -1)
        ]))) : lt("", !0),
        r.value === "advanced" ? (ce(), ye("div", sy)) : lt("", !0)
      ])
    ]));
  }
}), uy = /* @__PURE__ */ Xa(ay, [["__scopeId", "data-v-ec5c053a"]]), ly = {
  class: "modal",
  ref: "dialogRef"
}, cy = { class: "modal-box" }, fy = /* @__PURE__ */ kt({
  __name: "dialog-container",
  setup(t) {
    const r = To(), { currentDialogContent: s } = cn(r), u = nf("dialogRef");
    return Ko(() => {
      u.value && (r.dialogRef = u.value);
    }), (c, d) => (ce(), ye("dialog", ly, [
      L("div", cy, [
        d[0] || (d[0] = L("form", { method: "dialog" }, [
          L("button", {
            class: "btn btn-sm btn-circle btn-ghost absolute right-2 top-2",
            "aria-label": "Close dialog"
          }, " ✕ ")
        ], -1)),
        Ae(s).component ? (ce(), On(yf(Ae(s).component), yc(Ql({ key: 0 }, Ae(s).props)), null, 16)) : lt("", !0)
      ])
    ], 512));
  }
}), dy = ["id"], py = { class: "p-10" }, hy = /* @__PURE__ */ kt({
  __name: "app",
  props: {
    api: {}
  },
  setup(t) {
    const r = "dataflow", s = t, u = Qt();
    let c = () => {
    };
    return Ko(() => {
      c = s.api.activeFileName.subscribe((d) => {
        u.initApp(d);
      }), u.initApp(s.api.activeFileName.value);
    }), $a(() => {
      u.closeDatabase(), c();
    }), (d, f) => (ce(), ye("article", {
      id: Ae(r),
      style: { height: "100%" }
    }, [
      _t(ny, null, {
        main: ca(() => [
          L("div", py, [
            _t(Xm),
            _t(fy)
          ])
        ]),
        sidebar: ca(() => [
          _t(uy)
        ]),
        _: 1
      })
    ], 8, dy));
  }
});
function Fy(t, r) {
  if (!document.getElementById(t)) {
    console.error({ msg: "could not found root element", rootId: t });
    return;
  }
  const u = Dd(hy, { api: r });
  return u.use(kd()), u.mount(`#${t}`), u.unmount;
}
export {
  Fy as default
};
